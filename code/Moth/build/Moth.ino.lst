
/Users/nathan/workspace/Victoria/Moth/code/Moth/build/Moth.ino.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <_VectorsFlash>:
  free(ptr);
}

void operator delete[](void * ptr, size_t size)
{
  free(ptr);
       0:	00 80 00 20 bd 01 00 00 2d 9a 00 00 e5 99 00 00     ... ....-.......
      10:	e5 99 00 00 e5 99 00 00 e5 99 00 00 e5 99 00 00     ................
      20:	e5 99 00 00 e5 99 00 00 e5 99 00 00 2d 9a 00 00     ............-...
      30:	2d 9a 00 00 e5 99 00 00 e9 90 00 00 ed 91 00 00     -...............
      40:	2d 9a 00 00 2d 9a 00 00 2d 9a 00 00 2d 9a 00 00     -...-...-...-...
      50:	2d 9a 00 00 2d 9a 00 00 2d 9a 00 00 2d 9a 00 00     -...-...-...-...
      60:	2d 9a 00 00 2d 9a 00 00 2d 9a 00 00 2d 9a 00 00     -...-...-...-...
      70:	2d 9a 00 00 2d 9a 00 00 2d 9a 00 00 2d 9a 00 00     -...-...-...-...
      80:	2d 9a 00 00 2d 9a 00 00 2d 9a 00 00 2d 9a 00 00     -...-...-...-...
      90:	2d 9a 00 00 2d 9a 00 00 2d 9a 00 00 2d 9a 00 00     -...-...-...-...
      a0:	8d 84 00 00 99 84 00 00 2d 9a 00 00 2d 9a 00 00     ........-...-...
      b0:	2d 9a 00 00 2d 9a 00 00 2d 9a 00 00 2d 9a 00 00     -...-...-...-...
      c0:	2d 9a 00 00 2d 9a 00 00 2d 9a 00 00 2d 9a 00 00     -...-...-...-...
      d0:	2d 9a 00 00 2d 9a 00 00 2d 9a 00 00 2d 9a 00 00     -...-...-...-...
      e0:	2d 9a 00 00 2d 9a 00 00 2d 9a 00 00 2d 9a 00 00     -...-...-...-...
      f0:	2d 9a 00 00 d1 b8 00 00 2d 9a 00 00 fd b9 00 00     -.......-.......
     100:	2d 9a 00 00 29 bb 00 00 2d 9a 00 00 2d 9a 00 00     -...)...-...-...
     110:	2d 9a 00 00 2d 9a 00 00 2d 9a 00 00 2d 9a 00 00     -...-...-...-...
     120:	2d 9a 00 00 2d 9a 00 00 2d 9a 00 00 2d 9a 00 00     -...-...-...-...
     130:	2d 9a 00 00 2d 9a 00 00 2d 9a 00 00 2d 9a 00 00     -...-...-...-...
     140:	2d 9a 00 00 2d 9a 00 00 2d 9a 00 00 2d 9a 00 00     -...-...-...-...
     150:	2d 9a 00 00 2d 9a 00 00 2d 9a 00 00 2d 9a 00 00     -...-...-...-...
     160:	2d 9a 00 00 b5 a8 00 00 2d 9a 00 00 2d 9a 00 00     -.......-...-...
     170:	2d 9a 00 00 2d 9a 00 00 2d 9a 00 00 2d 9a 00 00     -...-...-...-...
     180:	2d 9a 00 00 2d 9a 00 00 2d 9a 00 00 2d 9a 00 00     -...-...-...-...
     190:	2d 9a 00 00 2d 9a 00 00 2d 9a 00 00 2d 9a 00 00     -...-...-...-...
     1a0:	2d 9a 00 00 2d 9a 00 00 2d 9a 00 00 2d 9a 00 00     -...-...-...-...
     1b0:	2d 9a 00 00 2d 9a 00 00 a5 8e 00 00                 -...-.......

000001bc <ResetHandler>:
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1bc:	4b56      	ldr	r3, [pc, #344]	; (318 <ResetHandler+0x15c>)
     1be:	f24c 5220 	movw	r2, #50464	; 0xc520
#else
// hopefully all others fit into startup section (below 0x400)
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
     1c2:	b510      	push	{r4, lr}
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1c4:	801a      	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
     1c6:	f64d 1228 	movw	r2, #55592	; 0xd928
     1ca:	801a      	strh	r2, [r3, #0]
	__asm__ volatile ("nop");
     1cc:	bf00      	nop
	__asm__ volatile ("nop");
     1ce:	bf00      	nop
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
     1d0:	f009 fc30 	bl	9a34 <startup_early_hook>
	// enable clocks to always-used peripherals
#if defined(__MK20DX128__)
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
     1d4:	4b51      	ldr	r3, [pc, #324]	; (31c <ResetHandler+0x160>)
     1d6:	f04f 6210 	mov.w	r2, #150994944	; 0x9000000
     1da:	601a      	str	r2, [r3, #0]
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
     1dc:	4a50      	ldr	r2, [pc, #320]	; (320 <ResetHandler+0x164>)
     1de:	609a      	str	r2, [r3, #8]
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
     1e0:	4a50      	ldr	r2, [pc, #320]	; (324 <ResetHandler+0x168>)
     1e2:	60da      	str	r2, [r3, #12]
#endif
#if defined(KINETISK) && !defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started early.
	// But don't do this early on Teensy 3.6 - RTC_CR depends on 3.3V+VBAT
	// which may be ~0.4V "behind" 3.3V if the power ramps up slowly.
	if (!(RTC_CR & RTC_CR_OSCE)) {
     1e4:	4a50      	ldr	r2, [pc, #320]	; (328 <ResetHandler+0x16c>)
     1e6:	6813      	ldr	r3, [r2, #0]
     1e8:	f413 7380 	ands.w	r3, r3, #256	; 0x100
     1ec:	d104      	bne.n	1f8 <ResetHandler+0x3c>
		RTC_SR = 0;
     1ee:	494f      	ldr	r1, [pc, #316]	; (32c <ResetHandler+0x170>)
     1f0:	600b      	str	r3, [r1, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
     1f2:	f44f 53a8 	mov.w	r3, #5376	; 0x1500
     1f6:	6013      	str	r3, [r2, #0]
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     1f8:	4b4d      	ldr	r3, [pc, #308]	; (330 <ResetHandler+0x174>)
     1fa:	781a      	ldrb	r2, [r3, #0]
     1fc:	0711      	lsls	r1, r2, #28
     1fe:	d503      	bpl.n	208 <ResetHandler+0x4c>
     200:	781a      	ldrb	r2, [r3, #0]
     202:	f042 0208 	orr.w	r2, r2, #8
     206:	701a      	strb	r2, [r3, #0]
    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     208:	4b4a      	ldr	r3, [pc, #296]	; (334 <ResetHandler+0x178>)
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     20a:	494b      	ldr	r1, [pc, #300]	; (338 <ResetHandler+0x17c>)
    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     20c:	222a      	movs	r2, #42	; 0x2a
     20e:	701a      	strb	r2, [r3, #0]
     210:	4a4a      	ldr	r2, [pc, #296]	; (33c <ResetHandler+0x180>)
     212:	4b4b      	ldr	r3, [pc, #300]	; (340 <ResetHandler+0x184>)
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     214:	428b      	cmp	r3, r1
     216:	d204      	bcs.n	222 <ResetHandler+0x66>
     218:	f852 0f04 	ldr.w	r0, [r2, #4]!
     21c:	f843 0b04 	str.w	r0, [r3], #4
     220:	e7f8      	b.n	214 <ResetHandler+0x58>
     222:	4b48      	ldr	r3, [pc, #288]	; (344 <ResetHandler+0x188>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     224:	4948      	ldr	r1, [pc, #288]	; (348 <ResetHandler+0x18c>)
     226:	2200      	movs	r2, #0
     228:	428b      	cmp	r3, r1
     22a:	d202      	bcs.n	232 <ResetHandler+0x76>
     22c:	f843 2b04 	str.w	r2, [r3], #4
     230:	e7fa      	b.n	228 <ResetHandler+0x6c>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     232:	4946      	ldr	r1, [pc, #280]	; (34c <ResetHandler+0x190>)
     234:	4a46      	ldr	r2, [pc, #280]	; (350 <ResetHandler+0x194>)
     236:	2300      	movs	r3, #0
     238:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
     23c:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
     240:	3301      	adds	r3, #1
     242:	2b6f      	cmp	r3, #111	; 0x6f
     244:	d1f8      	bne.n	238 <ResetHandler+0x7c>
     246:	4b43      	ldr	r3, [pc, #268]	; (354 <ResetHandler+0x198>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     248:	4a43      	ldr	r2, [pc, #268]	; (358 <ResetHandler+0x19c>)
     24a:	2180      	movs	r1, #128	; 0x80
     24c:	f803 1b01 	strb.w	r1, [r3], #1
     250:	4293      	cmp	r3, r2
     252:	d1fb      	bne.n	24c <ResetHandler+0x90>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     254:	4b41      	ldr	r3, [pc, #260]	; (35c <ResetHandler+0x1a0>)
     256:	4a3d      	ldr	r2, [pc, #244]	; (34c <ResetHandler+0x190>)
     258:	601a      	str	r2, [r3, #0]
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     25a:	4b41      	ldr	r3, [pc, #260]	; (360 <ResetHandler+0x1a4>)
     25c:	228a      	movs	r2, #138	; 0x8a
     25e:	701a      	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     260:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
     264:	2224      	movs	r2, #36	; 0x24
     266:	705a      	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     268:	22a0      	movs	r2, #160	; 0xa0
     26a:	701a      	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     26c:	799a      	ldrb	r2, [r3, #6]
     26e:	0792      	lsls	r2, r2, #30
     270:	d5fc      	bpl.n	26c <ResetHandler+0xb0>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     272:	799a      	ldrb	r2, [r3, #6]
     274:	06d4      	lsls	r4, r2, #27
     276:	d4fc      	bmi.n	272 <ResetHandler+0xb6>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     278:	4a3a      	ldr	r2, [pc, #232]	; (364 <ResetHandler+0x1a8>)
     27a:	7993      	ldrb	r3, [r2, #6]
     27c:	f003 030c 	and.w	r3, r3, #12
     280:	2b08      	cmp	r3, #8
     282:	4b38      	ldr	r3, [pc, #224]	; (364 <ResetHandler+0x1a8>)
     284:	d1f9      	bne.n	27a <ResetHandler+0xbe>
    #endif
   #else
    #if F_CPU == 72000000
	MCG_C5 = MCG_C5_PRDIV0(5);		 // config PLL input for 16 MHz Crystal / 6 = 2.667 Hz
    #else
	MCG_C5 = MCG_C5_PRDIV0(3);		 // config PLL input for 16 MHz Crystal / 4 = 4 MHz
     286:	2203      	movs	r2, #3
     288:	711a      	strb	r2, [r3, #4]
    #if F_CPU == 168000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(18); // config PLL for 168 MHz output
    #elif F_CPU == 144000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(12); // config PLL for 144 MHz output
    #elif F_CPU == 120000000
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(6); // config PLL for 120 MHz output
     28a:	2246      	movs	r2, #70	; 0x46
     28c:	715a      	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     28e:	799a      	ldrb	r2, [r3, #6]
     290:	0690      	lsls	r0, r2, #26
     292:	d5fc      	bpl.n	28e <ResetHandler+0xd2>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     294:	4a33      	ldr	r2, [pc, #204]	; (364 <ResetHandler+0x1a8>)
     296:	7991      	ldrb	r1, [r2, #6]
     298:	4b32      	ldr	r3, [pc, #200]	; (364 <ResetHandler+0x1a8>)
     29a:	0649      	lsls	r1, r1, #25
     29c:	d5fb      	bpl.n	296 <ResetHandler+0xda>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(2);
#elif F_CPU == 120000000
	// config divisors: 120 MHz core, 60 MHz bus, 24 MHz flash, USB = 128 * 2 / 5
	#if F_BUS == 60000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(4);
     29e:	4a32      	ldr	r2, [pc, #200]	; (368 <ResetHandler+0x1ac>)
     2a0:	f04f 7182 	mov.w	r1, #17039360	; 0x1040000
     2a4:	6011      	str	r1, [r2, #0]
	#elif F_BUS == 120000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(0) | SIM_CLKDIV1_OUTDIV4(4);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC;
     2a6:	2109      	movs	r1, #9
     2a8:	6051      	str	r1, [r2, #4]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     2aa:	2220      	movs	r2, #32
     2ac:	701a      	strb	r2, [r3, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     2ae:	799a      	ldrb	r2, [r3, #6]
     2b0:	f002 020c 	and.w	r2, r2, #12
     2b4:	2a0c      	cmp	r2, #12
     2b6:	d1fa      	bne.n	2ae <ResetHandler+0xf2>
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
	#else
	// USB uses PLL clock
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
     2b8:	4b2c      	ldr	r3, [pc, #176]	; (36c <ResetHandler+0x1b0>)
     2ba:	4a2d      	ldr	r2, [pc, #180]	; (370 <ResetHandler+0x1b4>)
     2bc:	601a      	str	r2, [r3, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     2be:	4b2d      	ldr	r3, [pc, #180]	; (374 <ResetHandler+0x1b8>)
     2c0:	4a2d      	ldr	r2, [pc, #180]	; (378 <ResetHandler+0x1bc>)
     2c2:	601a      	str	r2, [r3, #0]
	SYST_CVR = 0;
     2c4:	2200      	movs	r2, #0
     2c6:	605a      	str	r2, [r3, #4]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     2c8:	2207      	movs	r2, #7
     2ca:	f843 2c04 	str.w	r2, [r3, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     2ce:	4a2b      	ldr	r2, [pc, #172]	; (37c <ResetHandler+0x1c0>)
     2d0:	f8c3 2d0c 	str.w	r2, [r3, #3340]	; 0xd0c

	//init_pins();
	__enable_irq();
     2d4:	b662      	cpsie	i

	_init_Teensyduino_internal_();
     2d6:	f009 ff69 	bl	a1ac <_init_Teensyduino_internal_>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
     2da:	4b14      	ldr	r3, [pc, #80]	; (32c <ResetHandler+0x170>)
     2dc:	681b      	ldr	r3, [r3, #0]
     2de:	07da      	lsls	r2, r3, #31
     2e0:	d505      	bpl.n	2ee <ResetHandler+0x132>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     2e2:	4827      	ldr	r0, [pc, #156]	; (380 <ResetHandler+0x1c4>)
     2e4:	f009 fec6 	bl	a074 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
     2e8:	4b26      	ldr	r3, [pc, #152]	; (384 <ResetHandler+0x1c8>)
     2ea:	4a27      	ldr	r2, [pc, #156]	; (388 <ResetHandler+0x1cc>)
     2ec:	601a      	str	r2, [r3, #0]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
     2ee:	4b27      	ldr	r3, [pc, #156]	; (38c <ResetHandler+0x1d0>)
     2f0:	781b      	ldrb	r3, [r3, #0]
     2f2:	065b      	lsls	r3, r3, #25
     2f4:	d509      	bpl.n	30a <ResetHandler+0x14e>
     2f6:	4c23      	ldr	r4, [pc, #140]	; (384 <ResetHandler+0x1c8>)
     2f8:	4b23      	ldr	r3, [pc, #140]	; (388 <ResetHandler+0x1cc>)
     2fa:	6822      	ldr	r2, [r4, #0]
     2fc:	429a      	cmp	r2, r3
     2fe:	d104      	bne.n	30a <ResetHandler+0x14e>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     300:	481f      	ldr	r0, [pc, #124]	; (380 <ResetHandler+0x1c4>)
     302:	f009 feb7 	bl	a074 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
     306:	2300      	movs	r3, #0
     308:	6023      	str	r3, [r4, #0]
	}
#endif

	__libc_init_array();
     30a:	f00d fc0f 	bl	db2c <__libc_init_array>

	startup_late_hook();
     30e:	f009 fb97 	bl	9a40 <startup_late_hook>
	main();
     312:	f009 fac5 	bl	98a0 <main>
     316:	e7fe      	b.n	316 <ResetHandler+0x15a>
     318:	4005200e 	.word	0x4005200e
     31c:	40048030 	.word	0x40048030
     320:	00043f82 	.word	0x00043f82
     324:	2b000001 	.word	0x2b000001
     328:	4003d010 	.word	0x4003d010
     32c:	4003d014 	.word	0x4003d014
     330:	4007d002 	.word	0x4007d002
     334:	4007e000 	.word	0x4007e000
     338:	1fffc50c 	.word	0x1fffc50c
     33c:	00022068 	.word	0x00022068
     340:	1fffb798 	.word	0x1fffb798
     344:	1fffc510 	.word	0x1fffc510
     348:	20004948 	.word	0x20004948
     34c:	1fffac00 	.word	0x1fffac00
     350:	00000000 	.word	0x00000000
     354:	e000e400 	.word	0xe000e400
     358:	e000e45f 	.word	0xe000e45f
     35c:	e000ed08 	.word	0xe000ed08
     360:	40065000 	.word	0x40065000
     364:	40064000 	.word	0x40064000
     368:	40048044 	.word	0x40048044
     36c:	40048004 	.word	0x40048004
     370:	000510c0 	.word	0x000510c0
     374:	e000e014 	.word	0xe000e014
     378:	0001d4bf 	.word	0x0001d4bf
     37c:	20200000 	.word	0x20200000
     380:	5e528ecb 	.word	0x5e528ecb
     384:	4003e01c 	.word	0x4003e01c
     388:	5a94c3a5 	.word	0x5a94c3a5
     38c:	4007f000 	.word	0x4007f000
     390:	ffffffff 	.word	0xffffffff
     394:	ffffffff 	.word	0xffffffff
     398:	ffffffff 	.word	0xffffffff
     39c:	ffffffff 	.word	0xffffffff
     3a0:	ffffffff 	.word	0xffffffff
     3a4:	ffffffff 	.word	0xffffffff
     3a8:	ffffffff 	.word	0xffffffff
     3ac:	ffffffff 	.word	0xffffffff
     3b0:	ffffffff 	.word	0xffffffff
     3b4:	ffffffff 	.word	0xffffffff
     3b8:	ffffffff 	.word	0xffffffff
     3bc:	ffffffff 	.word	0xffffffff
     3c0:	ffffffff 	.word	0xffffffff
     3c4:	ffffffff 	.word	0xffffffff
     3c8:	ffffffff 	.word	0xffffffff
     3cc:	ffffffff 	.word	0xffffffff
     3d0:	ffffffff 	.word	0xffffffff
     3d4:	ffffffff 	.word	0xffffffff
     3d8:	ffffffff 	.word	0xffffffff
     3dc:	ffffffff 	.word	0xffffffff
     3e0:	ffffffff 	.word	0xffffffff
     3e4:	ffffffff 	.word	0xffffffff
     3e8:	ffffffff 	.word	0xffffffff
     3ec:	ffffffff 	.word	0xffffffff
     3f0:	ffffffff 	.word	0xffffffff
     3f4:	ffffffff 	.word	0xffffffff
     3f8:	ffffffff 	.word	0xffffffff
     3fc:	ffffffff 	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	ffffffff ffffffff ffffffff fffff9de     ................

00000410 <__do_global_dtors_aux>:
     410:	b510      	push	{r4, lr}
     412:	4c05      	ldr	r4, [pc, #20]	; (428 <__do_global_dtors_aux+0x18>)
     414:	7823      	ldrb	r3, [r4, #0]
     416:	b933      	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	4b04      	ldr	r3, [pc, #16]	; (42c <__do_global_dtors_aux+0x1c>)
     41a:	b113      	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	4804      	ldr	r0, [pc, #16]	; (430 <__do_global_dtors_aux+0x20>)
     41e:	f3af 8000 	nop.w
     422:	2301      	movs	r3, #1
     424:	7023      	strb	r3, [r4, #0]
     426:	bd10      	pop	{r4, pc}
     428:	1fffc510 	.word	0x1fffc510
     42c:	00000000 	.word	0x00000000
     430:	00022064 	.word	0x00022064

00000434 <frame_dummy>:
     434:	4b08      	ldr	r3, [pc, #32]	; (458 <frame_dummy+0x24>)
     436:	b510      	push	{r4, lr}
     438:	b11b      	cbz	r3, 442 <frame_dummy+0xe>
     43a:	4908      	ldr	r1, [pc, #32]	; (45c <frame_dummy+0x28>)
     43c:	4808      	ldr	r0, [pc, #32]	; (460 <frame_dummy+0x2c>)
     43e:	f3af 8000 	nop.w
     442:	4808      	ldr	r0, [pc, #32]	; (464 <frame_dummy+0x30>)
     444:	6803      	ldr	r3, [r0, #0]
     446:	b903      	cbnz	r3, 44a <frame_dummy+0x16>
     448:	bd10      	pop	{r4, pc}
     44a:	4b07      	ldr	r3, [pc, #28]	; (468 <frame_dummy+0x34>)
     44c:	2b00      	cmp	r3, #0
     44e:	d0fb      	beq.n	448 <frame_dummy+0x14>
     450:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     454:	4718      	bx	r3
     456:	bf00      	nop
     458:	00000000 	.word	0x00000000
     45c:	1fffc514 	.word	0x1fffc514
     460:	00022064 	.word	0x00022064
     464:	1fffc50c 	.word	0x1fffc50c
     468:	00000000 	.word	0x00000000

0000046c <DLManager::~DLManager()>:
        long remaining_logs[DATALOG_MANAGER_TIMER_NUM];
};

///////////////////////// constructors ///////////////////////////////////////////
DLManager::DLManager(){};
DLManager::~DLManager(){};
     46c:	b570      	push	{r4, r5, r6, lr}
     46e:	f500 5597 	add.w	r5, r0, #4832	; 0x12e0
     472:	3514      	adds	r5, #20
     474:	4606      	mov	r6, r0
     476:	b155      	cbz	r5, 48e <DLManager::~DLManager()+0x22>
     478:	f500 54f5 	add.w	r4, r0, #7840	; 0x1ea0
     47c:	340c      	adds	r4, #12
     47e:	42a5      	cmp	r5, r4
     480:	d005      	beq.n	48e <DLManager::~DLManager()+0x22>
     482:	3c3c      	subs	r4, #60	; 0x3c
        void printlog(uint8_t lines);
        void printlog(){printlog(4);};

};
Datalog::Datalog(){};
Datalog::~Datalog(){};
     484:	1d20      	adds	r0, r4, #4
     486:	f009 f827 	bl	94d8 <String::~String()>
     48a:	42a5      	cmp	r5, r4
     48c:	d1f9      	bne.n	482 <DLManager::~DLManager()+0x16>
     48e:	f116 0524 	adds.w	r5, r6, #36	; 0x24
     492:	d00a      	beq.n	4aa <DLManager::~DLManager()+0x3e>
     494:	f506 5497 	add.w	r4, r6, #4832	; 0x12e0
     498:	3404      	adds	r4, #4
     49a:	42a5      	cmp	r5, r4
     49c:	d005      	beq.n	4aa <DLManager::~DLManager()+0x3e>
     49e:	3c18      	subs	r4, #24
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     4a0:	4620      	mov	r0, r4
     4a2:	f009 f819 	bl	94d8 <String::~String()>
        long remaining_logs[DATALOG_MANAGER_TIMER_NUM];
};

///////////////////////// constructors ///////////////////////////////////////////
DLManager::DLManager(){};
DLManager::~DLManager(){};
     4a6:	42a5      	cmp	r5, r4
     4a8:	d1f9      	bne.n	49e <DLManager::~DLManager()+0x32>
     4aa:	4630      	mov	r0, r6
     4ac:	f009 f814 	bl	94d8 <String::~String()>
     4b0:	4630      	mov	r0, r6
     4b2:	bd70      	pop	{r4, r5, r6, pc}

000004b4 <__tcf_0>:
  uint32_t num_song_peaks[2];
*/
//////////////////////////////// Global Objects /////////////////////////
WS2812Serial leds(NUM_LED, LED_DISPLAY_MEMORY, LED_DRAWING_MEMORY, LED_PIN, WS2812_GRB);

NeoGroup neos[2] = {
     4b4:	b510      	push	{r4, lr}
  color = (red << 16) + (green << 8) + (blue);
  return color;
}

// todo add on/off bools for the datalogging shiz
class NeoGroup {
     4b6:	4c05      	ldr	r4, [pc, #20]	; (4cc <__tcf_0+0x18>)
     4b8:	f504 70ac 	add.w	r0, r4, #344	; 0x158
     4bc:	f009 f80c 	bl	94d8 <String::~String()>
     4c0:	f104 0080 	add.w	r0, r4, #128	; 0x80
     4c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     4c8:	f009 b806 	b.w	94d8 <String::~String()>
     4cc:	1ffff438 	.word	0x1ffff438

000004d0 <__tcf_1>:
  NeoGroup(&leds, 0, (NUM_LED / 2) - 1, "Front", MIN_FLASH_TIME, MAX_FLASH_TIME),
  NeoGroup(&leds, NUM_LED / 2, NUM_LED - 1, "Rear", MIN_FLASH_TIME, MAX_FLASH_TIME)
};

// lux managers to keep track of the VEML readings
LuxManager lux_managers[NUM_LUX_SENSORS] = {
     4d0:	b510      	push	{r4, lr}
#include "../NeopixelManager/NeopixelManager.h"

// TODO add code so if the TCA is not available things are cool... also add firmware #define to control this
#define TCAADDR 0x70

class LuxManager {
     4d2:	4c05      	ldr	r4, [pc, #20]	; (4e8 <__tcf_1+0x18>)
     4d4:	f504 70b8 	add.w	r0, r4, #368	; 0x170
     4d8:	f008 fffe 	bl	94d8 <String::~String()>
     4dc:	f104 0070 	add.w	r0, r4, #112	; 0x70
     4e0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     4e4:	f008 bff8 	b.w	94d8 <String::~String()>
     4e8:	1fffc580 	.word	0x1fffc580

000004ec <__tcf_2>:
};


DLManager datalog_manager = DLManager((String)"Datalog Manager");

FeatureCollector fc[4] = {FeatureCollector("front song"), FeatureCollector("rear song"), FeatureCollector("front click"), FeatureCollector("rear click")};
     4ec:	b510      	push	{r4, lr}
#ifndef __FEATURE_COLLECTOR_H__
#define __FEATURE_COLLECTOR_H__

#include "audio_utils.h"

class FeatureCollector {
     4ee:	4c0a      	ldr	r4, [pc, #40]	; (518 <__tcf_2+0x2c>)
     4f0:	f504 504d 	add.w	r0, r4, #13120	; 0x3340
     4f4:	3030      	adds	r0, #48	; 0x30
     4f6:	f008 ffef 	bl	94d8 <String::~String()>
     4fa:	f504 5009 	add.w	r0, r4, #8768	; 0x2240
     4fe:	3018      	adds	r0, #24
     500:	f008 ffea 	bl	94d8 <String::~String()>
     504:	f504 508a 	add.w	r0, r4, #4416	; 0x1140
     508:	f008 ffe6 	bl	94d8 <String::~String()>
     50c:	f104 0028 	add.w	r0, r4, #40	; 0x28
     510:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     514:	f008 bfe0 	b.w	94d8 <String::~String()>
     518:	1ffffa30 	.word	0x1ffffa30

0000051c <__tcf_3>:

AutoGain auto_gain[2] = {AutoGain("Song", &fc[0], &fc[1], STARTING_SONG_GAIN, STARTING_SONG_GAIN, MAX_GAIN_ADJUSTMENT),
     51c:	b510      	push	{r4, lr}
#define __AUDIOENGINE_H__

#include "../Configuration.h"
#include "FeatureCollector.h"

class AutoGain {
     51e:	4c09      	ldr	r4, [pc, #36]	; (544 <__tcf_3+0x28>)
     520:	f104 00c8 	add.w	r0, r4, #200	; 0xc8
     524:	f008 ffd8 	bl	94d8 <String::~String()>
     528:	f104 0080 	add.w	r0, r4, #128	; 0x80
     52c:	f008 ffd4 	bl	94d8 <String::~String()>
     530:	f104 0050 	add.w	r0, r4, #80	; 0x50
     534:	f008 ffd0 	bl	94d8 <String::~String()>
     538:	f104 0008 	add.w	r0, r4, #8
     53c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     540:	f008 bfca 	b.w	94d8 <String::~String()>
     544:	20003fa0 	.word	0x20003fa0

00000548 <AudioConnection::~AudioConnection()>:
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
		{ isConnected = false;
		  connect(); }
	friend class AudioStream;
	~AudioConnection() {
     548:	b510      	push	{r4, lr}
     54a:	4604      	mov	r4, r0
		disconnect();
     54c:	f008 fc54 	bl	8df8 <AudioConnection::disconnect()>
	}
     550:	4620      	mov	r0, r4
     552:	bd10      	pop	{r4, pc}

00000554 <dprintln(int, double) [clone .part.4]>:
  if (conditional > 0) {
    Serial.println(data);
  }
}

void dprintln(int conditional, double data) {
     554:	b530      	push	{r4, r5, lr}
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
     556:	4c07      	ldr	r4, [pc, #28]	; (574 <dprintln(int, double) [clone .part.4]+0x20>)
     558:	b083      	sub	sp, #12
     55a:	2502      	movs	r5, #2
     55c:	4602      	mov	r2, r0
     55e:	460b      	mov	r3, r1
     560:	9500      	str	r5, [sp, #0]
     562:	4620      	mov	r0, r4
     564:	f008 fee0 	bl	9328 <Print::printFloat(double, unsigned char)>
	size_t println(int n, int base)			{ return print(n, base) + println(); }
	size_t println(unsigned int n, int base)	{ return print(n, base) + println(); }
	size_t println(long n, int base)		{ return print(n, base) + println(); }
	size_t println(unsigned long n, int base)	{ return print(n, base) + println(); }

	size_t println(double n, int digits = 2)	{ return print(n, digits) + println(); }
     568:	4620      	mov	r0, r4
  if (conditional > 0) {
    Serial.println(data);
  }
}
     56a:	b003      	add	sp, #12
     56c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
     570:	f008 be80 	b.w	9274 <Print::println()>
     574:	1fffbaf4 	.word	0x1fffbaf4

00000578 <listenForSerialCommands() [clone .part.50]>:
  }
#endif
  printMajorDivide("Setup Loop Finished");
}

void listenForSerialCommands() {
     578:	b538      	push	{r3, r4, r5, lr}
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
     57a:	f00a ffdb 	bl	b534 <usb_serial_getchar>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
     57e:	4c07      	ldr	r4, [pc, #28]	; (59c <listenForSerialCommands() [clone .part.50]+0x24>)
     580:	4605      	mov	r5, r0
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
     582:	210a      	movs	r1, #10
     584:	4806      	ldr	r0, [pc, #24]	; (5a0 <listenForSerialCommands() [clone .part.50]+0x28>)
     586:	f00b f83b 	bl	b600 <usb_serial_write>
     58a:	4629      	mov	r1, r5
     58c:	4620      	mov	r0, r4
     58e:	f008 fec1 	bl	9314 <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
     592:	4620      	mov	r0, r4
  if (Serial.available() > 0) {
    int incByte = Serial.read();
    Serial.print("incbyte : ");
    Serial.println(incByte);
  }
}
     594:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     598:	f008 be6c 	b.w	9274 <Print::println()>
     59c:	1fffbaf4 	.word	0x1fffbaf4
     5a0:	000105d4 	.word	0x000105d4

000005a4 <FeatureCollector::printToneVals() [clone .part.38]>:
    if (fft_active && PRINT_FFT_VALS) {
        printFFTVals();
    };
}

void FeatureCollector::printToneVals() {
     5a4:	b530      	push	{r4, r5, lr}
    if (tone_active > 0) {
        Serial.print(name);
     5a6:	4c0c      	ldr	r4, [pc, #48]	; (5d8 <FeatureCollector::printToneVals() [clone .part.38]+0x34>)
    if (fft_active && PRINT_FFT_VALS) {
        printFFTVals();
    };
}

void FeatureCollector::printToneVals() {
     5a8:	b083      	sub	sp, #12
     5aa:	4605      	mov	r5, r0
    if (tone_active > 0) {
        Serial.print(name);
     5ac:	f100 0128 	add.w	r1, r0, #40	; 0x28
     5b0:	4620      	mov	r0, r4
     5b2:	f008 fe39 	bl	9228 <Print::print(String const&)>
     5b6:	210e      	movs	r1, #14
     5b8:	4808      	ldr	r0, [pc, #32]	; (5dc <FeatureCollector::printToneVals() [clone .part.38]+0x38>)
     5ba:	f00b f821 	bl	b600 <usb_serial_write>
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
     5be:	2102      	movs	r1, #2
     5c0:	e9d5 2334 	ldrd	r2, r3, [r5, #208]	; 0xd0
     5c4:	4620      	mov	r0, r4
     5c6:	9100      	str	r1, [sp, #0]
     5c8:	f008 feae 	bl	9328 <Print::printFloat(double, unsigned char)>
	size_t println(int n, int base)			{ return print(n, base) + println(); }
	size_t println(unsigned int n, int base)	{ return print(n, base) + println(); }
	size_t println(long n, int base)		{ return print(n, base) + println(); }
	size_t println(unsigned long n, int base)	{ return print(n, base) + println(); }

	size_t println(double n, int digits = 2)	{ return print(n, digits) + println(); }
     5cc:	4620      	mov	r0, r4
        Serial.print(" tone_level :\t");
        Serial.println(tone_level);
    }
}
     5ce:	b003      	add	sp, #12
     5d0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
     5d4:	f008 be4e 	b.w	9274 <Print::println()>
     5d8:	1fffbaf4 	.word	0x1fffbaf4
     5dc:	000105e0 	.word	0x000105e0

000005e0 <FeatureCollector::linkAmplifier(AudioAmplifier*, double, double) [clone .part.31]>:
    scale_bin_values = scale_bin_v;
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
     5e0:	b570      	push	{r4, r5, r6, lr}
     5e2:	4604      	mov	r4, r0
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
     5e4:	4d14      	ldr	r5, [pc, #80]	; (638 <FeatureCollector::linkAmplifier(AudioAmplifier*, double, double) [clone .part.31]+0x58>)
     5e6:	4815      	ldr	r0, [pc, #84]	; (63c <FeatureCollector::linkAmplifier(AudioAmplifier*, double, double) [clone .part.31]+0x5c>)
     5e8:	460e      	mov	r6, r1
     5ea:	211a      	movs	r1, #26
     5ec:	f00b f808 	bl	b600 <usb_serial_write>
     5f0:	f894 1051 	ldrb.w	r1, [r4, #81]	; 0x51
     5f4:	2300      	movs	r3, #0
     5f6:	220a      	movs	r2, #10
     5f8:	4628      	mov	r0, r5
     5fa:	f008 fe4b 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
     5fe:	2101      	movs	r1, #1
     600:	480f      	ldr	r0, [pc, #60]	; (640 <FeatureCollector::linkAmplifier(AudioAmplifier*, double, double) [clone .part.31]+0x60>)
     602:	f00a fffd 	bl	b600 <usb_serial_write>
    gain_lower_limit = low;
    gain_upper_limit = high;
    if (audio_amp_add_idx < 4) {
        Serial.print("Linked an audio amplifier ");Serial.print(audio_amp_add_idx);printTab();
        amp_ana[audio_amp_add_idx] = amp;
     606:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
     60a:	f103 0110 	add.w	r1, r3, #16
        gain_tracking_active = true;
        audio_amp_add_idx = audio_amp_add_idx + 1;
     60e:	3301      	adds	r3, #1
     610:	b2db      	uxtb	r3, r3
    gain_lower_limit = low;
    gain_upper_limit = high;
    if (audio_amp_add_idx < 4) {
        Serial.print("Linked an audio amplifier ");Serial.print(audio_amp_add_idx);printTab();
        amp_ana[audio_amp_add_idx] = amp;
        gain_tracking_active = true;
     612:	2201      	movs	r2, #1
void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    gain_upper_limit = high;
    if (audio_amp_add_idx < 4) {
        Serial.print("Linked an audio amplifier ");Serial.print(audio_amp_add_idx);printTab();
        amp_ana[audio_amp_add_idx] = amp;
     614:	f844 6021 	str.w	r6, [r4, r1, lsl #2]
     618:	4628      	mov	r0, r5
        gain_tracking_active = true;
        audio_amp_add_idx = audio_amp_add_idx + 1;
     61a:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
    gain_lower_limit = low;
    gain_upper_limit = high;
    if (audio_amp_add_idx < 4) {
        Serial.print("Linked an audio amplifier ");Serial.print(audio_amp_add_idx);printTab();
        amp_ana[audio_amp_add_idx] = amp;
        gain_tracking_active = true;
     61e:	f884 2052 	strb.w	r2, [r4, #82]	; 0x52
     622:	4619      	mov	r1, r3
     624:	220a      	movs	r2, #10
     626:	2300      	movs	r3, #0
     628:	f008 fe34 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
     62c:	4628      	mov	r0, r5
        Serial.println(audio_amp_add_idx);
    }
    else {
        Serial.println("ERROR, can't link audio amplifier, there are not enough available slots");
    }
}
     62e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
     632:	f008 be1f 	b.w	9274 <Print::println()>
     636:	bf00      	nop
     638:	1fffbaf4 	.word	0x1fffbaf4
     63c:	000105f0 	.word	0x000105f0
     640:	00010cc0 	.word	0x00010cc0

00000644 <FeatureCollector::printFreqVals() [clone .part.41]>:
    if (calculate_centroid == true && PRINT_CENTROID_VALS) {
        Serial.print("centroid: ");Serial.println(centroid);
    }
}

void FeatureCollector::printFreqVals() {
     644:	b570      	push	{r4, r5, r6, lr}
    if (freq_active > 0) {
        Serial.print(name); Serial.print("\tnote_freq prob/freq:\t");
     646:	4c11      	ldr	r4, [pc, #68]	; (68c <FeatureCollector::printFreqVals() [clone .part.41]+0x48>)
    if (calculate_centroid == true && PRINT_CENTROID_VALS) {
        Serial.print("centroid: ");Serial.println(centroid);
    }
}

void FeatureCollector::printFreqVals() {
     648:	b082      	sub	sp, #8
     64a:	4605      	mov	r5, r0
    if (freq_active > 0) {
        Serial.print(name); Serial.print("\tnote_freq prob/freq:\t");
     64c:	f100 0128 	add.w	r1, r0, #40	; 0x28
     650:	4620      	mov	r0, r4
     652:	f008 fde9 	bl	9228 <Print::print(String const&)>
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
     656:	2602      	movs	r6, #2
     658:	2116      	movs	r1, #22
     65a:	480d      	ldr	r0, [pc, #52]	; (690 <FeatureCollector::printFreqVals() [clone .part.41]+0x4c>)
     65c:	f00a ffd0 	bl	b600 <usb_serial_write>
     660:	e9d5 233a 	ldrd	r2, r3, [r5, #232]	; 0xe8
     664:	4620      	mov	r0, r4
     666:	9600      	str	r6, [sp, #0]
     668:	f008 fe5e 	bl	9328 <Print::printFloat(double, unsigned char)>
     66c:	2101      	movs	r1, #1
     66e:	4809      	ldr	r0, [pc, #36]	; (694 <FeatureCollector::printFreqVals() [clone .part.41]+0x50>)
     670:	f00a ffc6 	bl	b600 <usb_serial_write>
     674:	e9d5 2338 	ldrd	r2, r3, [r5, #224]	; 0xe0
     678:	4620      	mov	r0, r4
     67a:	9600      	str	r6, [sp, #0]
     67c:	f008 fe54 	bl	9328 <Print::printFloat(double, unsigned char)>
	size_t println(int n, int base)			{ return print(n, base) + println(); }
	size_t println(unsigned int n, int base)	{ return print(n, base) + println(); }
	size_t println(long n, int base)		{ return print(n, base) + println(); }
	size_t println(unsigned long n, int base)	{ return print(n, base) + println(); }

	size_t println(double n, int digits = 2)	{ return print(n, digits) + println(); }
     680:	4620      	mov	r0, r4
        Serial.print(freq_prob); printTab();
        Serial.println(freq_val);
    }
}
     682:	b002      	add	sp, #8
     684:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
     688:	f008 bdf4 	b.w	9274 <Print::println()>
     68c:	1fffbaf4 	.word	0x1fffbaf4
     690:	0001060c 	.word	0x0001060c
     694:	00010cc0 	.word	0x00010cc0

00000698 <FeatureCollector::printRMSVals() [clone .part.43]>:

void FeatureCollector::printRMSVals() {
     698:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (rms_active > 0) {
        Serial.print(name); Serial.print(" RMS vals\t");
     69a:	f100 0128 	add.w	r1, r0, #40	; 0x28
        Serial.print(freq_prob); printTab();
        Serial.println(freq_val);
    }
}

void FeatureCollector::printRMSVals() {
     69e:	b083      	sub	sp, #12
     6a0:	4604      	mov	r4, r0
    if (rms_active > 0) {
        Serial.print(name); Serial.print(" RMS vals\t");
     6a2:	4822      	ldr	r0, [pc, #136]	; (72c <FeatureCollector::printRMSVals() [clone .part.43]+0x94>)
     6a4:	f008 fdc0 	bl	9228 <Print::print(String const&)>
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
     6a8:	2502      	movs	r5, #2
     6aa:	210a      	movs	r1, #10
     6ac:	4820      	ldr	r0, [pc, #128]	; (730 <FeatureCollector::printRMSVals() [clone .part.43]+0x98>)
     6ae:	f00a ffa7 	bl	b600 <usb_serial_write>
     6b2:	e9d4 231c 	ldrd	r2, r3, [r4, #112]	; 0x70
     6b6:	481d      	ldr	r0, [pc, #116]	; (72c <FeatureCollector::printRMSVals() [clone .part.43]+0x94>)
     6b8:	9500      	str	r5, [sp, #0]
     6ba:	f008 fe35 	bl	9328 <Print::printFloat(double, unsigned char)>
     6be:	2101      	movs	r1, #1
     6c0:	481c      	ldr	r0, [pc, #112]	; (734 <FeatureCollector::printRMSVals() [clone .part.43]+0x9c>)
     6c2:	f00a ff9d 	bl	b600 <usb_serial_write>
     6c6:	2106      	movs	r1, #6
     6c8:	481b      	ldr	r0, [pc, #108]	; (738 <FeatureCollector::printRMSVals() [clone .part.43]+0xa0>)
     6ca:	f00a ff99 	bl	b600 <usb_serial_write>
     6ce:	e9d4 2324 	ldrd	r2, r3, [r4, #144]	; 0x90
     6d2:	4816      	ldr	r0, [pc, #88]	; (72c <FeatureCollector::printRMSVals() [clone .part.43]+0x94>)
     6d4:	9500      	str	r5, [sp, #0]
     6d6:	f008 fe27 	bl	9328 <Print::printFloat(double, unsigned char)>
     6da:	2109      	movs	r1, #9
     6dc:	4817      	ldr	r0, [pc, #92]	; (73c <FeatureCollector::printRMSVals() [clone .part.43]+0xa4>)
     6de:	f00a ff8f 	bl	b600 <usb_serial_write>
    }
    return peak_val;
}

double FeatureCollector::getRMSAvg() {
    if (rms_readings > 0 && rms_totals > 0) {
     6e2:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
     6e6:	b1a5      	cbz	r5, 712 <FeatureCollector::printRMSVals() [clone .part.43]+0x7a>
     6e8:	e9d4 671e 	ldrd	r6, r7, [r4, #120]	; 0x78
     6ec:	2200      	movs	r2, #0
     6ee:	2300      	movs	r3, #0
     6f0:	4630      	mov	r0, r6
     6f2:	4639      	mov	r1, r7
     6f4:	f00c fc6c 	bl	cfd0 <__aeabi_dcmpgt>
     6f8:	b158      	cbz	r0, 712 <FeatureCollector::printRMSVals() [clone .part.43]+0x7a>
        return ((double)rms_totals / (double)rms_readings);
     6fa:	4628      	mov	r0, r5
     6fc:	f00c f962 	bl	c9c4 <__aeabi_ui2d>
     700:	4602      	mov	r2, r0
     702:	460b      	mov	r3, r1
     704:	4630      	mov	r0, r6
     706:	4639      	mov	r1, r7
     708:	f00c fafc 	bl	cd04 <__aeabi_ddiv>
     70c:	4602      	mov	r2, r0
     70e:	460b      	mov	r3, r1
     710:	e001      	b.n	716 <FeatureCollector::printRMSVals() [clone .part.43]+0x7e>
    }
    return rms_val;
     712:	e9d4 231c 	ldrd	r2, r3, [r4, #112]	; 0x70
     716:	2102      	movs	r1, #2
     718:	9100      	str	r1, [sp, #0]
     71a:	4804      	ldr	r0, [pc, #16]	; (72c <FeatureCollector::printRMSVals() [clone .part.43]+0x94>)
     71c:	f008 fe04 	bl	9328 <Print::printFloat(double, unsigned char)>
	size_t println(int n, int base)			{ return print(n, base) + println(); }
	size_t println(unsigned int n, int base)	{ return print(n, base) + println(); }
	size_t println(long n, int base)		{ return print(n, base) + println(); }
	size_t println(unsigned long n, int base)	{ return print(n, base) + println(); }

	size_t println(double n, int digits = 2)	{ return print(n, digits) + println(); }
     720:	4802      	ldr	r0, [pc, #8]	; (72c <FeatureCollector::printRMSVals() [clone .part.43]+0x94>)
        Serial.print(name); Serial.print(" RMS vals\t");
        Serial.print(rms_val);printTab();
        Serial.print("delta\t");Serial.print(rms_pos_delta);
        Serial.print(" average\t");Serial.println(getRMSAvg());
    }
}
     722:	b003      	add	sp, #12
     724:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
     728:	f008 bda4 	b.w	9274 <Print::println()>
     72c:	1fffbaf4 	.word	0x1fffbaf4
     730:	00010624 	.word	0x00010624
     734:	00010cc0 	.word	0x00010cc0
     738:	00010630 	.word	0x00010630
     73c:	00010638 	.word	0x00010638

00000740 <FeatureCollector::printPeakVals() [clone .part.44]>:

void FeatureCollector::printPeakVals() {
     740:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (peak_active > 0) {
        Serial.print(name); Serial.print(" Peak vals\t");
     742:	f100 0128 	add.w	r1, r0, #40	; 0x28
        Serial.print("delta\t");Serial.print(rms_pos_delta);
        Serial.print(" average\t");Serial.println(getRMSAvg());
    }
}

void FeatureCollector::printPeakVals() {
     746:	b083      	sub	sp, #12
     748:	4604      	mov	r4, r0
    if (peak_active > 0) {
        Serial.print(name); Serial.print(" Peak vals\t");
     74a:	4822      	ldr	r0, [pc, #136]	; (7d4 <FeatureCollector::printPeakVals() [clone .part.44]+0x94>)
     74c:	f008 fd6c 	bl	9228 <Print::print(String const&)>
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
     750:	2502      	movs	r5, #2
     752:	210b      	movs	r1, #11
     754:	4820      	ldr	r0, [pc, #128]	; (7d8 <FeatureCollector::printPeakVals() [clone .part.44]+0x98>)
     756:	f00a ff53 	bl	b600 <usb_serial_write>
     75a:	e9d4 232a 	ldrd	r2, r3, [r4, #168]	; 0xa8
     75e:	481d      	ldr	r0, [pc, #116]	; (7d4 <FeatureCollector::printPeakVals() [clone .part.44]+0x94>)
     760:	9500      	str	r5, [sp, #0]
     762:	f008 fde1 	bl	9328 <Print::printFloat(double, unsigned char)>
     766:	2101      	movs	r1, #1
     768:	481c      	ldr	r0, [pc, #112]	; (7dc <FeatureCollector::printPeakVals() [clone .part.44]+0x9c>)
     76a:	f00a ff49 	bl	b600 <usb_serial_write>
     76e:	2106      	movs	r1, #6
     770:	481b      	ldr	r0, [pc, #108]	; (7e0 <FeatureCollector::printPeakVals() [clone .part.44]+0xa0>)
     772:	f00a ff45 	bl	b600 <usb_serial_write>
     776:	e9d4 2306 	ldrd	r2, r3, [r4, #24]
     77a:	4816      	ldr	r0, [pc, #88]	; (7d4 <FeatureCollector::printPeakVals() [clone .part.44]+0x94>)
     77c:	9500      	str	r5, [sp, #0]
     77e:	f008 fdd3 	bl	9328 <Print::printFloat(double, unsigned char)>
     782:	2109      	movs	r1, #9
     784:	4817      	ldr	r0, [pc, #92]	; (7e4 <FeatureCollector::printPeakVals() [clone .part.44]+0xa4>)
     786:	f00a ff3b 	bl	b600 <usb_serial_write>
    Serial.println("ERROR  - Peak IS NOT AN ACTIVE AUDIO FEATURE : "); Serial.println(name);
    return -1.0;
}

double FeatureCollector::getPeakAvg() {
    if (peak_readings > 0 && peak_totals > 0) {
     78a:	f8d4 50c0 	ldr.w	r5, [r4, #192]	; 0xc0
     78e:	b1a5      	cbz	r5, 7ba <FeatureCollector::printPeakVals() [clone .part.44]+0x7a>
     790:	e9d4 672e 	ldrd	r6, r7, [r4, #184]	; 0xb8
     794:	2200      	movs	r2, #0
     796:	2300      	movs	r3, #0
     798:	4630      	mov	r0, r6
     79a:	4639      	mov	r1, r7
     79c:	f00c fc18 	bl	cfd0 <__aeabi_dcmpgt>
     7a0:	b158      	cbz	r0, 7ba <FeatureCollector::printPeakVals() [clone .part.44]+0x7a>
        return ((double)peak_totals / (double)peak_readings);
     7a2:	4628      	mov	r0, r5
     7a4:	f00c f90e 	bl	c9c4 <__aeabi_ui2d>
     7a8:	4602      	mov	r2, r0
     7aa:	460b      	mov	r3, r1
     7ac:	4630      	mov	r0, r6
     7ae:	4639      	mov	r1, r7
     7b0:	f00c faa8 	bl	cd04 <__aeabi_ddiv>
     7b4:	4602      	mov	r2, r0
     7b6:	460b      	mov	r3, r1
     7b8:	e001      	b.n	7be <FeatureCollector::printPeakVals() [clone .part.44]+0x7e>
    }
    return peak_val;
     7ba:	e9d4 232a 	ldrd	r2, r3, [r4, #168]	; 0xa8
     7be:	2102      	movs	r1, #2
     7c0:	9100      	str	r1, [sp, #0]
     7c2:	4804      	ldr	r0, [pc, #16]	; (7d4 <FeatureCollector::printPeakVals() [clone .part.44]+0x94>)
     7c4:	f008 fdb0 	bl	9328 <Print::printFloat(double, unsigned char)>
	size_t println(int n, int base)			{ return print(n, base) + println(); }
	size_t println(unsigned int n, int base)	{ return print(n, base) + println(); }
	size_t println(long n, int base)		{ return print(n, base) + println(); }
	size_t println(unsigned long n, int base)	{ return print(n, base) + println(); }

	size_t println(double n, int digits = 2)	{ return print(n, digits) + println(); }
     7c8:	4802      	ldr	r0, [pc, #8]	; (7d4 <FeatureCollector::printPeakVals() [clone .part.44]+0x94>)
        Serial.print(name); Serial.print(" Peak vals\t");
        Serial.print(peak_val);printTab();
        Serial.print("delta\t");Serial.print(peak_pos_delta);
        Serial.print(" average\t");Serial.println(getPeakAvg());
    }
}
     7ca:	b003      	add	sp, #12
     7cc:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
     7d0:	f008 bd50 	b.w	9274 <Print::println()>
     7d4:	1fffbaf4 	.word	0x1fffbaf4
     7d8:	00010644 	.word	0x00010644
     7dc:	00010cc0 	.word	0x00010cc0
     7e0:	00010630 	.word	0x00010630
     7e4:	00010638 	.word	0x00010638

000007e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>:
class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
     7e8:	2300      	movs	r3, #0
#define AudioMemoryUsageMaxReset() (AudioStream::memory_used_max = AudioStream::memory_used)

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
     7ea:	b410      	push	{r4}
		num_inputs(ninput), inputQueue(iqueue) {
     7ec:	4c10      	ldr	r4, [pc, #64]	; (830 <AudioStream::AudioStream(unsigned char, audio_block_struct**)+0x48>)
     7ee:	7241      	strb	r1, [r0, #9]
     7f0:	6102      	str	r2, [r0, #16]
     7f2:	6004      	str	r4, [r0, #0]
			active = false;
     7f4:	7203      	strb	r3, [r0, #8]
			destination_list = NULL;
     7f6:	60c3      	str	r3, [r0, #12]
			for (int i=0; i < num_inputs; i++) {
     7f8:	b141      	cbz	r1, 80c <AudioStream::AudioStream(unsigned char, audio_block_struct**)+0x24>
				inputQueue[i] = NULL;
     7fa:	4619      	mov	r1, r3
     7fc:	e000      	b.n	800 <AudioStream::AudioStream(unsigned char, audio_block_struct**)+0x18>
     7fe:	6902      	ldr	r2, [r0, #16]
     800:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
     804:	7a42      	ldrb	r2, [r0, #9]
     806:	3301      	adds	r3, #1
     808:	429a      	cmp	r2, r3
     80a:	dcf8      	bgt.n	7fe <AudioStream::AudioStream(unsigned char, audio_block_struct**)+0x16>
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
     80c:	4b09      	ldr	r3, [pc, #36]	; (834 <AudioStream::AudioStream(unsigned char, audio_block_struct**)+0x4c>)
     80e:	681a      	ldr	r2, [r3, #0]
     810:	b90a      	cbnz	r2, 816 <AudioStream::AudioStream(unsigned char, audio_block_struct**)+0x2e>
     812:	e00b      	b.n	82c <AudioStream::AudioStream(unsigned char, audio_block_struct**)+0x44>
     814:	461a      	mov	r2, r3
				first_update = this;
			} else {
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
     816:	6953      	ldr	r3, [r2, #20]
     818:	2b00      	cmp	r3, #0
     81a:	d1fb      	bne.n	814 <AudioStream::AudioStream(unsigned char, audio_block_struct**)+0x2c>
				p->next_update = this;
     81c:	6150      	str	r0, [r2, #20]
			}
			next_update = NULL;
     81e:	2300      	movs	r3, #0
     820:	6143      	str	r3, [r0, #20]
			cpu_cycles = 0;
     822:	8083      	strh	r3, [r0, #4]
			cpu_cycles_max = 0;
     824:	80c3      	strh	r3, [r0, #6]
			numConnections = 0;
     826:	7283      	strb	r3, [r0, #10]
		}
     828:	bc10      	pop	{r4}
     82a:	4770      	bx	lr
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
				first_update = this;
     82c:	6018      	str	r0, [r3, #0]
     82e:	e7f6      	b.n	81e <AudioStream::AudioStream(unsigned char, audio_block_struct**)+0x36>
     830:	000105d0 	.word	0x000105d0
     834:	20004598 	.word	0x20004598

00000838 <printMajorDivide(String)>:
}

void printDivide() {
  Serial.println("|||||||||||||||||||||||||||||||||||||");
}
void printMajorDivide(String text) {
     838:	b510      	push	{r4, lr}
     83a:	2125      	movs	r1, #37	; 0x25
     83c:	4604      	mov	r4, r0
     83e:	480f      	ldr	r0, [pc, #60]	; (87c <printMajorDivide(String)+0x44>)
     840:	f00a fede 	bl	b600 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     844:	480e      	ldr	r0, [pc, #56]	; (880 <printMajorDivide(String)+0x48>)
     846:	f008 fd15 	bl	9274 <Print::println()>
	//unsigned char equals(const __FlashStringHelper *pgmstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
	unsigned char operator == (const __FlashStringHelper *s) const {return equals((const char *)s);}
	unsigned char operator != (const String &rhs) const {return !equals(rhs);}
	unsigned char operator != (const char *cstr) const {return !equals(cstr);}
     84a:	4620      	mov	r0, r4
     84c:	490d      	ldr	r1, [pc, #52]	; (884 <printMajorDivide(String)+0x4c>)
     84e:	f008 fefd 	bl	964c <String::equals(char const*) const>
  Serial.println("|||||||||||||||||||||||||||||||||||||");
  if (text != "") {
     852:	b158      	cbz	r0, 86c <printMajorDivide(String)+0x34>
    Serial.println(text);
  } else {
    Serial.println();
     854:	480a      	ldr	r0, [pc, #40]	; (880 <printMajorDivide(String)+0x48>)
     856:	f008 fd0d 	bl	9274 <Print::println()>
     85a:	2125      	movs	r1, #37	; 0x25
     85c:	4807      	ldr	r0, [pc, #28]	; (87c <printMajorDivide(String)+0x44>)
     85e:	f00a fecf 	bl	b600 <usb_serial_write>
     862:	4807      	ldr	r0, [pc, #28]	; (880 <printMajorDivide(String)+0x48>)
  };
  Serial.println("|||||||||||||||||||||||||||||||||||||");
}
     864:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     868:	f008 bd04 	b.w	9274 <Print::println()>
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
     86c:	4621      	mov	r1, r4
     86e:	4804      	ldr	r0, [pc, #16]	; (880 <printMajorDivide(String)+0x48>)
     870:	f008 fcda 	bl	9228 <Print::print(String const&)>
     874:	4802      	ldr	r0, [pc, #8]	; (880 <printMajorDivide(String)+0x48>)
     876:	f008 fcfd 	bl	9274 <Print::println()>
     87a:	e7ee      	b.n	85a <printMajorDivide(String)+0x22>
     87c:	000107ac 	.word	0x000107ac
     880:	1fffbaf4 	.word	0x1fffbaf4
     884:	00010b88 	.word	0x00010b88

00000888 <Datalog::writeDouble()>:

void Datalog::writeDouble() {
    // to do this is aweful, need to rewrite todo
    // store the dat with least significant bytes in lower index
    uint8_t b[4];
    uint32_t d = *dval * DOUBLE_PRECISION;
     888:	6981      	ldr	r1, [r0, #24]
        b[i] = (d >> i * 8) & 0x00FF;
        EEPROM.update(addr + i, b[i]);
    }
}

void Datalog::writeDouble() {
     88a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    // to do this is aweful, need to rewrite todo
    // store the dat with least significant bytes in lower index
    uint8_t b[4];
    uint32_t d = *dval * DOUBLE_PRECISION;
     88e:	a310      	add	r3, pc, #64	; (adr r3, 8d0 <Datalog::writeDouble()+0x48>)
     890:	e9d3 2300 	ldrd	r2, r3, [r3]
        b[i] = (d >> i * 8) & 0x00FF;
        EEPROM.update(addr + i, b[i]);
    }
}

void Datalog::writeDouble() {
     894:	4607      	mov	r7, r0
    // to do this is aweful, need to rewrite todo
    // store the dat with least significant bytes in lower index
    uint8_t b[4];
    uint32_t d = *dval * DOUBLE_PRECISION;
     896:	e9d1 0100 	ldrd	r0, r1, [r1]
     89a:	f00c f909 	bl	cab0 <__aeabi_dmul>
     89e:	f00c fbdf 	bl	d060 <__aeabi_d2uiz>
    for (int i = 0; i < 4; i++) {
     8a2:	2500      	movs	r5, #0

void Datalog::writeDouble() {
    // to do this is aweful, need to rewrite todo
    // store the dat with least significant bytes in lower index
    uint8_t b[4];
    uint32_t d = *dval * DOUBLE_PRECISION;
     8a4:	4680      	mov	r8, r0

    EERef( const int index )
        : index( index )                 {}

    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
     8a6:	6afe      	ldr	r6, [r7, #44]	; 0x2c
     8a8:	442e      	add	r6, r5
     8aa:	4630      	mov	r0, r6
     8ac:	f008 ffb6 	bl	981c <eeprom_read_byte>
    for (int i = 0; i < 4; i++) {
        b[i] = (d >> i * 8) & 0x00FF;
     8b0:	00ec      	lsls	r4, r5, #3
     8b2:	fa28 f404 	lsr.w	r4, r8, r4
     8b6:	b2e4      	uxtb	r4, r4
    EERef &operator &=( uint8_t in )     { return *this = **this & in; }
    EERef &operator |=( uint8_t in )     { return *this = **this | in; }
    EERef &operator <<=( uint8_t in )    { return *this = **this << in; }
    EERef &operator >>=( uint8_t in )    { return *this = **this >> in; }

    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
     8b8:	4284      	cmp	r4, r0
void Datalog::writeDouble() {
    // to do this is aweful, need to rewrite todo
    // store the dat with least significant bytes in lower index
    uint8_t b[4];
    uint32_t d = *dval * DOUBLE_PRECISION;
    for (int i = 0; i < 4; i++) {
     8ba:	f105 0501 	add.w	r5, r5, #1
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    operator const uint8_t() const       { return **this; }

    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
     8be:	4621      	mov	r1, r4
     8c0:	4630      	mov	r0, r6
    EERef &operator &=( uint8_t in )     { return *this = **this & in; }
    EERef &operator |=( uint8_t in )     { return *this = **this | in; }
    EERef &operator <<=( uint8_t in )    { return *this = **this << in; }
    EERef &operator >>=( uint8_t in )    { return *this = **this >> in; }

    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
     8c2:	d001      	beq.n	8c8 <Datalog::writeDouble()+0x40>
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    operator const uint8_t() const       { return **this; }

    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
     8c4:	f008 ffc4 	bl	9850 <eeprom_write_byte>
     8c8:	2d04      	cmp	r5, #4
     8ca:	d1ec      	bne.n	8a6 <Datalog::writeDouble()+0x1e>
        b[i] = (d >> i * 8) & 0x00FF;
        EEPROM.update(addr + i, b[i]);
    }
}
     8cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     8d0:	00000000 	.word	0x00000000
     8d4:	40f86a00 	.word	0x40f86a00

000008d8 <Datalog::writeShort()>:
    EEPROM.update(addr, lsb);
    EEPROM.update(addr + 1, msb);
    writeCheck(*sval);
}

void Datalog::writeShort() {
     8d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    // store the dat with least significant bytes in lower index
    uint8_t lsb = *sval & 0x00FF;
     8da:	6a03      	ldr	r3, [r0, #32]
    uint8_t msb = *sval >> 8;
    EEPROM.update(addr, lsb);
     8dc:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
    writeCheck(*sval);
}

void Datalog::writeShort() {
    // store the dat with least significant bytes in lower index
    uint8_t lsb = *sval & 0x00FF;
     8de:	881b      	ldrh	r3, [r3, #0]
    EEPROM.update(addr, lsb);
    EEPROM.update(addr + 1, msb);
    writeCheck(*sval);
}

void Datalog::writeShort() {
     8e0:	4606      	mov	r6, r0

    EERef( const int index )
        : index( index )                 {}

    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
     8e2:	4620      	mov	r0, r4
    // store the dat with least significant bytes in lower index
    uint8_t lsb = *sval & 0x00FF;
     8e4:	b2df      	uxtb	r7, r3
    uint8_t msb = *sval >> 8;
     8e6:	0a1d      	lsrs	r5, r3, #8
     8e8:	f008 ff98 	bl	981c <eeprom_read_byte>
    EERef &operator &=( uint8_t in )     { return *this = **this & in; }
    EERef &operator |=( uint8_t in )     { return *this = **this | in; }
    EERef &operator <<=( uint8_t in )    { return *this = **this << in; }
    EERef &operator >>=( uint8_t in )    { return *this = **this >> in; }

    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
     8ec:	4287      	cmp	r7, r0
     8ee:	d004      	beq.n	8fa <Datalog::writeShort()+0x22>
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    operator const uint8_t() const       { return **this; }

    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
     8f0:	4620      	mov	r0, r4
     8f2:	4639      	mov	r1, r7
     8f4:	f008 ffac 	bl	9850 <eeprom_write_byte>
     8f8:	6af4      	ldr	r4, [r6, #44]	; 0x2c

    EERef( const int index )
        : index( index )                 {}

    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
     8fa:	3401      	adds	r4, #1
     8fc:	4620      	mov	r0, r4
     8fe:	f008 ff8d 	bl	981c <eeprom_read_byte>
    EERef &operator &=( uint8_t in )     { return *this = **this & in; }
    EERef &operator |=( uint8_t in )     { return *this = **this | in; }
    EERef &operator <<=( uint8_t in )    { return *this = **this << in; }
    EERef &operator >>=( uint8_t in )    { return *this = **this >> in; }

    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
     902:	4285      	cmp	r5, r0
     904:	d005      	beq.n	912 <Datalog::writeShort()+0x3a>
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    operator const uint8_t() const       { return **this; }

    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
     906:	4629      	mov	r1, r5
     908:	4620      	mov	r0, r4
    EEPROM.update(addr, lsb);
    EEPROM.update(addr + 1, msb);
    writeCheck(*sval);
}
     90a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
     90e:	f008 bf9f 	b.w	9850 <eeprom_write_byte>
     912:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00000914 <Datalog::writeLong()>:
    writeCheck(data);
}

void Datalog::writeLong() {
    uint8_t b[4];
    uint32_t v = *lval;
     914:	6a43      	ldr	r3, [r0, #36]	; 0x24
        EEPROM.update(addr + i, b[i]);
    }
    writeCheck(data);
}

void Datalog::writeLong() {
     916:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint8_t b[4];
    uint32_t v = *lval;
     91a:	f8d3 8000 	ldr.w	r8, [r3]
        EEPROM.update(addr + i, b[i]);
    }
    writeCheck(data);
}

void Datalog::writeLong() {
     91e:	4607      	mov	r7, r0
    uint8_t b[4];
    uint32_t v = *lval;
    for (int i = 0; i < 4; i++) {
     920:	2500      	movs	r5, #0

    EERef( const int index )
        : index( index )                 {}

    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
     922:	6afe      	ldr	r6, [r7, #44]	; 0x2c
     924:	442e      	add	r6, r5
     926:	4630      	mov	r0, r6
     928:	f008 ff78 	bl	981c <eeprom_read_byte>
        b[i] = v >> 8 * i;
     92c:	00ec      	lsls	r4, r5, #3
     92e:	fa28 f404 	lsr.w	r4, r8, r4
     932:	b2e4      	uxtb	r4, r4
    EERef &operator &=( uint8_t in )     { return *this = **this & in; }
    EERef &operator |=( uint8_t in )     { return *this = **this | in; }
    EERef &operator <<=( uint8_t in )    { return *this = **this << in; }
    EERef &operator >>=( uint8_t in )    { return *this = **this >> in; }

    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
     934:	4284      	cmp	r4, r0
}

void Datalog::writeLong() {
    uint8_t b[4];
    uint32_t v = *lval;
    for (int i = 0; i < 4; i++) {
     936:	f105 0501 	add.w	r5, r5, #1
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    operator const uint8_t() const       { return **this; }

    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
     93a:	4621      	mov	r1, r4
     93c:	4630      	mov	r0, r6
    EERef &operator &=( uint8_t in )     { return *this = **this & in; }
    EERef &operator |=( uint8_t in )     { return *this = **this | in; }
    EERef &operator <<=( uint8_t in )    { return *this = **this << in; }
    EERef &operator >>=( uint8_t in )    { return *this = **this >> in; }

    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
     93e:	d001      	beq.n	944 <Datalog::writeLong()+0x30>
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    operator const uint8_t() const       { return **this; }

    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
     940:	f008 ff86 	bl	9850 <eeprom_write_byte>
     944:	2d04      	cmp	r5, #4
     946:	d1ec      	bne.n	922 <Datalog::writeLong()+0xe>
        b[i] = v >> 8 * i;
        EEPROM.update(addr + i, b[i]);
    }
    writeCheck(v);
}
     948:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000094c <Datalog::update()>:
    return false;
}

//////////////////////// Misc. Methods /////////////////////////////////

bool Datalog::update() {
     94c:	b5f0      	push	{r4, r5, r6, r7, lr}
     94e:	b085      	sub	sp, #20
    // if the log is currently active
    dprint(PRINT_LOG_WRITE, id);
     950:	1d01      	adds	r1, r0, #4
    return false;
}

//////////////////////// Misc. Methods /////////////////////////////////

bool Datalog::update() {
     952:	4604      	mov	r4, r0
    // if the log is currently active
    dprint(PRINT_LOG_WRITE, id);
     954:	4668      	mov	r0, sp
     956:	f008 fe13 	bl	9580 <String::String(String const&)>
     95a:	4668      	mov	r0, sp
     95c:	f008 fdbc 	bl	94d8 <String::~String()>
    if (active == false) {
     960:	f894 5028 	ldrb.w	r5, [r4, #40]	; 0x28
     964:	b345      	cbz	r5, 9b8 <Datalog::update()+0x6c>
        // dprint(PRINT_LOG_WRITE, id);
        dprint(PRINT_LOG_WRITE, " not active, not updating");
        return 0;
    }
    // if we got this far then everything is good for an update
    dprint(PRINT_LOG_WRITE, " updated ");
     966:	492a      	ldr	r1, [pc, #168]	; (a10 <Datalog::update()+0xc4>)
     968:	4668      	mov	r0, sp
     96a:	f008 fdf5 	bl	9558 <String::String(char const*)>
     96e:	4668      	mov	r0, sp
     970:	f008 fdb2 	bl	94d8 <String::~String()>
    // dprint(PRINT_LOG_WRITE, id);
    switch(data_type) {
     974:	7d63      	ldrb	r3, [r4, #21]
     976:	2b03      	cmp	r3, #3
     978:	d80f      	bhi.n	99a <Datalog::update()+0x4e>
     97a:	e8df f003 	tbb	[pc, r3]
     97e:	2e27      	.short	0x2e27
     980:	0235      	.short	0x0235

    EERef( const int index )
        : index( index )                 {}

    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
     982:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
        case DATATYPE_DOUBLE:
            writeDouble();
            dprintln(PRINT_LOG_WRITE, *dval);
            break;
        case DATATYPE_BYTE:
            EEPROM.update(addr, *bval);
     984:	69e3      	ldr	r3, [r4, #28]
     986:	4630      	mov	r0, r6
     988:	781f      	ldrb	r7, [r3, #0]
     98a:	f008 ff47 	bl	981c <eeprom_read_byte>
    EERef &operator &=( uint8_t in )     { return *this = **this & in; }
    EERef &operator |=( uint8_t in )     { return *this = **this | in; }
    EERef &operator <<=( uint8_t in )    { return *this = **this << in; }
    EERef &operator >>=( uint8_t in )    { return *this = **this >> in; }

    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
     98e:	4287      	cmp	r7, r0
     990:	d003      	beq.n	99a <Datalog::update()+0x4e>
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    operator const uint8_t() const       { return **this; }

    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
     992:	4639      	mov	r1, r7
     994:	4630      	mov	r0, r6
     996:	f008 ff5b 	bl	9850 <eeprom_write_byte>
            dprintln(PRINT_LOG_WRITE, *lval);
            break;
    }
    // print some feedback if the appropiate flag is set
    /////////// autolog stuff
    if (autolog_active == true && moving_index == true) {
     99a:	7de3      	ldrb	r3, [r4, #23]
     99c:	b14b      	cbz	r3, 9b2 <Datalog::update()+0x66>
     99e:	7826      	ldrb	r6, [r4, #0]
     9a0:	b13e      	cbz	r6, 9b2 <Datalog::update()+0x66>
        // increment the addr counter
        addr += value_size;
     9a2:	7da3      	ldrb	r3, [r4, #22]
     9a4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
        // if the current address plus the data_length is greater than the end index and 
        // if the datalogger is on autolog then stop the autologger
        if (addr + value_size > end_addr) {
     9a6:	6b61      	ldr	r1, [r4, #52]	; 0x34
    }
    // print some feedback if the appropiate flag is set
    /////////// autolog stuff
    if (autolog_active == true && moving_index == true) {
        // increment the addr counter
        addr += value_size;
     9a8:	441a      	add	r2, r3
        // if the current address plus the data_length is greater than the end index and 
        // if the datalogger is on autolog then stop the autologger
        if (addr + value_size > end_addr) {
     9aa:	4413      	add	r3, r2
     9ac:	428b      	cmp	r3, r1
    }
    // print some feedback if the appropiate flag is set
    /////////// autolog stuff
    if (autolog_active == true && moving_index == true) {
        // increment the addr counter
        addr += value_size;
     9ae:	62e2      	str	r2, [r4, #44]	; 0x2c
        // if the current address plus the data_length is greater than the end index and 
        // if the datalogger is on autolog then stop the autologger
        if (addr + value_size > end_addr) {
     9b0:	d821      	bhi.n	9f6 <Datalog::update()+0xaa>
            active = false;
            dprintln(PRINT_LOG_WRITE, "Autolog deactivated, allocated memory has been used up");
        }
    }
    return 1;
}
     9b2:	4628      	mov	r0, r5
     9b4:	b005      	add	sp, #20
     9b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
bool Datalog::update() {
    // if the log is currently active
    dprint(PRINT_LOG_WRITE, id);
    if (active == false) {
        // dprint(PRINT_LOG_WRITE, id);
        dprint(PRINT_LOG_WRITE, " not active, not updating");
     9b8:	4916      	ldr	r1, [pc, #88]	; (a14 <Datalog::update()+0xc8>)
     9ba:	4668      	mov	r0, sp
     9bc:	f008 fdcc 	bl	9558 <String::String(char const*)>
     9c0:	4668      	mov	r0, sp
     9c2:	f008 fd89 	bl	94d8 <String::~String()>
            active = false;
            dprintln(PRINT_LOG_WRITE, "Autolog deactivated, allocated memory has been used up");
        }
    }
    return 1;
}
     9c6:	4628      	mov	r0, r5
     9c8:	b005      	add	sp, #20
     9ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
        case DATATYPE_SHORT:
            writeShort();
            dprintln(PRINT_LOG_WRITE, *sval);
            break;
        case DATATYPE_DOUBLE:
            writeDouble();
     9cc:	4620      	mov	r0, r4
     9ce:	f7ff ff5b 	bl	888 <Datalog::writeDouble()>
            dprintln(PRINT_LOG_WRITE, *lval);
            break;
    }
    // print some feedback if the appropiate flag is set
    /////////// autolog stuff
    if (autolog_active == true && moving_index == true) {
     9d2:	7de3      	ldrb	r3, [r4, #23]
     9d4:	2b00      	cmp	r3, #0
     9d6:	d1e2      	bne.n	99e <Datalog::update()+0x52>
     9d8:	e7eb      	b.n	9b2 <Datalog::update()+0x66>
    // if we got this far then everything is good for an update
    dprint(PRINT_LOG_WRITE, " updated ");
    // dprint(PRINT_LOG_WRITE, id);
    switch(data_type) {
        case DATATYPE_SHORT:
            writeShort();
     9da:	4620      	mov	r0, r4
     9dc:	f7ff ff7c 	bl	8d8 <Datalog::writeShort()>
            dprintln(PRINT_LOG_WRITE, *lval);
            break;
    }
    // print some feedback if the appropiate flag is set
    /////////// autolog stuff
    if (autolog_active == true && moving_index == true) {
     9e0:	7de3      	ldrb	r3, [r4, #23]
     9e2:	2b00      	cmp	r3, #0
     9e4:	d1db      	bne.n	99e <Datalog::update()+0x52>
     9e6:	e7e4      	b.n	9b2 <Datalog::update()+0x66>
        case DATATYPE_BYTE:
            EEPROM.update(addr, *bval);
            dprintln(PRINT_LOG_WRITE, *bval);
            break;
        case DATATYPE_LONG:
            writeLong();
     9e8:	4620      	mov	r0, r4
     9ea:	f7ff ff93 	bl	914 <Datalog::writeLong()>
            dprintln(PRINT_LOG_WRITE, *lval);
            break;
    }
    // print some feedback if the appropiate flag is set
    /////////// autolog stuff
    if (autolog_active == true && moving_index == true) {
     9ee:	7de3      	ldrb	r3, [r4, #23]
     9f0:	2b00      	cmp	r3, #0
     9f2:	d1d4      	bne.n	99e <Datalog::update()+0x52>
     9f4:	e7dd      	b.n	9b2 <Datalog::update()+0x66>
        // increment the addr counter
        addr += value_size;
        // if the current address plus the data_length is greater than the end index and 
        // if the datalogger is on autolog then stop the autologger
        if (addr + value_size > end_addr) {
            autolog_active = false;
     9f6:	2300      	movs	r3, #0
     9f8:	75e3      	strb	r3, [r4, #23]
            active = false;
     9fa:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
            dprintln(PRINT_LOG_WRITE, "Autolog deactivated, allocated memory has been used up");
     9fe:	4906      	ldr	r1, [pc, #24]	; (a18 <Datalog::update()+0xcc>)
     a00:	4668      	mov	r0, sp
     a02:	f008 fda9 	bl	9558 <String::String(char const*)>
     a06:	4668      	mov	r0, sp
     a08:	f008 fd66 	bl	94d8 <String::~String()>
     a0c:	4635      	mov	r5, r6
     a0e:	e7d0      	b.n	9b2 <Datalog::update()+0x66>
     a10:	0001083c 	.word	0x0001083c
     a14:	00010820 	.word	0x00010820
     a18:	00010848 	.word	0x00010848

00000a1c <Datalog::printLog(unsigned char)>:

void Datalog::printlog(uint8_t lines) {
    printLog(lines);
}

void Datalog::printLog(uint8_t lines) {
     a1c:	b5f0      	push	{r4, r5, r6, r7, lr}
     a1e:	b085      	sub	sp, #20
     a20:	4607      	mov	r7, r0
     a22:	460c      	mov	r4, r1
    //printDivide(PRINT_LOG_WRITE);
    dprint(PRINT_LOG_WRITE, "Printing the ");
     a24:	4668      	mov	r0, sp
     a26:	4928      	ldr	r1, [pc, #160]	; (ac8 <Datalog::printLog(unsigned char)+0xac>)
     a28:	f008 fd96 	bl	9558 <String::String(char const*)>
     a2c:	4668      	mov	r0, sp
     a2e:	f008 fd53 	bl	94d8 <String::~String()>
    dprint(PRINT_LOG_WRITE, id);
     a32:	1d39      	adds	r1, r7, #4
     a34:	4668      	mov	r0, sp
     a36:	f008 fda3 	bl	9580 <String::String(String const&)>
     a3a:	4668      	mov	r0, sp
     a3c:	f008 fd4c 	bl	94d8 <String::~String()>
    uint32_t per_line;
    if (end_addr > start_addr) {
     a40:	6b7b      	ldr	r3, [r7, #52]	; 0x34
     a42:	6b3a      	ldr	r2, [r7, #48]	; 0x30
     a44:	4293      	cmp	r3, r2
     a46:	d93c      	bls.n	ac2 <Datalog::printLog(unsigned char)+0xa6>
        per_line = (end_addr - start_addr) / value_size / lines;
     a48:	7dbe      	ldrb	r6, [r7, #22]
     a4a:	1a9b      	subs	r3, r3, r2
     a4c:	fbb3 f3f6 	udiv	r3, r3, r6
     a50:	fbb3 f6f4 	udiv	r6, r3, r4
    } else {
        per_line =  1;
    }
    dprint(PRINT_LOG_WRITE, " from start/end addr : ");
     a54:	491d      	ldr	r1, [pc, #116]	; (acc <Datalog::printLog(unsigned char)+0xb0>)
     a56:	4668      	mov	r0, sp
     a58:	f008 fd7e 	bl	9558 <String::String(char const*)>
     a5c:	4668      	mov	r0, sp
     a5e:	f008 fd3b 	bl	94d8 <String::~String()>
    dprint(PRINT_LOG_WRITE, start_addr);dprint(PRINT_LOG_WRITE,"-");
     a62:	491b      	ldr	r1, [pc, #108]	; (ad0 <Datalog::printLog(unsigned char)+0xb4>)
     a64:	4668      	mov	r0, sp
     a66:	f008 fd77 	bl	9558 <String::String(char const*)>
     a6a:	4668      	mov	r0, sp
     a6c:	f008 fd34 	bl	94d8 <String::~String()>
    dprint(PRINT_LOG_WRITE, end_addr);
    if (end_addr - start_addr > 4)  {
        dprintln(PRINT_LOG_WRITE, "\t");
     a70:	4918      	ldr	r1, [pc, #96]	; (ad4 <Datalog::printLog(unsigned char)+0xb8>)
     a72:	4668      	mov	r0, sp
    } else  {
        dprint(PRINT_LOG_WRITE, "\t");
     a74:	f008 fd70 	bl	9558 <String::String(char const*)>
     a78:	4668      	mov	r0, sp
     a7a:	f008 fd2d 	bl	94d8 <String::~String()>
    double d = 0.0;
    uint32_t l = 0;
    uint16_t iv = 0;
    uint8_t b = 0;

    for (uint16_t i = start_addr; i < end_addr; i += value_size) {
     a7e:	8e3d      	ldrh	r5, [r7, #48]	; 0x30
     a80:	6b7a      	ldr	r2, [r7, #52]	; 0x34
     a82:	4295      	cmp	r5, r2
     a84:	d21b      	bcs.n	abe <Datalog::printLog(unsigned char)+0xa2>
     a86:	2400      	movs	r4, #0
     a88:	e004      	b.n	a94 <Datalog::printLog(unsigned char)+0x78>
     a8a:	7dbb      	ldrb	r3, [r7, #22]
     a8c:	441d      	add	r5, r3
     a8e:	b2ad      	uxth	r5, r5
     a90:	4295      	cmp	r5, r2
     a92:	d214      	bcs.n	abe <Datalog::printLog(unsigned char)+0xa2>
        itters++;
     a94:	3401      	adds	r4, #1
     a96:	b2e4      	uxtb	r4, r4
                d = readDouble(i);
                dprint(PRINT_LOG_WRITE, d);
                break;
        }
        // print tab or line depending on how many prints have occured so far
        if (itters % per_line == 0) {
     a98:	fbb4 f3f6 	udiv	r3, r4, r6
     a9c:	fb06 4313 	mls	r3, r6, r3, r4
     aa0:	2b00      	cmp	r3, #0
     aa2:	d0f2      	beq.n	a8a <Datalog::printLog(unsigned char)+0x6e>
            dprintln(PRINT_LOG_WRITE);
        } else {
            dprint(PRINT_LOG_WRITE, "\t");
     aa4:	490b      	ldr	r1, [pc, #44]	; (ad4 <Datalog::printLog(unsigned char)+0xb8>)
     aa6:	4668      	mov	r0, sp
     aa8:	f008 fd56 	bl	9558 <String::String(char const*)>
     aac:	4668      	mov	r0, sp
     aae:	f008 fd13 	bl	94d8 <String::~String()>
    double d = 0.0;
    uint32_t l = 0;
    uint16_t iv = 0;
    uint8_t b = 0;

    for (uint16_t i = start_addr; i < end_addr; i += value_size) {
     ab2:	7dbb      	ldrb	r3, [r7, #22]
     ab4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
     ab6:	441d      	add	r5, r3
     ab8:	b2ad      	uxth	r5, r5
     aba:	4295      	cmp	r5, r2
     abc:	d3ea      	bcc.n	a94 <Datalog::printLog(unsigned char)+0x78>
        } else {
            dprint(PRINT_LOG_WRITE, "\t");
        }
    }
    dprintln(PRINT_LOG_WRITE);
}
     abe:	b005      	add	sp, #20
     ac0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    dprint(PRINT_LOG_WRITE, id);
    uint32_t per_line;
    if (end_addr > start_addr) {
        per_line = (end_addr - start_addr) / value_size / lines;
    } else {
        per_line =  1;
     ac2:	2601      	movs	r6, #1
     ac4:	e7c6      	b.n	a54 <Datalog::printLog(unsigned char)+0x38>
     ac6:	bf00      	nop
     ac8:	0001089c 	.word	0x0001089c
     acc:	000108ac 	.word	0x000108ac
     ad0:	000107a8 	.word	0x000107a8
     ad4:	00010cc0 	.word	0x00010cc0

00000ad8 <writeDoubleToEEPROM(unsigned long, double)>:
typedef struct oneofflog OneOffLog;

//////////////////////// Writing Methods /////////////////////////////////
// to do this is aweful, need to rewrite todo
// store the dat with least significant bytes in lower index
void writeDoubleToEEPROM(uint32_t addr, double data) {
     ad8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     ada:	4616      	mov	r6, r2
     adc:	461f      	mov	r7, r3
    uint8_t b[4];
    uint32_t d = data * DOUBLE_PRECISION;
     ade:	4639      	mov	r1, r7
     ae0:	a30f      	add	r3, pc, #60	; (adr r3, b20 <writeDoubleToEEPROM(unsigned long, double)+0x48>)
     ae2:	e9d3 2300 	ldrd	r2, r3, [r3]
typedef struct oneofflog OneOffLog;

//////////////////////// Writing Methods /////////////////////////////////
// to do this is aweful, need to rewrite todo
// store the dat with least significant bytes in lower index
void writeDoubleToEEPROM(uint32_t addr, double data) {
     ae6:	4605      	mov	r5, r0
    uint8_t b[4];
    uint32_t d = data * DOUBLE_PRECISION;
     ae8:	4630      	mov	r0, r6
     aea:	f00b ffe1 	bl	cab0 <__aeabi_dmul>
     aee:	f00c fab7 	bl	d060 <__aeabi_d2uiz>
     af2:	2600      	movs	r6, #0
     af4:	4607      	mov	r7, r0

    EERef( const int index )
        : index( index )                 {}

    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
     af6:	4628      	mov	r0, r5
     af8:	f008 fe90 	bl	981c <eeprom_read_byte>
    for (int i = 0; i < 4; i++) {
      b[i] = (d >> i * 8) & 0x00FF;
     afc:	fa27 f406 	lsr.w	r4, r7, r6
     b00:	b2e4      	uxtb	r4, r4
    EERef &operator &=( uint8_t in )     { return *this = **this & in; }
    EERef &operator |=( uint8_t in )     { return *this = **this | in; }
    EERef &operator <<=( uint8_t in )    { return *this = **this << in; }
    EERef &operator >>=( uint8_t in )    { return *this = **this >> in; }

    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
     b02:	4284      	cmp	r4, r0
     b04:	f106 0608 	add.w	r6, r6, #8
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    operator const uint8_t() const       { return **this; }

    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
     b08:	4628      	mov	r0, r5
     b0a:	4621      	mov	r1, r4
     b0c:	f105 0501 	add.w	r5, r5, #1
    EERef &operator &=( uint8_t in )     { return *this = **this & in; }
    EERef &operator |=( uint8_t in )     { return *this = **this | in; }
    EERef &operator <<=( uint8_t in )    { return *this = **this << in; }
    EERef &operator >>=( uint8_t in )    { return *this = **this >> in; }

    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
     b10:	d001      	beq.n	b16 <writeDoubleToEEPROM(unsigned long, double)+0x3e>
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    operator const uint8_t() const       { return **this; }

    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
     b12:	f008 fe9d 	bl	9850 <eeprom_write_byte>
// to do this is aweful, need to rewrite todo
// store the dat with least significant bytes in lower index
void writeDoubleToEEPROM(uint32_t addr, double data) {
    uint8_t b[4];
    uint32_t d = data * DOUBLE_PRECISION;
    for (int i = 0; i < 4; i++) {
     b16:	2e20      	cmp	r6, #32
     b18:	d1ed      	bne.n	af6 <writeDoubleToEEPROM(unsigned long, double)+0x1e>
      b[i] = (d >> i * 8) & 0x00FF;
      EEPROM.update(addr + i, b[i]);
    }
}
     b1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     b1c:	f3af 8000 	nop.w
     b20:	00000000 	.word	0x00000000
     b24:	40f86a00 	.word	0x40f86a00

00000b28 <readDoubleFromEEPROM(int)>:
      EEPROM.update(addr + i, b[i]);
    }
}

//////////////////////// Reading Methods /////////////////////////////////
double readDoubleFromEEPROM(int a) {
     b28:	b570      	push	{r4, r5, r6, lr}
     b2a:	4606      	mov	r6, r0

    EERef( const int index )
        : index( index )                 {}

    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
     b2c:	3003      	adds	r0, #3
     b2e:	f008 fe75 	bl	981c <eeprom_read_byte>
     b32:	1cb4      	adds	r4, r6, #2
     b34:	4605      	mov	r5, r0
     b36:	3e01      	subs	r6, #1
     b38:	4620      	mov	r0, r4
     b3a:	f008 fe6f 	bl	981c <eeprom_read_byte>
     b3e:	3c01      	subs	r4, #1
  uint32_t data = EEPROM.read(a + 3);
  for (int i = 2; i > -1; i--) {
     b40:	42a6      	cmp	r6, r4
    uint8_t reading = EEPROM.read(a + i);
    // dprint(PRINT_LOG_WRITE, reading);
    // dprint(PRINT_LOG_WRITE, "|");
    data = (data << 8) | reading;
     b42:	ea40 2505 	orr.w	r5, r0, r5, lsl #8
}

//////////////////////// Reading Methods /////////////////////////////////
double readDoubleFromEEPROM(int a) {
  uint32_t data = EEPROM.read(a + 3);
  for (int i = 2; i > -1; i--) {
     b46:	d1f7      	bne.n	b38 <readDoubleFromEEPROM(int)+0x10>
    uint8_t reading = EEPROM.read(a + i);
    // dprint(PRINT_LOG_WRITE, reading);
    // dprint(PRINT_LOG_WRITE, "|");
    data = (data << 8) | reading;
  }
  return (double)data / DOUBLE_PRECISION;
     b48:	4628      	mov	r0, r5
     b4a:	f00b ff3b 	bl	c9c4 <__aeabi_ui2d>
     b4e:	a304      	add	r3, pc, #16	; (adr r3, b60 <readDoubleFromEEPROM(int)+0x38>)
     b50:	e9d3 2300 	ldrd	r2, r3, [r3]
     b54:	f00c f8d6 	bl	cd04 <__aeabi_ddiv>
}
     b58:	bd70      	pop	{r4, r5, r6, pc}
     b5a:	bf00      	nop
     b5c:	f3af 8000 	nop.w
     b60:	00000000 	.word	0x00000000
     b64:	40f86a00 	.word	0x40f86a00

00000b68 <readShortFromEEPROM(int)>:

uint16_t readShortFromEEPROM(int a) {
     b68:	b538      	push	{r3, r4, r5, lr}
     b6a:	4605      	mov	r5, r0
     b6c:	3001      	adds	r0, #1
     b6e:	f008 fe55 	bl	981c <eeprom_read_byte>
  int data = EEPROM.read(a + 1);
  data = (data << 8) + EEPROM.read(a);
     b72:	0204      	lsls	r4, r0, #8
     b74:	4628      	mov	r0, r5
     b76:	f008 fe51 	bl	981c <eeprom_read_byte>
  return data;
     b7a:	4420      	add	r0, r4
}
     b7c:	b280      	uxth	r0, r0
     b7e:	bd38      	pop	{r3, r4, r5, pc}

00000b80 <DLManager::DLManager(String)>:
        logs[i] = &l[i];
    }
}
*/

DLManager::DLManager(String _id) {
     b80:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     b84:	4606      	mov	r6, r0
     b86:	b083      	sub	sp, #12
     b88:	460f      	mov	r7, r1
     b8a:	4939      	ldr	r1, [pc, #228]	; (c70 <DLManager::DLManager(String)+0xf0>)
     b8c:	f008 fce4 	bl	9558 <String::String(char const*)>
     b90:	2500      	movs	r5, #0
     b92:	f44f 73c8 	mov.w	r3, #400	; 0x190
     b96:	f506 5897 	add.w	r8, r6, #4832	; 0x12e0
     b9a:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
     b9e:	6132      	str	r2, [r6, #16]
     ba0:	f108 0804 	add.w	r8, r8, #4
     ba4:	6175      	str	r5, [r6, #20]
     ba6:	6235      	str	r5, [r6, #32]
     ba8:	61b3      	str	r3, [r6, #24]
     baa:	61f3      	str	r3, [r6, #28]
     bac:	f106 0424 	add.w	r4, r6, #36	; 0x24
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     bb0:	4620      	mov	r0, r4
     bb2:	2100      	movs	r1, #0
     bb4:	f008 fcd0 	bl	9558 <String::String(char const*)>
     bb8:	3418      	adds	r4, #24
     bba:	f804 5c02 	strb.w	r5, [r4, #-2]
        logs[i] = &l[i];
    }
}
*/

DLManager::DLManager(String _id) {
     bbe:	45a0      	cmp	r8, r4
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     bc0:	f04f 0300 	mov.w	r3, #0
        logs[i] = &l[i];
    }
}
*/

DLManager::DLManager(String _id) {
     bc4:	d1f4      	bne.n	bb0 <DLManager::DLManager(String)+0x30>

        // the number of one_off_logs which have actually been stored
        uint16_t active_one_off_logs = 0;

        //////////// autolog ////////////////////
        uint32_t autolog_start_idx = one_off_log_size;
     bc6:	69b1      	ldr	r1, [r6, #24]
        logs[i] = &l[i];
    }
}
*/

DLManager::DLManager(String _id) {
     bc8:	6932      	ldr	r2, [r6, #16]
     bca:	f241 20e8 	movw	r0, #4840	; 0x12e8
     bce:	f241 25ec 	movw	r5, #4844	; 0x12ec
     bd2:	5031      	str	r1, [r6, r0]
     bd4:	f241 24f0 	movw	r4, #4848	; 0x12f0
     bd8:	5171      	str	r1, [r6, r5]
     bda:	1a52      	subs	r2, r2, r1
     bdc:	f241 20e4 	movw	r0, #4836	; 0x12e4
     be0:	f241 21e6 	movw	r1, #4838	; 0x12e6
     be4:	5132      	str	r2, [r6, r4]
     be6:	f506 59f5 	add.w	r9, r6, #7840	; 0x1ea0
     bea:	5233      	strh	r3, [r6, r0]
     bec:	f506 5497 	add.w	r4, r6, #4832	; 0x12e0
     bf0:	5273      	strh	r3, [r6, r1]
        void printLog(uint8_t lines);
        void printlog(uint8_t lines);
        void printlog(){printlog(4);};

};
Datalog::Datalog(){};
     bf2:	461d      	mov	r5, r3
     bf4:	3418      	adds	r4, #24
     bf6:	f109 0910 	add.w	r9, r9, #16
     bfa:	f04f 0801 	mov.w	r8, #1
     bfe:	f804 5c04 	strb.w	r5, [r4, #-4]
     c02:	4620      	mov	r0, r4
     c04:	491b      	ldr	r1, [pc, #108]	; (c74 <DLManager::DLManager(String)+0xf4>)
     c06:	f008 fca7 	bl	9558 <String::String(char const*)>
     c0a:	343c      	adds	r4, #60	; 0x3c
     c0c:	f804 8c29 	strb.w	r8, [r4, #-41]
     c10:	f804 8c18 	strb.w	r8, [r4, #-24]
     c14:	454c      	cmp	r4, r9
     c16:	f04f 0300 	mov.w	r3, #0
     c1a:	d1f0      	bne.n	bfe <DLManager::DLManager(String)+0x7e>
     c1c:	f506 5101 	add.w	r1, r6, #8256	; 0x2040
     c20:	f641 7211 	movw	r2, #7953	; 0x1f11
     c24:	f242 0041 	movw	r0, #8257	; 0x2041
     c28:	f641 7410 	movw	r4, #7952	; 0x1f10
     c2c:	5533      	strb	r3, [r6, r4]
     c2e:	54b3      	strb	r3, [r6, r2]
     c30:	460a      	mov	r2, r1
     c32:	700b      	strb	r3, [r1, #0]
     c34:	5433      	strb	r3, [r6, r0]
     c36:	4810      	ldr	r0, [pc, #64]	; (c78 <DLManager::DLManager(String)+0xf8>)
     c38:	3204      	adds	r2, #4
     c3a:	3114      	adds	r1, #20
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     c3c:	6803      	ldr	r3, [r0, #0]
     c3e:	9301      	str	r3, [sp, #4]
	return ret;
     c40:	9b01      	ldr	r3, [sp, #4]
class elapsedMillis
{
private:
	unsigned long ms;
public:
	elapsedMillis(void) { ms = millis(); }
     c42:	f842 3b04 	str.w	r3, [r2], #4
     c46:	428a      	cmp	r2, r1
     c48:	d1f8      	bne.n	c3c <DLManager::DLManager(String)+0xbc>
    id = _id;
     c4a:	4639      	mov	r1, r7
     c4c:	4630      	mov	r0, r6
     c4e:	f008 fced 	bl	962c <String::operator=(String const&)>
     c52:	f506 53f5 	add.w	r3, r6, #7840	; 0x1ea0
     c56:	f506 52f6 	add.w	r2, r6, #7872	; 0x1ec0
     c5a:	330b      	adds	r3, #11
     c5c:	321d      	adds	r2, #29
    for (int i = 0; i < DATALOG_MANAGER_MAX_LOGS; i++ ) {
        first_reading[i] = true;
     c5e:	2101      	movs	r1, #1
     c60:	f803 1f01 	strb.w	r1, [r3, #1]!
}
*/

DLManager::DLManager(String _id) {
    id = _id;
    for (int i = 0; i < DATALOG_MANAGER_MAX_LOGS; i++ ) {
     c64:	4293      	cmp	r3, r2
     c66:	d1fb      	bne.n	c60 <DLManager::DLManager(String)+0xe0>
        first_reading[i] = true;
    }
}
     c68:	4630      	mov	r0, r6
     c6a:	b003      	add	sp, #12
     c6c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     c70:	00010b88 	.word	0x00010b88
     c74:	000107d4 	.word	0x000107d4
     c78:	200045ec 	.word	0x200045ec

00000c7c <DLManager::logSetupConfigByte(String, unsigned char)>:
/////////////////////// One-off logs ////////////////////////////////////////

void DLManager::logSetupConfigByte(String str, uint8_t data) {
    // if there is enough room in the log to track another value
    uint8_t dlen = 1;
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
     c7c:	f241 23e4 	movw	r3, #4836	; 0x12e4
    }
}

/////////////////////// One-off logs ////////////////////////////////////////

void DLManager::logSetupConfigByte(String str, uint8_t data) {
     c80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    // if there is enough room in the log to track another value
    uint8_t dlen = 1;
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
     c84:	6946      	ldr	r6, [r0, #20]
     c86:	5ac5      	ldrh	r5, [r0, r3]
     c88:	6983      	ldr	r3, [r0, #24]
    }
}

/////////////////////// One-off logs ////////////////////////////////////////

void DLManager::logSetupConfigByte(String str, uint8_t data) {
     c8a:	4604      	mov	r4, r0
    // if there is enough room in the log to track another value
    uint8_t dlen = 1;
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
     c8c:	4433      	add	r3, r6
     c8e:	1c68      	adds	r0, r5, #1
     c90:	4298      	cmp	r0, r3
    }
}

/////////////////////// One-off logs ////////////////////////////////////////

void DLManager::logSetupConfigByte(String str, uint8_t data) {
     c92:	b087      	sub	sp, #28
    // if there is enough room in the log to track another value
    uint8_t dlen = 1;
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
     c94:	d309      	bcc.n	caa <DLManager::logSetupConfigByte(String, unsigned char)+0x2e>
     c96:	2177      	movs	r1, #119	; 0x77
     c98:	483e      	ldr	r0, [pc, #248]	; (d94 <DLManager::logSetupConfigByte(String, unsigned char)+0x118>)
     c9a:	f00a fcb1 	bl	b600 <usb_serial_write>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     c9e:	483e      	ldr	r0, [pc, #248]	; (d98 <DLManager::logSetupConfigByte(String, unsigned char)+0x11c>)
     ca0:	f008 fae8 	bl	9274 <Print::println()>
        Serial.print("\t");
        Serial.println(data);
    } else {
        Serial.println("ERROR - Sorry can't create any more one-off logs, there is not enough allocated space on the EEPROM for one-off logging");
    }
}
     ca4:	b007      	add	sp, #28
     ca6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     caa:	4628      	mov	r0, r5
     cac:	4616      	mov	r6, r2
     cae:	460f      	mov	r7, r1
     cb0:	f008 fdb4 	bl	981c <eeprom_read_byte>
    EERef &operator &=( uint8_t in )     { return *this = **this & in; }
    EERef &operator |=( uint8_t in )     { return *this = **this | in; }
    EERef &operator <<=( uint8_t in )    { return *this = **this << in; }
    EERef &operator >>=( uint8_t in )    { return *this = **this >> in; }

    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
     cb4:	4286      	cmp	r6, r0

    EERef( const int index )
        : index( index )                 {}

    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
     cb6:	4680      	mov	r8, r0
    EERef &operator &=( uint8_t in )     { return *this = **this & in; }
    EERef &operator |=( uint8_t in )     { return *this = **this | in; }
    EERef &operator <<=( uint8_t in )    { return *this = **this << in; }
    EERef &operator >>=( uint8_t in )    { return *this = **this >> in; }

    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
     cb8:	d003      	beq.n	cc2 <DLManager::logSetupConfigByte(String, unsigned char)+0x46>
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    operator const uint8_t() const       { return **this; }

    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
     cba:	4628      	mov	r0, r5
     cbc:	4631      	mov	r1, r6
     cbe:	f008 fdc7 	bl	9850 <eeprom_write_byte>
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
        // write the data to eeprom according to type
        uint8_t _data = EEPROM.read(one_off_write_idx);
        EEPROM.update(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_BYTE, dlen, true};
     cc2:	f241 2ae6 	movw	sl, #4838	; 0x12e6
     cc6:	f241 2be4 	movw	fp, #4836	; 0x12e4
     cca:	f834 500a 	ldrh.w	r5, [r4, sl]
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     cce:	eb05 0545 	add.w	r5, r5, r5, lsl #1
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
        // write the data to eeprom according to type
        uint8_t _data = EEPROM.read(one_off_write_idx);
        EEPROM.update(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_BYTE, dlen, true};
     cd2:	4639      	mov	r1, r7
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     cd4:	00ed      	lsls	r5, r5, #3
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
        // write the data to eeprom according to type
        uint8_t _data = EEPROM.read(one_off_write_idx);
        EEPROM.update(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_BYTE, dlen, true};
     cd6:	4668      	mov	r0, sp
     cd8:	f008 fc52 	bl	9580 <String::String(String const&)>
     cdc:	f834 300b 	ldrh.w	r3, [r4, fp]
     ce0:	9304      	str	r3, [sp, #16]
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     ce2:	1960      	adds	r0, r4, r5
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
        // write the data to eeprom according to type
        uint8_t _data = EEPROM.read(one_off_write_idx);
        EEPROM.update(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_BYTE, dlen, true};
     ce4:	f04f 0901 	mov.w	r9, #1
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     ce8:	4669      	mov	r1, sp
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
        // write the data to eeprom according to type
        uint8_t _data = EEPROM.read(one_off_write_idx);
        EEPROM.update(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_BYTE, dlen, true};
     cea:	2303      	movs	r3, #3
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     cec:	3024      	adds	r0, #36	; 0x24
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
        // write the data to eeprom according to type
        uint8_t _data = EEPROM.read(one_off_write_idx);
        EEPROM.update(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_BYTE, dlen, true};
     cee:	f88d 3014 	strb.w	r3, [sp, #20]
     cf2:	f88d 9015 	strb.w	r9, [sp, #21]
     cf6:	f88d 9016 	strb.w	r9, [sp, #22]
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     cfa:	f008 fc9f 	bl	963c <String::operator=(String&&)>
     cfe:	1963      	adds	r3, r4, r5
     d00:	9a04      	ldr	r2, [sp, #16]
     d02:	f89d 0014 	ldrb.w	r0, [sp, #20]
     d06:	f89d 1015 	ldrb.w	r1, [sp, #21]
     d0a:	635a      	str	r2, [r3, #52]	; 0x34
     d0c:	f89d 2016 	ldrb.w	r2, [sp, #22]
     d10:	f883 0038 	strb.w	r0, [r3, #56]	; 0x38
     d14:	f883 1039 	strb.w	r1, [r3, #57]	; 0x39
     d18:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
     d1c:	4668      	mov	r0, sp
     d1e:	f008 fbdb 	bl	94d8 <String::~String()>
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_BYTE, dlen, true};
        // incrment the one off timer write idx
        one_off_write_idx += dlen;
        // update the stored one off log active structs idx
        active_one_off_logs++;
     d22:	f834 200a 	ldrh.w	r2, [r4, sl]
        uint8_t _data = EEPROM.read(one_off_write_idx);
        EEPROM.update(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_BYTE, dlen, true};
        // incrment the one off timer write idx
        one_off_write_idx += dlen;
     d26:	f834 300b 	ldrh.w	r3, [r4, fp]
     d2a:	481c      	ldr	r0, [pc, #112]	; (d9c <DLManager::logSetupConfigByte(String, unsigned char)+0x120>)
        // update the stored one off log active structs idx
        active_one_off_logs++;
     d2c:	444a      	add	r2, r9
        uint8_t _data = EEPROM.read(one_off_write_idx);
        EEPROM.update(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_BYTE, dlen, true};
        // incrment the one off timer write idx
        one_off_write_idx += dlen;
     d2e:	444b      	add	r3, r9
        // update the stored one off log active structs idx
        active_one_off_logs++;
     d30:	f824 200a 	strh.w	r2, [r4, sl]
     d34:	2104      	movs	r1, #4
        uint8_t _data = EEPROM.read(one_off_write_idx);
        EEPROM.update(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_BYTE, dlen, true};
        // incrment the one off timer write idx
        one_off_write_idx += dlen;
     d36:	f824 300b 	strh.w	r3, [r4, fp]
     d3a:	f00a fc61 	bl	b600 <usb_serial_write>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
     d3e:	f834 100b 	ldrh.w	r1, [r4, fp]
     d42:	4815      	ldr	r0, [pc, #84]	; (d98 <DLManager::logSetupConfigByte(String, unsigned char)+0x11c>)
     d44:	f008 fae6 	bl	9314 <Print::print(long)>
     d48:	4649      	mov	r1, r9
     d4a:	4815      	ldr	r0, [pc, #84]	; (da0 <DLManager::logSetupConfigByte(String, unsigned char)+0x124>)
     d4c:	f00a fc58 	bl	b600 <usb_serial_write>
     d50:	2108      	movs	r1, #8
     d52:	4814      	ldr	r0, [pc, #80]	; (da4 <DLManager::logSetupConfigByte(String, unsigned char)+0x128>)
     d54:	f00a fc54 	bl	b600 <usb_serial_write>
        // dprint
        Serial.print("idx:");
        Serial.print(one_off_write_idx);
        Serial.print(" ");
        Serial.print("old/new ");
        Serial.print(str);
     d58:	4639      	mov	r1, r7
     d5a:	480f      	ldr	r0, [pc, #60]	; (d98 <DLManager::logSetupConfigByte(String, unsigned char)+0x11c>)
     d5c:	f008 fa64 	bl	9228 <Print::print(String const&)>
     d60:	4649      	mov	r1, r9
     d62:	4811      	ldr	r0, [pc, #68]	; (da8 <DLManager::logSetupConfigByte(String, unsigned char)+0x12c>)
     d64:	f00a fc4c 	bl	b600 <usb_serial_write>
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
     d68:	4641      	mov	r1, r8
     d6a:	2300      	movs	r3, #0
     d6c:	220a      	movs	r2, #10
     d6e:	480a      	ldr	r0, [pc, #40]	; (d98 <DLManager::logSetupConfigByte(String, unsigned char)+0x11c>)
     d70:	f008 fa90 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
     d74:	4649      	mov	r1, r9
     d76:	480c      	ldr	r0, [pc, #48]	; (da8 <DLManager::logSetupConfigByte(String, unsigned char)+0x12c>)
     d78:	f00a fc42 	bl	b600 <usb_serial_write>
     d7c:	4631      	mov	r1, r6
     d7e:	2300      	movs	r3, #0
     d80:	220a      	movs	r2, #10
     d82:	4805      	ldr	r0, [pc, #20]	; (d98 <DLManager::logSetupConfigByte(String, unsigned char)+0x11c>)
     d84:	f008 fa86 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
     d88:	4803      	ldr	r0, [pc, #12]	; (d98 <DLManager::logSetupConfigByte(String, unsigned char)+0x11c>)
     d8a:	f008 fa73 	bl	9274 <Print::println()>
        Serial.print("\t");
        Serial.println(data);
    } else {
        Serial.println("ERROR - Sorry can't create any more one-off logs, there is not enough allocated space on the EEPROM for one-off logging");
    }
}
     d8e:	b007      	add	sp, #28
     d90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     d94:	000108d8 	.word	0x000108d8
     d98:	1fffbaf4 	.word	0x1fffbaf4
     d9c:	000108c4 	.word	0x000108c4
     da0:	00010d30 	.word	0x00010d30
     da4:	000108cc 	.word	0x000108cc
     da8:	00010cc0 	.word	0x00010cc0

00000dac <DLManager::logSetupConfigLong(String, unsigned long)>:
}

void DLManager::logSetupConfigLong(String str, uint32_t data) {
    // if there is enough room in the log to track another value
    uint8_t dlen = 4;
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
     dac:	f241 23e4 	movw	r3, #4836	; 0x12e4
    } else {
        Serial.println("ERROR - Sorry can't create any more one-off logs, there is not enough allocated space on the EEPROM for one-off logging");
    }
}

void DLManager::logSetupConfigLong(String str, uint32_t data) {
     db0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    // if there is enough room in the log to track another value
    uint8_t dlen = 4;
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
     db4:	6944      	ldr	r4, [r0, #20]
     db6:	f830 a003 	ldrh.w	sl, [r0, r3]
     dba:	6983      	ldr	r3, [r0, #24]
    } else {
        Serial.println("ERROR - Sorry can't create any more one-off logs, there is not enough allocated space on the EEPROM for one-off logging");
    }
}

void DLManager::logSetupConfigLong(String str, uint32_t data) {
     dbc:	4606      	mov	r6, r0
    // if there is enough room in the log to track another value
    uint8_t dlen = 4;
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
     dbe:	4423      	add	r3, r4
     dc0:	f10a 0004 	add.w	r0, sl, #4
     dc4:	4298      	cmp	r0, r3
    } else {
        Serial.println("ERROR - Sorry can't create any more one-off logs, there is not enough allocated space on the EEPROM for one-off logging");
    }
}

void DLManager::logSetupConfigLong(String str, uint32_t data) {
     dc6:	b087      	sub	sp, #28
    // if there is enough room in the log to track another value
    uint8_t dlen = 4;
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
     dc8:	f080 8088 	bcs.w	edc <DLManager::logSetupConfigLong(String, unsigned long)+0x130>
     dcc:	2700      	movs	r7, #0
     dce:	4689      	mov	r9, r1
     dd0:	4690      	mov	r8, r2
     dd2:	463d      	mov	r5, r7
     dd4:	4654      	mov	r4, sl

    EERef( const int index )
        : index( index )                 {}

    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
     dd6:	1928      	adds	r0, r5, r4
     dd8:	f008 fd20 	bl	981c <eeprom_read_byte>

uint32_t readLongFromEEPROM(int a) {
  uint32_t data = 0;
  for (int i = 0; i < 4; i++) {
    uint32_t n = EEPROM.read(a + i) << 8 * i;
    data = n | data;
     ddc:	00eb      	lsls	r3, r5, #3
  return data;
}

uint32_t readLongFromEEPROM(int a) {
  uint32_t data = 0;
  for (int i = 0; i < 4; i++) {
     dde:	3501      	adds	r5, #1
    uint32_t n = EEPROM.read(a + i) << 8 * i;
    data = n | data;
     de0:	4098      	lsls	r0, r3
  return data;
}

uint32_t readLongFromEEPROM(int a) {
  uint32_t data = 0;
  for (int i = 0; i < 4; i++) {
     de2:	2d04      	cmp	r5, #4
    uint32_t n = EEPROM.read(a + i) << 8 * i;
    data = n | data;
     de4:	ea47 0700 	orr.w	r7, r7, r0
  return data;
}

uint32_t readLongFromEEPROM(int a) {
  uint32_t data = 0;
  for (int i = 0; i < 4; i++) {
     de8:	d1f4      	bne.n	dd4 <DLManager::logSetupConfigLong(String, unsigned long)+0x28>
     dea:	f04f 0a00 	mov.w	sl, #0
     dee:	4620      	mov	r0, r4
     df0:	f008 fd14 	bl	981c <eeprom_read_byte>
}

void writeLongToEEPROM(uint32_t addr, uint32_t data) {
    uint8_t b[4];
    for (int i = 0; i < 4; i++) {
      b[i] = data >> 8 * i;
     df4:	fa28 f50a 	lsr.w	r5, r8, sl
     df8:	b2ed      	uxtb	r5, r5
    EERef &operator &=( uint8_t in )     { return *this = **this & in; }
    EERef &operator |=( uint8_t in )     { return *this = **this | in; }
    EERef &operator <<=( uint8_t in )    { return *this = **this << in; }
    EERef &operator >>=( uint8_t in )    { return *this = **this >> in; }

    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
     dfa:	4285      	cmp	r5, r0
     dfc:	f10a 0a08 	add.w	sl, sl, #8
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    operator const uint8_t() const       { return **this; }

    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
     e00:	4620      	mov	r0, r4
     e02:	4629      	mov	r1, r5
     e04:	f104 0401 	add.w	r4, r4, #1
    EERef &operator &=( uint8_t in )     { return *this = **this & in; }
    EERef &operator |=( uint8_t in )     { return *this = **this | in; }
    EERef &operator <<=( uint8_t in )    { return *this = **this << in; }
    EERef &operator >>=( uint8_t in )    { return *this = **this >> in; }

    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
     e08:	d001      	beq.n	e0e <DLManager::logSetupConfigLong(String, unsigned long)+0x62>
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    operator const uint8_t() const       { return **this; }

    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
     e0a:	f008 fd21 	bl	9850 <eeprom_write_byte>
    EEPROM.update(addr + 1, msb);
}

void writeLongToEEPROM(uint32_t addr, uint32_t data) {
    uint8_t b[4];
    for (int i = 0; i < 4; i++) {
     e0e:	f1ba 0f20 	cmp.w	sl, #32
     e12:	d1ec      	bne.n	dee <DLManager::logSetupConfigLong(String, unsigned long)+0x42>
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
        // write the data to eeprom according to type.
        uint32_t _data = readLongFromEEPROM(one_off_write_idx);
        writeLongToEEPROM(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_LONG, dlen, true};
     e14:	f241 2be6 	movw	fp, #4838	; 0x12e6
     e18:	f241 2ae4 	movw	sl, #4836	; 0x12e4
     e1c:	f836 400b 	ldrh.w	r4, [r6, fp]
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     e20:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
        // write the data to eeprom according to type.
        uint32_t _data = readLongFromEEPROM(one_off_write_idx);
        writeLongToEEPROM(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_LONG, dlen, true};
     e24:	4649      	mov	r1, r9
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     e26:	00e4      	lsls	r4, r4, #3
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
        // write the data to eeprom according to type.
        uint32_t _data = readLongFromEEPROM(one_off_write_idx);
        writeLongToEEPROM(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_LONG, dlen, true};
     e28:	4668      	mov	r0, sp
     e2a:	f008 fba9 	bl	9580 <String::String(String const&)>
     e2e:	f836 300a 	ldrh.w	r3, [r6, sl]
     e32:	9304      	str	r3, [sp, #16]
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     e34:	1930      	adds	r0, r6, r4
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
        // write the data to eeprom according to type.
        uint32_t _data = readLongFromEEPROM(one_off_write_idx);
        writeLongToEEPROM(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_LONG, dlen, true};
     e36:	2501      	movs	r5, #1
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     e38:	4669      	mov	r1, sp
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
        // write the data to eeprom according to type.
        uint32_t _data = readLongFromEEPROM(one_off_write_idx);
        writeLongToEEPROM(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_LONG, dlen, true};
     e3a:	2202      	movs	r2, #2
     e3c:	2304      	movs	r3, #4
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     e3e:	3024      	adds	r0, #36	; 0x24
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
        // write the data to eeprom according to type.
        uint32_t _data = readLongFromEEPROM(one_off_write_idx);
        writeLongToEEPROM(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_LONG, dlen, true};
     e40:	f88d 2014 	strb.w	r2, [sp, #20]
     e44:	f88d 3015 	strb.w	r3, [sp, #21]
     e48:	f88d 5016 	strb.w	r5, [sp, #22]
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     e4c:	f008 fbf6 	bl	963c <String::operator=(String&&)>
     e50:	1933      	adds	r3, r6, r4
     e52:	9a04      	ldr	r2, [sp, #16]
     e54:	f89d 0014 	ldrb.w	r0, [sp, #20]
     e58:	f89d 1015 	ldrb.w	r1, [sp, #21]
     e5c:	635a      	str	r2, [r3, #52]	; 0x34
     e5e:	f89d 2016 	ldrb.w	r2, [sp, #22]
     e62:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
     e66:	f883 0038 	strb.w	r0, [r3, #56]	; 0x38
     e6a:	f883 1039 	strb.w	r1, [r3, #57]	; 0x39
     e6e:	4668      	mov	r0, sp
     e70:	f008 fb32 	bl	94d8 <String::~String()>
        uint32_t _data = readLongFromEEPROM(one_off_write_idx);
        writeLongToEEPROM(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_LONG, dlen, true};
        // incrment the one off timer write idx
        one_off_write_idx += dlen;
     e74:	f836 100a 	ldrh.w	r1, [r6, sl]
        // update the stored one off log active structs idx
        active_one_off_logs++;
     e78:	f836 300b 	ldrh.w	r3, [r6, fp]
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
     e7c:	481c      	ldr	r0, [pc, #112]	; (ef0 <DLManager::logSetupConfigLong(String, unsigned long)+0x144>)
        uint32_t _data = readLongFromEEPROM(one_off_write_idx);
        writeLongToEEPROM(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_LONG, dlen, true};
        // incrment the one off timer write idx
        one_off_write_idx += dlen;
     e7e:	3104      	adds	r1, #4
        // update the stored one off log active structs idx
        active_one_off_logs++;
     e80:	442b      	add	r3, r5
        uint32_t _data = readLongFromEEPROM(one_off_write_idx);
        writeLongToEEPROM(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_LONG, dlen, true};
        // incrment the one off timer write idx
        one_off_write_idx += dlen;
     e82:	b289      	uxth	r1, r1
        // update the stored one off log active structs idx
        active_one_off_logs++;
     e84:	f826 300b 	strh.w	r3, [r6, fp]
        uint32_t _data = readLongFromEEPROM(one_off_write_idx);
        writeLongToEEPROM(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_LONG, dlen, true};
        // incrment the one off timer write idx
        one_off_write_idx += dlen;
     e88:	f826 100a 	strh.w	r1, [r6, sl]
     e8c:	f008 fa42 	bl	9314 <Print::print(long)>
     e90:	4629      	mov	r1, r5
     e92:	4818      	ldr	r0, [pc, #96]	; (ef4 <DLManager::logSetupConfigLong(String, unsigned long)+0x148>)
     e94:	f00a fbb4 	bl	b600 <usb_serial_write>
     e98:	2108      	movs	r1, #8
     e9a:	4817      	ldr	r0, [pc, #92]	; (ef8 <DLManager::logSetupConfigLong(String, unsigned long)+0x14c>)
     e9c:	f00a fbb0 	bl	b600 <usb_serial_write>
        active_one_off_logs++;
        // dprint
        Serial.print(one_off_write_idx);
        Serial.print("\t");
        Serial.print("old/new ");
        Serial.print(str);
     ea0:	4649      	mov	r1, r9
     ea2:	4813      	ldr	r0, [pc, #76]	; (ef0 <DLManager::logSetupConfigLong(String, unsigned long)+0x144>)
     ea4:	f008 f9c0 	bl	9228 <Print::print(String const&)>
     ea8:	4629      	mov	r1, r5
     eaa:	4812      	ldr	r0, [pc, #72]	; (ef4 <DLManager::logSetupConfigLong(String, unsigned long)+0x148>)
     eac:	f00a fba8 	bl	b600 <usb_serial_write>
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
     eb0:	4639      	mov	r1, r7
     eb2:	2300      	movs	r3, #0
     eb4:	220a      	movs	r2, #10
     eb6:	480e      	ldr	r0, [pc, #56]	; (ef0 <DLManager::logSetupConfigLong(String, unsigned long)+0x144>)
     eb8:	f008 f9ec 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
     ebc:	4629      	mov	r1, r5
     ebe:	480d      	ldr	r0, [pc, #52]	; (ef4 <DLManager::logSetupConfigLong(String, unsigned long)+0x148>)
     ec0:	f00a fb9e 	bl	b600 <usb_serial_write>
     ec4:	4641      	mov	r1, r8
     ec6:	2300      	movs	r3, #0
     ec8:	220a      	movs	r2, #10
     eca:	4809      	ldr	r0, [pc, #36]	; (ef0 <DLManager::logSetupConfigLong(String, unsigned long)+0x144>)
     ecc:	f008 f9e2 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
     ed0:	4807      	ldr	r0, [pc, #28]	; (ef0 <DLManager::logSetupConfigLong(String, unsigned long)+0x144>)
     ed2:	f008 f9cf 	bl	9274 <Print::println()>
        Serial.print("\t");
        Serial.println(data);
    } else {
        Serial.println("ERROR - Sorry can't create any more one-off logs, there is not enough allocated space on the EEPROM for one-off logging");
    }
}
     ed6:	b007      	add	sp, #28
     ed8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     edc:	2177      	movs	r1, #119	; 0x77
     ede:	4807      	ldr	r0, [pc, #28]	; (efc <DLManager::logSetupConfigLong(String, unsigned long)+0x150>)
     ee0:	f00a fb8e 	bl	b600 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     ee4:	4802      	ldr	r0, [pc, #8]	; (ef0 <DLManager::logSetupConfigLong(String, unsigned long)+0x144>)
     ee6:	f008 f9c5 	bl	9274 <Print::println()>
     eea:	b007      	add	sp, #28
     eec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     ef0:	1fffbaf4 	.word	0x1fffbaf4
     ef4:	00010cc0 	.word	0x00010cc0
     ef8:	000108cc 	.word	0x000108cc
     efc:	000108d8 	.word	0x000108d8

00000f00 <DLManager::logSetupConfigDouble(String, double)>:

void DLManager::logSetupConfigDouble(String str, double data) {
     f00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    // if there is enough room in the log to track another value
    uint8_t dlen = 4;
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
     f04:	f241 25e4 	movw	r5, #4836	; 0x12e4
     f08:	6947      	ldr	r7, [r0, #20]
     f0a:	5b46      	ldrh	r6, [r0, r5]
    } else {
        Serial.println("ERROR - Sorry can't create any more one-off logs, there is not enough allocated space on the EEPROM for one-off logging");
    }
}

void DLManager::logSetupConfigDouble(String str, double data) {
     f0c:	4604      	mov	r4, r0
    // if there is enough room in the log to track another value
    uint8_t dlen = 4;
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
     f0e:	6980      	ldr	r0, [r0, #24]
     f10:	f106 0e04 	add.w	lr, r6, #4
     f14:	4438      	add	r0, r7
     f16:	4586      	cmp	lr, r0
    } else {
        Serial.println("ERROR - Sorry can't create any more one-off logs, there is not enough allocated space on the EEPROM for one-off logging");
    }
}

void DLManager::logSetupConfigDouble(String str, double data) {
     f18:	b08b      	sub	sp, #44	; 0x2c
    // if there is enough room in the log to track another value
    uint8_t dlen = 4;
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
     f1a:	d309      	bcc.n	f30 <DLManager::logSetupConfigDouble(String, double)+0x30>
     f1c:	2177      	movs	r1, #119	; 0x77
     f1e:	483d      	ldr	r0, [pc, #244]	; (1014 <DLManager::logSetupConfigDouble(String, double)+0x114>)
     f20:	f00a fb6e 	bl	b600 <usb_serial_write>
     f24:	483c      	ldr	r0, [pc, #240]	; (1018 <DLManager::logSetupConfigDouble(String, double)+0x118>)
     f26:	f008 f9a5 	bl	9274 <Print::println()>
        Serial.print("\t");
        Serial.println(data);
    } else {
        Serial.println("ERROR - Sorry can't create any more one-off logs, there is not enough allocated space on the EEPROM for one-off logging");
    }
}
     f2a:	b00b      	add	sp, #44	; 0x2c
     f2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
void DLManager::logSetupConfigDouble(String str, double data) {
    // if there is enough room in the log to track another value
    uint8_t dlen = 4;
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
        // write the data to eeprom according to type
        double _data = readDoubleFromEEPROM(one_off_write_idx);
     f30:	4630      	mov	r0, r6
     f32:	460f      	mov	r7, r1
     f34:	4690      	mov	r8, r2
     f36:	4699      	mov	r9, r3
     f38:	f7ff fdf6 	bl	b28 <readDoubleFromEEPROM(int)>
        writeDoubleToEEPROM(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_DOUBLE, dlen, true};
     f3c:	f241 2ae6 	movw	sl, #4838	; 0x12e6
void DLManager::logSetupConfigDouble(String str, double data) {
    // if there is enough room in the log to track another value
    uint8_t dlen = 4;
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
        // write the data to eeprom according to type
        double _data = readDoubleFromEEPROM(one_off_write_idx);
     f40:	e9cd 0102 	strd	r0, r1, [sp, #8]
        writeDoubleToEEPROM(one_off_write_idx, data);
     f44:	4642      	mov	r2, r8
     f46:	464b      	mov	r3, r9
     f48:	4630      	mov	r0, r6
     f4a:	f7ff fdc5 	bl	ad8 <writeDoubleToEEPROM(unsigned long, double)>
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_DOUBLE, dlen, true};
     f4e:	f834 b00a 	ldrh.w	fp, [r4, sl]
     f52:	ab04      	add	r3, sp, #16
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     f54:	eb0b 0b4b 	add.w	fp, fp, fp, lsl #1
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
        // write the data to eeprom according to type
        double _data = readDoubleFromEEPROM(one_off_write_idx);
        writeDoubleToEEPROM(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_DOUBLE, dlen, true};
     f58:	4639      	mov	r1, r7
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     f5a:	ea4f 0bcb 	mov.w	fp, fp, lsl #3
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
        // write the data to eeprom according to type
        double _data = readDoubleFromEEPROM(one_off_write_idx);
        writeDoubleToEEPROM(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_DOUBLE, dlen, true};
     f5e:	4618      	mov	r0, r3
     f60:	f008 fb0e 	bl	9580 <String::String(String const&)>
     f64:	5b63      	ldrh	r3, [r4, r5]
     f66:	9308      	str	r3, [sp, #32]
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     f68:	eb04 000b 	add.w	r0, r4, fp
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
        // write the data to eeprom according to type
        double _data = readDoubleFromEEPROM(one_off_write_idx);
        writeDoubleToEEPROM(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_DOUBLE, dlen, true};
     f6c:	2601      	movs	r6, #1
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     f6e:	a904      	add	r1, sp, #16
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
        // write the data to eeprom according to type
        double _data = readDoubleFromEEPROM(one_off_write_idx);
        writeDoubleToEEPROM(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_DOUBLE, dlen, true};
     f70:	2200      	movs	r2, #0
     f72:	2304      	movs	r3, #4
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     f74:	3024      	adds	r0, #36	; 0x24
    if (one_off_write_idx + dlen < one_off_start_idx + one_off_log_size) {
        // write the data to eeprom according to type
        double _data = readDoubleFromEEPROM(one_off_write_idx);
        writeDoubleToEEPROM(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_DOUBLE, dlen, true};
     f76:	f88d 2024 	strb.w	r2, [sp, #36]	; 0x24
     f7a:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
     f7e:	f88d 6026 	strb.w	r6, [sp, #38]	; 0x26
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
     f82:	f008 fb5b 	bl	963c <String::operator=(String&&)>
     f86:	eb04 030b 	add.w	r3, r4, fp
     f8a:	9a08      	ldr	r2, [sp, #32]
     f8c:	f89d 0024 	ldrb.w	r0, [sp, #36]	; 0x24
     f90:	f89d 1025 	ldrb.w	r1, [sp, #37]	; 0x25
     f94:	635a      	str	r2, [r3, #52]	; 0x34
     f96:	f89d 2026 	ldrb.w	r2, [sp, #38]	; 0x26
     f9a:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
     f9e:	f883 0038 	strb.w	r0, [r3, #56]	; 0x38
     fa2:	f883 1039 	strb.w	r1, [r3, #57]	; 0x39
     fa6:	a804      	add	r0, sp, #16
     fa8:	f008 fa96 	bl	94d8 <String::~String()>
        double _data = readDoubleFromEEPROM(one_off_write_idx);
        writeDoubleToEEPROM(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_DOUBLE, dlen, true};
        // incrment the one off timer write idx
        one_off_write_idx += dlen;
     fac:	5b61      	ldrh	r1, [r4, r5]
        // update the stored one off log active structs idx
        active_one_off_logs++;
     fae:	f834 300a 	ldrh.w	r3, [r4, sl]
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
     fb2:	4819      	ldr	r0, [pc, #100]	; (1018 <DLManager::logSetupConfigDouble(String, double)+0x118>)
        double _data = readDoubleFromEEPROM(one_off_write_idx);
        writeDoubleToEEPROM(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_DOUBLE, dlen, true};
        // incrment the one off timer write idx
        one_off_write_idx += dlen;
     fb4:	3104      	adds	r1, #4
        // update the stored one off log active structs idx
        active_one_off_logs++;
     fb6:	4433      	add	r3, r6
        double _data = readDoubleFromEEPROM(one_off_write_idx);
        writeDoubleToEEPROM(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_DOUBLE, dlen, true};
        // incrment the one off timer write idx
        one_off_write_idx += dlen;
     fb8:	b289      	uxth	r1, r1
        // update the stored one off log active structs idx
        active_one_off_logs++;
     fba:	f824 300a 	strh.w	r3, [r4, sl]
        double _data = readDoubleFromEEPROM(one_off_write_idx);
        writeDoubleToEEPROM(one_off_write_idx, data);
        // update a new struct with the log data
        one_off_logs[active_one_off_logs] = {str, one_off_write_idx, DATATYPE_DOUBLE, dlen, true};
        // incrment the one off timer write idx
        one_off_write_idx += dlen;
     fbe:	5361      	strh	r1, [r4, r5]
     fc0:	f008 f9a8 	bl	9314 <Print::print(long)>
     fc4:	4631      	mov	r1, r6
     fc6:	4815      	ldr	r0, [pc, #84]	; (101c <DLManager::logSetupConfigDouble(String, double)+0x11c>)
     fc8:	f00a fb1a 	bl	b600 <usb_serial_write>
     fcc:	2108      	movs	r1, #8
     fce:	4814      	ldr	r0, [pc, #80]	; (1020 <DLManager::logSetupConfigDouble(String, double)+0x120>)
     fd0:	f00a fb16 	bl	b600 <usb_serial_write>
        active_one_off_logs++;
        // dprint
        Serial.print(one_off_write_idx);
        Serial.print("\t");
        Serial.print("old/new ");
        Serial.print(str);
     fd4:	4639      	mov	r1, r7
     fd6:	4810      	ldr	r0, [pc, #64]	; (1018 <DLManager::logSetupConfigDouble(String, double)+0x118>)
     fd8:	f008 f926 	bl	9228 <Print::print(String const&)>
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
     fdc:	2402      	movs	r4, #2
     fde:	4631      	mov	r1, r6
     fe0:	480e      	ldr	r0, [pc, #56]	; (101c <DLManager::logSetupConfigDouble(String, double)+0x11c>)
     fe2:	f00a fb0d 	bl	b600 <usb_serial_write>
     fe6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     fea:	9400      	str	r4, [sp, #0]
     fec:	480a      	ldr	r0, [pc, #40]	; (1018 <DLManager::logSetupConfigDouble(String, double)+0x118>)
     fee:	f008 f99b 	bl	9328 <Print::printFloat(double, unsigned char)>
     ff2:	4631      	mov	r1, r6
     ff4:	4809      	ldr	r0, [pc, #36]	; (101c <DLManager::logSetupConfigDouble(String, double)+0x11c>)
     ff6:	f00a fb03 	bl	b600 <usb_serial_write>
     ffa:	4642      	mov	r2, r8
     ffc:	464b      	mov	r3, r9
     ffe:	9400      	str	r4, [sp, #0]
    1000:	4805      	ldr	r0, [pc, #20]	; (1018 <DLManager::logSetupConfigDouble(String, double)+0x118>)
    1002:	f008 f991 	bl	9328 <Print::printFloat(double, unsigned char)>
	size_t println(int n, int base)			{ return print(n, base) + println(); }
	size_t println(unsigned int n, int base)	{ return print(n, base) + println(); }
	size_t println(long n, int base)		{ return print(n, base) + println(); }
	size_t println(unsigned long n, int base)	{ return print(n, base) + println(); }

	size_t println(double n, int digits = 2)	{ return print(n, digits) + println(); }
    1006:	4804      	ldr	r0, [pc, #16]	; (1018 <DLManager::logSetupConfigDouble(String, double)+0x118>)
    1008:	f008 f934 	bl	9274 <Print::println()>
        Serial.print("\t");
        Serial.println(data);
    } else {
        Serial.println("ERROR - Sorry can't create any more one-off logs, there is not enough allocated space on the EEPROM for one-off logging");
    }
}
    100c:	b00b      	add	sp, #44	; 0x2c
    100e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1012:	bf00      	nop
    1014:	000108d8 	.word	0x000108d8
    1018:	1fffbaf4 	.word	0x1fffbaf4
    101c:	00010cc0 	.word	0x00010cc0
    1020:	000108cc 	.word	0x000108cc

00001024 <DLManager::update()>:
        Serial.println("ERROR - sorry the autolog is not initiated due to a lack of remaining EEPROM space.");
    }
}

/////////////////////////////// Update Functions ////////////////////////////////
void DLManager::update() {
    1024:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1028:	f500 52f5 	add.w	r2, r0, #7840	; 0x1ea0
    102c:	b087      	sub	sp, #28
    102e:	4611      	mov	r1, r2
    1030:	f500 5801 	add.w	r8, r0, #8256	; 0x2040
        // if it is the first reading then only update if it has been longer than the start delay
        if ((first_reading[timer_num] == true && u_time > start_delays[timer_num]) || (first_reading[timer_num] == false )) {
            first_reading[timer_num] = false;
            // if it is time to update these logs then do so
            uint8_t updates = 0;
            for (int log = 0; log < active_logs; log++) {
    1034:	f500 57f8 	add.w	r7, r0, #7936	; 0x1f00
    1038:	f101 030b 	add.w	r3, r1, #11
        Serial.println("ERROR - sorry the autolog is not initiated due to a lack of remaining EEPROM space.");
    }
}

/////////////////////////////// Update Functions ////////////////////////////////
void DLManager::update() {
    103c:	9002      	str	r0, [sp, #8]
    // update each timer one at a time
    for (int timer_num = 0; timer_num < DATALOG_MANAGER_TIMER_NUM; timer_num++) {
    103e:	2600      	movs	r6, #0
    1040:	9301      	str	r3, [sp, #4]
        // if it is the first reading then only update if it has been longer than the start delay
        if ((first_reading[timer_num] == true && u_time > start_delays[timer_num]) || (first_reading[timer_num] == false )) {
            first_reading[timer_num] = false;
            // if it is time to update these logs then do so
            uint8_t updates = 0;
            for (int log = 0; log < active_logs; log++) {
    1042:	3710      	adds	r7, #16
        // take the elapsedd millis value at start of loop to ensure that
        // all related logs either update or dont update at the same time
        unsigned long u_time = log_timers[timer_num];
        // if it is the first reading then only update if it has been longer than the start delay
        if ((first_reading[timer_num] == true && u_time > start_delays[timer_num]) || (first_reading[timer_num] == false )) {
            first_reading[timer_num] = false;
    1044:	46c3      	mov	fp, r8
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1046:	4b4b      	ldr	r3, [pc, #300]	; (1174 <DLManager::update()+0x150>)
    for (int timer_num = 0; timer_num < DATALOG_MANAGER_TIMER_NUM; timer_num++) {
        // take the elapsedd millis value at start of loop to ensure that
        // all related logs either update or dont update at the same time
        unsigned long u_time = log_timers[timer_num];
        // if it is the first reading then only update if it has been longer than the start delay
        if ((first_reading[timer_num] == true && u_time > start_delays[timer_num]) || (first_reading[timer_num] == false )) {
    1048:	9a01      	ldr	r2, [sp, #4]
    104a:	681b      	ldr	r3, [r3, #0]
    104c:	9304      	str	r3, [sp, #16]
	return ret;
    104e:	9804      	ldr	r0, [sp, #16]
	elapsedMillis(unsigned long val) { ms = millis() - val; }
	elapsedMillis(const elapsedMillis &orig) { ms = orig.ms; }
	operator unsigned long () const { return millis() - ms; }
    1050:	f85b 3f04 	ldr.w	r3, [fp, #4]!
    1054:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    1058:	9201      	str	r2, [sp, #4]
    105a:	ebc3 0900 	rsb	r9, r3, r0
    105e:	b119      	cbz	r1, 1068 <DLManager::update()+0x44>
    1060:	f8db 1020 	ldr.w	r1, [fp, #32]
    1064:	4549      	cmp	r1, r9
    1066:	d278      	bcs.n	115a <DLManager::update()+0x136>
            first_reading[timer_num] = false;
    1068:	9b01      	ldr	r3, [sp, #4]
    106a:	f04f 0200 	mov.w	r2, #0
    106e:	701a      	strb	r2, [r3, #0]
            // if it is time to update these logs then do so
            uint8_t updates = 0;
            for (int log = 0; log < active_logs; log++) {
    1070:	7839      	ldrb	r1, [r7, #0]
    1072:	2900      	cmp	r1, #0
    1074:	d078      	beq.n	1168 <DLManager::update()+0x144>
    1076:	9a02      	ldr	r2, [sp, #8]
    1078:	f8cd 800c 	str.w	r8, [sp, #12]
    107c:	f502 51f6 	add.w	r1, r2, #7872	; 0x1ec0
    1080:	465b      	mov	r3, fp
    1082:	f502 5597 	add.w	r5, r2, #4832	; 0x12e0
    1086:	2400      	movs	r4, #0
    1088:	311d      	adds	r1, #29
    108a:	46cb      	mov	fp, r9
    108c:	46b8      	mov	r8, r7
    108e:	3514      	adds	r5, #20
    1090:	4637      	mov	r7, r6
    1092:	46a2      	mov	sl, r4
    1094:	460e      	mov	r6, r1
    1096:	4699      	mov	r9, r3
    1098:	e005      	b.n	10a6 <DLManager::update()+0x82>
    109a:	f898 3000 	ldrb.w	r3, [r8]
    109e:	42a3      	cmp	r3, r4
    10a0:	f105 053c 	add.w	r5, r5, #60	; 0x3c
    10a4:	dd16      	ble.n	10d4 <DLManager::update()+0xb0>
                 if (log_timer_map[log] == timer_num && u_time > log_refresh_length[timer_num]) {
    10a6:	f816 3f01 	ldrb.w	r3, [r6, #1]!
    10aa:	42bb      	cmp	r3, r7
        // if it is the first reading then only update if it has been longer than the start delay
        if ((first_reading[timer_num] == true && u_time > start_delays[timer_num]) || (first_reading[timer_num] == false )) {
            first_reading[timer_num] = false;
            // if it is time to update these logs then do so
            uint8_t updates = 0;
            for (int log = 0; log < active_logs; log++) {
    10ac:	f104 0401 	add.w	r4, r4, #1
                 if (log_timer_map[log] == timer_num && u_time > log_refresh_length[timer_num]) {
    10b0:	d1f3      	bne.n	109a <DLManager::update()+0x76>
    10b2:	f8d9 3010 	ldr.w	r3, [r9, #16]
    10b6:	455b      	cmp	r3, fp
    10b8:	d2ef      	bcs.n	109a <DLManager::update()+0x76>
                    // Serial.print("Updating : ");Serial.println(logs[log].getName());
                    logs[log].update();
    10ba:	4628      	mov	r0, r5
    10bc:	f7ff fc46 	bl	94c <Datalog::update()>
        // if it is the first reading then only update if it has been longer than the start delay
        if ((first_reading[timer_num] == true && u_time > start_delays[timer_num]) || (first_reading[timer_num] == false )) {
            first_reading[timer_num] = false;
            // if it is time to update these logs then do so
            uint8_t updates = 0;
            for (int log = 0; log < active_logs; log++) {
    10c0:	f898 3000 	ldrb.w	r3, [r8]
                 if (log_timer_map[log] == timer_num && u_time > log_refresh_length[timer_num]) {
                    // Serial.print("Updating : ");Serial.println(logs[log].getName());
                    logs[log].update();
                    updates++;
    10c4:	f10a 0a01 	add.w	sl, sl, #1
        // if it is the first reading then only update if it has been longer than the start delay
        if ((first_reading[timer_num] == true && u_time > start_delays[timer_num]) || (first_reading[timer_num] == false )) {
            first_reading[timer_num] = false;
            // if it is time to update these logs then do so
            uint8_t updates = 0;
            for (int log = 0; log < active_logs; log++) {
    10c8:	42a3      	cmp	r3, r4
                 if (log_timer_map[log] == timer_num && u_time > log_refresh_length[timer_num]) {
                    // Serial.print("Updating : ");Serial.println(logs[log].getName());
                    logs[log].update();
                    updates++;
    10ca:	fa5f fa8a 	uxtb.w	sl, sl
    10ce:	f105 053c 	add.w	r5, r5, #60	; 0x3c
        // if it is the first reading then only update if it has been longer than the start delay
        if ((first_reading[timer_num] == true && u_time > start_delays[timer_num]) || (first_reading[timer_num] == false )) {
            first_reading[timer_num] = false;
            // if it is time to update these logs then do so
            uint8_t updates = 0;
            for (int log = 0; log < active_logs; log++) {
    10d2:	dce8      	bgt.n	10a6 <DLManager::update()+0x82>
    10d4:	463e      	mov	r6, r7
    10d6:	4647      	mov	r7, r8
    10d8:	f8dd 800c 	ldr.w	r8, [sp, #12]
                    // Serial.print("Updating : ");Serial.println(logs[log].getName());
                    logs[log].update();
                    updates++;
                 }
            }
            for (int log = 0; log < active_logs_p; log++) {
    10dc:	f898 1000 	ldrb.w	r1, [r8]
    10e0:	464b      	mov	r3, r9
    10e2:	46d9      	mov	r9, fp
    10e4:	469b      	mov	fp, r3
    10e6:	b351      	cbz	r1, 113e <DLManager::update()+0x11a>
    10e8:	9a02      	ldr	r2, [sp, #8]
        unsigned long u_time = log_timers[timer_num];
        // if it is the first reading then only update if it has been longer than the start delay
        if ((first_reading[timer_num] == true && u_time > start_delays[timer_num]) || (first_reading[timer_num] == false )) {
            first_reading[timer_num] = false;
            // if it is time to update these logs then do so
            uint8_t updates = 0;
    10ea:	9703      	str	r7, [sp, #12]
    10ec:	f502 5100 	add.w	r1, r2, #8192	; 0x2000
    10f0:	f502 55f8 	add.w	r5, r2, #7936	; 0x1f00
    10f4:	310d      	adds	r1, #13
    10f6:	465f      	mov	r7, fp
    10f8:	3514      	adds	r5, #20
    10fa:	46cb      	mov	fp, r9
    10fc:	2400      	movs	r4, #0
    10fe:	4689      	mov	r9, r1
    1100:	e005      	b.n	110e <DLManager::update()+0xea>
                    // Serial.print("Updating : ");Serial.println(logs[log].getName());
                    logs[log].update();
                    updates++;
                 }
            }
            for (int log = 0; log < active_logs_p; log++) {
    1102:	f898 3000 	ldrb.w	r3, [r8]
    1106:	42a3      	cmp	r3, r4
    1108:	f105 0504 	add.w	r5, r5, #4
    110c:	dd15      	ble.n	113a <DLManager::update()+0x116>
                 if (log_timer_map_p[log] == timer_num && u_time > log_refresh_length[timer_num]) {
    110e:	f819 3f01 	ldrb.w	r3, [r9, #1]!
    1112:	42b3      	cmp	r3, r6
                    // Serial.print("Updating : ");Serial.println(logs[log].getName());
                    logs[log].update();
                    updates++;
                 }
            }
            for (int log = 0; log < active_logs_p; log++) {
    1114:	f104 0401 	add.w	r4, r4, #1
                 if (log_timer_map_p[log] == timer_num && u_time > log_refresh_length[timer_num]) {
    1118:	d1f3      	bne.n	1102 <DLManager::update()+0xde>
    111a:	693b      	ldr	r3, [r7, #16]
    111c:	455b      	cmp	r3, fp
    111e:	d2f0      	bcs.n	1102 <DLManager::update()+0xde>
                    // Serial.print("Updating : ");Serial.println(logs[log].getName());
                    logs_p[log]->update();
    1120:	6828      	ldr	r0, [r5, #0]
    1122:	f7ff fc13 	bl	94c <Datalog::update()>
                    // Serial.print("Updating : ");Serial.println(logs[log].getName());
                    logs[log].update();
                    updates++;
                 }
            }
            for (int log = 0; log < active_logs_p; log++) {
    1126:	f898 3000 	ldrb.w	r3, [r8]
                 if (log_timer_map_p[log] == timer_num && u_time > log_refresh_length[timer_num]) {
                    // Serial.print("Updating : ");Serial.println(logs[log].getName());
                    logs_p[log]->update();
                    updates++;
    112a:	f10a 0a01 	add.w	sl, sl, #1
                    // Serial.print("Updating : ");Serial.println(logs[log].getName());
                    logs[log].update();
                    updates++;
                 }
            }
            for (int log = 0; log < active_logs_p; log++) {
    112e:	42a3      	cmp	r3, r4
                 if (log_timer_map_p[log] == timer_num && u_time > log_refresh_length[timer_num]) {
                    // Serial.print("Updating : ");Serial.println(logs[log].getName());
                    logs_p[log]->update();
                    updates++;
    1130:	fa5f fa8a 	uxtb.w	sl, sl
    1134:	f105 0504 	add.w	r5, r5, #4
                    // Serial.print("Updating : ");Serial.println(logs[log].getName());
                    logs[log].update();
                    updates++;
                 }
            }
            for (int log = 0; log < active_logs_p; log++) {
    1138:	dce9      	bgt.n	110e <DLManager::update()+0xea>
    113a:	46bb      	mov	fp, r7
    113c:	9f03      	ldr	r7, [sp, #12]
                    // Serial.print("Updating : ");Serial.println(logs[log].getName());
                    logs_p[log]->update();
                    updates++;
                 }
            }
            if (updates > 0) {
    113e:	f1ba 0f00 	cmp.w	sl, #0
    1142:	d00a      	beq.n	115a <DLManager::update()+0x136>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1144:	4b0b      	ldr	r3, [pc, #44]	; (1174 <DLManager::update()+0x150>)
    1146:	6819      	ldr	r1, [r3, #0]
                log_timers[timer_num] = 0;
                remaining_logs[timer_num]--;
    1148:	f8db 3030 	ldr.w	r3, [fp, #48]	; 0x30
    114c:	9105      	str	r1, [sp, #20]
	return ret;
    114e:	9905      	ldr	r1, [sp, #20]
	elapsedMillis & operator = (const elapsedMillis &rhs) { ms = rhs.ms; return *this; }
	elapsedMillis & operator = (unsigned long val) { ms = millis() - val; return *this; }
    1150:	f8cb 1000 	str.w	r1, [fp]
    1154:	3b01      	subs	r3, #1
    1156:	f8cb 3030 	str.w	r3, [fp, #48]	; 0x30
}

/////////////////////////////// Update Functions ////////////////////////////////
void DLManager::update() {
    // update each timer one at a time
    for (int timer_num = 0; timer_num < DATALOG_MANAGER_TIMER_NUM; timer_num++) {
    115a:	3601      	adds	r6, #1
    115c:	2e04      	cmp	r6, #4
    115e:	f47f af72 	bne.w	1046 <DLManager::update()+0x22>
                log_timers[timer_num] = 0;
                remaining_logs[timer_num]--;
            }
        }
    }
}
    1162:	b007      	add	sp, #28
    1164:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    // Serial.print("Updating : ");Serial.println(logs[log].getName());
                    logs[log].update();
                    updates++;
                 }
            }
            for (int log = 0; log < active_logs_p; log++) {
    1168:	f898 0000 	ldrb.w	r0, [r8]
    116c:	2800      	cmp	r0, #0
    116e:	d0f4      	beq.n	115a <DLManager::update()+0x136>
        unsigned long u_time = log_timers[timer_num];
        // if it is the first reading then only update if it has been longer than the start delay
        if ((first_reading[timer_num] == true && u_time > start_delays[timer_num]) || (first_reading[timer_num] == false )) {
            first_reading[timer_num] = false;
            // if it is time to update these logs then do so
            uint8_t updates = 0;
    1170:	468a      	mov	sl, r1
    1172:	e7b9      	b.n	10e8 <DLManager::update()+0xc4>
    1174:	200045ec 	.word	0x200045ec

00001178 <DLManager::printOneOffLog(oneofflog)>:
        logs_p[i]->clear();
    }
}

////////////////////////////////////// Printing Functions //////////////////////////////
void DLManager::printOneOffLog(OneOffLog log) {
    1178:	b5f0      	push	{r4, r5, r6, r7, lr}

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
    117a:	2300      	movs	r3, #0
    117c:	b083      	sub	sp, #12
    117e:	220a      	movs	r2, #10
    1180:	460c      	mov	r4, r1
    1182:	482e      	ldr	r0, [pc, #184]	; (123c <DLManager::printOneOffLog(oneofflog)+0xc4>)
    1184:	6909      	ldr	r1, [r1, #16]
    1186:	f008 f885 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    118a:	2101      	movs	r1, #1
    118c:	482c      	ldr	r0, [pc, #176]	; (1240 <DLManager::printOneOffLog(oneofflog)+0xc8>)
    118e:	f00a fa37 	bl	b600 <usb_serial_write>
    Serial.print(log.addr);printTab();
    Serial.print(log.readMsg);printTab();
    1192:	4621      	mov	r1, r4
    1194:	4829      	ldr	r0, [pc, #164]	; (123c <DLManager::printOneOffLog(oneofflog)+0xc4>)
    1196:	f008 f847 	bl	9228 <Print::print(String const&)>
    119a:	2101      	movs	r1, #1
    119c:	4828      	ldr	r0, [pc, #160]	; (1240 <DLManager::printOneOffLog(oneofflog)+0xc8>)
    119e:	f00a fa2f 	bl	b600 <usb_serial_write>
    if (log.type == DATATYPE_BYTE) {
    11a2:	7d23      	ldrb	r3, [r4, #20]
    11a4:	2b03      	cmp	r3, #3
    11a6:	d036      	beq.n	1216 <DLManager::printOneOffLog(oneofflog)+0x9e>
        Serial.print(EEPROM.read(log.addr));
    } else if (log.type == DATATYPE_SHORT) {
    11a8:	2b01      	cmp	r3, #1
    11aa:	d03e      	beq.n	122a <DLManager::printOneOffLog(oneofflog)+0xb2>
        Serial.print(readShortFromEEPROM(log.addr));
    } else if (log.type == DATATYPE_LONG) {
    11ac:	2b02      	cmp	r3, #2
    11ae:	d01d      	beq.n	11ec <DLManager::printOneOffLog(oneofflog)+0x74>
        Serial.print(readLongFromEEPROM(log.addr));
    } else if (log.type == DATATYPE_DOUBLE) {
    11b0:	b18b      	cbz	r3, 11d6 <DLManager::printOneOffLog(oneofflog)+0x5e>
    11b2:	2101      	movs	r1, #1
    11b4:	4822      	ldr	r0, [pc, #136]	; (1240 <DLManager::printOneOffLog(oneofflog)+0xc8>)
    11b6:	f00a fa23 	bl	b600 <usb_serial_write>
    11ba:	210a      	movs	r1, #10
    11bc:	4821      	ldr	r0, [pc, #132]	; (1244 <DLManager::printOneOffLog(oneofflog)+0xcc>)
    11be:	f00a fa1f 	bl	b600 <usb_serial_write>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    11c2:	7da1      	ldrb	r1, [r4, #22]
    11c4:	481d      	ldr	r0, [pc, #116]	; (123c <DLManager::printOneOffLog(oneofflog)+0xc4>)
    11c6:	f008 f8a5 	bl	9314 <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    11ca:	481c      	ldr	r0, [pc, #112]	; (123c <DLManager::printOneOffLog(oneofflog)+0xc4>)
        Serial.print(readDoubleFromEEPROM(log.addr));
    }
    printTab();
    Serial.print("written = ");
    Serial.println(log.written);
}
    11cc:	b003      	add	sp, #12
    11ce:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    11d2:	f008 b84f 	b.w	9274 <Print::println()>
    } else if (log.type == DATATYPE_SHORT) {
        Serial.print(readShortFromEEPROM(log.addr));
    } else if (log.type == DATATYPE_LONG) {
        Serial.print(readLongFromEEPROM(log.addr));
    } else if (log.type == DATATYPE_DOUBLE) {
        Serial.print(readDoubleFromEEPROM(log.addr));
    11d6:	6920      	ldr	r0, [r4, #16]
    11d8:	f7ff fca6 	bl	b28 <readDoubleFromEEPROM(int)>
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
    11dc:	2502      	movs	r5, #2
    11de:	4602      	mov	r2, r0
    11e0:	460b      	mov	r3, r1
    11e2:	9500      	str	r5, [sp, #0]
    11e4:	4815      	ldr	r0, [pc, #84]	; (123c <DLManager::printOneOffLog(oneofflog)+0xc4>)
    11e6:	f008 f89f 	bl	9328 <Print::printFloat(double, unsigned char)>
    11ea:	e7e2      	b.n	11b2 <DLManager::printOneOffLog(oneofflog)+0x3a>
    if (log.type == DATATYPE_BYTE) {
        Serial.print(EEPROM.read(log.addr));
    } else if (log.type == DATATYPE_SHORT) {
        Serial.print(readShortFromEEPROM(log.addr));
    } else if (log.type == DATATYPE_LONG) {
        Serial.print(readLongFromEEPROM(log.addr));
    11ec:	2500      	movs	r5, #0
    11ee:	6926      	ldr	r6, [r4, #16]
  data = (data << 8) + EEPROM.read(a);
  return data;
}

uint32_t readLongFromEEPROM(int a) {
  uint32_t data = 0;
    11f0:	462f      	mov	r7, r5

    EERef( const int index )
        : index( index )                 {}

    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    11f2:	4630      	mov	r0, r6
    11f4:	f008 fb12 	bl	981c <eeprom_read_byte>
  for (int i = 0; i < 4; i++) {
    uint32_t n = EEPROM.read(a + i) << 8 * i;
    data = n | data;
    11f8:	40a8      	lsls	r0, r5
    11fa:	3508      	adds	r5, #8
  return data;
}

uint32_t readLongFromEEPROM(int a) {
  uint32_t data = 0;
  for (int i = 0; i < 4; i++) {
    11fc:	2d20      	cmp	r5, #32
    uint32_t n = EEPROM.read(a + i) << 8 * i;
    data = n | data;
    11fe:	ea47 0700 	orr.w	r7, r7, r0
    1202:	f106 0601 	add.w	r6, r6, #1
  return data;
}

uint32_t readLongFromEEPROM(int a) {
  uint32_t data = 0;
  for (int i = 0; i < 4; i++) {
    1206:	d1f4      	bne.n	11f2 <DLManager::printOneOffLog(oneofflog)+0x7a>

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
    1208:	4639      	mov	r1, r7
    120a:	2300      	movs	r3, #0
    120c:	220a      	movs	r2, #10
    120e:	480b      	ldr	r0, [pc, #44]	; (123c <DLManager::printOneOffLog(oneofflog)+0xc4>)
    1210:	f008 f840 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1214:	e7cd      	b.n	11b2 <DLManager::printOneOffLog(oneofflog)+0x3a>
    1216:	6920      	ldr	r0, [r4, #16]
    1218:	f008 fb00 	bl	981c <eeprom_read_byte>
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    121c:	2300      	movs	r3, #0
    121e:	4601      	mov	r1, r0
    1220:	220a      	movs	r2, #10
    1222:	4806      	ldr	r0, [pc, #24]	; (123c <DLManager::printOneOffLog(oneofflog)+0xc4>)
    1224:	f008 f836 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1228:	e7c3      	b.n	11b2 <DLManager::printOneOffLog(oneofflog)+0x3a>
    Serial.print(log.addr);printTab();
    Serial.print(log.readMsg);printTab();
    if (log.type == DATATYPE_BYTE) {
        Serial.print(EEPROM.read(log.addr));
    } else if (log.type == DATATYPE_SHORT) {
        Serial.print(readShortFromEEPROM(log.addr));
    122a:	6920      	ldr	r0, [r4, #16]
    122c:	f7ff fc9c 	bl	b68 <readShortFromEEPROM(int)>
	size_t print(int n)				{ return print((long)n); }
    1230:	4601      	mov	r1, r0
    1232:	4802      	ldr	r0, [pc, #8]	; (123c <DLManager::printOneOffLog(oneofflog)+0xc4>)
    1234:	f008 f86e 	bl	9314 <Print::print(long)>
    1238:	e7bb      	b.n	11b2 <DLManager::printOneOffLog(oneofflog)+0x3a>
    123a:	bf00      	nop
    123c:	1fffbaf4 	.word	0x1fffbaf4
    1240:	00010cc0 	.word	0x00010cc0
    1244:	00010b8c 	.word	0x00010b8c

00001248 <DLManager::printOneOffLogs()>:
    printTab();
    Serial.print("written = ");
    Serial.println(log.written);
}

void DLManager::printOneOffLogs() {
    1248:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    for (int i = 0; i < active_one_off_logs; i++) {
    124c:	f241 23e6 	movw	r3, #4838	; 0x12e6
    printTab();
    Serial.print("written = ");
    Serial.println(log.written);
}

void DLManager::printOneOffLogs() {
    1250:	b086      	sub	sp, #24
    for (int i = 0; i < active_one_off_logs; i++) {
    1252:	5ac3      	ldrh	r3, [r0, r3]
    1254:	b323      	cbz	r3, 12a0 <DLManager::printOneOffLogs()+0x58>
    1256:	f500 5897 	add.w	r8, r0, #4832	; 0x12e0
    125a:	4607      	mov	r7, r0
    125c:	f108 0806 	add.w	r8, r8, #6
    1260:	f100 0424 	add.w	r4, r0, #36	; 0x24
    1264:	2500      	movs	r5, #0
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
    1266:	4621      	mov	r1, r4
    1268:	4668      	mov	r0, sp
    126a:	f008 f989 	bl	9580 <String::String(String const&)>
    126e:	6921      	ldr	r1, [r4, #16]
    1270:	7da3      	ldrb	r3, [r4, #22]
    1272:	7d62      	ldrb	r2, [r4, #21]
    1274:	7d26      	ldrb	r6, [r4, #20]
    1276:	9104      	str	r1, [sp, #16]
    Serial.println(log.written);
}

void DLManager::printOneOffLogs() {
    for (int i = 0; i < active_one_off_logs; i++) {
        printOneOffLog(one_off_logs[i]);
    1278:	4638      	mov	r0, r7
    127a:	4669      	mov	r1, sp
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
    127c:	f88d 3016 	strb.w	r3, [sp, #22]
    1280:	f88d 2015 	strb.w	r2, [sp, #21]
    1284:	f88d 6014 	strb.w	r6, [sp, #20]
    Serial.println(log.written);
}

void DLManager::printOneOffLogs() {
    for (int i = 0; i < active_one_off_logs; i++) {
        printOneOffLog(one_off_logs[i]);
    1288:	f7ff ff76 	bl	1178 <DLManager::printOneOffLog(oneofflog)>
#include <EEPROM.h>
#include "Datalog.h"

////////////////////////// Struct for One-Off logs ///////////////////////

struct oneofflog {
    128c:	4668      	mov	r0, sp
    128e:	f008 f923 	bl	94d8 <String::~String()>
    Serial.print("written = ");
    Serial.println(log.written);
}

void DLManager::printOneOffLogs() {
    for (int i = 0; i < active_one_off_logs; i++) {
    1292:	f8b8 3000 	ldrh.w	r3, [r8]
    1296:	3501      	adds	r5, #1
    1298:	42ab      	cmp	r3, r5
    129a:	f104 0418 	add.w	r4, r4, #24
    129e:	dce2      	bgt.n	1266 <DLManager::printOneOffLogs()+0x1e>
        printOneOffLog(one_off_logs[i]);
    }
    Serial.println();
    12a0:	4802      	ldr	r0, [pc, #8]	; (12ac <DLManager::printOneOffLogs()+0x64>)
    12a2:	f007 ffe7 	bl	9274 <Print::println()>
}
    12a6:	b006      	add	sp, #24
    12a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    12ac:	1fffbaf4 	.word	0x1fffbaf4

000012b0 <DLManager::printAutologs()>:

void DLManager::printAutologs() {
    12b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    // note this also prints static logs
    for (int i = 0; i < active_logs; i++) {
    12b2:	f641 7310 	movw	r3, #7952	; 0x1f10
        printOneOffLog(one_off_logs[i]);
    }
    Serial.println();
}

void DLManager::printAutologs() {
    12b6:	4605      	mov	r5, r0
    // note this also prints static logs
    for (int i = 0; i < active_logs; i++) {
    12b8:	5cc3      	ldrb	r3, [r0, r3]
    12ba:	b1e3      	cbz	r3, 12f6 <DLManager::printAutologs()+0x46>
    12bc:	f500 5697 	add.w	r6, r0, #4832	; 0x12e0
    12c0:	f500 57f8 	add.w	r7, r0, #7936	; 0x1f00
    12c4:	3614      	adds	r6, #20
    12c6:	3710      	adds	r7, #16
    12c8:	2400      	movs	r4, #0
    12ca:	2108      	movs	r1, #8
    12cc:	4819      	ldr	r0, [pc, #100]	; (1334 <DLManager::printAutologs()+0x84>)
    12ce:	f00a f997 	bl	b600 <usb_serial_write>
    12d2:	4621      	mov	r1, r4
    12d4:	4818      	ldr	r0, [pc, #96]	; (1338 <DLManager::printAutologs()+0x88>)
    12d6:	f008 f81d 	bl	9314 <Print::print(long)>
    12da:	2101      	movs	r1, #1
    12dc:	4817      	ldr	r0, [pc, #92]	; (133c <DLManager::printAutologs()+0x8c>)
    12de:	f00a f98f 	bl	b600 <usb_serial_write>
        Serial.print("Log idx ");
        Serial.print(i);printTab();
        logs[i].printLog(4);
    12e2:	4630      	mov	r0, r6
    12e4:	2104      	movs	r1, #4
    12e6:	f7ff fb99 	bl	a1c <Datalog::printLog(unsigned char)>
    Serial.println();
}

void DLManager::printAutologs() {
    // note this also prints static logs
    for (int i = 0; i < active_logs; i++) {
    12ea:	783b      	ldrb	r3, [r7, #0]
    12ec:	3401      	adds	r4, #1
    12ee:	42a3      	cmp	r3, r4
    12f0:	f106 063c 	add.w	r6, r6, #60	; 0x3c
    12f4:	dce9      	bgt.n	12ca <DLManager::printAutologs()+0x1a>
        Serial.print("Log idx ");
        Serial.print(i);printTab();
        logs[i].printLog(4);
    }
    for (int i = 0; i < active_logs_p; i++) {
    12f6:	f505 5601 	add.w	r6, r5, #8256	; 0x2040
    12fa:	7833      	ldrb	r3, [r6, #0]
    12fc:	b1a3      	cbz	r3, 1328 <DLManager::printAutologs()+0x78>
    12fe:	f505 55f8 	add.w	r5, r5, #7936	; 0x1f00
    1302:	3510      	adds	r5, #16
    1304:	2400      	movs	r4, #0
    1306:	4621      	mov	r1, r4
    1308:	480b      	ldr	r0, [pc, #44]	; (1338 <DLManager::printAutologs()+0x88>)
    130a:	f008 f803 	bl	9314 <Print::print(long)>
    130e:	2102      	movs	r1, #2
    1310:	480b      	ldr	r0, [pc, #44]	; (1340 <DLManager::printAutologs()+0x90>)
    1312:	f00a f975 	bl	b600 <usb_serial_write>
        Serial.print(i);Serial.print("p\t");
        logs_p[i]->printLog(8);
    1316:	2108      	movs	r1, #8
    1318:	f855 0f04 	ldr.w	r0, [r5, #4]!
    131c:	f7ff fb7e 	bl	a1c <Datalog::printLog(unsigned char)>
    for (int i = 0; i < active_logs; i++) {
        Serial.print("Log idx ");
        Serial.print(i);printTab();
        logs[i].printLog(4);
    }
    for (int i = 0; i < active_logs_p; i++) {
    1320:	7833      	ldrb	r3, [r6, #0]
    1322:	3401      	adds	r4, #1
    1324:	42a3      	cmp	r3, r4
    1326:	dcee      	bgt.n	1306 <DLManager::printAutologs()+0x56>
        Serial.print(i);Serial.print("p\t");
        logs_p[i]->printLog(8);
    }
    Serial.println();
    1328:	4803      	ldr	r0, [pc, #12]	; (1338 <DLManager::printAutologs()+0x88>)
}
    132a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    }
    for (int i = 0; i < active_logs_p; i++) {
        Serial.print(i);Serial.print("p\t");
        logs_p[i]->printLog(8);
    }
    Serial.println();
    132e:	f007 bfa1 	b.w	9274 <Print::println()>
    1332:	bf00      	nop
    1334:	00010b98 	.word	0x00010b98
    1338:	1fffbaf4 	.word	0x1fffbaf4
    133c:	00010cc0 	.word	0x00010cc0
    1340:	00010ba4 	.word	0x00010ba4

00001344 <DLManager::printAllLogs()>:
}

void DLManager::printAllLogs() {
    1344:	b530      	push	{r4, r5, lr}
    1346:	b085      	sub	sp, #20
    1348:	4605      	mov	r5, r0
    printMajorDivide("All Logs Stored in EEPROM");
    134a:	4919      	ldr	r1, [pc, #100]	; (13b0 <DLManager::printAllLogs()+0x6c>)
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    134c:	4c19      	ldr	r4, [pc, #100]	; (13b4 <DLManager::printAllLogs()+0x70>)
    134e:	4668      	mov	r0, sp
    1350:	f008 f902 	bl	9558 <String::String(char const*)>
    1354:	4668      	mov	r0, sp
    1356:	f7ff fa6f 	bl	838 <printMajorDivide(String)>
    135a:	4668      	mov	r0, sp
    135c:	f008 f8bc 	bl	94d8 <String::~String()>
    1360:	2130      	movs	r1, #48	; 0x30
    1362:	4815      	ldr	r0, [pc, #84]	; (13b8 <DLManager::printAllLogs()+0x74>)
    1364:	f00a f94c 	bl	b600 <usb_serial_write>
    1368:	4620      	mov	r0, r4
    136a:	f007 ff83 	bl	9274 <Print::println()>
    Serial.println("----------- Printing One-off Logs --------------");
    printOneOffLogs();
    136e:	4628      	mov	r0, r5
    1370:	f7ff ff6a 	bl	1248 <DLManager::printOneOffLogs()>
    1374:	2125      	movs	r1, #37	; 0x25
    1376:	4811      	ldr	r0, [pc, #68]	; (13bc <DLManager::printAllLogs()+0x78>)
    1378:	f00a f942 	bl	b600 <usb_serial_write>
    137c:	4620      	mov	r0, r4
    137e:	f007 ff79 	bl	9274 <Print::println()>
    1382:	2138      	movs	r1, #56	; 0x38
    1384:	480e      	ldr	r0, [pc, #56]	; (13c0 <DLManager::printAllLogs()+0x7c>)
    1386:	f00a f93b 	bl	b600 <usb_serial_write>
    138a:	4620      	mov	r0, r4
    138c:	f007 ff72 	bl	9274 <Print::println()>
    printMinorDivide();
    Serial.println("----------- Printing Auto and Static Logs --------------");
    printAutologs();
    1390:	4628      	mov	r0, r5
    1392:	f7ff ff8d 	bl	12b0 <DLManager::printAutologs()>
    printMajorDivide("Finished Printing EEPROM Contents");
    1396:	490b      	ldr	r1, [pc, #44]	; (13c4 <DLManager::printAllLogs()+0x80>)
    1398:	4668      	mov	r0, sp
    139a:	f008 f8dd 	bl	9558 <String::String(char const*)>
    139e:	4668      	mov	r0, sp
    13a0:	f7ff fa4a 	bl	838 <printMajorDivide(String)>
    13a4:	4668      	mov	r0, sp
    13a6:	f008 f897 	bl	94d8 <String::~String()>
}
    13aa:	b005      	add	sp, #20
    13ac:	bd30      	pop	{r4, r5, pc}
    13ae:	bf00      	nop
    13b0:	00010ba8 	.word	0x00010ba8
    13b4:	1fffbaf4 	.word	0x1fffbaf4
    13b8:	00010bc4 	.word	0x00010bc4
    13bc:	00010734 	.word	0x00010734
    13c0:	00010bf8 	.word	0x00010bf8
    13c4:	00010c34 	.word	0x00010c34

000013c8 <DLManager::printTimerConfigs()>:

void DLManager::printTimerConfigs()  {
    13c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    13ca:	2125      	movs	r1, #37	; 0x25
    13cc:	b083      	sub	sp, #12
    13ce:	4605      	mov	r5, r0
    13d0:	484e      	ldr	r0, [pc, #312]	; (150c <DLManager::printTimerConfigs()+0x144>)
    13d2:	4f4f      	ldr	r7, [pc, #316]	; (1510 <DLManager::printTimerConfigs()+0x148>)
    13d4:	f00a f914 	bl	b600 <usb_serial_write>
    13d8:	484e      	ldr	r0, [pc, #312]	; (1514 <DLManager::printTimerConfigs()+0x14c>)
    13da:	f007 ff4b 	bl	9274 <Print::println()>
    13de:	2139      	movs	r1, #57	; 0x39
    13e0:	484d      	ldr	r0, [pc, #308]	; (1518 <DLManager::printTimerConfigs()+0x150>)
    13e2:	f00a f90d 	bl	b600 <usb_serial_write>
    13e6:	484b      	ldr	r0, [pc, #300]	; (1514 <DLManager::printTimerConfigs()+0x14c>)
    13e8:	f007 ff44 	bl	9274 <Print::println()>
    13ec:	f505 5601 	add.w	r6, r5, #8256	; 0x2040
    printMinorDivide();
    Serial.println("Printing the Timer Configurations for the Datalog Manager");
    for (int i = 0; i < DATALOG_MANAGER_TIMER_NUM; i++) {
    13f0:	2400      	movs	r4, #0
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    13f2:	4621      	mov	r1, r4
    13f4:	4847      	ldr	r0, [pc, #284]	; (1514 <DLManager::printTimerConfigs()+0x14c>)
    13f6:	f007 ff8d 	bl	9314 <Print::print(long)>
    13fa:	210a      	movs	r1, #10
    13fc:	4847      	ldr	r0, [pc, #284]	; (151c <DLManager::printTimerConfigs()+0x154>)
    13fe:	f00a f8ff 	bl	b600 <usb_serial_write>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1402:	683b      	ldr	r3, [r7, #0]
    1404:	9301      	str	r3, [sp, #4]
	return ret;
    1406:	9901      	ldr	r1, [sp, #4]
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
    1408:	f856 3f04 	ldr.w	r3, [r6, #4]!
    140c:	4841      	ldr	r0, [pc, #260]	; (1514 <DLManager::printTimerConfigs()+0x14c>)
    140e:	1ac9      	subs	r1, r1, r3
    1410:	220a      	movs	r2, #10
    1412:	2300      	movs	r3, #0
    1414:	f007 ff3e 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    1418:	2105      	movs	r1, #5
    141a:	4841      	ldr	r0, [pc, #260]	; (1520 <DLManager::printTimerConfigs()+0x158>)
    141c:	f00a f8f0 	bl	b600 <usb_serial_write>
    1420:	6931      	ldr	r1, [r6, #16]
    1422:	483c      	ldr	r0, [pc, #240]	; (1514 <DLManager::printTimerConfigs()+0x14c>)
    1424:	2300      	movs	r3, #0
    1426:	220a      	movs	r2, #10
    1428:	f007 ff34 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    142c:	3401      	adds	r4, #1

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
    142e:	4839      	ldr	r0, [pc, #228]	; (1514 <DLManager::printTimerConfigs()+0x14c>)
    1430:	f007 ff20 	bl	9274 <Print::println()>
    1434:	2c04      	cmp	r4, #4
    1436:	d1dc      	bne.n	13f2 <DLManager::printTimerConfigs()+0x2a>
    1438:	2119      	movs	r1, #25
    143a:	483a      	ldr	r0, [pc, #232]	; (1524 <DLManager::printTimerConfigs()+0x15c>)
    143c:	f505 5701 	add.w	r7, r5, #8256	; 0x2040
    1440:	f00a f8de 	bl	b600 <usb_serial_write>
    1444:	3720      	adds	r7, #32
    1446:	f505 5401 	add.w	r4, r5, #8256	; 0x2040
    144a:	463e      	mov	r6, r7
    144c:	3430      	adds	r4, #48	; 0x30

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
    144e:	f856 1f04 	ldr.w	r1, [r6, #4]!
    1452:	4830      	ldr	r0, [pc, #192]	; (1514 <DLManager::printTimerConfigs()+0x14c>)
    1454:	2300      	movs	r3, #0
    1456:	220a      	movs	r2, #10
    1458:	f007 ff1c 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    145c:	2101      	movs	r1, #1
    145e:	4832      	ldr	r0, [pc, #200]	; (1528 <DLManager::printTimerConfigs()+0x160>)
    1460:	f00a f8ce 	bl	b600 <usb_serial_write>
        Serial.print(i);Serial.print(" current: ");Serial.print(log_timers[i]);Serial.print("\tmax\t");
        Serial.println(log_refresh_length[i]);
    }

    Serial.print("start_delays           :\t");
    for (int i = 0; i < DATALOG_MANAGER_TIMER_NUM; i++) {
    1464:	42a6      	cmp	r6, r4
    1466:	d1f2      	bne.n	144e <DLManager::printTimerConfigs()+0x86>
        Serial.print(start_delays[i]);printTab();
    }
    Serial.println();
    1468:	482a      	ldr	r0, [pc, #168]	; (1514 <DLManager::printTimerConfigs()+0x14c>)
    146a:	f007 ff03 	bl	9274 <Print::println()>
    146e:	2118      	movs	r1, #24
    1470:	482e      	ldr	r0, [pc, #184]	; (152c <DLManager::printTimerConfigs()+0x164>)
    1472:	f00a f8c5 	bl	b600 <usb_serial_write>
    1476:	f505 5602 	add.w	r6, r5, #8320	; 0x2080

    Serial.print("remaining_logs        :\t");
    for (int i = 0; i < DATALOG_MANAGER_TIMER_NUM; i++) {
        Serial.print(remaining_logs[i]);printTab();
    147a:	f854 1f04 	ldr.w	r1, [r4, #4]!
    147e:	4825      	ldr	r0, [pc, #148]	; (1514 <DLManager::printTimerConfigs()+0x14c>)
    1480:	f007 ff48 	bl	9314 <Print::print(long)>
    1484:	2101      	movs	r1, #1
    1486:	4828      	ldr	r0, [pc, #160]	; (1528 <DLManager::printTimerConfigs()+0x160>)
    1488:	f00a f8ba 	bl	b600 <usb_serial_write>
        Serial.print(start_delays[i]);printTab();
    }
    Serial.println();

    Serial.print("remaining_logs        :\t");
    for (int i = 0; i < DATALOG_MANAGER_TIMER_NUM; i++) {
    148c:	42a6      	cmp	r6, r4
    148e:	d1f4      	bne.n	147a <DLManager::printTimerConfigs()+0xb2>
        Serial.print(remaining_logs[i]);printTab();

    }
    Serial.println();
    1490:	4820      	ldr	r0, [pc, #128]	; (1514 <DLManager::printTimerConfigs()+0x14c>)
    1492:	f007 feef 	bl	9274 <Print::println()>
    1496:	2117      	movs	r1, #23
    1498:	4825      	ldr	r0, [pc, #148]	; (1530 <DLManager::printTimerConfigs()+0x168>)
    149a:	f00a f8b1 	bl	b600 <usb_serial_write>
    149e:	f505 5401 	add.w	r4, r5, #8256	; 0x2040
    14a2:	3410      	adds	r4, #16
    14a4:	f854 1f04 	ldr.w	r1, [r4, #4]!
    14a8:	481a      	ldr	r0, [pc, #104]	; (1514 <DLManager::printTimerConfigs()+0x14c>)
    14aa:	2300      	movs	r3, #0
    14ac:	220a      	movs	r2, #10
    14ae:	f007 fef1 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    14b2:	2101      	movs	r1, #1
    14b4:	481c      	ldr	r0, [pc, #112]	; (1528 <DLManager::printTimerConfigs()+0x160>)
    14b6:	f00a f8a3 	bl	b600 <usb_serial_write>

    Serial.print("log_refresh_length   :\t");
    for (int i = 0; i < DATALOG_MANAGER_TIMER_NUM; i++) {
    14ba:	42a7      	cmp	r7, r4
    14bc:	d1f2      	bne.n	14a4 <DLManager::printTimerConfigs()+0xdc>
        Serial.print(log_refresh_length[i]);printTab();

    }
    Serial.println();
    14be:	4815      	ldr	r0, [pc, #84]	; (1514 <DLManager::printTimerConfigs()+0x14c>)
    14c0:	f007 fed8 	bl	9274 <Print::println()>
    14c4:	2116      	movs	r1, #22
    14c6:	481b      	ldr	r0, [pc, #108]	; (1534 <DLManager::printTimerConfigs()+0x16c>)
    14c8:	f00a f89a 	bl	b600 <usb_serial_write>
    14cc:	f505 54f6 	add.w	r4, r5, #7872	; 0x1ec0
    14d0:	f505 55f8 	add.w	r5, r5, #7936	; 0x1f00
    14d4:	341d      	adds	r4, #29
    14d6:	350f      	adds	r5, #15
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    14d8:	f814 1f01 	ldrb.w	r1, [r4, #1]!
    14dc:	480d      	ldr	r0, [pc, #52]	; (1514 <DLManager::printTimerConfigs()+0x14c>)
    14de:	2300      	movs	r3, #0
    14e0:	220a      	movs	r2, #10
    14e2:	f007 fed7 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    14e6:	2101      	movs	r1, #1
    14e8:	480f      	ldr	r0, [pc, #60]	; (1528 <DLManager::printTimerConfigs()+0x160>)
    14ea:	f00a f889 	bl	b600 <usb_serial_write>

    Serial.print("log_timer_map       :\t");
    for (int i = 0; i < DATALOG_MANAGER_MAX_LOGS; i++) {
    14ee:	42a5      	cmp	r5, r4
    14f0:	d1f2      	bne.n	14d8 <DLManager::printTimerConfigs()+0x110>
        Serial.print(log_timer_map[i]);Serial.print("\t");
    }
    Serial.println();
    14f2:	4808      	ldr	r0, [pc, #32]	; (1514 <DLManager::printTimerConfigs()+0x14c>)
    14f4:	f007 febe 	bl	9274 <Print::println()>
    14f8:	2125      	movs	r1, #37	; 0x25
    14fa:	4804      	ldr	r0, [pc, #16]	; (150c <DLManager::printTimerConfigs()+0x144>)
    14fc:	f00a f880 	bl	b600 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    1500:	4804      	ldr	r0, [pc, #16]	; (1514 <DLManager::printTimerConfigs()+0x14c>)
    1502:	f007 feb7 	bl	9274 <Print::println()>
    printMinorDivide();
}
    1506:	b003      	add	sp, #12
    1508:	bdf0      	pop	{r4, r5, r6, r7, pc}
    150a:	bf00      	nop
    150c:	00010734 	.word	0x00010734
    1510:	200045ec 	.word	0x200045ec
    1514:	1fffbaf4 	.word	0x1fffbaf4
    1518:	00010c58 	.word	0x00010c58
    151c:	00010c94 	.word	0x00010c94
    1520:	00010ca0 	.word	0x00010ca0
    1524:	00010ca8 	.word	0x00010ca8
    1528:	00010cc0 	.word	0x00010cc0
    152c:	00010cc4 	.word	0x00010cc4
    1530:	00010ce0 	.word	0x00010ce0
    1534:	00010cf8 	.word	0x00010cf8

00001538 <packColors(unsigned char&, unsigned char&, unsigned char&, double)>:
#include "../Macros.h"

#include <PrintUtils.h>
// #include <elapsedMillis.h>

uint32_t packColors(uint8_t &red, uint8_t &green, uint8_t &blue, double scaler) {
    1538:	b570      	push	{r4, r5, r6, lr}
    153a:	4604      	mov	r4, r0
    /*
     * TODO write a function summary
     * 
     * */
  uint32_t color = 0;
  red = red * scaler;
    153c:	7800      	ldrb	r0, [r0, #0]
#include "../Macros.h"

#include <PrintUtils.h>
// #include <elapsedMillis.h>

uint32_t packColors(uint8_t &red, uint8_t &green, uint8_t &blue, double scaler) {
    153e:	460d      	mov	r5, r1
    1540:	4616      	mov	r6, r2
    /*
     * TODO write a function summary
     * 
     * */
  uint32_t color = 0;
  red = red * scaler;
    1542:	f00b fa4f 	bl	c9e4 <__aeabi_i2d>
    1546:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    154a:	f00b fab1 	bl	cab0 <__aeabi_dmul>
    154e:	f00b fd87 	bl	d060 <__aeabi_d2uiz>
    1552:	7020      	strb	r0, [r4, #0]
  green = green * scaler;
    1554:	7828      	ldrb	r0, [r5, #0]
    1556:	f00b fa45 	bl	c9e4 <__aeabi_i2d>
    155a:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    155e:	f00b faa7 	bl	cab0 <__aeabi_dmul>
    1562:	f00b fd7d 	bl	d060 <__aeabi_d2uiz>
    1566:	7028      	strb	r0, [r5, #0]
  blue = blue * scaler;
    1568:	7830      	ldrb	r0, [r6, #0]
    156a:	f00b fa3b 	bl	c9e4 <__aeabi_i2d>
    156e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    1572:	f00b fa9d 	bl	cab0 <__aeabi_dmul>
    1576:	f00b fd73 	bl	d060 <__aeabi_d2uiz>
    157a:	b2c0      	uxtb	r0, r0
    157c:	7030      	strb	r0, [r6, #0]
  blue = min(blue, MAX_BRIGHTNESS);
  if (red < MIN_BRIGHTNESS) {red = 0;};
  if (green < MIN_BRIGHTNESS) {green = 0;};
  if (blue < MIN_BRIGHTNESS) {blue = 0;};
  color = (red << 16) + (green << 8) + (blue);
  return color;
    157e:	782b      	ldrb	r3, [r5, #0]
    1580:	7822      	ldrb	r2, [r4, #0]
    1582:	021b      	lsls	r3, r3, #8
    1584:	eb03 4302 	add.w	r3, r3, r2, lsl #16
}
    1588:	4418      	add	r0, r3
    158a:	bd70      	pop	{r4, r5, r6, pc}

0000158c <NeoGroup::NeoGroup(WS2812Serial*, int, int, String, unsigned long, unsigned long)>:
double NeoGroup::getFPM() {
  fpm = (double)num_flashes / (double)fpm_timer * 1000 * 60;
  return fpm;
}

NeoGroup::NeoGroup(WS2812Serial *neos, int start_idx, int end_idx, String _id, uint32_t f_min, uint32_t f_max) {
    158c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1590:	4e30      	ldr	r6, [pc, #192]	; (1654 <NeoGroup::NeoGroup(WS2812Serial*, int, int, String, unsigned long, unsigned long)+0xc8>)
    1592:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 165c <NeoGroup::NeoGroup(WS2812Serial*, int, int, String, unsigned long, unsigned long)+0xd0>
    1596:	6834      	ldr	r4, [r6, #0]
    1598:	b087      	sub	sp, #28
    159a:	25ff      	movs	r5, #255	; 0xff
    159c:	9405      	str	r4, [sp, #20]
    159e:	4604      	mov	r4, r0
    15a0:	2701      	movs	r7, #1
	return ret;
    15a2:	9805      	ldr	r0, [sp, #20]
    15a4:	f884 504e 	strb.w	r5, [r4, #78]	; 0x4e
    15a8:	f104 0a80 	add.w	sl, r4, #128	; 0x80
    15ac:	2500      	movs	r5, #0
    15ae:	f04f 0800 	mov.w	r8, #0
    15b2:	e9c4 890a 	strd	r8, r9, [r4, #40]	; 0x28
    15b6:	468b      	mov	fp, r1
class elapsedMillis
{
private:
	unsigned long ms;
public:
	elapsedMillis(void) { ms = millis(); }
    15b8:	6620      	str	r0, [r4, #96]	; 0x60
    15ba:	61a5      	str	r5, [r4, #24]
    15bc:	61e5      	str	r5, [r4, #28]
    15be:	f884 504b 	strb.w	r5, [r4, #75]	; 0x4b
    15c2:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
    15c6:	f884 504d 	strb.w	r5, [r4, #77]	; 0x4d
    15ca:	6525      	str	r5, [r4, #80]	; 0x50
    15cc:	f884 5054 	strb.w	r5, [r4, #84]	; 0x54
    15d0:	f884 707c 	strb.w	r7, [r4, #124]	; 0x7c
    15d4:	4629      	mov	r1, r5
    15d6:	4650      	mov	r0, sl
    15d8:	4691      	mov	r9, r2
    15da:	4698      	mov	r8, r3
    15dc:	f007 ffbc 	bl	9558 <String::String(char const*)>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    15e0:	6833      	ldr	r3, [r6, #0]
    15e2:	9304      	str	r3, [sp, #16]
	return ret;
    15e4:	f8dd c010 	ldr.w	ip, [sp, #16]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    15e8:	6833      	ldr	r3, [r6, #0]
    15ea:	9303      	str	r3, [sp, #12]
	return ret;
    15ec:	f8dd e00c 	ldr.w	lr, [sp, #12]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    15f0:	6833      	ldr	r3, [r6, #0]
    15f2:	9302      	str	r3, [sp, #8]
	return ret;
    15f4:	9902      	ldr	r1, [sp, #8]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    15f6:	6833      	ldr	r3, [r6, #0]
    15f8:	9301      	str	r3, [sp, #4]
  // todo
  flash_min_time = f_min;
    15fa:	9b11      	ldr	r3, [sp, #68]	; 0x44
    15fc:	65a3      	str	r3, [r4, #88]	; 0x58
  flash_max_time = f_max;
  num_pixels = end_idx - start_idx + 1;
    15fe:	ebc9 0608 	rsb	r6, r9, r8
double NeoGroup::getFPM() {
  fpm = (double)num_flashes / (double)fpm_timer * 1000 * 60;
  return fpm;
}

NeoGroup::NeoGroup(WS2812Serial *neos, int start_idx, int end_idx, String _id, uint32_t f_min, uint32_t f_max) {
    1602:	4b15      	ldr	r3, [pc, #84]	; (1658 <NeoGroup::NeoGroup(WS2812Serial*, int, int, String, unsigned long, unsigned long)+0xcc>)
    1604:	f8c4 50a4 	str.w	r5, [r4, #164]	; 0xa4
  // todo
  flash_min_time = f_min;
  flash_max_time = f_max;
  num_pixels = end_idx - start_idx + 1;
    1608:	443e      	add	r6, r7
double NeoGroup::getFPM() {
  fpm = (double)num_flashes / (double)fpm_timer * 1000 * 60;
  return fpm;
}

NeoGroup::NeoGroup(WS2812Serial *neos, int start_idx, int end_idx, String _id, uint32_t f_min, uint32_t f_max) {
    160a:	f884 50a8 	strb.w	r5, [r4, #168]	; 0xa8
    160e:	f8c4 70b8 	str.w	r7, [r4, #184]	; 0xb8
	return ret;
    1612:	9d01      	ldr	r5, [sp, #4]
    1614:	f8c4 70bc 	str.w	r7, [r4, #188]	; 0xbc
    1618:	2200      	movs	r2, #0
  // todo
  flash_min_time = f_min;
  flash_max_time = f_max;
    161a:	9f12      	ldr	r7, [sp, #72]	; 0x48
    161c:	f8c4 10b0 	str.w	r1, [r4, #176]	; 0xb0
  num_pixels = end_idx - start_idx + 1;
  idx_start = start_idx;
  idx_end = end_idx;
  leds = neos;
  id = _id;
    1620:	4650      	mov	r0, sl
}

NeoGroup::NeoGroup(WS2812Serial *neos, int start_idx, int end_idx, String _id, uint32_t f_min, uint32_t f_max) {
  // todo
  flash_min_time = f_min;
  flash_max_time = f_max;
    1622:	65e7      	str	r7, [r4, #92]	; 0x5c
  num_pixels = end_idx - start_idx + 1;
  idx_start = start_idx;
    1624:	f8c4 9094 	str.w	r9, [r4, #148]	; 0x94

NeoGroup::NeoGroup(WS2812Serial *neos, int start_idx, int end_idx, String _id, uint32_t f_min, uint32_t f_max) {
  // todo
  flash_min_time = f_min;
  flash_max_time = f_max;
  num_pixels = end_idx - start_idx + 1;
    1628:	f8c4 609c 	str.w	r6, [r4, #156]	; 0x9c
  idx_start = start_idx;
  idx_end = end_idx;
    162c:	f8c4 8098 	str.w	r8, [r4, #152]	; 0x98
  leds = neos;
    1630:	f8c4 b090 	str.w	fp, [r4, #144]	; 0x90
    1634:	f8c4 c0a0 	str.w	ip, [r4, #160]	; 0xa0
    1638:	f8c4 e0ac 	str.w	lr, [r4, #172]	; 0xac
    163c:	f8c4 50b4 	str.w	r5, [r4, #180]	; 0xb4
double NeoGroup::getFPM() {
  fpm = (double)num_flashes / (double)fpm_timer * 1000 * 60;
  return fpm;
}

NeoGroup::NeoGroup(WS2812Serial *neos, int start_idx, int end_idx, String _id, uint32_t f_min, uint32_t f_max) {
    1640:	e9c4 2330 	strd	r2, r3, [r4, #192]	; 0xc0
  flash_max_time = f_max;
  num_pixels = end_idx - start_idx + 1;
  idx_start = start_idx;
  idx_end = end_idx;
  leds = neos;
  id = _id;
    1644:	9910      	ldr	r1, [sp, #64]	; 0x40
    1646:	f007 fff1 	bl	962c <String::operator=(String const&)>
}
    164a:	4620      	mov	r0, r4
    164c:	b007      	add	sp, #28
    164e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1652:	bf00      	nop
    1654:	200045ec 	.word	0x200045ec
    1658:	3ff00000 	.word	0x3ff00000
    165c:	3fe00000 	.word	0x3fe00000

00001660 <NeoGroup::powerOn()>:
    Serial.print("\thue "); Serial.print(hsb[0]);
    Serial.print("\tsat "); Serial.print(hsb[1]);
    Serial.print("\tbgt "); Serial.println(hsb[2]);
}

void NeoGroup::powerOn() {
    1660:	b510      	push	{r4, lr}
    1662:	b084      	sub	sp, #16
    1664:	4604      	mov	r4, r0
  dprintln(PRINT_LUX_DEBUG, "POWER ON MESSAGE RECEIVED");
    1666:	4908      	ldr	r1, [pc, #32]	; (1688 <NeoGroup::powerOn()+0x28>)
    1668:	4668      	mov	r0, sp
    166a:	f007 ff75 	bl	9558 <String::String(char const*)>
    166e:	4668      	mov	r0, sp
    1670:	f007 ff32 	bl	94d8 <String::~String()>
	elapsedMillis(const elapsedMillis &orig) { ms = orig.ms; }
	operator unsigned long () const { return millis() - ms; }
	elapsedMillis & operator = (const elapsedMillis &rhs) { ms = rhs.ms; return *this; }
	elapsedMillis & operator = (unsigned long val) { ms = millis() - val; return *this; }
	elapsedMillis & operator -= (unsigned long val)      { ms += val ; return *this; }
	elapsedMillis & operator += (unsigned long val)      { ms -= val ; return *this; }
    1674:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    1678:	f8d4 20a4 	ldr.w	r2, [r4, #164]	; 0xa4
    167c:	1a9b      	subs	r3, r3, r2
    167e:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
  shdn_timer += shdn_len;
}
    1682:	b004      	add	sp, #16
    1684:	bd10      	pop	{r4, pc}
    1686:	bf00      	nop
    1688:	00010d4c 	.word	0x00010d4c

0000168c <NeoGroup::updateOnRatio(int)>:
  off_time = 0;
  dprintln(PRINT_LED_DEBUG, "reset the led on/off ratio counters");
}

// mode 0 is just front, mode 1 is just rear, mode 2 is both (using combined values?), mode 3 is both using independent values
void NeoGroup::updateOnRatio(int color) {
    168c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  // when color wipe is called it should take care of this for  us
  // to keep track of on/off times
  if (color > 0) {
    1690:	2900      	cmp	r1, #0
  off_time = 0;
  dprintln(PRINT_LED_DEBUG, "reset the led on/off ratio counters");
}

// mode 0 is just front, mode 1 is just rear, mode 2 is both (using combined values?), mode 3 is both using independent values
void NeoGroup::updateOnRatio(int color) {
    1692:	b089      	sub	sp, #36	; 0x24
    1694:	4605      	mov	r5, r0
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1696:	4e29      	ldr	r6, [pc, #164]	; (173c <NeoGroup::updateOnRatio(int)+0xb0>)
  // when color wipe is called it should take care of this for  us
  // to keep track of on/off times
  if (color > 0) {
    1698:	dd42      	ble.n	1720 <NeoGroup::updateOnRatio(int)+0x94>
    169a:	6832      	ldr	r2, [r6, #0]
    169c:	9201      	str	r2, [sp, #4]
    on_time += on_off_len;
    169e:	f8d0 30b8 	ldr.w	r3, [r0, #184]	; 0xb8
	return ret;
    16a2:	9c01      	ldr	r4, [sp, #4]
    16a4:	f8d0 20b0 	ldr.w	r2, [r0, #176]	; 0xb0
    16a8:	4423      	add	r3, r4
    16aa:	1a9c      	subs	r4, r3, r2
    16ac:	f8c0 40b8 	str.w	r4, [r0, #184]	; 0xb8
  } else {
    off_time += on_off_len;
  }
  if (on_time > 0 && off_time > 0) {
    16b0:	b1bc      	cbz	r4, 16e2 <NeoGroup::updateOnRatio(int)+0x56>
    16b2:	f8d5 70bc 	ldr.w	r7, [r5, #188]	; 0xbc
    16b6:	b1a7      	cbz	r7, 16e2 <NeoGroup::updateOnRatio(int)+0x56>
    on_ratio = (double)on_time / (double)(on_time + off_time);
    16b8:	4620      	mov	r0, r4
    16ba:	f00b f983 	bl	c9c4 <__aeabi_ui2d>
    16be:	4680      	mov	r8, r0
    16c0:	1938      	adds	r0, r7, r4
    16c2:	4689      	mov	r9, r1
    16c4:	f00b f97e 	bl	c9c4 <__aeabi_ui2d>
    16c8:	460b      	mov	r3, r1
    16ca:	4602      	mov	r2, r0
    16cc:	4649      	mov	r1, r9
    16ce:	4640      	mov	r0, r8
    16d0:	f00b fb18 	bl	cd04 <__aeabi_ddiv>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    16d4:	6833      	ldr	r3, [r6, #0]
    16d6:	9303      	str	r3, [sp, #12]
    16d8:	e9c5 010a 	strd	r0, r1, [r5, #40]	; 0x28
	return ret;
    16dc:	9b03      	ldr	r3, [sp, #12]
	elapsedMillis(void) { ms = millis(); }
	elapsedMillis(unsigned long val) { ms = millis() - val; }
	elapsedMillis(const elapsedMillis &orig) { ms = orig.ms; }
	operator unsigned long () const { return millis() - ms; }
	elapsedMillis & operator = (const elapsedMillis &rhs) { ms = rhs.ms; return *this; }
	elapsedMillis & operator = (unsigned long val) { ms = millis() - val; return *this; }
    16de:	f8c5 30b0 	str.w	r3, [r5, #176]	; 0xb0
    on_off_len = 0;
  }
  dprint(PRINT_LED_ON_RATIO_DEBUG, "updated led on/off ratio "); dprint(PRINT_LED_ON_RATIO_DEBUG, " :\t");
    16e2:	4917      	ldr	r1, [pc, #92]	; (1740 <NeoGroup::updateOnRatio(int)+0xb4>)
    16e4:	a804      	add	r0, sp, #16
    16e6:	f007 ff37 	bl	9558 <String::String(char const*)>
    16ea:	a804      	add	r0, sp, #16
    16ec:	f007 fef4 	bl	94d8 <String::~String()>
    16f0:	4914      	ldr	r1, [pc, #80]	; (1744 <NeoGroup::updateOnRatio(int)+0xb8>)
    16f2:	a804      	add	r0, sp, #16
    16f4:	f007 ff30 	bl	9558 <String::String(char const*)>
    16f8:	a804      	add	r0, sp, #16
    16fa:	f007 feed 	bl	94d8 <String::~String()>
  dprint(PRINT_LED_ON_RATIO_DEBUG, on_ratio); dprint(PRINT_LED_ON_RATIO_DEBUG, "\t=\t"); dprint(PRINT_LED_ON_RATIO_DEBUG, on_time);
    16fe:	4912      	ldr	r1, [pc, #72]	; (1748 <NeoGroup::updateOnRatio(int)+0xbc>)
    1700:	a804      	add	r0, sp, #16
    1702:	f007 ff29 	bl	9558 <String::String(char const*)>
    1706:	a804      	add	r0, sp, #16
    1708:	f007 fee6 	bl	94d8 <String::~String()>
  dprint(PRINT_LED_ON_RATIO_DEBUG, "\t"); dprintln(PRINT_LED_ON_RATIO_DEBUG, off_time);
    170c:	490f      	ldr	r1, [pc, #60]	; (174c <NeoGroup::updateOnRatio(int)+0xc0>)
    170e:	a804      	add	r0, sp, #16
    1710:	f007 ff22 	bl	9558 <String::String(char const*)>
    1714:	a804      	add	r0, sp, #16
    1716:	f007 fedf 	bl	94d8 <String::~String()>
}
    171a:	b009      	add	sp, #36	; 0x24
    171c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1720:	6832      	ldr	r2, [r6, #0]
    1722:	9202      	str	r2, [sp, #8]
  // when color wipe is called it should take care of this for  us
  // to keep track of on/off times
  if (color > 0) {
    on_time += on_off_len;
  } else {
    off_time += on_off_len;
    1724:	f8d0 30bc 	ldr.w	r3, [r0, #188]	; 0xbc
	return ret;
    1728:	9902      	ldr	r1, [sp, #8]
    172a:	f8d0 20b0 	ldr.w	r2, [r0, #176]	; 0xb0
    172e:	f8d0 40b8 	ldr.w	r4, [r0, #184]	; 0xb8
    1732:	440b      	add	r3, r1
    1734:	1a9b      	subs	r3, r3, r2
    1736:	f8c0 30bc 	str.w	r3, [r0, #188]	; 0xbc
    173a:	e7b9      	b.n	16b0 <NeoGroup::updateOnRatio(int)+0x24>
    173c:	200045ec 	.word	0x200045ec
    1740:	00010d8c 	.word	0x00010d8c
    1744:	00010cf4 	.word	0x00010cf4
    1748:	00010da8 	.word	0x00010da8
    174c:	00010cc0 	.word	0x00010cc0

00001750 <NeoGroup::updateColorLog(unsigned char, unsigned char, unsigned char)>:

void NeoGroup::colorWipe(uint8_t red, uint8_t green, uint8_t blue) {
  colorWipe(red, green, blue, brightness_scaler);
}

void NeoGroup::updateColorLog(uint8_t red, uint8_t green, uint8_t blue) {
    1750:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1754:	4680      	mov	r8, r0
  rgb[1] = green;
  rgb[2] = blue;
  red_tot += red;
  green_tot += green;
  blue_tot += blue;
  red_readings++;
    1756:	6f06      	ldr	r6, [r0, #112]	; 0x70
  green_readings++;
  blue_readings++;
    1758:	6f87      	ldr	r7, [r0, #120]	; 0x78
void NeoGroup::updateColorLog(uint8_t red, uint8_t green, uint8_t blue) {
  rgb[0] = red;
  rgb[1] = green;
  rgb[2] = blue;
  red_tot += red;
  green_tot += green;
    175a:	f8d8 5068 	ldr.w	r5, [r8, #104]	; 0x68

void NeoGroup::updateColorLog(uint8_t red, uint8_t green, uint8_t blue) {
  rgb[0] = red;
  rgb[1] = green;
  rgb[2] = blue;
  red_tot += red;
    175e:	6e40      	ldr	r0, [r0, #100]	; 0x64
  green_tot += green;
  blue_tot += blue;
    1760:	f8d8 406c 	ldr.w	r4, [r8, #108]	; 0x6c
  colorWipe(red, green, blue, brightness_scaler);
}

void NeoGroup::updateColorLog(uint8_t red, uint8_t green, uint8_t blue) {
  rgb[0] = red;
  rgb[1] = green;
    1764:	f888 2049 	strb.w	r2, [r8, #73]	; 0x49

void NeoGroup::colorWipe(uint8_t red, uint8_t green, uint8_t blue) {
  colorWipe(red, green, blue, brightness_scaler);
}

void NeoGroup::updateColorLog(uint8_t red, uint8_t green, uint8_t blue) {
    1768:	469b      	mov	fp, r3
  rgb[2] = blue;
  red_tot += red;
  green_tot += green;
  blue_tot += blue;
  red_readings++;
  green_readings++;
    176a:	f8d8 3074 	ldr.w	r3, [r8, #116]	; 0x74
void NeoGroup::colorWipe(uint8_t red, uint8_t green, uint8_t blue) {
  colorWipe(red, green, blue, brightness_scaler);
}

void NeoGroup::updateColorLog(uint8_t red, uint8_t green, uint8_t blue) {
  rgb[0] = red;
    176e:	f888 1048 	strb.w	r1, [r8, #72]	; 0x48

void NeoGroup::colorWipe(uint8_t red, uint8_t green, uint8_t blue) {
  colorWipe(red, green, blue, brightness_scaler);
}

void NeoGroup::updateColorLog(uint8_t red, uint8_t green, uint8_t blue) {
    1772:	b085      	sub	sp, #20
  rgb[0] = red;
  rgb[1] = green;
  rgb[2] = blue;
  red_tot += red;
  green_tot += green;
    1774:	4415      	add	r5, r2
  blue_tot += blue;
  red_readings++;
  green_readings++;
    1776:	3301      	adds	r3, #1
  rgb[1] = green;
  rgb[2] = blue;
  red_tot += red;
  green_tot += green;
  blue_tot += blue;
  red_readings++;
    1778:	3601      	adds	r6, #1
  rgb[0] = red;
  rgb[1] = green;
  rgb[2] = blue;
  red_tot += red;
  green_tot += green;
  blue_tot += blue;
    177a:	445c      	add	r4, fp
  red_readings++;
  green_readings++;
  blue_readings++;
    177c:	3701      	adds	r7, #1

void NeoGroup::updateColorLog(uint8_t red, uint8_t green, uint8_t blue) {
  rgb[0] = red;
  rgb[1] = green;
  rgb[2] = blue;
  red_tot += red;
    177e:	4408      	add	r0, r1
  green_tot += green;
  blue_tot += blue;
  red_readings++;
  green_readings++;
    1780:	f8c8 3074 	str.w	r3, [r8, #116]	; 0x74
  rgb[1] = green;
  rgb[2] = blue;
  red_tot += red;
  green_tot += green;
  blue_tot += blue;
  red_readings++;
    1784:	f8c8 6070 	str.w	r6, [r8, #112]	; 0x70
void NeoGroup::updateColorLog(uint8_t red, uint8_t green, uint8_t blue) {
  rgb[0] = red;
  rgb[1] = green;
  rgb[2] = blue;
  red_tot += red;
  green_tot += green;
    1788:	f8c8 5068 	str.w	r5, [r8, #104]	; 0x68
  blue_tot += blue;
    178c:	f8c8 406c 	str.w	r4, [r8, #108]	; 0x6c
}

void NeoGroup::updateColorLog(uint8_t red, uint8_t green, uint8_t blue) {
  rgb[0] = red;
  rgb[1] = green;
  rgb[2] = blue;
    1790:	f888 b04a 	strb.w	fp, [r8, #74]	; 0x4a
  red_tot += red;
  green_tot += green;
  blue_tot += blue;
  red_readings++;
  green_readings++;
  blue_readings++;
    1794:	f8c8 7078 	str.w	r7, [r8, #120]	; 0x78

void NeoGroup::updateColorLog(uint8_t red, uint8_t green, uint8_t blue) {
  rgb[0] = red;
  rgb[1] = green;
  rgb[2] = blue;
  red_tot += red;
    1798:	f8c8 0064 	str.w	r0, [r8, #100]	; 0x64

void NeoGroup::colorWipe(uint8_t red, uint8_t green, uint8_t blue) {
  colorWipe(red, green, blue, brightness_scaler);
}

void NeoGroup::updateColorLog(uint8_t red, uint8_t green, uint8_t blue) {
    179c:	4692      	mov	sl, r2
  rgb[2] = blue;
  red_tot += red;
  green_tot += green;
  blue_tot += blue;
  red_readings++;
  green_readings++;
    179e:	9301      	str	r3, [sp, #4]

void NeoGroup::colorWipe(uint8_t red, uint8_t green, uint8_t blue) {
  colorWipe(red, green, blue, brightness_scaler);
}

void NeoGroup::updateColorLog(uint8_t red, uint8_t green, uint8_t blue) {
    17a0:	4689      	mov	r9, r1
  green_tot += green;
  blue_tot += blue;
  red_readings++;
  green_readings++;
  blue_readings++;
  red_avg = red_tot / (double)red_readings;
    17a2:	f00b f90f 	bl	c9c4 <__aeabi_ui2d>
    17a6:	e9cd 0102 	strd	r0, r1, [sp, #8]
    17aa:	4630      	mov	r0, r6
    17ac:	f00b f90a 	bl	c9c4 <__aeabi_ui2d>
    17b0:	4602      	mov	r2, r0
    17b2:	460b      	mov	r3, r1
    17b4:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    17b8:	f00b faa4 	bl	cd04 <__aeabi_ddiv>
    17bc:	e9c8 0100 	strd	r0, r1, [r8]
  green_avg = green_tot / (double)green_readings;
    17c0:	4628      	mov	r0, r5
    17c2:	f00b f8ff 	bl	c9c4 <__aeabi_ui2d>
    17c6:	4605      	mov	r5, r0
    17c8:	9801      	ldr	r0, [sp, #4]
    17ca:	460e      	mov	r6, r1
    17cc:	f00b f8fa 	bl	c9c4 <__aeabi_ui2d>
    17d0:	4602      	mov	r2, r0
    17d2:	460b      	mov	r3, r1
    17d4:	4628      	mov	r0, r5
    17d6:	4631      	mov	r1, r6
    17d8:	f00b fa94 	bl	cd04 <__aeabi_ddiv>
    17dc:	e9c8 0102 	strd	r0, r1, [r8, #8]
  blue_avg = blue_tot / (double)blue_readings;
    17e0:	4620      	mov	r0, r4
    17e2:	f00b f8ef 	bl	c9c4 <__aeabi_ui2d>
    17e6:	4604      	mov	r4, r0
    17e8:	4638      	mov	r0, r7
    17ea:	460d      	mov	r5, r1
    17ec:	f00b f8ea 	bl	c9c4 <__aeabi_ui2d>
    17f0:	460b      	mov	r3, r1
    17f2:	4602      	mov	r2, r0
    17f4:	4629      	mov	r1, r5
    17f6:	4620      	mov	r0, r4
    17f8:	f00b fa84 	bl	cd04 <__aeabi_ddiv>
  if (update_on_off_ratios) {
    17fc:	f898 307c 	ldrb.w	r3, [r8, #124]	; 0x7c
  red_readings++;
  green_readings++;
  blue_readings++;
  red_avg = red_tot / (double)red_readings;
  green_avg = green_tot / (double)green_readings;
  blue_avg = blue_tot / (double)blue_readings;
    1800:	e9c8 0104 	strd	r0, r1, [r8, #16]
  if (update_on_off_ratios) {
    1804:	b913      	cbnz	r3, 180c <NeoGroup::updateColorLog(unsigned char, unsigned char, unsigned char)+0xbc>
    updateOnRatio(red + green + blue);
  }
}
    1806:	b005      	add	sp, #20
    1808:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  blue_readings++;
  red_avg = red_tot / (double)red_readings;
  green_avg = green_tot / (double)green_readings;
  blue_avg = blue_tot / (double)blue_readings;
  if (update_on_off_ratios) {
    updateOnRatio(red + green + blue);
    180c:	eb09 010a 	add.w	r1, r9, sl
    1810:	4459      	add	r1, fp
    1812:	4640      	mov	r0, r8
  }
}
    1814:	b005      	add	sp, #20
    1816:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  blue_readings++;
  red_avg = red_tot / (double)red_readings;
  green_avg = green_tot / (double)green_readings;
  blue_avg = blue_tot / (double)blue_readings;
  if (update_on_off_ratios) {
    updateOnRatio(red + green + blue);
    181a:	f7ff bf37 	b.w	168c <NeoGroup::updateOnRatio(int)>
    181e:	bf00      	nop

00001820 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)>:
  }
}

void NeoGroup::colorWipe(uint8_t red, uint8_t green, uint8_t blue, double bs) {
    1820:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  // TODO this logic is broken...
  if (extreme_lux_shdn == true) {
    1824:	f890 404b 	ldrb.w	r4, [r0, #75]	; 0x4b
  if (update_on_off_ratios) {
    updateOnRatio(red + green + blue);
  }
}

void NeoGroup::colorWipe(uint8_t red, uint8_t green, uint8_t blue, double bs) {
    1828:	b08b      	sub	sp, #44	; 0x2c
    182a:	f88d 100f 	strb.w	r1, [sp, #15]
    182e:	f88d 200e 	strb.w	r2, [sp, #14]
    1832:	f88d 300d 	strb.w	r3, [sp, #13]
  // TODO this logic is broken...
  if (extreme_lux_shdn == true) {
    1836:	2c00      	cmp	r4, #0
    1838:	f040 80a2 	bne.w	1980 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0x160>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    183c:	4e6d      	ldr	r6, [pc, #436]	; (19f4 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0x1d4>)
    dprintln(PRINT_COLOR_WIPE_DEBUG, " colorWipe returning due extreme lux conditions");
    return;
  }
  if (shdn_timer < shdn_len) {
    183e:	f8d0 10a0 	ldr.w	r1, [r0, #160]	; 0xa0
    1842:	6833      	ldr	r3, [r6, #0]
    1844:	9305      	str	r3, [sp, #20]
	return ret;
    1846:	9b05      	ldr	r3, [sp, #20]
    1848:	f8d0 20a4 	ldr.w	r2, [r0, #164]	; 0xa4
    184c:	1a5b      	subs	r3, r3, r1
    184e:	429a      	cmp	r2, r3
    1850:	4605      	mov	r5, r0
    1852:	f200 80bc 	bhi.w	19ce <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0x1ae>
    dprint(PRINT_COLOR_WIPE_DEBUG, " colorWipe returning due to shdn_timer : "); dprintln(PRINT_COLOR_WIPE_DEBUG, shdn_timer);
    updateColorLog(0, 0, 0);
    return;
  }

  if (flash_on == true) {
    1856:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
      // if the flash is on then add the flash colors to the color wipe colors
      if (FLASH_DOMINATES == false) {
          dprintln(PRINT_COLOR_WIPE_DEBUG, " Flash blocked colorWipe");
    185a:	ac06      	add	r4, sp, #24
    dprint(PRINT_COLOR_WIPE_DEBUG, " colorWipe returning due to shdn_timer : "); dprintln(PRINT_COLOR_WIPE_DEBUG, shdn_timer);
    updateColorLog(0, 0, 0);
    return;
  }

  if (flash_on == true) {
    185c:	2b00      	cmp	r3, #0
    185e:	f040 8099 	bne.w	1994 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0x174>
          green += flash_green;
          blue += flash_blue;
      }
  }

  int colors = packColors(red, green, blue, bs);
    1862:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
    1866:	f10d 010e 	add.w	r1, sp, #14
    186a:	e9cd 2300 	strd	r2, r3, [sp]
    186e:	f10d 000f 	add.w	r0, sp, #15
    1872:	f10d 020d 	add.w	r2, sp, #13
    1876:	f7ff fe5f 	bl	1538 <packColors(unsigned char&, unsigned char&, unsigned char&, double)>
  updateColorLog(red, green, blue);
    187a:	f89d 300d 	ldrb.w	r3, [sp, #13]
    187e:	f89d 200e 	ldrb.w	r2, [sp, #14]
    1882:	f89d 100f 	ldrb.w	r1, [sp, #15]
          green += flash_green;
          blue += flash_blue;
      }
  }

  int colors = packColors(red, green, blue, bs);
    1886:	4607      	mov	r7, r0
  updateColorLog(red, green, blue);
    1888:	4628      	mov	r0, r5
    188a:	f7ff ff61 	bl	1750 <NeoGroup::updateColorLog(unsigned char, unsigned char, unsigned char)>

  dprint(PRINT_COLOR_WIPE_DEBUG, id);
    188e:	f105 0180 	add.w	r1, r5, #128	; 0x80
    1892:	4620      	mov	r0, r4
    1894:	f007 fe74 	bl	9580 <String::String(String const&)>
    1898:	4620      	mov	r0, r4
    189a:	f007 fe1d 	bl	94d8 <String::~String()>
  dprint(PRINT_COLOR_WIPE_DEBUG, " Starting colorWipe in NeoGroup - ");
    189e:	4956      	ldr	r1, [pc, #344]	; (19f8 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0x1d8>)
    18a0:	4620      	mov	r0, r4
    18a2:	f007 fe59 	bl	9558 <String::String(char const*)>
    18a6:	4620      	mov	r0, r4
    18a8:	f007 fe16 	bl	94d8 <String::~String()>
  dprint(PRINT_COLOR_WIPE_DEBUG, " num_pixels: ");
    18ac:	4953      	ldr	r1, [pc, #332]	; (19fc <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0x1dc>)
    18ae:	4620      	mov	r0, r4
    18b0:	f007 fe52 	bl	9558 <String::String(char const*)>
    18b4:	4620      	mov	r0, r4
    18b6:	f007 fe0f 	bl	94d8 <String::~String()>
  dprint(PRINT_COLOR_WIPE_DEBUG, num_pixels); 
  dprint(PRINT_COLOR_WIPE_DEBUG, " - ");
    18ba:	4951      	ldr	r1, [pc, #324]	; (1a00 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0x1e0>)
    18bc:	4620      	mov	r0, r4
    18be:	f007 fe4b 	bl	9558 <String::String(char const*)>
    18c2:	4620      	mov	r0, r4
    18c4:	f007 fe08 	bl	94d8 <String::~String()>

  for (int i = 0; i < num_pixels; i++) {
    18c8:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
    18cc:	2b00      	cmp	r3, #0
    18ce:	dd32      	ble.n	1936 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0x116>
	bool begin();
	void setPixel(uint32_t num, int color) {
		if (num >= numled) return;
		num *= 3;
		drawBuffer[num+0] = color & 255;
		drawBuffer[num+1] = (color >> 8) & 255;
    18d0:	f3c7 2907 	ubfx	r9, r7, #8, #8
		drawBuffer[num+2] = (color >> 16) & 255;
    18d4:	f3c7 4807 	ubfx	r8, r7, #16, #8
    18d8:	2600      	movs	r6, #0
    18da:	e00f      	b.n	18fc <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0xdc>
      leds->setPixel(idx_start + i, colors);
      dprint(PRINT_COLOR_WIPE_DEBUG, idx_start+i);
      dprint(PRINT_COLOR_WIPE_DEBUG, ": ");
    18dc:	f007 fe3c 	bl	9558 <String::String(char const*)>
    18e0:	4620      	mov	r0, r4
    18e2:	f007 fdf9 	bl	94d8 <String::~String()>
      dprint(PRINT_COLOR_WIPE_DEBUG, colors); 
      dprint(PRINT_COLOR_WIPE_DEBUG, "\t");
    18e6:	4947      	ldr	r1, [pc, #284]	; (1a04 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0x1e4>)
    18e8:	4620      	mov	r0, r4
    18ea:	f007 fe35 	bl	9558 <String::String(char const*)>
    18ee:	4620      	mov	r0, r4
    18f0:	f007 fdf2 	bl	94d8 <String::~String()>
  dprint(PRINT_COLOR_WIPE_DEBUG, " Starting colorWipe in NeoGroup - ");
  dprint(PRINT_COLOR_WIPE_DEBUG, " num_pixels: ");
  dprint(PRINT_COLOR_WIPE_DEBUG, num_pixels); 
  dprint(PRINT_COLOR_WIPE_DEBUG, " - ");

  for (int i = 0; i < num_pixels; i++) {
    18f4:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
    18f8:	42b3      	cmp	r3, r6
    18fa:	dd1c      	ble.n	1936 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0x116>
      leds->setPixel(idx_start + i, colors);
    18fc:	f8d5 e090 	ldr.w	lr, [r5, #144]	; 0x90
    1900:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
		numled(num), pin(pin), config(cfg),
		frameBuffer((uint8_t *)fb), drawBuffer((uint8_t *)db) {
	}
	bool begin();
	void setPixel(uint32_t num, int color) {
		if (num >= numled) return;
    1904:	f8be 2000 	ldrh.w	r2, [lr]
      dprint(PRINT_COLOR_WIPE_DEBUG, idx_start+i);
      dprint(PRINT_COLOR_WIPE_DEBUG, ": ");
    1908:	493f      	ldr	r1, [pc, #252]	; (1a08 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0x1e8>)
  dprint(PRINT_COLOR_WIPE_DEBUG, " num_pixels: ");
  dprint(PRINT_COLOR_WIPE_DEBUG, num_pixels); 
  dprint(PRINT_COLOR_WIPE_DEBUG, " - ");

  for (int i = 0; i < num_pixels; i++) {
      leds->setPixel(idx_start + i, colors);
    190a:	4433      	add	r3, r6
    190c:	4293      	cmp	r3, r2
      dprint(PRINT_COLOR_WIPE_DEBUG, idx_start+i);
      dprint(PRINT_COLOR_WIPE_DEBUG, ": ");
    190e:	4620      	mov	r0, r4
  dprint(PRINT_COLOR_WIPE_DEBUG, " Starting colorWipe in NeoGroup - ");
  dprint(PRINT_COLOR_WIPE_DEBUG, " num_pixels: ");
  dprint(PRINT_COLOR_WIPE_DEBUG, num_pixels); 
  dprint(PRINT_COLOR_WIPE_DEBUG, " - ");

  for (int i = 0; i < num_pixels; i++) {
    1910:	f106 0601 	add.w	r6, r6, #1
    1914:	d2e2      	bcs.n	18dc <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0xbc>
		num *= 3;
		drawBuffer[num+0] = color & 255;
    1916:	f8de 2008 	ldr.w	r2, [lr, #8]
		frameBuffer((uint8_t *)fb), drawBuffer((uint8_t *)db) {
	}
	bool begin();
	void setPixel(uint32_t num, int color) {
		if (num >= numled) return;
		num *= 3;
    191a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
		drawBuffer[num+0] = color & 255;
    191e:	54d7      	strb	r7, [r2, r3]
		drawBuffer[num+1] = (color >> 8) & 255;
    1920:	f8de 2008 	ldr.w	r2, [lr, #8]
    1924:	441a      	add	r2, r3
    1926:	f882 9001 	strb.w	r9, [r2, #1]
		drawBuffer[num+2] = (color >> 16) & 255;
    192a:	f8de 2008 	ldr.w	r2, [lr, #8]
    192e:	4413      	add	r3, r2
    1930:	f883 8002 	strb.w	r8, [r3, #2]
    1934:	e7d2      	b.n	18dc <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0xbc>
      dprint(PRINT_COLOR_WIPE_DEBUG, idx_start+i);
      dprint(PRINT_COLOR_WIPE_DEBUG, ": ");
      dprint(PRINT_COLOR_WIPE_DEBUG, colors); 
      dprint(PRINT_COLOR_WIPE_DEBUG, "\t");
  }
  leds->show();
    1936:	f8d5 0090 	ldr.w	r0, [r5, #144]	; 0x90
    193a:	f006 f805 	bl	7948 <WS2812Serial::show()>
  dprint(PRINT_COLOR_WIPE_DEBUG, " finished updating the neopixels");
    193e:	4933      	ldr	r1, [pc, #204]	; (1a0c <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0x1ec>)
    1940:	4620      	mov	r0, r4
    1942:	f007 fe09 	bl	9558 <String::String(char const*)>
    1946:	4620      	mov	r0, r4
    1948:	f007 fdc6 	bl	94d8 <String::~String()>

  // if the LEDs are on set "led_on" to true, otherwise turn "led_on" to false
  // also reset led_off_len if the leds  were just turned off
  if (colors == 0) {
    194c:	b167      	cbz	r7, 1968 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0x148>
    leds_on = false;
    dprint(PRINT_COLOR_WIPE_DEBUG, " setting leds_on to false");
  } else {
    leds_on = true;
    194e:	2301      	movs	r3, #1
    1950:	f885 30a8 	strb.w	r3, [r5, #168]	; 0xa8
    dprint(PRINT_COLOR_WIPE_DEBUG, " setting leds_on to true");
    1954:	492e      	ldr	r1, [pc, #184]	; (1a10 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0x1f0>)
    1956:	4620      	mov	r0, r4
    1958:	f007 fdfe 	bl	9558 <String::String(char const*)>
    195c:	4620      	mov	r0, r4
    195e:	f007 fdbb 	bl	94d8 <String::~String()>
  }
}
    1962:	b00b      	add	sp, #44	; 0x2c
    1964:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  // if the LEDs are on set "led_on" to true, otherwise turn "led_on" to false
  // also reset led_off_len if the leds  were just turned off
  if (colors == 0) {
    leds_on = false;
    dprint(PRINT_COLOR_WIPE_DEBUG, " setting leds_on to false");
    1968:	492a      	ldr	r1, [pc, #168]	; (1a14 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0x1f4>)
  dprint(PRINT_COLOR_WIPE_DEBUG, " finished updating the neopixels");

  // if the LEDs are on set "led_on" to true, otherwise turn "led_on" to false
  // also reset led_off_len if the leds  were just turned off
  if (colors == 0) {
    leds_on = false;
    196a:	f885 70a8 	strb.w	r7, [r5, #168]	; 0xa8
    dprint(PRINT_COLOR_WIPE_DEBUG, " setting leds_on to false");
    196e:	4620      	mov	r0, r4
    1970:	f007 fdf2 	bl	9558 <String::String(char const*)>
    1974:	4620      	mov	r0, r4
    1976:	f007 fdaf 	bl	94d8 <String::~String()>
  } else {
    leds_on = true;
    dprint(PRINT_COLOR_WIPE_DEBUG, " setting leds_on to true");
  }
}
    197a:	b00b      	add	sp, #44	; 0x2c
    197c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
}

void NeoGroup::colorWipe(uint8_t red, uint8_t green, uint8_t blue, double bs) {
  // TODO this logic is broken...
  if (extreme_lux_shdn == true) {
    dprintln(PRINT_COLOR_WIPE_DEBUG, " colorWipe returning due extreme lux conditions");
    1980:	4925      	ldr	r1, [pc, #148]	; (1a18 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0x1f8>)
    1982:	a806      	add	r0, sp, #24
    1984:	f007 fde8 	bl	9558 <String::String(char const*)>
    1988:	a806      	add	r0, sp, #24
    198a:	f007 fda5 	bl	94d8 <String::~String()>
    dprint(PRINT_COLOR_WIPE_DEBUG, " setting leds_on to false");
  } else {
    leds_on = true;
    dprint(PRINT_COLOR_WIPE_DEBUG, " setting leds_on to true");
  }
}
    198e:	b00b      	add	sp, #44	; 0x2c
    1990:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  }

  if (flash_on == true) {
      // if the flash is on then add the flash colors to the color wipe colors
      if (FLASH_DOMINATES == false) {
          dprintln(PRINT_COLOR_WIPE_DEBUG, " Flash blocked colorWipe");
    1994:	4921      	ldr	r1, [pc, #132]	; (1a1c <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0x1fc>)
    1996:	4620      	mov	r0, r4
    1998:	f007 fdde 	bl	9558 <String::String(char const*)>
    199c:	4620      	mov	r0, r4
    199e:	f007 fd9b 	bl	94d8 <String::~String()>
          red += flash_red;
    19a2:	f89d 100f 	ldrb.w	r1, [sp, #15]
          green += flash_green;
    19a6:	f89d 200e 	ldrb.w	r2, [sp, #14]
          blue += flash_blue;
    19aa:	f89d 300d 	ldrb.w	r3, [sp, #13]

  if (flash_on == true) {
      // if the flash is on then add the flash colors to the color wipe colors
      if (FLASH_DOMINATES == false) {
          dprintln(PRINT_COLOR_WIPE_DEBUG, " Flash blocked colorWipe");
          red += flash_red;
    19ae:	f895 704c 	ldrb.w	r7, [r5, #76]	; 0x4c
          green += flash_green;
    19b2:	f895 604d 	ldrb.w	r6, [r5, #77]	; 0x4d
          blue += flash_blue;
    19b6:	f895 004e 	ldrb.w	r0, [r5, #78]	; 0x4e

  if (flash_on == true) {
      // if the flash is on then add the flash colors to the color wipe colors
      if (FLASH_DOMINATES == false) {
          dprintln(PRINT_COLOR_WIPE_DEBUG, " Flash blocked colorWipe");
          red += flash_red;
    19ba:	4439      	add	r1, r7
          green += flash_green;
    19bc:	4432      	add	r2, r6
          blue += flash_blue;
    19be:	4403      	add	r3, r0

  if (flash_on == true) {
      // if the flash is on then add the flash colors to the color wipe colors
      if (FLASH_DOMINATES == false) {
          dprintln(PRINT_COLOR_WIPE_DEBUG, " Flash blocked colorWipe");
          red += flash_red;
    19c0:	f88d 100f 	strb.w	r1, [sp, #15]
          green += flash_green;
    19c4:	f88d 200e 	strb.w	r2, [sp, #14]
          blue += flash_blue;
    19c8:	f88d 300d 	strb.w	r3, [sp, #13]
    19cc:	e749      	b.n	1862 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0x42>
    dprintln(PRINT_COLOR_WIPE_DEBUG, " colorWipe returning due extreme lux conditions");
    return;
  }
  if (shdn_timer < shdn_len) {
    // if the LEDs are in shutdown mode than simply exit without changing the LEDs
    dprint(PRINT_COLOR_WIPE_DEBUG, " colorWipe returning due to shdn_timer : "); dprintln(PRINT_COLOR_WIPE_DEBUG, shdn_timer);
    19ce:	4914      	ldr	r1, [pc, #80]	; (1a20 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)+0x200>)
    19d0:	a806      	add	r0, sp, #24
    19d2:	f007 fdc1 	bl	9558 <String::String(char const*)>
    19d6:	a806      	add	r0, sp, #24
    19d8:	f007 fd7e 	bl	94d8 <String::~String()>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    19dc:	6833      	ldr	r3, [r6, #0]
    19de:	9306      	str	r3, [sp, #24]
    updateColorLog(0, 0, 0);
    19e0:	4622      	mov	r2, r4
    19e2:	4623      	mov	r3, r4
    19e4:	4621      	mov	r1, r4
    19e6:	4628      	mov	r0, r5
	return ret;
    19e8:	9c06      	ldr	r4, [sp, #24]
    19ea:	f7ff feb1 	bl	1750 <NeoGroup::updateColorLog(unsigned char, unsigned char, unsigned char)>
    dprint(PRINT_COLOR_WIPE_DEBUG, " setting leds_on to false");
  } else {
    leds_on = true;
    dprint(PRINT_COLOR_WIPE_DEBUG, " setting leds_on to true");
  }
}
    19ee:	b00b      	add	sp, #44	; 0x2c
    19f0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    19f4:	200045ec 	.word	0x200045ec
    19f8:	00010e24 	.word	0x00010e24
    19fc:	00010e48 	.word	0x00010e48
    1a00:	00010e58 	.word	0x00010e58
    1a04:	00010cc0 	.word	0x00010cc0
    1a08:	00011880 	.word	0x00011880
    1a0c:	00010e5c 	.word	0x00010e5c
    1a10:	00010e9c 	.word	0x00010e9c
    1a14:	00010e80 	.word	0x00010e80
    1a18:	00010dac 	.word	0x00010dac
    1a1c:	00010e08 	.word	0x00010e08
    1a20:	00010ddc 	.word	0x00010ddc

00001a24 <NeoGroup::flashOff() [clone .part.21]>:
    leds_on = true;
  }
}

////////////// General Purpose Helper Functions /////////////////////////
void NeoGroup::flashOff() {
    1a24:	b570      	push	{r4, r5, r6, lr}
    1a26:	b086      	sub	sp, #24
    1a28:	4604      	mov	r4, r0
  // if the flash is allowed to be turned off
  if (remaining_flash_delay <= 0) {
    dprint(PRINT_CLICK_DEBUG, id);
    1a2a:	f100 0180 	add.w	r1, r0, #128	; 0x80
    1a2e:	a802      	add	r0, sp, #8
    1a30:	f007 fda6 	bl	9580 <String::String(String const&)>
    1a34:	a802      	add	r0, sp, #8
    1a36:	f007 fd4f 	bl	94d8 <String::~String()>
    dprint(PRINT_CLICK_DEBUG, " FlashOff : ");
    1a3a:	490e      	ldr	r1, [pc, #56]	; (1a74 <NeoGroup::flashOff() [clone .part.21]+0x50>)
    1a3c:	a802      	add	r0, sp, #8
    1a3e:	f007 fd8b 	bl	9558 <String::String(char const*)>
    1a42:	a802      	add	r0, sp, #8
    1a44:	f007 fd48 	bl	94d8 <String::~String()>
  HsbToRgb(h, s, b);
  colorWipe(rgb[0], rgb[1], rgb[2]);
}

void NeoGroup::colorWipe(uint8_t red, uint8_t green, uint8_t blue) {
  colorWipe(red, green, blue, brightness_scaler);
    1a48:	e9d4 2330 	ldrd	r2, r3, [r4, #192]	; 0xc0
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1a4c:	490a      	ldr	r1, [pc, #40]	; (1a78 <NeoGroup::flashOff() [clone .part.21]+0x54>)
  // if the flash is allowed to be turned off
  if (remaining_flash_delay <= 0) {
    dprint(PRINT_CLICK_DEBUG, id);
    dprint(PRINT_CLICK_DEBUG, " FlashOff : ");
    dprintln(PRINT_CLICK_DEBUG, last_flash);
    flash_on = false;
    1a4e:	2500      	movs	r5, #0
    1a50:	6809      	ldr	r1, [r1, #0]
    1a52:	9102      	str	r1, [sp, #8]
  HsbToRgb(h, s, b);
  colorWipe(rgb[0], rgb[1], rgb[2]);
}

void NeoGroup::colorWipe(uint8_t red, uint8_t green, uint8_t blue) {
  colorWipe(red, green, blue, brightness_scaler);
    1a54:	e9cd 2300 	strd	r2, r3, [sp]
    1a58:	4629      	mov	r1, r5
  // if the flash is allowed to be turned off
  if (remaining_flash_delay <= 0) {
    dprint(PRINT_CLICK_DEBUG, id);
    dprint(PRINT_CLICK_DEBUG, " FlashOff : ");
    dprintln(PRINT_CLICK_DEBUG, last_flash);
    flash_on = false;
    1a5a:	f884 5054 	strb.w	r5, [r4, #84]	; 0x54
    leds_on = false;
    1a5e:	f884 50a8 	strb.w	r5, [r4, #168]	; 0xa8
  HsbToRgb(h, s, b);
  colorWipe(rgb[0], rgb[1], rgb[2]);
}

void NeoGroup::colorWipe(uint8_t red, uint8_t green, uint8_t blue) {
  colorWipe(red, green, blue, brightness_scaler);
    1a62:	462b      	mov	r3, r5
    1a64:	462a      	mov	r2, r5
    1a66:	4620      	mov	r0, r4
	return ret;
    1a68:	9e02      	ldr	r6, [sp, #8]
    1a6a:	f7ff fed9 	bl	1820 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)>
    dprint(PRINT_CLICK_DEBUG, " FlashOff : ");
    dprintln(PRINT_CLICK_DEBUG, last_flash);
    flash_on = false;
    leds_on = false;
    colorWipe(0, 0, 0);
    remaining_flash_delay = 0;
    1a6e:	6525      	str	r5, [r4, #80]	; 0x50
    // last_flash = 0;
  }
}
    1a70:	b006      	add	sp, #24
    1a72:	bd70      	pop	{r4, r5, r6, pc}
    1a74:	00010eb8 	.word	0x00010eb8
    1a78:	200045ec 	.word	0x200045ec

00001a7c <NeoGroup::flashOn(unsigned char, unsigned char, unsigned char)>:

bool NeoGroup::flashOn(uint8_t red, uint8_t green, uint8_t blue) {
    1a7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1a80:	4d4c      	ldr	r5, [pc, #304]	; (1bb4 <NeoGroup::flashOn(unsigned char, unsigned char, unsigned char)+0x138>)
    1a82:	b08a      	sub	sp, #40	; 0x28
    1a84:	4604      	mov	r4, r0
    1a86:	6828      	ldr	r0, [r5, #0]
    1a88:	9002      	str	r0, [sp, #8]
	return ret;
    1a8a:	9802      	ldr	r0, [sp, #8]
  // if it has been uint32_t enough since the last flash occured
  if (last_flash > FLASH_DEBOUNCE_TIME) {
    1a8c:	f8d4 60ac 	ldr.w	r6, [r4, #172]	; 0xac
    1a90:	1b80      	subs	r0, r0, r6
    1a92:	2850      	cmp	r0, #80	; 0x50
    1a94:	d924      	bls.n	1ae0 <NeoGroup::flashOn(unsigned char, unsigned char, unsigned char)+0x64>
    1a96:	4698      	mov	r8, r3
    if (red + green + blue > 0 && shdn_timer > shdn_len) {
    1a98:	188b      	adds	r3, r1, r2
    1a9a:	eb13 0f08 	cmn.w	r3, r8
    1a9e:	460e      	mov	r6, r1
    1aa0:	4617      	mov	r7, r2
    1aa2:	d019      	beq.n	1ad8 <NeoGroup::flashOn(unsigned char, unsigned char, unsigned char)+0x5c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1aa4:	682b      	ldr	r3, [r5, #0]
    1aa6:	9303      	str	r3, [sp, #12]
	return ret;
    1aa8:	9b03      	ldr	r3, [sp, #12]
    1aaa:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
    1aae:	f8d4 20a4 	ldr.w	r2, [r4, #164]	; 0xa4
    1ab2:	1a5b      	subs	r3, r3, r1
    1ab4:	429a      	cmp	r2, r3
    1ab6:	d20f      	bcs.n	1ad8 <NeoGroup::flashOn(unsigned char, unsigned char, unsigned char)+0x5c>
      // if a flash is not currently on
      if ( (flash_on == false) || (leds_on == false) ) {
    1ab8:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
    1abc:	b1f3      	cbz	r3, 1afc <NeoGroup::flashOn(unsigned char, unsigned char, unsigned char)+0x80>
    1abe:	f894 00a8 	ldrb.w	r0, [r4, #168]	; 0xa8
    1ac2:	b1d8      	cbz	r0, 1afc <NeoGroup::flashOn(unsigned char, unsigned char, unsigned char)+0x80>
  dprint(PRINT_LED_ON_RATIO_DEBUG, on_ratio); dprint(PRINT_LED_ON_RATIO_DEBUG, "\t=\t"); dprint(PRINT_LED_ON_RATIO_DEBUG, on_time);
  dprint(PRINT_LED_ON_RATIO_DEBUG, "\t"); dprintln(PRINT_LED_ON_RATIO_DEBUG, off_time);
}

void NeoGroup::addToRemainingFlashDelay(long i) {
  remaining_flash_delay += i;
    1ac4:	6d23      	ldr	r3, [r4, #80]	; 0x50
  if (remaining_flash_delay > flash_max_time) {
    1ac6:	6de2      	ldr	r2, [r4, #92]	; 0x5c
  dprint(PRINT_LED_ON_RATIO_DEBUG, on_ratio); dprint(PRINT_LED_ON_RATIO_DEBUG, "\t=\t"); dprint(PRINT_LED_ON_RATIO_DEBUG, on_time);
  dprint(PRINT_LED_ON_RATIO_DEBUG, "\t"); dprintln(PRINT_LED_ON_RATIO_DEBUG, off_time);
}

void NeoGroup::addToRemainingFlashDelay(long i) {
  remaining_flash_delay += i;
    1ac8:	3301      	adds	r3, #1
  if (remaining_flash_delay > flash_max_time) {
    1aca:	4293      	cmp	r3, r2
  dprint(PRINT_LED_ON_RATIO_DEBUG, on_ratio); dprint(PRINT_LED_ON_RATIO_DEBUG, "\t=\t"); dprint(PRINT_LED_ON_RATIO_DEBUG, on_time);
  dprint(PRINT_LED_ON_RATIO_DEBUG, "\t"); dprintln(PRINT_LED_ON_RATIO_DEBUG, off_time);
}

void NeoGroup::addToRemainingFlashDelay(long i) {
  remaining_flash_delay += i;
    1acc:	6523      	str	r3, [r4, #80]	; 0x50
  if (remaining_flash_delay > flash_max_time) {
    1ace:	dd04      	ble.n	1ada <NeoGroup::flashOn(unsigned char, unsigned char, unsigned char)+0x5e>
    remaining_flash_delay = flash_max_time;
    1ad0:	6522      	str	r2, [r4, #80]	; 0x50
  } else {
    dprint(PRINT_CLICK_DEBUG, "Flash skipped due to FLASH_DEBOUNCE_TIME : ");
    dprintln(PRINT_CLICK_DEBUG, last_flash);
  }
  return false;
}
    1ad2:	b00a      	add	sp, #40	; 0x28
    1ad4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
  } else {
    dprint(PRINT_CLICK_DEBUG, "Flash skipped due to FLASH_DEBOUNCE_TIME : ");
    dprintln(PRINT_CLICK_DEBUG, last_flash);
  }
  return false;
    1ad8:	2000      	movs	r0, #0
}
    1ada:	b00a      	add	sp, #40	; 0x28
    1adc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        }
      }
      return true;
    }
  } else {
    dprint(PRINT_CLICK_DEBUG, "Flash skipped due to FLASH_DEBOUNCE_TIME : ");
    1ae0:	4935      	ldr	r1, [pc, #212]	; (1bb8 <NeoGroup::flashOn(unsigned char, unsigned char, unsigned char)+0x13c>)
    1ae2:	a806      	add	r0, sp, #24
    1ae4:	f007 fd38 	bl	9558 <String::String(char const*)>
    1ae8:	a806      	add	r0, sp, #24
    1aea:	f007 fcf5 	bl	94d8 <String::~String()>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1aee:	682b      	ldr	r3, [r5, #0]
    1af0:	9306      	str	r3, [sp, #24]
	return ret;
    1af2:	9b06      	ldr	r3, [sp, #24]
    dprintln(PRINT_CLICK_DEBUG, last_flash);
  }
  return false;
    1af4:	2000      	movs	r0, #0
}
    1af6:	b00a      	add	sp, #40	; 0x28
    1af8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  // if it has been uint32_t enough since the last flash occured
  if (last_flash > FLASH_DEBOUNCE_TIME) {
    if (red + green + blue > 0 && shdn_timer > shdn_len) {
      // if a flash is not currently on
      if ( (flash_on == false) || (leds_on == false) ) {
        remaining_flash_delay = flash_min_time;
    1afc:	6da3      	ldr	r3, [r4, #88]	; 0x58
    1afe:	6523      	str	r3, [r4, #80]	; 0x50
        colorWipe(red, green, blue, brightness_scaler * 1.5); // has to be on first as flash_on will block the colorWipe
    1b00:	e9d4 0130 	ldrd	r0, r1, [r4, #192]	; 0xc0
    1b04:	2200      	movs	r2, #0
    1b06:	4b2d      	ldr	r3, [pc, #180]	; (1bbc <NeoGroup::flashOn(unsigned char, unsigned char, unsigned char)+0x140>)
    1b08:	f00a ffd2 	bl	cab0 <__aeabi_dmul>
    1b0c:	4643      	mov	r3, r8
    1b0e:	e9cd 0100 	strd	r0, r1, [sp]
    1b12:	463a      	mov	r2, r7
    1b14:	4631      	mov	r1, r6
    1b16:	4620      	mov	r0, r4
    1b18:	f7ff fe82 	bl	1820 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1b1c:	682a      	ldr	r2, [r5, #0]
        flash_on = true; // turn the light on along with the flag
        leds_on = true;
        last_flash = 0; // reset the elapsed millis variable as the light was just turned on
        num_flashes = num_flashes  + 1;
    1b1e:	69a0      	ldr	r0, [r4, #24]
        total_flashes++;
    1b20:	69e3      	ldr	r3, [r4, #28]
    1b22:	9204      	str	r2, [sp, #16]
	return ret;
    1b24:	9904      	ldr	r1, [sp, #16]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1b26:	682a      	ldr	r2, [r5, #0]
    1b28:	f8c4 10ac 	str.w	r1, [r4, #172]	; 0xac
    if (red + green + blue > 0 && shdn_timer > shdn_len) {
      // if a flash is not currently on
      if ( (flash_on == false) || (leds_on == false) ) {
        remaining_flash_delay = flash_min_time;
        colorWipe(red, green, blue, brightness_scaler * 1.5); // has to be on first as flash_on will block the colorWipe
        flash_on = true; // turn the light on along with the flag
    1b2c:	2501      	movs	r5, #1
        leds_on = true;
        last_flash = 0; // reset the elapsed millis variable as the light was just turned on
        num_flashes = num_flashes  + 1;
        total_flashes++;
    1b2e:	3301      	adds	r3, #1
        remaining_flash_delay = flash_min_time;
        colorWipe(red, green, blue, brightness_scaler * 1.5); // has to be on first as flash_on will block the colorWipe
        flash_on = true; // turn the light on along with the flag
        leds_on = true;
        last_flash = 0; // reset the elapsed millis variable as the light was just turned on
        num_flashes = num_flashes  + 1;
    1b30:	3001      	adds	r0, #1
        total_flashes++;
    1b32:	61e3      	str	r3, [r4, #28]
        remaining_flash_delay = flash_min_time;
        colorWipe(red, green, blue, brightness_scaler * 1.5); // has to be on first as flash_on will block the colorWipe
        flash_on = true; // turn the light on along with the flag
        leds_on = true;
        last_flash = 0; // reset the elapsed millis variable as the light was just turned on
        num_flashes = num_flashes  + 1;
    1b34:	61a0      	str	r0, [r4, #24]
    if (red + green + blue > 0 && shdn_timer > shdn_len) {
      // if a flash is not currently on
      if ( (flash_on == false) || (leds_on == false) ) {
        remaining_flash_delay = flash_min_time;
        colorWipe(red, green, blue, brightness_scaler * 1.5); // has to be on first as flash_on will block the colorWipe
        flash_on = true; // turn the light on along with the flag
    1b36:	f884 5054 	strb.w	r5, [r4, #84]	; 0x54
        leds_on = true;
    1b3a:	f884 50a8 	strb.w	r5, [r4, #168]	; 0xa8
    1b3e:	9205      	str	r2, [sp, #20]
  num_flashes = 0;
  fpm_timer = 0;
}

double NeoGroup::getFPM() {
  fpm = (double)num_flashes / (double)fpm_timer * 1000 * 60;
    1b40:	f00a ff40 	bl	c9c4 <__aeabi_ui2d>
    1b44:	6e23      	ldr	r3, [r4, #96]	; 0x60
    1b46:	4606      	mov	r6, r0
	return ret;
    1b48:	9805      	ldr	r0, [sp, #20]
    1b4a:	1ac0      	subs	r0, r0, r3
    1b4c:	460f      	mov	r7, r1
    1b4e:	f00a ff39 	bl	c9c4 <__aeabi_ui2d>
    1b52:	4602      	mov	r2, r0
    1b54:	460b      	mov	r3, r1
    1b56:	4630      	mov	r0, r6
    1b58:	4639      	mov	r1, r7
    1b5a:	f00b f8d3 	bl	cd04 <__aeabi_ddiv>
    1b5e:	2200      	movs	r2, #0
    1b60:	4b17      	ldr	r3, [pc, #92]	; (1bc0 <NeoGroup::flashOn(unsigned char, unsigned char, unsigned char)+0x144>)
    1b62:	f00a ffa5 	bl	cab0 <__aeabi_dmul>
    1b66:	2200      	movs	r2, #0
    1b68:	4b16      	ldr	r3, [pc, #88]	; (1bc4 <NeoGroup::flashOn(unsigned char, unsigned char, unsigned char)+0x148>)
    1b6a:	f00a ffa1 	bl	cab0 <__aeabi_dmul>
    1b6e:	e9c4 0108 	strd	r0, r1, [r4, #32]
        leds_on = true;
        last_flash = 0; // reset the elapsed millis variable as the light was just turned on
        num_flashes = num_flashes  + 1;
        total_flashes++;
        getFPM();
        dprint(PRINT_CLICK_DEBUG, id);
    1b72:	f104 0180 	add.w	r1, r4, #128	; 0x80
    1b76:	a806      	add	r0, sp, #24
    1b78:	f007 fd02 	bl	9580 <String::String(String const&)>
    1b7c:	a806      	add	r0, sp, #24
    1b7e:	f007 fcab 	bl	94d8 <String::~String()>
        dprint(PRINT_CLICK_DEBUG, " FLASH ON #");
    1b82:	4911      	ldr	r1, [pc, #68]	; (1bc8 <NeoGroup::flashOn(unsigned char, unsigned char, unsigned char)+0x14c>)
    1b84:	a806      	add	r0, sp, #24
    1b86:	f007 fce7 	bl	9558 <String::String(char const*)>
    1b8a:	a806      	add	r0, sp, #24
    1b8c:	f007 fca4 	bl	94d8 <String::~String()>
        dprint(PRINT_CLICK_DEBUG, num_flashes);
        dprint(PRINT_CLICK_DEBUG, " Flashed "); dprint(PRINT_CLICK_DEBUG, remaining_flash_delay);
    1b90:	490e      	ldr	r1, [pc, #56]	; (1bcc <NeoGroup::flashOn(unsigned char, unsigned char, unsigned char)+0x150>)
    1b92:	a806      	add	r0, sp, #24
    1b94:	f007 fce0 	bl	9558 <String::String(char const*)>
    1b98:	a806      	add	r0, sp, #24
    1b9a:	f007 fc9d 	bl	94d8 <String::~String()>
        dprint(PRINT_CLICK_DEBUG, " FPM "); dprintln(PRINT_CLICK_DEBUG, fpm);
    1b9e:	490c      	ldr	r1, [pc, #48]	; (1bd0 <NeoGroup::flashOn(unsigned char, unsigned char, unsigned char)+0x154>)
    1ba0:	a806      	add	r0, sp, #24
    1ba2:	f007 fcd9 	bl	9558 <String::String(char const*)>
    1ba6:	a806      	add	r0, sp, #24
    1ba8:	f007 fc96 	bl	94d8 <String::~String()>
    1bac:	4628      	mov	r0, r5
  } else {
    dprint(PRINT_CLICK_DEBUG, "Flash skipped due to FLASH_DEBOUNCE_TIME : ");
    dprintln(PRINT_CLICK_DEBUG, last_flash);
  }
  return false;
}
    1bae:	b00a      	add	sp, #40	; 0x28
    1bb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1bb4:	200045ec 	.word	0x200045ec
    1bb8:	00010ee8 	.word	0x00010ee8
    1bbc:	3ff80000 	.word	0x3ff80000
    1bc0:	408f4000 	.word	0x408f4000
    1bc4:	404e0000 	.word	0x404e0000
    1bc8:	00010ec8 	.word	0x00010ec8
    1bcc:	00010ed4 	.word	0x00010ed4
    1bd0:	00010ee0 	.word	0x00010ee0

00001bd4 <NeoGroup::update()>:
}

//////////////////////////////////////////////////////
////////////// Update Methods/////////////////////////
//////////////////////////////////////////////////////
void NeoGroup::update() {
    1bd4:	b570      	push	{r4, r5, r6, lr}
  // if there is time remaining in the flash it either needs to be turned
  // on or the timer needs to increment
  if (remaining_flash_delay > 0) {
    1bd6:	6d03      	ldr	r3, [r0, #80]	; 0x50
    1bd8:	2b00      	cmp	r3, #0
}

//////////////////////////////////////////////////////
////////////// Update Methods/////////////////////////
//////////////////////////////////////////////////////
void NeoGroup::update() {
    1bda:	b08a      	sub	sp, #40	; 0x28
    1bdc:	4604      	mov	r4, r0
  // if there is time remaining in the flash it either needs to be turned
  // on or the timer needs to increment
  if (remaining_flash_delay > 0) {
    1bde:	dd7a      	ble.n	1cd6 <NeoGroup::update()+0x102>
    dprintln(PRINT_CLICK_DEBUG, "-------------------------------------");
    1be0:	4955      	ldr	r1, [pc, #340]	; (1d38 <NeoGroup::update()+0x164>)
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1be2:	4d56      	ldr	r5, [pc, #344]	; (1d3c <NeoGroup::update()+0x168>)
    1be4:	a806      	add	r0, sp, #24
    1be6:	f007 fcb7 	bl	9558 <String::String(char const*)>
    1bea:	a806      	add	r0, sp, #24
    1bec:	f007 fc74 	bl	94d8 <String::~String()>
    dprint(PRINT_CLICK_DEBUG, "flash delay "); dprint(PRINT_CLICK_DEBUG, id); dprint(PRINT_CLICK_DEBUG, " : ");
    1bf0:	4953      	ldr	r1, [pc, #332]	; (1d40 <NeoGroup::update()+0x16c>)
    1bf2:	a806      	add	r0, sp, #24
    1bf4:	f007 fcb0 	bl	9558 <String::String(char const*)>
    1bf8:	f104 0680 	add.w	r6, r4, #128	; 0x80
    1bfc:	a806      	add	r0, sp, #24
    1bfe:	f007 fc6b 	bl	94d8 <String::~String()>
    1c02:	4631      	mov	r1, r6
    1c04:	a806      	add	r0, sp, #24
    1c06:	f007 fcbb 	bl	9580 <String::String(String const&)>
    1c0a:	a806      	add	r0, sp, #24
    1c0c:	f007 fc64 	bl	94d8 <String::~String()>
    1c10:	494c      	ldr	r1, [pc, #304]	; (1d44 <NeoGroup::update()+0x170>)
    1c12:	a806      	add	r0, sp, #24
    1c14:	f007 fca0 	bl	9558 <String::String(char const*)>
    1c18:	a806      	add	r0, sp, #24
    1c1a:	f007 fc5d 	bl	94d8 <String::~String()>
    1c1e:	2101      	movs	r1, #1
    1c20:	4849      	ldr	r0, [pc, #292]	; (1d48 <NeoGroup::update()+0x174>)
    1c22:	f009 fced 	bl	b600 <usb_serial_write>
    1c26:	682b      	ldr	r3, [r5, #0]
    1c28:	9301      	str	r3, [sp, #4]
    1c2a:	2101      	movs	r1, #1
    1c2c:	4846      	ldr	r0, [pc, #280]	; (1d48 <NeoGroup::update()+0x174>)
	return ret;
    1c2e:	9b01      	ldr	r3, [sp, #4]
    1c30:	f009 fce6 	bl	b600 <usb_serial_write>
    dprint(PRINT_CLICK_DEBUG, remaining_flash_delay); dprintTab(PRINT_CLICK_DEBUG);
    dprint(PRINT_CLICK_DEBUG, last_flash_update); dprintTab(PRINT_CLICK_DEBUG);
    // if the flash is not currently on, turn the flash on
    if (flash_on < 1) { //and the light is not currently on
    1c34:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
    1c38:	2b00      	cmp	r3, #0
    1c3a:	d050      	beq.n	1cde <NeoGroup::update()+0x10a>
      dprintln(PRINT_CLICK_DEBUG, "-- Turning the Flash ON --");
      flashOn(flash_red, flash_green, flash_blue);// flash on
    }
    // if the flash is already on subtract from the timer
    else {
      dprintln(PRINT_CLICK_DEBUG, "- - - - - - - - - - - - - - - - - - -");
    1c3c:	4943      	ldr	r1, [pc, #268]	; (1d4c <NeoGroup::update()+0x178>)
    1c3e:	a806      	add	r0, sp, #24
    1c40:	f007 fc8a 	bl	9558 <String::String(char const*)>
    1c44:	a806      	add	r0, sp, #24
    1c46:	f007 fc47 	bl	94d8 <String::~String()>
      dprint(PRINT_CLICK_DEBUG, "last_flash :\t"); dprintln(PRINT_CLICK_DEBUG, last_flash);
    1c4a:	4941      	ldr	r1, [pc, #260]	; (1d50 <NeoGroup::update()+0x17c>)
    1c4c:	a806      	add	r0, sp, #24
    1c4e:	f007 fc83 	bl	9558 <String::String(char const*)>
    1c52:	a806      	add	r0, sp, #24
    1c54:	f007 fc40 	bl	94d8 <String::~String()>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1c58:	682b      	ldr	r3, [r5, #0]
      dprint(PRINT_CLICK_DEBUG, "remaining_flash_delay "); 
    1c5a:	493e      	ldr	r1, [pc, #248]	; (1d54 <NeoGroup::update()+0x180>)
    1c5c:	9303      	str	r3, [sp, #12]
    1c5e:	a806      	add	r0, sp, #24
	return ret;
    1c60:	9b03      	ldr	r3, [sp, #12]
    1c62:	f007 fc79 	bl	9558 <String::String(char const*)>
    1c66:	a806      	add	r0, sp, #24
    1c68:	f007 fc36 	bl	94d8 <String::~String()>
      dprint(PRINT_CLICK_DEBUG, id); dprint(PRINT_CLICK_DEBUG, ":\t");
    1c6c:	4631      	mov	r1, r6
    1c6e:	a806      	add	r0, sp, #24
    1c70:	f007 fc86 	bl	9580 <String::String(String const&)>
    1c74:	a806      	add	r0, sp, #24
    1c76:	f007 fc2f 	bl	94d8 <String::~String()>
    1c7a:	4937      	ldr	r1, [pc, #220]	; (1d58 <NeoGroup::update()+0x184>)
    1c7c:	a806      	add	r0, sp, #24
    1c7e:	f007 fc6b 	bl	9558 <String::String(char const*)>
    1c82:	a806      	add	r0, sp, #24
    1c84:	f007 fc28 	bl	94d8 <String::~String()>
      dprint(PRINT_CLICK_DEBUG, remaining_flash_delay); dprint(PRINT_CLICK_DEBUG, "\t");
    1c88:	492f      	ldr	r1, [pc, #188]	; (1d48 <NeoGroup::update()+0x174>)
    1c8a:	a806      	add	r0, sp, #24
    1c8c:	f007 fc64 	bl	9558 <String::String(char const*)>
    1c90:	a806      	add	r0, sp, #24
    1c92:	f007 fc21 	bl	94d8 <String::~String()>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1c96:	682b      	ldr	r3, [r5, #0]
    1c98:	9302      	str	r3, [sp, #8]
	return ret;
    1c9a:	9a02      	ldr	r2, [sp, #8]
	unsigned long ms;
public:
	elapsedMillis(void) { ms = millis(); }
	elapsedMillis(unsigned long val) { ms = millis() - val; }
	elapsedMillis(const elapsedMillis &orig) { ms = orig.ms; }
	operator unsigned long () const { return millis() - ms; }
    1c9c:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
      remaining_flash_delay = remaining_flash_delay - last_flash_update;
    1ca0:	6d21      	ldr	r1, [r4, #80]	; 0x50
    1ca2:	1ad2      	subs	r2, r2, r3
    1ca4:	1a8a      	subs	r2, r1, r2
constexpr auto min(A&& a, B&& b) -> decltype(a < b ? std::forward<A>(a) : std::forward<B>(b)) {
  return a < b ? std::forward<A>(a) : std::forward<B>(b);
}
template<class A, class B>
constexpr auto max(A&& a, B&& b) -> decltype(a < b ? std::forward<A>(a) : std::forward<B>(b)) {
  return a >= b ? std::forward<A>(a) : std::forward<B>(b);
    1ca6:	2a00      	cmp	r2, #0
    1ca8:	6522      	str	r2, [r4, #80]	; 0x50
    1caa:	db2b      	blt.n	1d04 <NeoGroup::update()+0x130>
      remaining_flash_delay = max(remaining_flash_delay, 0);
      dprintln(PRINT_CLICK_DEBUG, remaining_flash_delay);
      if (remaining_flash_delay == 0) {
    1cac:	d02c      	beq.n	1d08 <NeoGroup::update()+0x134>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1cae:	682a      	ldr	r2, [r5, #0]
    1cb0:	9204      	str	r2, [sp, #16]
	return ret;
    1cb2:	9a04      	ldr	r2, [sp, #16]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1cb4:	4921      	ldr	r1, [pc, #132]	; (1d3c <NeoGroup::update()+0x168>)
      }
    }
  }
  // this is so the timer does not get reset 
  // if it has been running for less than one ms
  if (last_flash_update != 0) {
    1cb6:	4293      	cmp	r3, r2
    1cb8:	d00b      	beq.n	1cd2 <NeoGroup::update()+0xfe>
    1cba:	680b      	ldr	r3, [r1, #0]
    1cbc:	9305      	str	r3, [sp, #20]
	return ret;
    1cbe:	9b05      	ldr	r3, [sp, #20]
	elapsedMillis & operator = (const elapsedMillis &rhs) { ms = rhs.ms; return *this; }
	elapsedMillis & operator = (unsigned long val) { ms = millis() - val; return *this; }
    1cc0:	f8c4 30b4 	str.w	r3, [r4, #180]	; 0xb4
    last_flash_update = 0;
    dprintln(PRINT_CLICK_DEBUG, "updated last_flash_upate to 0");
    1cc4:	a806      	add	r0, sp, #24
    1cc6:	4925      	ldr	r1, [pc, #148]	; (1d5c <NeoGroup::update()+0x188>)
    1cc8:	f007 fc46 	bl	9558 <String::String(char const*)>
    1ccc:	a806      	add	r0, sp, #24
    1cce:	f007 fc03 	bl	94d8 <String::~String()>
  }
}
    1cd2:	b00a      	add	sp, #40	; 0x28
    1cd4:	bd70      	pop	{r4, r5, r6, pc}
    1cd6:	f8d0 30b4 	ldr.w	r3, [r0, #180]	; 0xb4
    1cda:	4d18      	ldr	r5, [pc, #96]	; (1d3c <NeoGroup::update()+0x168>)
    1cdc:	e7e7      	b.n	1cae <NeoGroup::update()+0xda>
    dprint(PRINT_CLICK_DEBUG, "flash delay "); dprint(PRINT_CLICK_DEBUG, id); dprint(PRINT_CLICK_DEBUG, " : ");
    dprint(PRINT_CLICK_DEBUG, remaining_flash_delay); dprintTab(PRINT_CLICK_DEBUG);
    dprint(PRINT_CLICK_DEBUG, last_flash_update); dprintTab(PRINT_CLICK_DEBUG);
    // if the flash is not currently on, turn the flash on
    if (flash_on < 1) { //and the light is not currently on
      dprintln(PRINT_CLICK_DEBUG, "-- Turning the Flash ON --");
    1cde:	4920      	ldr	r1, [pc, #128]	; (1d60 <NeoGroup::update()+0x18c>)
    1ce0:	a806      	add	r0, sp, #24
    1ce2:	f007 fc39 	bl	9558 <String::String(char const*)>
    1ce6:	a806      	add	r0, sp, #24
    1ce8:	f007 fbf6 	bl	94d8 <String::~String()>
      flashOn(flash_red, flash_green, flash_blue);// flash on
    1cec:	f894 304e 	ldrb.w	r3, [r4, #78]	; 0x4e
    1cf0:	f894 204d 	ldrb.w	r2, [r4, #77]	; 0x4d
    1cf4:	f894 104c 	ldrb.w	r1, [r4, #76]	; 0x4c
    1cf8:	4620      	mov	r0, r4
    1cfa:	f7ff febf 	bl	1a7c <NeoGroup::flashOn(unsigned char, unsigned char, unsigned char)>
    1cfe:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
    1d02:	e7d4      	b.n	1cae <NeoGroup::update()+0xda>
      dprint(PRINT_CLICK_DEBUG, "last_flash :\t"); dprintln(PRINT_CLICK_DEBUG, last_flash);
      dprint(PRINT_CLICK_DEBUG, "remaining_flash_delay "); 
      dprint(PRINT_CLICK_DEBUG, id); dprint(PRINT_CLICK_DEBUG, ":\t");
      dprint(PRINT_CLICK_DEBUG, remaining_flash_delay); dprint(PRINT_CLICK_DEBUG, "\t");
      remaining_flash_delay = remaining_flash_delay - last_flash_update;
      remaining_flash_delay = max(remaining_flash_delay, 0);
    1d04:	2300      	movs	r3, #0
    1d06:	6523      	str	r3, [r4, #80]	; 0x50
      dprintln(PRINT_CLICK_DEBUG, remaining_flash_delay);
      if (remaining_flash_delay == 0) {
        dprint(PRINT_CLICK_DEBUG, "Click time over, turning off flash "); dprintln(PRINT_CLICK_DEBUG, id);
    1d08:	4916      	ldr	r1, [pc, #88]	; (1d64 <NeoGroup::update()+0x190>)
    1d0a:	a806      	add	r0, sp, #24
    1d0c:	f007 fc24 	bl	9558 <String::String(char const*)>
    1d10:	a806      	add	r0, sp, #24
    1d12:	f007 fbe1 	bl	94d8 <String::~String()>
    1d16:	4631      	mov	r1, r6
    1d18:	a806      	add	r0, sp, #24
    1d1a:	f007 fc31 	bl	9580 <String::String(String const&)>
    1d1e:	a806      	add	r0, sp, #24
    1d20:	f007 fbda 	bl	94d8 <String::~String()>
}

////////////// General Purpose Helper Functions /////////////////////////
void NeoGroup::flashOff() {
  // if the flash is allowed to be turned off
  if (remaining_flash_delay <= 0) {
    1d24:	6d23      	ldr	r3, [r4, #80]	; 0x50
    1d26:	2b00      	cmp	r3, #0
    1d28:	dd02      	ble.n	1d30 <NeoGroup::update()+0x15c>
    1d2a:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
    1d2e:	e7be      	b.n	1cae <NeoGroup::update()+0xda>
    1d30:	4620      	mov	r0, r4
    1d32:	f7ff fe77 	bl	1a24 <NeoGroup::flashOff() [clone .part.21]>
    1d36:	e7f8      	b.n	1d2a <NeoGroup::update()+0x156>
    1d38:	00010734 	.word	0x00010734
    1d3c:	200045ec 	.word	0x200045ec
    1d40:	00010f14 	.word	0x00010f14
    1d44:	00011bf0 	.word	0x00011bf0
    1d48:	00010cc0 	.word	0x00010cc0
    1d4c:	00010784 	.word	0x00010784
    1d50:	00010f40 	.word	0x00010f40
    1d54:	00010f50 	.word	0x00010f50
    1d58:	000109d0 	.word	0x000109d0
    1d5c:	00010f8c 	.word	0x00010f8c
    1d60:	00010f24 	.word	0x00010f24
    1d64:	00010f68 	.word	0x00010f68

00001d68 <NeoGroup::shutdown(unsigned long)>:
  idx_end = end_idx;
  leds = neos;
  id = _id;
}

bool NeoGroup::shutdown(uint32_t len) {
    1d68:	b570      	push	{r4, r5, r6, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1d6a:	4d1c      	ldr	r5, [pc, #112]	; (1ddc <NeoGroup::shutdown(unsigned long)+0x74>)
void NeoGroup::setRemainingFlashDelay(long d) {
  remaining_flash_delay = d;
};

bool NeoGroup::isInShutdown() {
  if (shdn_timer < shdn_len) {
    1d6c:	f8d0 40a0 	ldr.w	r4, [r0, #160]	; 0xa0
    1d70:	682b      	ldr	r3, [r5, #0]
    1d72:	f8d0 20a4 	ldr.w	r2, [r0, #164]	; 0xa4
  idx_end = end_idx;
  leds = neos;
  id = _id;
}

bool NeoGroup::shutdown(uint32_t len) {
    1d76:	b088      	sub	sp, #32
    1d78:	9302      	str	r3, [sp, #8]
	return ret;
    1d7a:	9b02      	ldr	r3, [sp, #8]
void NeoGroup::setRemainingFlashDelay(long d) {
  remaining_flash_delay = d;
};

bool NeoGroup::isInShutdown() {
  if (shdn_timer < shdn_len) {
    1d7c:	1b1b      	subs	r3, r3, r4
    1d7e:	4293      	cmp	r3, r2
    1d80:	d202      	bcs.n	1d88 <NeoGroup::shutdown(unsigned long)+0x20>
    colorWipe(0, 0, 0);
    shdn_timer = 0;
    leds_on = false;
    return 0;
  }
  return 1;
    1d82:	2001      	movs	r0, #1
}
    1d84:	b008      	add	sp, #32
    1d86:	bd70      	pop	{r4, r5, r6, pc}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1d88:	682b      	ldr	r3, [r5, #0]
    1d8a:	9303      	str	r3, [sp, #12]
    1d8c:	4604      	mov	r4, r0
    1d8e:	460e      	mov	r6, r1
}

bool NeoGroup::shutdown(uint32_t len) {
  // return 0 if lux shutdown not a success, 1 if it is
  if (!isInShutdown()) {
    dprint(PRINT_LUX_DEBUG,millis());dprint(PRINT_LUX_DEBUG, "\tSHUTTING DOWN GROUP ");
    1d90:	a804      	add	r0, sp, #16
    1d92:	4913      	ldr	r1, [pc, #76]	; (1de0 <NeoGroup::shutdown(unsigned long)+0x78>)
	return ret;
    1d94:	9b03      	ldr	r3, [sp, #12]
    1d96:	f007 fbdf 	bl	9558 <String::String(char const*)>
    1d9a:	a804      	add	r0, sp, #16
    1d9c:	f007 fb9c 	bl	94d8 <String::~String()>
    dprintln(PRINT_LUX_DEBUG, id);
    1da0:	f104 0180 	add.w	r1, r4, #128	; 0x80
    1da4:	a804      	add	r0, sp, #16
    1da6:	f007 fbeb 	bl	9580 <String::String(String const&)>
    1daa:	a804      	add	r0, sp, #16
    1dac:	f007 fb94 	bl	94d8 <String::~String()>
  HsbToRgb(h, s, b);
  colorWipe(rgb[0], rgb[1], rgb[2]);
}

void NeoGroup::colorWipe(uint8_t red, uint8_t green, uint8_t blue) {
  colorWipe(red, green, blue, brightness_scaler);
    1db0:	e9d4 0130 	ldrd	r0, r1, [r4, #192]	; 0xc0
    1db4:	2300      	movs	r3, #0
bool NeoGroup::shutdown(uint32_t len) {
  // return 0 if lux shutdown not a success, 1 if it is
  if (!isInShutdown()) {
    dprint(PRINT_LUX_DEBUG,millis());dprint(PRINT_LUX_DEBUG, "\tSHUTTING DOWN GROUP ");
    dprintln(PRINT_LUX_DEBUG, id);
    shdn_len = len;
    1db6:	f8c4 60a4 	str.w	r6, [r4, #164]	; 0xa4
  HsbToRgb(h, s, b);
  colorWipe(rgb[0], rgb[1], rgb[2]);
}

void NeoGroup::colorWipe(uint8_t red, uint8_t green, uint8_t blue) {
  colorWipe(red, green, blue, brightness_scaler);
    1dba:	461a      	mov	r2, r3
    1dbc:	e9cd 0100 	strd	r0, r1, [sp]
    1dc0:	4619      	mov	r1, r3
    1dc2:	4620      	mov	r0, r4
    1dc4:	f7ff fd2c 	bl	1820 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1dc8:	682b      	ldr	r3, [r5, #0]
    1dca:	9304      	str	r3, [sp, #16]
	return ret;
    1dcc:	9b04      	ldr	r3, [sp, #16]
    1dce:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
    dprint(PRINT_LUX_DEBUG,millis());dprint(PRINT_LUX_DEBUG, "\tSHUTTING DOWN GROUP ");
    dprintln(PRINT_LUX_DEBUG, id);
    shdn_len = len;
    colorWipe(0, 0, 0);
    shdn_timer = 0;
    leds_on = false;
    1dd2:	2000      	movs	r0, #0
    1dd4:	f884 00a8 	strb.w	r0, [r4, #168]	; 0xa8
    return 0;
  }
  return 1;
}
    1dd8:	b008      	add	sp, #32
    1dda:	bd70      	pop	{r4, r5, r6, pc}
    1ddc:	200045ec 	.word	0x200045ec
    1de0:	00010fac 	.word	0x00010fac
    1de4:	ffffffff 	.word	0xffffffff

00001de8 <LuxManager::LuxManager(long, long, int, String, NeoGroup*)>:
    double read();
};

//////////////////////////// lux and stuff /////////////////////////

LuxManager::LuxManager (long minrt, long maxrt, int tca, String _name, NeoGroup *n) {
    1de8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    1dec:	f20f 0970 	addw	r9, pc, #112	; 0x70
    1df0:	e9d9 8900 	ldrd	r8, r9, [r9]
    1df4:	2600      	movs	r6, #0
    1df6:	2700      	movs	r7, #0
    1df8:	4604      	mov	r4, r0
    1dfa:	b083      	sub	sp, #12
    1dfc:	e9c0 8900 	strd	r8, r9, [r0]
    1e00:	e9c0 6702 	strd	r6, r7, [r0, #8]
    1e04:	e9c0 6706 	strd	r6, r7, [r0, #24]
    1e08:	e9c0 6708 	strd	r6, r7, [r0, #32]
    1e0c:	3028      	adds	r0, #40	; 0x28
    1e0e:	4616      	mov	r6, r2
    1e10:	460f      	mov	r7, r1
    1e12:	4699      	mov	r9, r3
    1e14:	f104 0570 	add.w	r5, r4, #112	; 0x70
    1e18:	f005 fe66 	bl	7ae8 <Adafruit_VEML7700::Adafruit_VEML7700()>
    1e1c:	2300      	movs	r3, #0
    1e1e:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
    1e22:	4628      	mov	r0, r5
    1e24:	4910      	ldr	r1, [pc, #64]	; (1e68 <LuxManager::LuxManager(long, long, int, String, NeoGroup*)+0x80>)
    1e26:	f007 fb97 	bl	9558 <String::String(char const*)>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    1e2a:	4a10      	ldr	r2, [pc, #64]	; (1e6c <LuxManager::LuxManager(long, long, int, String, NeoGroup*)+0x84>)
  num_sensors = 1;
  tca_addr = tca;
    1e2c:	f8c4 9068 	str.w	r9, [r4, #104]	; 0x68
    1e30:	6813      	ldr	r3, [r2, #0]
    1e32:	9301      	str	r3, [sp, #4]
	return ret;
    1e34:	9b01      	ldr	r3, [sp, #4]
class elapsedMillis
{
private:
	unsigned long ms;
public:
	elapsedMillis(void) { ms = millis(); }
    1e36:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
};

//////////////////////////// lux and stuff /////////////////////////

LuxManager::LuxManager (long minrt, long maxrt, int tca, String _name, NeoGroup *n) {
  num_sensors = 1;
    1e3a:	2301      	movs	r3, #1
    1e3c:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
  tca_addr = tca;
  id = _name;
    1e40:	4628      	mov	r0, r5
    1e42:	990a      	ldr	r1, [sp, #40]	; 0x28
    1e44:	f007 fbf2 	bl	962c <String::operator=(String const&)>
  neo = n;
    1e48:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1e4a:	66e3      	str	r3, [r4, #108]	; 0x6c
  min_reading_time = minrt;
  max_reading_time = maxrt;
}
    1e4c:	4620      	mov	r0, r4
LuxManager::LuxManager (long minrt, long maxrt, int tca, String _name, NeoGroup *n) {
  num_sensors = 1;
  tca_addr = tca;
  id = _name;
  neo = n;
  min_reading_time = minrt;
    1e4e:	f8c4 70d0 	str.w	r7, [r4, #208]	; 0xd0
  max_reading_time = maxrt;
    1e52:	f8c4 60d4 	str.w	r6, [r4, #212]	; 0xd4
}
    1e56:	b003      	add	sp, #12
    1e58:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    1e5c:	f3af 8000 	nop.w
    1e60:	40000000 	.word	0x40000000
    1e64:	40c387f3 	.word	0x40c387f3
    1e68:	00010b88 	.word	0x00010b88
    1e6c:	200045ec 	.word	0x200045ec

00001e70 <LuxManager::checkForLuxOverValue()>:
    sensor.setGain(g);
    sensor.setIntegrationTime(r);// 800ms was default
  }
}

double LuxManager::checkForLuxOverValue() {
    1e70:	b5d0      	push	{r4, r6, r7, lr}
  // sometimes the sensor will give an incorrect extremely high reading, this compensates for this...
  if (lux > 100000) {
    1e72:	e9d0 6704 	ldrd	r6, r7, [r0, #16]
    sensor.setGain(g);
    sensor.setIntegrationTime(r);// 800ms was default
  }
}

double LuxManager::checkForLuxOverValue() {
    1e76:	b084      	sub	sp, #16
    1e78:	4604      	mov	r4, r0
  // sometimes the sensor will give an incorrect extremely high reading, this compensates for this...
  if (lux > 100000) {
    1e7a:	a325      	add	r3, pc, #148	; (adr r3, 1f10 <LuxManager::checkForLuxOverValue()+0xa0>)
    1e7c:	e9d3 2300 	ldrd	r2, r3, [r3]
    1e80:	4630      	mov	r0, r6
    1e82:	4639      	mov	r1, r7
    1e84:	f00b f8a4 	bl	cfd0 <__aeabi_dcmpgt>
    1e88:	2800      	cmp	r0, #0
    1e8a:	d03b      	beq.n	1f04 <LuxManager::checkForLuxOverValue()+0x94>
    dprintln(PRINT_LUX_DEBUG, "lux "); dprintln(PRINT_LUX_DEBUG, id); dprintln(PRINT_LUX_DEBUG, " reading error: ");
    1e8c:	4922      	ldr	r1, [pc, #136]	; (1f18 <LuxManager::checkForLuxOverValue()+0xa8>)
    1e8e:	4668      	mov	r0, sp
    1e90:	f007 fb62 	bl	9558 <String::String(char const*)>
    1e94:	4668      	mov	r0, sp
    1e96:	f007 fb1f 	bl	94d8 <String::~String()>
    1e9a:	f104 0170 	add.w	r1, r4, #112	; 0x70
    1e9e:	4668      	mov	r0, sp
    1ea0:	f007 fb6e 	bl	9580 <String::String(String const&)>
    1ea4:	4668      	mov	r0, sp
    1ea6:	f007 fb17 	bl	94d8 <String::~String()>
    1eaa:	491c      	ldr	r1, [pc, #112]	; (1f1c <LuxManager::checkForLuxOverValue()+0xac>)
    1eac:	4668      	mov	r0, sp
    1eae:	f007 fb53 	bl	9558 <String::String(char const*)>
    1eb2:	4668      	mov	r0, sp
    1eb4:	f007 fb10 	bl	94d8 <String::~String()>
	String(int, unsigned char base=10);
	String(unsigned int, unsigned char base=10);
	String(long, unsigned char base=10);
	String(unsigned long, unsigned char base=10);
        String(float num, unsigned char digits=2);
	String(double num, unsigned char digits=2) : String((float)num, digits) {}
    1eb8:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
    1ebc:	f00b f8f0 	bl	d0a0 <__aeabi_d2f>
    1ec0:	2202      	movs	r2, #2
    1ec2:	4601      	mov	r1, r0
    1ec4:	4668      	mov	r0, sp
    1ec6:	f007 fb79 	bl	95bc <String::String(float, unsigned char)>
    dprintln(PRINT_LUX_DEBUG, (String)lux);
    1eca:	4668      	mov	r0, sp
    1ecc:	f007 fb04 	bl	94d8 <String::~String()>
    if (SMOOTH_LUX_READINGS && lux != 0) {
      lux = (lux + sensor.readLux()) * 0.5;
      lux_total += lux;
      lux_readings++;
    } else {
      lux = sensor.readLux();
    1ed0:	f104 0028 	add.w	r0, r4, #40	; 0x28
    1ed4:	f005 ff42 	bl	7d5c <Adafruit_VEML7700::readLux()>
    1ed8:	f00a fd96 	bl	ca08 <__aeabi_f2d>
    1edc:	4606      	mov	r6, r0
    1ede:	460f      	mov	r7, r1
      lux_total += lux;
    1ee0:	4602      	mov	r2, r0
    1ee2:	460b      	mov	r3, r1
    if (SMOOTH_LUX_READINGS && lux != 0) {
      lux = (lux + sensor.readLux()) * 0.5;
      lux_total += lux;
      lux_readings++;
    } else {
      lux = sensor.readLux();
    1ee4:	e9c4 6704 	strd	r6, r7, [r4, #16]
      lux_total += lux;
    1ee8:	e9d4 0138 	ldrd	r0, r1, [r4, #224]	; 0xe0
    1eec:	f00a fc2e 	bl	c74c <__adddf3>
      lux_readings++;
    1ef0:	2200      	movs	r2, #0
      lux = (lux + sensor.readLux()) * 0.5;
      lux_total += lux;
      lux_readings++;
    } else {
      lux = sensor.readLux();
      lux_total += lux;
    1ef2:	e9c4 0138 	strd	r0, r1, [r4, #224]	; 0xe0
      lux_readings++;
    1ef6:	4b0a      	ldr	r3, [pc, #40]	; (1f20 <LuxManager::checkForLuxOverValue()+0xb0>)
    1ef8:	e9d4 013a 	ldrd	r0, r1, [r4, #232]	; 0xe8
    1efc:	f00a fc26 	bl	c74c <__adddf3>
    1f00:	e9c4 013a 	strd	r0, r1, [r4, #232]	; 0xe8
    }
  }
  return lux;
}
    1f04:	4630      	mov	r0, r6
    1f06:	4639      	mov	r1, r7
    1f08:	b004      	add	sp, #16
    1f0a:	bdd0      	pop	{r4, r6, r7, pc}
    1f0c:	f3af 8000 	nop.w
    1f10:	00000000 	.word	0x00000000
    1f14:	40f86a00 	.word	0x40f86a00
    1f18:	00011044 	.word	0x00011044
    1f1c:	0001104c 	.word	0x0001104c
    1f20:	3ff00000 	.word	0x3ff00000

00001f24 <LuxManager::calculateBrightnessScaler()>:
  updateMinMax();
  last_reading = 0;
}


double LuxManager::calculateBrightnessScaler() {
    1f24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1f28:	b084      	sub	sp, #16
    // todo need to make this function better... linear mapping does not really work, need to map li
    double bs;
    // conduct brightness scaling depending on if the reading is above or below the mid thresh
    // is the unconstrained lux above the extreme_lux_thresh?
    dprint(PRINT_BRIGHTNESS_SCALER_DEBUG, id);
    1f2a:	f100 0170 	add.w	r1, r0, #112	; 0x70
  updateMinMax();
  last_reading = 0;
}


double LuxManager::calculateBrightnessScaler() {
    1f2e:	4604      	mov	r4, r0
    // todo need to make this function better... linear mapping does not really work, need to map li
    double bs;
    // conduct brightness scaling depending on if the reading is above or below the mid thresh
    // is the unconstrained lux above the extreme_lux_thresh?
    dprint(PRINT_BRIGHTNESS_SCALER_DEBUG, id);
    1f30:	4668      	mov	r0, sp
    1f32:	f007 fb25 	bl	9580 <String::String(String const&)>
    1f36:	4668      	mov	r0, sp
    1f38:	f007 face 	bl	94d8 <String::~String()>
    if (lux >= EXTREME_LUX_THRESHOLD) {
    1f3c:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
    1f40:	2200      	movs	r2, #0
    1f42:	4b5c      	ldr	r3, [pc, #368]	; (20b4 <LuxManager::calculateBrightnessScaler()+0x190>)
    1f44:	4630      	mov	r0, r6
    1f46:	4639      	mov	r1, r7
    1f48:	f00b f838 	bl	cfbc <__aeabi_dcmpge>
    1f4c:	2800      	cmp	r0, #0
    1f4e:	d13f      	bne.n	1fd0 <LuxManager::calculateBrightnessScaler()+0xac>
    1f50:	4605      	mov	r5, r0
        dprintln(PRINT_BRIGHTNESS_SCALER_DEBUG, " Neopixel brightness scaler set to 0.0 due to extreme lux");
        if (neo->getLuxShdn() == false) {
            neo->setExtremeLuxShdn(1);
        }
    } 
    else if (lux >= HIGH_LUX_THRESHOLD) {
    1f52:	2200      	movs	r2, #0
    1f54:	4b58      	ldr	r3, [pc, #352]	; (20b8 <LuxManager::calculateBrightnessScaler()+0x194>)
    1f56:	4630      	mov	r0, r6
    1f58:	4639      	mov	r1, r7
    1f5a:	f00b f82f 	bl	cfbc <__aeabi_dcmpge>
    1f5e:	4680      	mov	r8, r0
    1f60:	2800      	cmp	r0, #0
    1f62:	d147      	bne.n	1ff4 <LuxManager::calculateBrightnessScaler()+0xd0>
        dprintln(PRINT_BRIGHTNESS_SCALER_DEBUG, " is greater than the MAX_LUX_THRESHOLD, setting brightness scaler to BRIGHTNESS_SCALER_MAX");
        if (neo->getLuxShdn() == true) {
            neo->setExtremeLuxShdn(false);
        }
    }
    else if (lux >= MID_LUX_THRESHOLD) {
    1f64:	2200      	movs	r2, #0
    1f66:	4b55      	ldr	r3, [pc, #340]	; (20bc <LuxManager::calculateBrightnessScaler()+0x198>)
    1f68:	4630      	mov	r0, r6
    1f6a:	4639      	mov	r1, r7
    1f6c:	f00b f826 	bl	cfbc <__aeabi_dcmpge>
    1f70:	4605      	mov	r5, r0
    1f72:	2800      	cmp	r0, #0
    1f74:	d172      	bne.n	205c <LuxManager::calculateBrightnessScaler()+0x138>
        dprintln(PRINT_BRIGHTNESS_SCALER_DEBUG, " is greater than the MID_LUX_THRESHOLD, setting brightness scaler to a value > 1.0");
        if (neo->getLuxShdn() == true) {
            neo->setExtremeLuxShdn(false);
        }
    }
    else if (lux >= LOW_LUX_THRESHOLD)  {
    1f76:	2200      	movs	r2, #0
    1f78:	4b51      	ldr	r3, [pc, #324]	; (20c0 <LuxManager::calculateBrightnessScaler()+0x19c>)
    1f7a:	4630      	mov	r0, r6
    1f7c:	4639      	mov	r1, r7
    1f7e:	f00b f81d 	bl	cfbc <__aeabi_dcmpge>
    1f82:	4680      	mov	r8, r0
    1f84:	2800      	cmp	r0, #0
    1f86:	d146      	bne.n	2016 <LuxManager::calculateBrightnessScaler()+0xf2>
        if (neo->getLuxShdn() == true) {
            neo->setExtremeLuxShdn(false);
        }
    } else {
        bs = BRIGHTNESS_SCALER_MIN;
        dprintln(PRINT_BRIGHTNESS_SCALER_DEBUG, " is lower than the MIN_LUX_THRESHOLD, setting brightness scaler to BRIGHTNESS_SCALER_MIN");
    1f88:	494e      	ldr	r1, [pc, #312]	; (20c4 <LuxManager::calculateBrightnessScaler()+0x1a0>)
    1f8a:	4668      	mov	r0, sp
    1f8c:	f007 fae4 	bl	9558 <String::String(char const*)>
    1f90:	4668      	mov	r0, sp
    1f92:	f007 faa1 	bl	94d8 <String::~String()>
        if (neo->getLuxShdn() == true) {
    1f96:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    1f98:	f893 204b 	ldrb.w	r2, [r3, #75]	; 0x4b
    1f9c:	2a00      	cmp	r2, #0
    1f9e:	f000 8086 	beq.w	20ae <LuxManager::calculateBrightnessScaler()+0x18a>
        dprintln(PRINT_BRIGHTNESS_SCALER_DEBUG, " is greater than the MIN_LUX_THRESHOLD, setting brightness scaler to a value < 1.0");
        if (neo->getLuxShdn() == true) {
            neo->setExtremeLuxShdn(false);
        }
    } else {
        bs = BRIGHTNESS_SCALER_MIN;
    1fa2:	4f49      	ldr	r7, [pc, #292]	; (20c8 <LuxManager::calculateBrightnessScaler()+0x1a4>)

    ///////////////////////////// Misc //////////////////////////////////////
    bool shutdown(uint32_t len);
    String getName() { return id;};

    void setExtremeLuxShdn(bool e){extreme_lux_shdn = e;};
    1fa4:	f883 804b 	strb.w	r8, [r3, #75]	; 0x4b
    1fa8:	2600      	movs	r6, #0
        dprintln(PRINT_BRIGHTNESS_SCALER_DEBUG, " is lower than the MIN_LUX_THRESHOLD, setting brightness scaler to BRIGHTNESS_SCALER_MIN");
        if (neo->getLuxShdn() == true) {
            neo->setExtremeLuxShdn(false);
        }
    }
    dprint(PRINT_BRIGHTNESS_SCALER_DEBUG, "lux:\t");
    1faa:	4948      	ldr	r1, [pc, #288]	; (20cc <LuxManager::calculateBrightnessScaler()+0x1a8>)
    1fac:	4668      	mov	r0, sp
    1fae:	f007 fad3 	bl	9558 <String::String(char const*)>
    1fb2:	4668      	mov	r0, sp
    1fb4:	f007 fa90 	bl	94d8 <String::~String()>
    dprint(PRINT_BRIGHTNESS_SCALER_DEBUG, lux);
    dprint(PRINT_BRIGHTNESS_SCALER_DEBUG, "\tbrightness_scaler:\t");
    1fb8:	4945      	ldr	r1, [pc, #276]	; (20d0 <LuxManager::calculateBrightnessScaler()+0x1ac>)
    1fba:	4668      	mov	r0, sp
    1fbc:	f007 facc 	bl	9558 <String::String(char const*)>
    1fc0:	4668      	mov	r0, sp
    1fc2:	f007 fa89 	bl	94d8 <String::~String()>
    dprintln(PRINT_BRIGHTNESS_SCALER_DEBUG, bs);
    return bs;
}
    1fc6:	4630      	mov	r0, r6
    1fc8:	4639      	mov	r1, r7
    1fca:	b004      	add	sp, #16
    1fcc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    // conduct brightness scaling depending on if the reading is above or below the mid thresh
    // is the unconstrained lux above the extreme_lux_thresh?
    dprint(PRINT_BRIGHTNESS_SCALER_DEBUG, id);
    if (lux >= EXTREME_LUX_THRESHOLD) {
        bs = 0.0;
        dprintln(PRINT_BRIGHTNESS_SCALER_DEBUG, " Neopixel brightness scaler set to 0.0 due to extreme lux");
    1fd0:	4940      	ldr	r1, [pc, #256]	; (20d4 <LuxManager::calculateBrightnessScaler()+0x1b0>)
    1fd2:	4668      	mov	r0, sp
    1fd4:	f007 fac0 	bl	9558 <String::String(char const*)>
    1fd8:	4668      	mov	r0, sp
    1fda:	f007 fa7d 	bl	94d8 <String::~String()>
        if (neo->getLuxShdn() == false) {
    1fde:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    1fe0:	f893 204b 	ldrb.w	r2, [r3, #75]	; 0x4b
    1fe4:	2a00      	cmp	r2, #0
    1fe6:	d15c      	bne.n	20a2 <LuxManager::calculateBrightnessScaler()+0x17e>
    1fe8:	2201      	movs	r2, #1
    1fea:	f883 204b 	strb.w	r2, [r3, #75]	; 0x4b
    double bs;
    // conduct brightness scaling depending on if the reading is above or below the mid thresh
    // is the unconstrained lux above the extreme_lux_thresh?
    dprint(PRINT_BRIGHTNESS_SCALER_DEBUG, id);
    if (lux >= EXTREME_LUX_THRESHOLD) {
        bs = 0.0;
    1fee:	2600      	movs	r6, #0
    1ff0:	2700      	movs	r7, #0
    1ff2:	e7da      	b.n	1faa <LuxManager::calculateBrightnessScaler()+0x86>
            neo->setExtremeLuxShdn(1);
        }
    } 
    else if (lux >= HIGH_LUX_THRESHOLD) {
        bs = BRIGHTNESS_SCALER_MAX;
        dprintln(PRINT_BRIGHTNESS_SCALER_DEBUG, " is greater than the MAX_LUX_THRESHOLD, setting brightness scaler to BRIGHTNESS_SCALER_MAX");
    1ff4:	4938      	ldr	r1, [pc, #224]	; (20d8 <LuxManager::calculateBrightnessScaler()+0x1b4>)
    1ff6:	4668      	mov	r0, sp
    1ff8:	f007 faae 	bl	9558 <String::String(char const*)>
    1ffc:	4668      	mov	r0, sp
    1ffe:	f007 fa6b 	bl	94d8 <String::~String()>
        if (neo->getLuxShdn() == true) {
    2002:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    2004:	f893 204b 	ldrb.w	r2, [r3, #75]	; 0x4b
    2008:	2a00      	cmp	r2, #0
    200a:	d04d      	beq.n	20a8 <LuxManager::calculateBrightnessScaler()+0x184>
    200c:	f883 504b 	strb.w	r5, [r3, #75]	; 0x4b
        if (neo->getLuxShdn() == false) {
            neo->setExtremeLuxShdn(1);
        }
    } 
    else if (lux >= HIGH_LUX_THRESHOLD) {
        bs = BRIGHTNESS_SCALER_MAX;
    2010:	2600      	movs	r6, #0
    2012:	4f32      	ldr	r7, [pc, #200]	; (20dc <LuxManager::calculateBrightnessScaler()+0x1b8>)
    2014:	e7c9      	b.n	1faa <LuxManager::calculateBrightnessScaler()+0x86>
}
// when the input is a float or double, do all math using the input's type
template <class T, class A, class B, class C, class D>
T map(T x, A in_min, B in_max, C out_min, D out_max, typename std::enable_if<std::is_floating_point<T>::value >::type* = 0)
{
	return (x - (T)in_min) * ((T)out_max - (T)out_min) / ((T)in_max - (T)in_min) + (T)out_min;
    2016:	4630      	mov	r0, r6
    2018:	4639      	mov	r1, r7
    201a:	2200      	movs	r2, #0
    201c:	4b28      	ldr	r3, [pc, #160]	; (20c0 <LuxManager::calculateBrightnessScaler()+0x19c>)
    201e:	f00a fb93 	bl	c748 <__aeabi_dsub>
    2022:	2200      	movs	r2, #0
    2024:	4b2e      	ldr	r3, [pc, #184]	; (20e0 <LuxManager::calculateBrightnessScaler()+0x1bc>)
    2026:	f00a fd43 	bl	cab0 <__aeabi_dmul>
    202a:	2200      	movs	r2, #0
    202c:	4b2d      	ldr	r3, [pc, #180]	; (20e4 <LuxManager::calculateBrightnessScaler()+0x1c0>)
    202e:	f00a fe69 	bl	cd04 <__aeabi_ddiv>
    2032:	2200      	movs	r2, #0
    2034:	4b24      	ldr	r3, [pc, #144]	; (20c8 <LuxManager::calculateBrightnessScaler()+0x1a4>)
    2036:	f00a fb89 	bl	c74c <__adddf3>
    203a:	4606      	mov	r6, r0
    203c:	460f      	mov	r7, r1
            neo->setExtremeLuxShdn(false);
        }
    }
    else if (lux >= LOW_LUX_THRESHOLD)  {
        bs = map(lux, LOW_LUX_THRESHOLD, MID_LUX_THRESHOLD, BRIGHTNESS_SCALER_MIN, 1.0);
        dprintln(PRINT_BRIGHTNESS_SCALER_DEBUG, " is greater than the MIN_LUX_THRESHOLD, setting brightness scaler to a value < 1.0");
    203e:	4668      	mov	r0, sp
    2040:	4929      	ldr	r1, [pc, #164]	; (20e8 <LuxManager::calculateBrightnessScaler()+0x1c4>)
    2042:	f007 fa89 	bl	9558 <String::String(char const*)>
    2046:	4668      	mov	r0, sp
    2048:	f007 fa46 	bl	94d8 <String::~String()>
        if (neo->getLuxShdn() == true) {
    204c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    204e:	f893 204b 	ldrb.w	r2, [r3, #75]	; 0x4b
    2052:	2a00      	cmp	r2, #0
    2054:	d0a9      	beq.n	1faa <LuxManager::calculateBrightnessScaler()+0x86>
    2056:	f883 504b 	strb.w	r5, [r3, #75]	; 0x4b
    205a:	e7a6      	b.n	1faa <LuxManager::calculateBrightnessScaler()+0x86>
    205c:	4630      	mov	r0, r6
    205e:	4639      	mov	r1, r7
    2060:	2200      	movs	r2, #0
    2062:	4b16      	ldr	r3, [pc, #88]	; (20bc <LuxManager::calculateBrightnessScaler()+0x198>)
    2064:	f00a fb70 	bl	c748 <__aeabi_dsub>
    2068:	2200      	movs	r2, #0
    206a:	4b17      	ldr	r3, [pc, #92]	; (20c8 <LuxManager::calculateBrightnessScaler()+0x1a4>)
    206c:	f00a fd20 	bl	cab0 <__aeabi_dmul>
    2070:	2200      	movs	r2, #0
    2072:	4b12      	ldr	r3, [pc, #72]	; (20bc <LuxManager::calculateBrightnessScaler()+0x198>)
    2074:	f00a fe46 	bl	cd04 <__aeabi_ddiv>
    2078:	2200      	movs	r2, #0
    207a:	4b1c      	ldr	r3, [pc, #112]	; (20ec <LuxManager::calculateBrightnessScaler()+0x1c8>)
    207c:	f00a fb66 	bl	c74c <__adddf3>
    2080:	4606      	mov	r6, r0
    2082:	460f      	mov	r7, r1
            neo->setExtremeLuxShdn(false);
        }
    }
    else if (lux >= MID_LUX_THRESHOLD) {
        bs = map(lux, MID_LUX_THRESHOLD, HIGH_LUX_THRESHOLD, 1.0, BRIGHTNESS_SCALER_MAX);
        dprintln(PRINT_BRIGHTNESS_SCALER_DEBUG, " is greater than the MID_LUX_THRESHOLD, setting brightness scaler to a value > 1.0");
    2084:	4668      	mov	r0, sp
    2086:	491a      	ldr	r1, [pc, #104]	; (20f0 <LuxManager::calculateBrightnessScaler()+0x1cc>)
    2088:	f007 fa66 	bl	9558 <String::String(char const*)>
    208c:	4668      	mov	r0, sp
    208e:	f007 fa23 	bl	94d8 <String::~String()>
        if (neo->getLuxShdn() == true) {
    2092:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    2094:	f893 204b 	ldrb.w	r2, [r3, #75]	; 0x4b
    2098:	2a00      	cmp	r2, #0
    209a:	d086      	beq.n	1faa <LuxManager::calculateBrightnessScaler()+0x86>
    209c:	f883 804b 	strb.w	r8, [r3, #75]	; 0x4b
    20a0:	e783      	b.n	1faa <LuxManager::calculateBrightnessScaler()+0x86>
    double bs;
    // conduct brightness scaling depending on if the reading is above or below the mid thresh
    // is the unconstrained lux above the extreme_lux_thresh?
    dprint(PRINT_BRIGHTNESS_SCALER_DEBUG, id);
    if (lux >= EXTREME_LUX_THRESHOLD) {
        bs = 0.0;
    20a2:	2600      	movs	r6, #0
    20a4:	2700      	movs	r7, #0
    20a6:	e780      	b.n	1faa <LuxManager::calculateBrightnessScaler()+0x86>
        if (neo->getLuxShdn() == false) {
            neo->setExtremeLuxShdn(1);
        }
    } 
    else if (lux >= HIGH_LUX_THRESHOLD) {
        bs = BRIGHTNESS_SCALER_MAX;
    20a8:	2600      	movs	r6, #0
    20aa:	4f0c      	ldr	r7, [pc, #48]	; (20dc <LuxManager::calculateBrightnessScaler()+0x1b8>)
    20ac:	e77d      	b.n	1faa <LuxManager::calculateBrightnessScaler()+0x86>
        dprintln(PRINT_BRIGHTNESS_SCALER_DEBUG, " is greater than the MIN_LUX_THRESHOLD, setting brightness scaler to a value < 1.0");
        if (neo->getLuxShdn() == true) {
            neo->setExtremeLuxShdn(false);
        }
    } else {
        bs = BRIGHTNESS_SCALER_MIN;
    20ae:	2600      	movs	r6, #0
    20b0:	4f05      	ldr	r7, [pc, #20]	; (20c8 <LuxManager::calculateBrightnessScaler()+0x1a4>)
    20b2:	e77a      	b.n	1faa <LuxManager::calculateBrightnessScaler()+0x86>
    20b4:	40af4000 	.word	0x40af4000
    20b8:	409f4000 	.word	0x409f4000
    20bc:	408f4000 	.word	0x408f4000
    20c0:	40490000 	.word	0x40490000
    20c4:	000111a0 	.word	0x000111a0
    20c8:	3fe80000 	.word	0x3fe80000
    20cc:	000111fc 	.word	0x000111fc
    20d0:	00011204 	.word	0x00011204
    20d4:	00011060 	.word	0x00011060
    20d8:	0001109c 	.word	0x0001109c
    20dc:	3ffc0000 	.word	0x3ffc0000
    20e0:	3fd00000 	.word	0x3fd00000
    20e4:	408db000 	.word	0x408db000
    20e8:	0001114c 	.word	0x0001114c
    20ec:	3ff00000 	.word	0x3ff00000
    20f0:	000110f8 	.word	0x000110f8
    20f4:	ffffffff 	.word	0xffffffff

000020f8 <LuxManager::setLuxValue(double)>:
    }
  }
  return lux;
}

void LuxManager::setLuxValue(double temp) {
    20f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    20fc:	b086      	sub	sp, #24
  dprintln(PRINT_LUX_DEBUG, "\nForce lux reading");
    20fe:	4964      	ldr	r1, [pc, #400]	; (2290 <LuxManager::setLuxValue(double)+0x198>)
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2100:	4d64      	ldr	r5, [pc, #400]	; (2294 <LuxManager::setLuxValue(double)+0x19c>)
    }
  }
  return lux;
}

void LuxManager::setLuxValue(double temp) {
    2102:	4604      	mov	r4, r0
  dprintln(PRINT_LUX_DEBUG, "\nForce lux reading");
    2104:	a802      	add	r0, sp, #8
    }
  }
  return lux;
}

void LuxManager::setLuxValue(double temp) {
    2106:	4690      	mov	r8, r2
    2108:	4699      	mov	r9, r3
  dprintln(PRINT_LUX_DEBUG, "\nForce lux reading");
    210a:	f007 fa25 	bl	9558 <String::String(char const*)>
    210e:	a802      	add	r0, sp, #8
    2110:	f007 f9e2 	bl	94d8 <String::~String()>
    2114:	682b      	ldr	r3, [r5, #0]
  dprint(PRINT_LUX_DEBUG, last_reading); dprint(PRINT_LUX_DEBUG, " readLux("); dprint(PRINT_LUX_DEBUG, id); dprint(PRINT_LUX_DEBUG, ")\t");
    2116:	4960      	ldr	r1, [pc, #384]	; (2298 <LuxManager::setLuxValue(double)+0x1a0>)
    2118:	9301      	str	r3, [sp, #4]
    211a:	a802      	add	r0, sp, #8
	return ret;
    211c:	9b01      	ldr	r3, [sp, #4]
    211e:	f104 0670 	add.w	r6, r4, #112	; 0x70
    2122:	f007 fa19 	bl	9558 <String::String(char const*)>
    2126:	a802      	add	r0, sp, #8
    2128:	f007 f9d6 	bl	94d8 <String::~String()>
    212c:	4631      	mov	r1, r6
    212e:	a802      	add	r0, sp, #8
    2130:	f007 fa26 	bl	9580 <String::String(String const&)>
    2134:	a802      	add	r0, sp, #8
    2136:	f007 f9cf 	bl	94d8 <String::~String()>
    213a:	4958      	ldr	r1, [pc, #352]	; (229c <LuxManager::setLuxValue(double)+0x1a4>)
    213c:	a802      	add	r0, sp, #8
    213e:	f007 fa0b 	bl	9558 <String::String(char const*)>
    2142:	a802      	add	r0, sp, #8
    2144:	f007 f9c8 	bl	94d8 <String::~String()>
  if (temp > 10000) {
    2148:	4640      	mov	r0, r8
    214a:	4649      	mov	r1, r9
    214c:	a34e      	add	r3, pc, #312	; (adr r3, 2288 <LuxManager::setLuxValue(double)+0x190>)
    214e:	e9d3 2300 	ldrd	r2, r3, [r3]
    2152:	f00a ff3d 	bl	cfd0 <__aeabi_dcmpgt>
    2156:	b110      	cbz	r0, 215e <LuxManager::setLuxValue(double)+0x66>
      dprint(PRINT_LUX_READINGS, "\tbs: "); 
      dprintln(PRINT_LUX_READINGS, brightness_scaler);
  };
  updateMinMax();
  last_reading = 0;
}
    2158:	b006      	add	sp, #24
    215a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    lux = (lux + temp) * 0.5;
    checkForLuxOverValue();
    lux_total += lux;
    lux_readings++;
  } else {
    lux = temp;
    215e:	e9c4 8904 	strd	r8, r9, [r4, #16]
    checkForLuxOverValue();
    2162:	4620      	mov	r0, r4
    2164:	f7ff fe84 	bl	1e70 <LuxManager::checkForLuxOverValue()>
    lux_total += lux;
    2168:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
    216c:	e9d4 0138 	ldrd	r0, r1, [r4, #224]	; 0xe0
    2170:	f00a faec 	bl	c74c <__adddf3>
    lux_readings++;
    2174:	2200      	movs	r2, #0
    2176:	4b4a      	ldr	r3, [pc, #296]	; (22a0 <LuxManager::setLuxValue(double)+0x1a8>)
    lux_total += lux;
    lux_readings++;
  } else {
    lux = temp;
    checkForLuxOverValue();
    lux_total += lux;
    2178:	e9c4 0138 	strd	r0, r1, [r4, #224]	; 0xe0
    lux_readings++;
    217c:	e9d4 013a 	ldrd	r0, r1, [r4, #232]	; 0xe8
    2180:	f00a fae4 	bl	c74c <__adddf3>
    2184:	e9c4 013a 	strd	r0, r1, [r4, #232]	; 0xe8
  }
  dprint(PRINT_LUX_READINGS, id); dprint(PRINT_LUX_READINGS,":");
    2188:	4631      	mov	r1, r6
    218a:	a802      	add	r0, sp, #8
    218c:	f007 f9f8 	bl	9580 <String::String(String const&)>
    2190:	a802      	add	r0, sp, #8
    2192:	f007 f9a1 	bl	94d8 <String::~String()>
    2196:	4943      	ldr	r1, [pc, #268]	; (22a4 <LuxManager::setLuxValue(double)+0x1ac>)
    2198:	a802      	add	r0, sp, #8
    219a:	f007 f9dd 	bl	9558 <String::String(char const*)>
    219e:	a802      	add	r0, sp, #8
    21a0:	f007 f99a 	bl	94d8 <String::~String()>
  dprint(PRINT_LUX_READINGS, lux); dprintln(PRINT_LUX_READINGS,"");
    21a4:	4940      	ldr	r1, [pc, #256]	; (22a8 <LuxManager::setLuxValue(double)+0x1b0>)
    21a6:	a802      	add	r0, sp, #8
    21a8:	f007 f9d6 	bl	9558 <String::String(char const*)>
    21ac:	a802      	add	r0, sp, #8
    21ae:	f007 f993 	bl	94d8 <String::~String()>
  // update the brightness scales TODO , this logic does not work if the number of lux sensors is less than the number of groups
  // todo have the brightness scaler mapping
  brightness_scaler = calculateBrightnessScaler();
    21b2:	4620      	mov	r0, r4
    21b4:	f7ff feb6 	bl	1f24 <LuxManager::calculateBrightnessScaler()>
  num_brightness_scaler_vals++;
    21b8:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
  }
  dprint(PRINT_LUX_READINGS, id); dprint(PRINT_LUX_READINGS,":");
  dprint(PRINT_LUX_READINGS, lux); dprintln(PRINT_LUX_READINGS,"");
  // update the brightness scales TODO , this logic does not work if the number of lux sensors is less than the number of groups
  // todo have the brightness scaler mapping
  brightness_scaler = calculateBrightnessScaler();
    21bc:	4606      	mov	r6, r0
    21be:	460f      	mov	r7, r1
  num_brightness_scaler_vals++;
    21c0:	f103 0a01 	add.w	sl, r3, #1
  }
  dprint(PRINT_LUX_READINGS, id); dprint(PRINT_LUX_READINGS,":");
  dprint(PRINT_LUX_READINGS, lux); dprintln(PRINT_LUX_READINGS,"");
  // update the brightness scales TODO , this logic does not work if the number of lux sensors is less than the number of groups
  // todo have the brightness scaler mapping
  brightness_scaler = calculateBrightnessScaler();
    21c4:	e9c4 6706 	strd	r6, r7, [r4, #24]
  num_brightness_scaler_vals++;
  brightness_scaler_total += brightness_scaler;
    21c8:	e9d4 233c 	ldrd	r2, r3, [r4, #240]	; 0xf0
  dprint(PRINT_LUX_READINGS, id); dprint(PRINT_LUX_READINGS,":");
  dprint(PRINT_LUX_READINGS, lux); dprintln(PRINT_LUX_READINGS,"");
  // update the brightness scales TODO , this logic does not work if the number of lux sensors is less than the number of groups
  // todo have the brightness scaler mapping
  brightness_scaler = calculateBrightnessScaler();
  num_brightness_scaler_vals++;
    21cc:	f8c4 a0f8 	str.w	sl, [r4, #248]	; 0xf8
  brightness_scaler_total += brightness_scaler;
    21d0:	f00a fabc 	bl	c74c <__adddf3>
    21d4:	4680      	mov	r8, r0
    21d6:	4689      	mov	r9, r1
    21d8:	e9c4 893c 	strd	r8, r9, [r4, #240]	; 0xf0
  brightness_scaler_avg = brightness_scaler_total / num_brightness_scaler_vals;
    21dc:	4650      	mov	r0, sl
    21de:	f00a fbf1 	bl	c9c4 <__aeabi_ui2d>
    21e2:	4602      	mov	r2, r0
    21e4:	460b      	mov	r3, r1
    21e6:	4640      	mov	r0, r8
    21e8:	4649      	mov	r1, r9
    21ea:	f00a fd8b 	bl	cd04 <__aeabi_ddiv>

  neo->setBrightnessScaler(brightness_scaler);
    21ee:	f8d4 806c 	ldr.w	r8, [r4, #108]	; 0x6c
  // update the brightness scales TODO , this logic does not work if the number of lux sensors is less than the number of groups
  // todo have the brightness scaler mapping
  brightness_scaler = calculateBrightnessScaler();
  num_brightness_scaler_vals++;
  brightness_scaler_total += brightness_scaler;
  brightness_scaler_avg = brightness_scaler_total / num_brightness_scaler_vals;
    21f2:	e9c4 0108 	strd	r0, r1, [r4, #32]
    dprintln(PRINT_CLICK_DEBUG, "updated last_flash_upate to 0");
  }
}

void NeoGroup::updateAvgBrightnessScaler() {
  brightness_scaler_total += brightness_scaler;
    21f6:	4632      	mov	r2, r6
    21f8:	463b      	mov	r3, r7
    21fa:	e9d8 0132 	ldrd	r0, r1, [r8, #200]	; 0xc8
    ////////////////////////////// SHDN Timer ///////////////////////////////
    uint32_t getShdnLen();
    bool isInShutdown();
    void updateAvgBrightnessScaler();
    void resetAvgBrightnessScaler();
    void setBrightnessScaler(double scaler) {brightness_scaler = scaler;updateAvgBrightnessScaler();};
    21fe:	e9c8 6730 	strd	r6, r7, [r8, #192]	; 0xc0
    dprintln(PRINT_CLICK_DEBUG, "updated last_flash_upate to 0");
  }
}

void NeoGroup::updateAvgBrightnessScaler() {
  brightness_scaler_total += brightness_scaler;
    2202:	f00a faa3 	bl	c74c <__adddf3>
  brightness_scaler_changes++;
    2206:	2200      	movs	r2, #0
    2208:	4b25      	ldr	r3, [pc, #148]	; (22a0 <LuxManager::setLuxValue(double)+0x1a8>)
    dprintln(PRINT_CLICK_DEBUG, "updated last_flash_upate to 0");
  }
}

void NeoGroup::updateAvgBrightnessScaler() {
  brightness_scaler_total += brightness_scaler;
    220a:	e9c8 0132 	strd	r0, r1, [r8, #200]	; 0xc8
  brightness_scaler_changes++;
    220e:	e9d8 0134 	ldrd	r0, r1, [r8, #208]	; 0xd0
    2212:	f00a fa9b 	bl	c74c <__adddf3>
    2216:	e9c8 0134 	strd	r0, r1, [r8, #208]	; 0xd0

  neo->setBrightnessScaler(brightness_scaler);
  if (PRINT_BRIGHTNESS_SCALER_DEBUG == 0) {
      dprint(PRINT_LUX_READINGS, "\tbs: "); 
    221a:	4924      	ldr	r1, [pc, #144]	; (22ac <LuxManager::setLuxValue(double)+0x1b4>)
    221c:	a802      	add	r0, sp, #8
    221e:	f007 f99b 	bl	9558 <String::String(char const*)>
    2222:	a802      	add	r0, sp, #8
    2224:	f007 f958 	bl	94d8 <String::~String()>
    num_brightness_scaler_vals = 0;
    brightness_scaler_total = 0;
}

void LuxManager::updateMinMax() {
  if (lux < min_reading && lux > 0.0) {
    2228:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
    222c:	e9d4 2300 	ldrd	r2, r3, [r4]
    2230:	4630      	mov	r0, r6
    2232:	4639      	mov	r1, r7
    2234:	f00a feae 	bl	cf94 <__aeabi_dcmplt>
    2238:	b180      	cbz	r0, 225c <LuxManager::setLuxValue(double)+0x164>
    223a:	2200      	movs	r2, #0
    223c:	2300      	movs	r3, #0
    223e:	4630      	mov	r0, r6
    2240:	4639      	mov	r1, r7
    2242:	f00a fec5 	bl	cfd0 <__aeabi_dcmpgt>
    2246:	b148      	cbz	r0, 225c <LuxManager::setLuxValue(double)+0x164>
    min_reading = lux;
    2248:	e9c4 6700 	strd	r6, r7, [r4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    224c:	682b      	ldr	r3, [r5, #0]
    224e:	9302      	str	r3, [sp, #8]
	return ret;
    2250:	9b02      	ldr	r3, [sp, #8]
	elapsedMillis(unsigned long val) { ms = millis() - val; }
	elapsedMillis(const elapsedMillis &orig) { ms = orig.ms; }
	operator unsigned long () const { return millis() - ms; }
	elapsedMillis & operator = (const elapsedMillis &rhs) { ms = rhs.ms; return *this; }
	elapsedMillis & operator = (unsigned long val) { ms = millis() - val; return *this; }
    2252:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
      dprint(PRINT_LUX_READINGS, "\tbs: "); 
      dprintln(PRINT_LUX_READINGS, brightness_scaler);
  };
  updateMinMax();
  last_reading = 0;
}
    2256:	b006      	add	sp, #24
    2258:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
}

void LuxManager::updateMinMax() {
  if (lux < min_reading && lux > 0.0) {
    min_reading = lux;
  } else if (lux > max_reading && lux < 10000) {
    225c:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
    2260:	4630      	mov	r0, r6
    2262:	4639      	mov	r1, r7
    2264:	f00a feb4 	bl	cfd0 <__aeabi_dcmpgt>
    2268:	2800      	cmp	r0, #0
    226a:	d0ef      	beq.n	224c <LuxManager::setLuxValue(double)+0x154>
    226c:	a306      	add	r3, pc, #24	; (adr r3, 2288 <LuxManager::setLuxValue(double)+0x190>)
    226e:	e9d3 2300 	ldrd	r2, r3, [r3]
    2272:	4630      	mov	r0, r6
    2274:	4639      	mov	r1, r7
    2276:	f00a fe8d 	bl	cf94 <__aeabi_dcmplt>
    227a:	2800      	cmp	r0, #0
    227c:	d0e6      	beq.n	224c <LuxManager::setLuxValue(double)+0x154>
    max_reading = lux;
    227e:	e9c4 6702 	strd	r6, r7, [r4, #8]
    2282:	e7e3      	b.n	224c <LuxManager::setLuxValue(double)+0x154>
    2284:	f3af 8000 	nop.w
    2288:	00000000 	.word	0x00000000
    228c:	40c38800 	.word	0x40c38800
    2290:	0001121c 	.word	0x0001121c
    2294:	200045ec 	.word	0x200045ec
    2298:	00011230 	.word	0x00011230
    229c:	0001123c 	.word	0x0001123c
    22a0:	3ff00000 	.word	0x3ff00000
    22a4:	00010a7c 	.word	0x00010a7c
    22a8:	00010b88 	.word	0x00010b88
    22ac:	00011240 	.word	0x00011240

000022b0 <FeatureCollector::FeatureCollector(String)>:
    else {
        Serial.println("ERROR, can't link audio amplifier, there are not enough available slots");
    }
}

FeatureCollector::FeatureCollector(String _id) {
    22b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    22b4:	4604      	mov	r4, r0
    22b6:	4f36      	ldr	r7, [pc, #216]	; (2390 <FeatureCollector::FeatureCollector(String)+0xe0>)
    22b8:	2500      	movs	r5, #0
    22ba:	2600      	movs	r6, #0
    22bc:	f100 0828 	add.w	r8, r0, #40	; 0x28
    22c0:	b084      	sub	sp, #16
    22c2:	4689      	mov	r9, r1
    22c4:	e9c4 6700 	strd	r6, r7, [r4]
    22c8:	e9c4 6702 	strd	r6, r7, [r4, #8]
    22cc:	e9c4 6704 	strd	r6, r7, [r4, #16]
    22d0:	4640      	mov	r0, r8
    22d2:	f884 5021 	strb.w	r5, [r4, #33]	; 0x21
    22d6:	f884 5022 	strb.w	r5, [r4, #34]	; 0x22
    22da:	f884 5023 	strb.w	r5, [r4, #35]	; 0x23
    22de:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
    22e2:	f884 5025 	strb.w	r5, [r4, #37]	; 0x25
    22e6:	f884 5026 	strb.w	r5, [r4, #38]	; 0x26
    22ea:	492a      	ldr	r1, [pc, #168]	; (2394 <FeatureCollector::FeatureCollector(String)+0xe4>)
    22ec:	f007 f934 	bl	9558 <String::String(char const*)>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    22f0:	4b29      	ldr	r3, [pc, #164]	; (2398 <FeatureCollector::FeatureCollector(String)+0xe8>)
    22f2:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
    22f6:	681a      	ldr	r2, [r3, #0]
    22f8:	9203      	str	r2, [sp, #12]
	return ret;
    22fa:	9903      	ldr	r1, [sp, #12]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    22fc:	681a      	ldr	r2, [r3, #0]
    22fe:	9202      	str	r2, [sp, #8]
	return ret;
    2300:	9802      	ldr	r0, [sp, #8]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2302:	681a      	ldr	r2, [r3, #0]
    2304:	9201      	str	r2, [sp, #4]
class elapsedMillis
{
private:
	unsigned long ms;
public:
	elapsedMillis(void) { ms = millis(); }
    2306:	63e1      	str	r1, [r4, #60]	; 0x3c
	return ret;
    2308:	9901      	ldr	r1, [sp, #4]
    230a:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
    230e:	f8c4 10c4 	str.w	r1, [r4, #196]	; 0xc4
    2312:	2000      	movs	r0, #0
    2314:	2100      	movs	r1, #0
    2316:	f504 5e86 	add.w	lr, r4, #4288	; 0x10c0
    231a:	2201      	movs	r2, #1
    231c:	e9c4 012e 	strd	r0, r1, [r4, #184]	; 0xb8
    2320:	e9c4 0134 	strd	r0, r1, [r4, #208]	; 0xd0
    2324:	e9c4 6722 	strd	r6, r7, [r4, #136]	; 0x88
    2328:	e9c4 672c 	strd	r6, r7, [r4, #176]	; 0xb0
    232c:	f884 2038 	strb.w	r2, [r4, #56]	; 0x38
    2330:	f884 5051 	strb.w	r5, [r4, #81]	; 0x51
    2334:	f884 5052 	strb.w	r5, [r4, #82]	; 0x52
    2338:	f884 506c 	strb.w	r5, [r4, #108]	; 0x6c
    233c:	f884 50a0 	strb.w	r5, [r4, #160]	; 0xa0
    2340:	f8c4 50c0 	str.w	r5, [r4, #192]	; 0xc0
    2344:	f884 50cc 	strb.w	r5, [r4, #204]	; 0xcc
    2348:	f884 50dc 	strb.w	r5, [r4, #220]	; 0xdc
    234c:	f8a4 50f4 	strh.w	r5, [r4, #244]	; 0xf4
    2350:	f884 50f6 	strb.w	r5, [r4, #246]	; 0xf6
    2354:	f241 0afc 	movw	sl, #4348	; 0x10fc
    2358:	e9ce 6706 	strd	r6, r7, [lr, #24]
    235c:	f241 06fd 	movw	r6, #4349	; 0x10fd
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2360:	f8d3 c000 	ldr.w	ip, [r3]
    2364:	f504 5287 	add.w	r2, r4, #4320	; 0x10e0
    2368:	f241 1310 	movw	r3, #4368	; 0x1110
    236c:	e9c2 0104 	strd	r0, r1, [r2, #16]
    2370:	f804 500a 	strb.w	r5, [r4, sl]
    2374:	55a5      	strb	r5, [r4, r6]
    2376:	f8cd c000 	str.w	ip, [sp]
	return ret;
    237a:	9a00      	ldr	r2, [sp, #0]
    237c:	50e2      	str	r2, [r4, r3]
    name = _id;
    237e:	4640      	mov	r0, r8
    2380:	4649      	mov	r1, r9
    2382:	f007 f953 	bl	962c <String::operator=(String const&)>
}
    2386:	4620      	mov	r0, r4
    2388:	b004      	add	sp, #16
    238a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    238e:	bf00      	nop
    2390:	3ff00000 	.word	0x3ff00000
    2394:	00010b88 	.word	0x00010b88
    2398:	200045ec 	.word	0x200045ec

0000239c <FeatureCollector::updateGain(double)>:
        }
    }
    return highest;
}

void FeatureCollector::updateGain(double g) {
    239c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    23a0:	4616      	mov	r6, r2
    23a2:	461f      	mov	r7, r3
    23a4:	4604      	mov	r4, r0
    gain = g;
    23a6:	e9c0 6700 	strd	r6, r7, [r0]
    if (gain > max_gain) {
    23aa:	e9d0 2304 	ldrd	r2, r3, [r0, #16]
    23ae:	4639      	mov	r1, r7
    23b0:	4630      	mov	r0, r6
    23b2:	f00a fe0d 	bl	cfd0 <__aeabi_dcmpgt>
    23b6:	b108      	cbz	r0, 23bc <FeatureCollector::updateGain(double)+0x20>
        max_gain = gain;
    23b8:	e9c4 6704 	strd	r6, r7, [r4, #16]
    }
    if (gain < min_gain) {
    23bc:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
    23c0:	4630      	mov	r0, r6
    23c2:	4639      	mov	r1, r7
    23c4:	f00a fde6 	bl	cf94 <__aeabi_dcmplt>
    23c8:	b108      	cbz	r0, 23ce <FeatureCollector::updateGain(double)+0x32>
        min_gain = gain;
    23ca:	e9c4 6702 	strd	r6, r7, [r4, #8]
    }
    if (gain > gain_upper_limit) {
    23ce:	e9d4 8918 	ldrd	r8, r9, [r4, #96]	; 0x60
    23d2:	4630      	mov	r0, r6
    23d4:	4639      	mov	r1, r7
    23d6:	4642      	mov	r2, r8
    23d8:	464b      	mov	r3, r9
    23da:	f00a fdf9 	bl	cfd0 <__aeabi_dcmpgt>
    23de:	bb88      	cbnz	r0, 2444 <FeatureCollector::updateGain(double)+0xa8>
        gain = gain_upper_limit;
    }
    else if (gain < gain_lower_limit) {
    23e0:	e9d4 8916 	ldrd	r8, r9, [r4, #88]	; 0x58
    23e4:	4630      	mov	r0, r6
    23e6:	4639      	mov	r1, r7
    23e8:	4642      	mov	r2, r8
    23ea:	464b      	mov	r3, r9
    23ec:	f00a fdd2 	bl	cf94 <__aeabi_dcmplt>
    23f0:	bb40      	cbnz	r0, 2444 <FeatureCollector::updateGain(double)+0xa8>
        gain = gain_lower_limit;
    }
    for (int i =  0; i < audio_amp_add_idx; i++) {
    23f2:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
    23f6:	b35b      	cbz	r3, 2450 <FeatureCollector::updateGain(double)+0xb4>
    23f8:	4630      	mov	r0, r6
    23fa:	4639      	mov	r1, r7
    23fc:	f00a fe50 	bl	d0a0 <__aeabi_d2f>
    2400:	f104 063c 	add.w	r6, r4, #60	; 0x3c
    2404:	4680      	mov	r8, r0
    2406:	2500      	movs	r5, #0
public:
	AudioAmplifier(void) : AudioStream(1, inputQueueArray), multiplier(65536) {
	}
	virtual void update(void);
	void gain(float n) {
		if (n > 32767.0f) n = 32767.0f;
    2408:	4912      	ldr	r1, [pc, #72]	; (2454 <FeatureCollector::updateGain(double)+0xb8>)
        amp_ana[i]->gain(g);
    240a:	f856 7f04 	ldr.w	r7, [r6, #4]!
    240e:	4640      	mov	r0, r8
    2410:	f00b f960 	bl	d6d4 <__aeabi_fcmpgt>
		else if (n < -32767.0f) n = -32767.0f;
    2414:	4910      	ldr	r1, [pc, #64]	; (2458 <FeatureCollector::updateGain(double)+0xbc>)
public:
	AudioAmplifier(void) : AudioStream(1, inputQueueArray), multiplier(65536) {
	}
	virtual void update(void);
	void gain(float n) {
		if (n > 32767.0f) n = 32767.0f;
    2416:	4b11      	ldr	r3, [pc, #68]	; (245c <FeatureCollector::updateGain(double)+0xc0>)
    2418:	b960      	cbnz	r0, 2434 <FeatureCollector::updateGain(double)+0x98>
		else if (n < -32767.0f) n = -32767.0f;
    241a:	4640      	mov	r0, r8
    241c:	f00b f93c 	bl	d698 <__aeabi_fcmplt>
    2420:	f04f 418f 	mov.w	r1, #1199570944	; 0x47800000
    2424:	4b0e      	ldr	r3, [pc, #56]	; (2460 <FeatureCollector::updateGain(double)+0xc4>)
    2426:	b928      	cbnz	r0, 2434 <FeatureCollector::updateGain(double)+0x98>
    2428:	4640      	mov	r0, r8
    242a:	f00a ff97 	bl	d35c <__aeabi_fmul>
    242e:	f00b f971 	bl	d714 <__aeabi_f2iz>
    2432:	4603      	mov	r3, r0
		multiplier = n * 65536.0f;
    2434:	61bb      	str	r3, [r7, #24]
        gain = gain_upper_limit;
    }
    else if (gain < gain_lower_limit) {
        gain = gain_lower_limit;
    }
    for (int i =  0; i < audio_amp_add_idx; i++) {
    2436:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
    243a:	3501      	adds	r5, #1
    243c:	42ab      	cmp	r3, r5
    243e:	dce3      	bgt.n	2408 <FeatureCollector::updateGain(double)+0x6c>
    2440:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    2444:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
    }
    if (gain < min_gain) {
        min_gain = gain;
    }
    if (gain > gain_upper_limit) {
        gain = gain_upper_limit;
    2448:	e9c4 8900 	strd	r8, r9, [r4]
    }
    else if (gain < gain_lower_limit) {
        gain = gain_lower_limit;
    }
    for (int i =  0; i < audio_amp_add_idx; i++) {
    244c:	2b00      	cmp	r3, #0
    244e:	d1d3      	bne.n	23f8 <FeatureCollector::updateGain(double)+0x5c>
    2450:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    2454:	46fffe00 	.word	0x46fffe00
    2458:	c6fffe00 	.word	0xc6fffe00
    245c:	7fff0000 	.word	0x7fff0000
    2460:	80010000 	.word	0x80010000

00002464 <FeatureCollector::testMicrophoneRMS()>:
        amp_ana[i]->gain(g);
    }
}

bool FeatureCollector::testMicrophoneRMS() {
    2464:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2468:	f8df 9128 	ldr.w	r9, [pc, #296]	; 2594 <FeatureCollector::testMicrophoneRMS()+0x130>
    246c:	b082      	sub	sp, #8
    246e:	f8d9 3000 	ldr.w	r3, [r9]
    2472:	9300      	str	r3, [sp, #0]
    // go through and gather 10 features from each channel and make sure it is picking up audio
    uint8_t readings = 0;
    double values = 0.0;
    unsigned long a_time = millis();
    Serial.print("Testing ");Serial.print(name);Serial.println(" Microphone using RMS");
    2474:	f100 0828 	add.w	r8, r0, #40	; 0x28
    2478:	2108      	movs	r1, #8
    for (int i =  0; i < audio_amp_add_idx; i++) {
        amp_ana[i]->gain(g);
    }
}

bool FeatureCollector::testMicrophoneRMS() {
    247a:	4607      	mov	r7, r0
    247c:	483d      	ldr	r0, [pc, #244]	; (2574 <FeatureCollector::testMicrophoneRMS()+0x110>)
	return ret;
    247e:	9e00      	ldr	r6, [sp, #0]
    2480:	f009 f8be 	bl	b600 <usb_serial_write>
    // go through and gather 10 features from each channel and make sure it is picking up audio
    uint8_t readings = 0;
    double values = 0.0;
    unsigned long a_time = millis();
    Serial.print("Testing ");Serial.print(name);Serial.println(" Microphone using RMS");
    2484:	4641      	mov	r1, r8
    2486:	483c      	ldr	r0, [pc, #240]	; (2578 <FeatureCollector::testMicrophoneRMS()+0x114>)
    2488:	f006 fece 	bl	9228 <Print::print(String const&)>
    248c:	2115      	movs	r1, #21
    248e:	483b      	ldr	r0, [pc, #236]	; (257c <FeatureCollector::testMicrophoneRMS()+0x118>)
    2490:	f009 f8b6 	bl	b600 <usb_serial_write>
    2494:	4838      	ldr	r0, [pc, #224]	; (2578 <FeatureCollector::testMicrophoneRMS()+0x114>)
    2496:	f006 feed 	bl	9274 <Print::println()>
    249a:	f206 56dc 	addw	r6, r6, #1500	; 0x5dc
}

bool FeatureCollector::testMicrophoneRMS() {
    // go through and gather 10 features from each channel and make sure it is picking up audio
    uint8_t readings = 0;
    double values = 0.0;
    249e:	2400      	movs	r4, #0
    24a0:	2500      	movs	r5, #0
    }
}

bool FeatureCollector::testMicrophoneRMS() {
    // go through and gather 10 features from each channel and make sure it is picking up audio
    uint8_t readings = 0;
    24a2:	f04f 0a00 	mov.w	sl, #0
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    24a6:	f8d9 3000 	ldr.w	r3, [r9]
    24aa:	9301      	str	r3, [sp, #4]
	return ret;
    24ac:	9b01      	ldr	r3, [sp, #4]
    double values = 0.0;
    unsigned long a_time = millis();
    Serial.print("Testing ");Serial.print(name);Serial.println(" Microphone using RMS");
    while (readings < 10 && millis() < a_time + MICROPHONE_TEST_DURATION) {
    24ae:	429e      	cmp	r6, r3
    24b0:	d81c      	bhi.n	24ec <FeatureCollector::testMicrophoneRMS()+0x88>
            readings++;
            Serial.print(". ");
            delay(20);
        }
    }
    if (values > 0) {
    24b2:	4620      	mov	r0, r4
    24b4:	4629      	mov	r1, r5
    24b6:	2200      	movs	r2, #0
    24b8:	2300      	movs	r3, #0
    24ba:	f00a fd89 	bl	cfd0 <__aeabi_dcmpgt>
    24be:	4604      	mov	r4, r0
    24c0:	2800      	cmp	r0, #0
    24c2:	d038      	beq.n	2536 <FeatureCollector::testMicrophoneRMS()+0xd2>
        Serial.println();
    24c4:	482c      	ldr	r0, [pc, #176]	; (2578 <FeatureCollector::testMicrophoneRMS()+0x114>)
    24c6:	f006 fed5 	bl	9274 <Print::println()>
        Serial.print(name);
    24ca:	4641      	mov	r1, r8
    24cc:	482a      	ldr	r0, [pc, #168]	; (2578 <FeatureCollector::testMicrophoneRMS()+0x114>)
    24ce:	f006 feab 	bl	9228 <Print::print(String const&)>
    24d2:	2113      	movs	r1, #19
    24d4:	482a      	ldr	r0, [pc, #168]	; (2580 <FeatureCollector::testMicrophoneRMS()+0x11c>)
    24d6:	f009 f893 	bl	b600 <usb_serial_write>
    24da:	4827      	ldr	r0, [pc, #156]	; (2578 <FeatureCollector::testMicrophoneRMS()+0x114>)
    24dc:	f006 feca 	bl	9274 <Print::println()>
        Serial.println(" Microphone is good");
        microphone_active = true;
    24e0:	2001      	movs	r0, #1
    24e2:	f887 0038 	strb.w	r0, [r7, #56]	; 0x38
    Serial.println("\nERROR, ");
    Serial.print(name);Serial.println(" Microphone does not work");
    printDivideLn();
    microphone_active = false;
    return false;
}
    24e6:	b002      	add	sp, #8
    24e8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    uint8_t readings = 0;
    double values = 0.0;
    unsigned long a_time = millis();
    Serial.print("Testing ");Serial.print(name);Serial.println(" Microphone using RMS");
    while (readings < 10 && millis() < a_time + MICROPHONE_TEST_DURATION) {
        if (rms_ana->available()) {
    24ec:	6eb8      	ldr	r0, [r7, #104]	; 0x68
    24ee:	6a83      	ldr	r3, [r0, #40]	; 0x28
    24f0:	b933      	cbnz	r3, 2500 <FeatureCollector::testMicrophoneRMS()+0x9c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    24f2:	f8d9 3000 	ldr.w	r3, [r9]
    24f6:	9301      	str	r3, [sp, #4]
	return ret;
    24f8:	9b01      	ldr	r3, [sp, #4]
    // go through and gather 10 features from each channel and make sure it is picking up audio
    uint8_t readings = 0;
    double values = 0.0;
    unsigned long a_time = millis();
    Serial.print("Testing ");Serial.print(name);Serial.println(" Microphone using RMS");
    while (readings < 10 && millis() < a_time + MICROPHONE_TEST_DURATION) {
    24fa:	429e      	cmp	r6, r3
    24fc:	d8f9      	bhi.n	24f2 <FeatureCollector::testMicrophoneRMS()+0x8e>
    24fe:	e7d8      	b.n	24b2 <FeatureCollector::testMicrophoneRMS()+0x4e>
        if (rms_ana->available()) {
            values += rms_ana->read();
    2500:	f003 ff84 	bl	640c <AudioAnalyzeRMS::read()>
    2504:	f00a fa80 	bl	ca08 <__aeabi_f2d>
    2508:	4602      	mov	r2, r0
    250a:	460b      	mov	r3, r1
    250c:	4620      	mov	r0, r4
    250e:	4629      	mov	r1, r5
    2510:	f00a f91c 	bl	c74c <__adddf3>
            readings++;
    2514:	f10a 0a01 	add.w	sl, sl, #1
    double values = 0.0;
    unsigned long a_time = millis();
    Serial.print("Testing ");Serial.print(name);Serial.println(" Microphone using RMS");
    while (readings < 10 && millis() < a_time + MICROPHONE_TEST_DURATION) {
        if (rms_ana->available()) {
            values += rms_ana->read();
    2518:	4604      	mov	r4, r0
    251a:	460d      	mov	r5, r1
    251c:	4819      	ldr	r0, [pc, #100]	; (2584 <FeatureCollector::testMicrophoneRMS()+0x120>)
    251e:	2102      	movs	r1, #2
    2520:	f009 f86e 	bl	b600 <usb_serial_write>
            readings++;
    2524:	fa5f fa8a 	uxtb.w	sl, sl
            Serial.print(". ");
            delay(20);
    2528:	2014      	movs	r0, #20
    252a:	f007 fdf1 	bl	a110 <delay>
    // go through and gather 10 features from each channel and make sure it is picking up audio
    uint8_t readings = 0;
    double values = 0.0;
    unsigned long a_time = millis();
    Serial.print("Testing ");Serial.print(name);Serial.println(" Microphone using RMS");
    while (readings < 10 && millis() < a_time + MICROPHONE_TEST_DURATION) {
    252e:	f1ba 0f0a 	cmp.w	sl, #10
    2532:	d0be      	beq.n	24b2 <FeatureCollector::testMicrophoneRMS()+0x4e>
    2534:	e7b7      	b.n	24a6 <FeatureCollector::testMicrophoneRMS()+0x42>
    2536:	2108      	movs	r1, #8
    2538:	4813      	ldr	r0, [pc, #76]	; (2588 <FeatureCollector::testMicrophoneRMS()+0x124>)
    253a:	f009 f861 	bl	b600 <usb_serial_write>
    253e:	480e      	ldr	r0, [pc, #56]	; (2578 <FeatureCollector::testMicrophoneRMS()+0x114>)
    2540:	f006 fe98 	bl	9274 <Print::println()>
        Serial.println(" Microphone is good");
        microphone_active = true;
        return true;
    } 
    Serial.println("\nERROR, ");
    Serial.print(name);Serial.println(" Microphone does not work");
    2544:	4641      	mov	r1, r8
    2546:	480c      	ldr	r0, [pc, #48]	; (2578 <FeatureCollector::testMicrophoneRMS()+0x114>)
    2548:	f006 fe6e 	bl	9228 <Print::print(String const&)>
    254c:	2119      	movs	r1, #25
    254e:	480f      	ldr	r0, [pc, #60]	; (258c <FeatureCollector::testMicrophoneRMS()+0x128>)
    2550:	f009 f856 	bl	b600 <usb_serial_write>
    2554:	4808      	ldr	r0, [pc, #32]	; (2578 <FeatureCollector::testMicrophoneRMS()+0x114>)
    2556:	f006 fe8d 	bl	9274 <Print::println()>
    255a:	2126      	movs	r1, #38	; 0x26
    255c:	480c      	ldr	r0, [pc, #48]	; (2590 <FeatureCollector::testMicrophoneRMS()+0x12c>)
    255e:	f009 f84f 	bl	b600 <usb_serial_write>
    2562:	4805      	ldr	r0, [pc, #20]	; (2578 <FeatureCollector::testMicrophoneRMS()+0x114>)
    2564:	f006 fe86 	bl	9274 <Print::println()>
    printDivideLn();
    microphone_active = false;
    return false;
    2568:	4620      	mov	r0, r4
        return true;
    } 
    Serial.println("\nERROR, ");
    Serial.print(name);Serial.println(" Microphone does not work");
    printDivideLn();
    microphone_active = false;
    256a:	f887 4038 	strb.w	r4, [r7, #56]	; 0x38
    return false;
}
    256e:	b002      	add	sp, #8
    2570:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2574:	00011290 	.word	0x00011290
    2578:	1fffbaf4 	.word	0x1fffbaf4
    257c:	0001129c 	.word	0x0001129c
    2580:	000112b8 	.word	0x000112b8
    2584:	000112b4 	.word	0x000112b4
    2588:	000112cc 	.word	0x000112cc
    258c:	000112d8 	.word	0x000112d8
    2590:	0001075c 	.word	0x0001075c
    2594:	200045ec 	.word	0x200045ec

00002598 <FeatureCollector::testMicrophonePeak()>:

bool FeatureCollector::testMicrophonePeak() {
    2598:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    259c:	f8df 817c 	ldr.w	r8, [pc, #380]	; 271c <FeatureCollector::testMicrophonePeak()+0x184>
    25a0:	b083      	sub	sp, #12
    25a2:	f8d8 3000 	ldr.w	r3, [r8]
    25a6:	9300      	str	r3, [sp, #0]
    25a8:	2125      	movs	r1, #37	; 0x25
    25aa:	4604      	mov	r4, r0
    25ac:	4851      	ldr	r0, [pc, #324]	; (26f4 <FeatureCollector::testMicrophonePeak()+0x15c>)
	return ret;
    25ae:	9d00      	ldr	r5, [sp, #0]
    25b0:	f009 f826 	bl	b600 <usb_serial_write>
    25b4:	4850      	ldr	r0, [pc, #320]	; (26f8 <FeatureCollector::testMicrophonePeak()+0x160>)
    25b6:	f006 fe5d 	bl	9274 <Print::println()>
    // go through and gather 10 features from each channel and make sure it is picking up audio
    uint8_t readings = 0;
    double values = 0.0;
    unsigned long a_time = millis();
    printDivide();
    Serial.print("Testing ");Serial.print(name);Serial.println(" Microphone using Peak");
    25ba:	f104 0b28 	add.w	fp, r4, #40	; 0x28
    25be:	2108      	movs	r1, #8
    25c0:	484e      	ldr	r0, [pc, #312]	; (26fc <FeatureCollector::testMicrophonePeak()+0x164>)
    25c2:	f009 f81d 	bl	b600 <usb_serial_write>
    25c6:	4659      	mov	r1, fp
    25c8:	484b      	ldr	r0, [pc, #300]	; (26f8 <FeatureCollector::testMicrophonePeak()+0x160>)
    25ca:	f006 fe2d 	bl	9228 <Print::print(String const&)>
    25ce:	2116      	movs	r1, #22
    25d0:	484b      	ldr	r0, [pc, #300]	; (2700 <FeatureCollector::testMicrophonePeak()+0x168>)
    25d2:	f009 f815 	bl	b600 <usb_serial_write>
    25d6:	4848      	ldr	r0, [pc, #288]	; (26f8 <FeatureCollector::testMicrophonePeak()+0x160>)
    25d8:	f006 fe4c 	bl	9274 <Print::println()>
    return false;
}

bool FeatureCollector::testMicrophonePeak() {
    // go through and gather 10 features from each channel and make sure it is picking up audio
    uint8_t readings = 0;
    25dc:	f04f 0a00 	mov.w	sl, #0
    25e0:	f205 55dc 	addw	r5, r5, #1500	; 0x5dc
		max_sample = -32768;
	}
	bool available(void) {
		__disable_irq();
		bool flag = new_output;
		if (flag) new_output = false;
    25e4:	46d1      	mov	r9, sl
    double values = 0.0;
    25e6:	2600      	movs	r6, #0
    25e8:	2700      	movs	r7, #0
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    25ea:	f8d8 3000 	ldr.w	r3, [r8]
    25ee:	9301      	str	r3, [sp, #4]
	return ret;
    25f0:	9b01      	ldr	r3, [sp, #4]
    unsigned long a_time = millis();
    printDivide();
    Serial.print("Testing ");Serial.print(name);Serial.println(" Microphone using Peak");
    while (readings < 10 && millis() < a_time + MICROPHONE_TEST_DURATION) {
    25f2:	429d      	cmp	r5, r3
    25f4:	d81c      	bhi.n	2630 <FeatureCollector::testMicrophonePeak()+0x98>
            readings++;
            Serial.print(". ");
            delay(20);
        }
    }
    if (values > 0) {
    25f6:	4630      	mov	r0, r6
    25f8:	4639      	mov	r1, r7
    25fa:	2200      	movs	r2, #0
    25fc:	2300      	movs	r3, #0
    25fe:	f00a fce7 	bl	cfd0 <__aeabi_dcmpgt>
    2602:	4605      	mov	r5, r0
    2604:	2800      	cmp	r0, #0
    2606:	d055      	beq.n	26b4 <FeatureCollector::testMicrophonePeak()+0x11c>
        Serial.println();
    2608:	483b      	ldr	r0, [pc, #236]	; (26f8 <FeatureCollector::testMicrophonePeak()+0x160>)
    260a:	f006 fe33 	bl	9274 <Print::println()>
        Serial.print(name);
    260e:	4659      	mov	r1, fp
    2610:	4839      	ldr	r0, [pc, #228]	; (26f8 <FeatureCollector::testMicrophonePeak()+0x160>)
    2612:	f006 fe09 	bl	9228 <Print::print(String const&)>
    2616:	2113      	movs	r1, #19
    2618:	483a      	ldr	r0, [pc, #232]	; (2704 <FeatureCollector::testMicrophonePeak()+0x16c>)
    261a:	f008 fff1 	bl	b600 <usb_serial_write>
    261e:	4836      	ldr	r0, [pc, #216]	; (26f8 <FeatureCollector::testMicrophonePeak()+0x160>)
    2620:	f006 fe28 	bl	9274 <Print::println()>
        Serial.println(" Microphone is good");
        microphone_active = true;
    2624:	2001      	movs	r0, #1
    2626:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38
    Serial.println("\nERROR, ");
    Serial.print(name);Serial.println(" Microphone does not work");
    printMinorDivideLn();
    microphone_active = false;
    return false;
}
    262a:	b003      	add	sp, #12
    262c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    double values = 0.0;
    unsigned long a_time = millis();
    printDivide();
    Serial.print("Testing ");Serial.print(name);Serial.println(" Microphone using Peak");
    while (readings < 10 && millis() < a_time + MICROPHONE_TEST_DURATION) {
        if (peak_ana->available()) {
    2630:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
	AudioAnalyzePeak(void) : AudioStream(1, inputQueueArray) {
		min_sample = 32767;
		max_sample = -32768;
	}
	bool available(void) {
		__disable_irq();
    2634:	b672      	cpsid	i
		bool flag = new_output;
    2636:	7f13      	ldrb	r3, [r2, #28]
		if (flag) new_output = false;
    2638:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    263c:	b10b      	cbz	r3, 2642 <FeatureCollector::testMicrophonePeak()+0xaa>
    263e:	f882 901c 	strb.w	r9, [r2, #28]
		__enable_irq();
    2642:	b662      	cpsie	i
    2644:	2900      	cmp	r1, #0
    2646:	d0d0      	beq.n	25ea <FeatureCollector::testMicrophonePeak()+0x52>
            values += peak_ana->read();
    2648:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
		return flag;
	}
	float read(void) {
		__disable_irq();
    264c:	b672      	cpsid	i
		int min = min_sample;
		int max = max_sample;
		min_sample = 32767;
    264e:	f647 72ff 	movw	r2, #32767	; 0x7fff
		max_sample = -32768;
    2652:	f44f 4100 	mov.w	r1, #32768	; 0x8000
		__enable_irq();
		return flag;
	}
	float read(void) {
		__disable_irq();
		int min = min_sample;
    2656:	f9b3 001e 	ldrsh.w	r0, [r3, #30]
		int max = max_sample;
		min_sample = 32767;
    265a:	83da      	strh	r2, [r3, #30]
		return flag;
	}
	float read(void) {
		__disable_irq();
		int min = min_sample;
		int max = max_sample;
    265c:	f9b3 2020 	ldrsh.w	r2, [r3, #32]
		min_sample = 32767;
		max_sample = -32768;
    2660:	8419      	strh	r1, [r3, #32]
		__enable_irq();
    2662:	b662      	cpsie	i
		min = abs(min);
		max = abs(max);
    2664:	ea82 73e2 	eor.w	r3, r2, r2, asr #31
		int min = min_sample;
		int max = max_sample;
		min_sample = 32767;
		max_sample = -32768;
		__enable_irq();
		min = abs(min);
    2668:	2800      	cmp	r0, #0
		max = abs(max);
    266a:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
		int min = min_sample;
		int max = max_sample;
		min_sample = 32767;
		max_sample = -32768;
		__enable_irq();
		min = abs(min);
    266e:	bfb8      	it	lt
    2670:	4240      	neglt	r0, r0
    2672:	4298      	cmp	r0, r3
    2674:	bfb8      	it	lt
    2676:	4618      	movlt	r0, r3
    2678:	f00a fe1c 	bl	d2b4 <__aeabi_i2f>
    267c:	4922      	ldr	r1, [pc, #136]	; (2708 <FeatureCollector::testMicrophonePeak()+0x170>)
    267e:	f00a ff21 	bl	d4c4 <__aeabi_fdiv>
    2682:	f00a f9c1 	bl	ca08 <__aeabi_f2d>
    2686:	4602      	mov	r2, r0
    2688:	460b      	mov	r3, r1
    268a:	4630      	mov	r0, r6
    268c:	4639      	mov	r1, r7
    268e:	f00a f85d 	bl	c74c <__adddf3>
            readings++;
    2692:	f10a 0a01 	add.w	sl, sl, #1
    unsigned long a_time = millis();
    printDivide();
    Serial.print("Testing ");Serial.print(name);Serial.println(" Microphone using Peak");
    while (readings < 10 && millis() < a_time + MICROPHONE_TEST_DURATION) {
        if (peak_ana->available()) {
            values += peak_ana->read();
    2696:	4606      	mov	r6, r0
    2698:	460f      	mov	r7, r1
    269a:	481c      	ldr	r0, [pc, #112]	; (270c <FeatureCollector::testMicrophonePeak()+0x174>)
    269c:	2102      	movs	r1, #2
    269e:	f008 ffaf 	bl	b600 <usb_serial_write>
            readings++;
    26a2:	fa5f fa8a 	uxtb.w	sl, sl
            Serial.print(". ");
            delay(20);
    26a6:	2014      	movs	r0, #20
    26a8:	f007 fd32 	bl	a110 <delay>
    uint8_t readings = 0;
    double values = 0.0;
    unsigned long a_time = millis();
    printDivide();
    Serial.print("Testing ");Serial.print(name);Serial.println(" Microphone using Peak");
    while (readings < 10 && millis() < a_time + MICROPHONE_TEST_DURATION) {
    26ac:	f1ba 0f0a 	cmp.w	sl, #10
    26b0:	d0a1      	beq.n	25f6 <FeatureCollector::testMicrophonePeak()+0x5e>
    26b2:	e79a      	b.n	25ea <FeatureCollector::testMicrophonePeak()+0x52>
    26b4:	2108      	movs	r1, #8
    26b6:	4816      	ldr	r0, [pc, #88]	; (2710 <FeatureCollector::testMicrophonePeak()+0x178>)
    26b8:	f008 ffa2 	bl	b600 <usb_serial_write>
    26bc:	480e      	ldr	r0, [pc, #56]	; (26f8 <FeatureCollector::testMicrophonePeak()+0x160>)
    26be:	f006 fdd9 	bl	9274 <Print::println()>
        Serial.println(" Microphone is good");
        microphone_active = true;
        return true;
    } 
    Serial.println("\nERROR, ");
    Serial.print(name);Serial.println(" Microphone does not work");
    26c2:	4659      	mov	r1, fp
    26c4:	480c      	ldr	r0, [pc, #48]	; (26f8 <FeatureCollector::testMicrophonePeak()+0x160>)
    26c6:	f006 fdaf 	bl	9228 <Print::print(String const&)>
    26ca:	2119      	movs	r1, #25
    26cc:	4811      	ldr	r0, [pc, #68]	; (2714 <FeatureCollector::testMicrophonePeak()+0x17c>)
    26ce:	f008 ff97 	bl	b600 <usb_serial_write>
    26d2:	4809      	ldr	r0, [pc, #36]	; (26f8 <FeatureCollector::testMicrophonePeak()+0x160>)
    26d4:	f006 fdce 	bl	9274 <Print::println()>
    26d8:	2126      	movs	r1, #38	; 0x26
    26da:	480f      	ldr	r0, [pc, #60]	; (2718 <FeatureCollector::testMicrophonePeak()+0x180>)
    26dc:	f008 ff90 	bl	b600 <usb_serial_write>
    26e0:	4805      	ldr	r0, [pc, #20]	; (26f8 <FeatureCollector::testMicrophonePeak()+0x160>)
    26e2:	f006 fdc7 	bl	9274 <Print::println()>
    printMinorDivideLn();
    microphone_active = false;
    return false;
    26e6:	4628      	mov	r0, r5
        return true;
    } 
    Serial.println("\nERROR, ");
    Serial.print(name);Serial.println(" Microphone does not work");
    printMinorDivideLn();
    microphone_active = false;
    26e8:	f884 5038 	strb.w	r5, [r4, #56]	; 0x38
    return false;
}
    26ec:	b003      	add	sp, #12
    26ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    26f2:	bf00      	nop
    26f4:	000107ac 	.word	0x000107ac
    26f8:	1fffbaf4 	.word	0x1fffbaf4
    26fc:	00011290 	.word	0x00011290
    2700:	000112f4 	.word	0x000112f4
    2704:	000112b8 	.word	0x000112b8
    2708:	46fffe00 	.word	0x46fffe00
    270c:	000112b4 	.word	0x000112b4
    2710:	000112cc 	.word	0x000112cc
    2714:	000112d8 	.word	0x000112d8
    2718:	0001070c 	.word	0x0001070c
    271c:	200045ec 	.word	0x200045ec

00002720 <FeatureCollector::testMicrophone()>:

bool FeatureCollector::testMicrophone () {
    if (rms_active) {
    2720:	f890 206c 	ldrb.w	r2, [r0, #108]	; 0x6c
    2724:	b982      	cbnz	r2, 2748 <FeatureCollector::testMicrophone()+0x28>
    printMinorDivideLn();
    microphone_active = false;
    return false;
}

bool FeatureCollector::testMicrophone () {
    2726:	b510      	push	{r4, lr}
    if (rms_active) {
        return testMicrophoneRMS();
    } else if (peak_active) {
    2728:	f890 40a0 	ldrb.w	r4, [r0, #160]	; 0xa0
    272c:	b944      	cbnz	r4, 2740 <FeatureCollector::testMicrophone()+0x20>
    272e:	214c      	movs	r1, #76	; 0x4c
    2730:	4806      	ldr	r0, [pc, #24]	; (274c <FeatureCollector::testMicrophone()+0x2c>)
    2732:	f008 ff65 	bl	b600 <usb_serial_write>
    2736:	4806      	ldr	r0, [pc, #24]	; (2750 <FeatureCollector::testMicrophone()+0x30>)
    2738:	f006 fd9c 	bl	9274 <Print::println()>
        return testMicrophonePeak();
    } else {
        Serial.println("Sorry unable to test microphone as neither the RMS or Peak feature is active");
        return false;
    }
}
    273c:	4620      	mov	r0, r4
    273e:	bd10      	pop	{r4, pc}
    2740:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

bool FeatureCollector::testMicrophone () {
    if (rms_active) {
        return testMicrophoneRMS();
    } else if (peak_active) {
        return testMicrophonePeak();
    2744:	f7ff bf28 	b.w	2598 <FeatureCollector::testMicrophonePeak()>
    return false;
}

bool FeatureCollector::testMicrophone () {
    if (rms_active) {
        return testMicrophoneRMS();
    2748:	f7ff be8c 	b.w	2464 <FeatureCollector::testMicrophoneRMS()>
    274c:	0001130c 	.word	0x0001130c
    2750:	1fffbaf4 	.word	0x1fffbaf4

00002754 <FeatureCollector::calculateSpectralFlux()>:
    }
}


//////////////// Update Functions ///////////////////////////////
void FeatureCollector::calculateSpectralFlux() {
    2754:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    double f = 0.0;
    if (last_fft_vals[0] != 0) {
    2758:	f500 659e 	add.w	r5, r0, #1264	; 0x4f0
    275c:	e9d5 6700 	ldrd	r6, r7, [r5]
    }
}


//////////////// Update Functions ///////////////////////////////
void FeatureCollector::calculateSpectralFlux() {
    2760:	4682      	mov	sl, r0
    double f = 0.0;
    if (last_fft_vals[0] != 0) {
    2762:	2200      	movs	r2, #0
    2764:	2300      	movs	r3, #0
    2766:	4630      	mov	r0, r6
    2768:	4639      	mov	r1, r7
    276a:	f00a fc09 	bl	cf80 <__aeabi_dcmpeq>
    276e:	bb50      	cbnz	r0, 27c6 <FeatureCollector::calculateSpectralFlux()+0x72>
    2770:	f10a 0bf0 	add.w	fp, sl, #240	; 0xf0
    2774:	247f      	movs	r4, #127	; 0x7f
    2776:	f04f 0800 	mov.w	r8, #0
    277a:	f04f 0900 	mov.w	r9, #0
    277e:	e001      	b.n	2784 <FeatureCollector::calculateSpectralFlux()+0x30>
    2780:	e9f5 6702 	ldrd	r6, r7, [r5, #8]!
        for (int i = 0; i < 127; i++) {
            f += pow((fft_vals[i] - last_fft_vals[i]), 2);
    2784:	4632      	mov	r2, r6
    2786:	463b      	mov	r3, r7
    2788:	e9fb 0102 	ldrd	r0, r1, [fp, #8]!
    278c:	f009 ffdc 	bl	c748 <__aeabi_dsub>
    2790:	4602      	mov	r2, r0
    2792:	460b      	mov	r3, r1
    2794:	f00a f98c 	bl	cab0 <__aeabi_dmul>
    2798:	4602      	mov	r2, r0
    279a:	460b      	mov	r3, r1
    279c:	4640      	mov	r0, r8
    279e:	4649      	mov	r1, r9
    27a0:	f009 ffd4 	bl	c74c <__adddf3>

//////////////// Update Functions ///////////////////////////////
void FeatureCollector::calculateSpectralFlux() {
    double f = 0.0;
    if (last_fft_vals[0] != 0) {
        for (int i = 0; i < 127; i++) {
    27a4:	3c01      	subs	r4, #1
            f += pow((fft_vals[i] - last_fft_vals[i]), 2);
    27a6:	4680      	mov	r8, r0
    27a8:	4689      	mov	r9, r1

//////////////// Update Functions ///////////////////////////////
void FeatureCollector::calculateSpectralFlux() {
    double f = 0.0;
    if (last_fft_vals[0] != 0) {
        for (int i = 0; i < 127; i++) {
    27aa:	d1e9      	bne.n	2780 <FeatureCollector::calculateSpectralFlux()+0x2c>
            f += pow((fft_vals[i] - last_fft_vals[i]), 2);
        }
        if (f != 0.0) {
    27ac:	2200      	movs	r2, #0
    27ae:	2300      	movs	r3, #0
    27b0:	f00a fbe6 	bl	cf80 <__aeabi_dcmpeq>
    27b4:	b928      	cbnz	r0, 27c2 <FeatureCollector::calculateSpectralFlux()+0x6e>
            flux = f;
    27b6:	f50a 5a88 	add.w	sl, sl, #4352	; 0x1100
    27ba:	e9ca 8902 	strd	r8, r9, [sl, #8]
    27be:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    27c2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    27c6:	2121      	movs	r1, #33	; 0x21
    27c8:	4802      	ldr	r0, [pc, #8]	; (27d4 <FeatureCollector::calculateSpectralFlux()+0x80>)
        }
    }
    else {
        Serial.print("last_fft_vals[0] is equal to zero");
    }
}
    27ca:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    27ce:	f008 bf17 	b.w	b600 <usb_serial_write>
    27d2:	bf00      	nop
    27d4:	0001135c 	.word	0x0001135c

000027d8 <FeatureCollector::getSpectralFlux()>:

double FeatureCollector::getSpectralFlux() {
    27d8:	b530      	push	{r4, r5, lr}
    dprint(print_flux, "flux: ");
    27da:	f890 4024 	ldrb.w	r4, [r0, #36]	; 0x24
    27de:	490e      	ldr	r1, [pc, #56]	; (2818 <FeatureCollector::getSpectralFlux()+0x40>)
    else {
        Serial.print("last_fft_vals[0] is equal to zero");
    }
}

double FeatureCollector::getSpectralFlux() {
    27e0:	b085      	sub	sp, #20
    27e2:	4605      	mov	r5, r0
    dprint(print_flux, "flux: ");
    27e4:	4668      	mov	r0, sp
    27e6:	f006 feb7 	bl	9558 <String::String(char const*)>
  Serial.print("\t");
}

///////////////////////////////////////////////////////////
void dprint(int conditional, String data) {
  if (conditional > 0) {
    27ea:	b11c      	cbz	r4, 27f4 <FeatureCollector::getSpectralFlux()+0x1c>
    Serial.print(data);
    27ec:	4669      	mov	r1, sp
    27ee:	480b      	ldr	r0, [pc, #44]	; (281c <FeatureCollector::getSpectralFlux()+0x44>)
    27f0:	f006 fd1a 	bl	9228 <Print::print(String const&)>
    27f4:	4668      	mov	r0, sp
    27f6:	f006 fe6f 	bl	94d8 <String::~String()>
    Serial.println(data);
  }
}

void dprintln(int conditional, double data) {
  if (conditional > 0) {
    27fa:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
    dprintln(print_flux, flux);
    27fe:	f505 5488 	add.w	r4, r5, #4352	; 0x1100
    2802:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
    2806:	3408      	adds	r4, #8
    2808:	b11b      	cbz	r3, 2812 <FeatureCollector::getSpectralFlux()+0x3a>
    280a:	f7fd fea3 	bl	554 <dprintln(int, double) [clone .part.4]>
    280e:	e9d4 0100 	ldrd	r0, r1, [r4]
    return flux;
}
    2812:	b005      	add	sp, #20
    2814:	bd30      	pop	{r4, r5, pc}
    2816:	bf00      	nop
    2818:	00011380 	.word	0x00011380
    281c:	1fffbaf4 	.word	0x1fffbaf4

00002820 <FeatureCollector::getCentroid()>:

/////////////// Calculate Features //////////////////////////////
double FeatureCollector::getCentroid() {
    2820:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2824:	f500 5386 	add.w	r3, r0, #4288	; 0x10c0
    2828:	e9d3 8906 	ldrd	r8, r9, [r3, #24]
    282c:	b085      	sub	sp, #20
    282e:	4683      	mov	fp, r0
    2830:	f100 05f8 	add.w	r5, r0, #248	; 0xf8
    2834:	f44f 7481 	mov.w	r4, #258	; 0x102
    double mags = 0.0;
    2838:	2600      	movs	r6, #0
    283a:	2700      	movs	r7, #0
    for (int i = 1; i < 127; i++) {
    283c:	f245 5aaa 	movw	sl, #21930	; 0x55aa
        // take the magnitude of all the bins
        // and multiply if by the mid frequency of the bin
        // then all it to the total cent value
        // we also have to remove the effect the FTT_SCALER has on the bins stored energy
        mags += fft_vals[i] * getBinsMidFreq256(i) / fft_scaler;
    2840:	4620      	mov	r0, r4
    2842:	f00a f8bf 	bl	c9c4 <__aeabi_ui2d>
    2846:	e9f5 2302 	ldrd	r2, r3, [r5, #8]!
    284a:	f00a f931 	bl	cab0 <__aeabi_dmul>
    284e:	4642      	mov	r2, r8
    2850:	464b      	mov	r3, r9
    2852:	f00a fa57 	bl	cd04 <__aeabi_ddiv>
    2856:	4602      	mov	r2, r0
    2858:	460b      	mov	r3, r1
    285a:	4630      	mov	r0, r6
    285c:	4639      	mov	r1, r7
    285e:	f009 ff75 	bl	c74c <__adddf3>
    2862:	34ac      	adds	r4, #172	; 0xac
}

/////////////// Calculate Features //////////////////////////////
double FeatureCollector::getCentroid() {
    double mags = 0.0;
    for (int i = 1; i < 127; i++) {
    2864:	4554      	cmp	r4, sl
        // take the magnitude of all the bins
        // and multiply if by the mid frequency of the bin
        // then all it to the total cent value
        // we also have to remove the effect the FTT_SCALER has on the bins stored energy
        mags += fft_vals[i] * getBinsMidFreq256(i) / fft_scaler;
    2866:	4606      	mov	r6, r0
    2868:	460f      	mov	r7, r1
}

/////////////// Calculate Features //////////////////////////////
double FeatureCollector::getCentroid() {
    double mags = 0.0;
    for (int i = 1; i < 127; i++) {
    286a:	d1e9      	bne.n	2840 <FeatureCollector::getCentroid()+0x20>
        // and multiply if by the mid frequency of the bin
        // then all it to the total cent value
        // we also have to remove the effect the FTT_SCALER has on the bins stored energy
        mags += fft_vals[i] * getBinsMidFreq256(i) / fft_scaler;
    }
    dprint(print_centroid, "centroid : ");
    286c:	f89b 4023 	ldrb.w	r4, [fp, #35]	; 0x23
    2870:	490b      	ldr	r1, [pc, #44]	; (28a0 <FeatureCollector::getCentroid()+0x80>)
    2872:	4668      	mov	r0, sp
    2874:	f006 fe70 	bl	9558 <String::String(char const*)>
  Serial.print("\t");
}

///////////////////////////////////////////////////////////
void dprint(int conditional, String data) {
  if (conditional > 0) {
    2878:	b11c      	cbz	r4, 2882 <FeatureCollector::getCentroid()+0x62>
    Serial.print(data);
    287a:	4669      	mov	r1, sp
    287c:	4809      	ldr	r0, [pc, #36]	; (28a4 <FeatureCollector::getCentroid()+0x84>)
    287e:	f006 fcd3 	bl	9228 <Print::print(String const&)>
    2882:	4668      	mov	r0, sp
    2884:	f006 fe28 	bl	94d8 <String::~String()>
    Serial.println(data);
  }
}

void dprintln(int conditional, double data) {
  if (conditional > 0) {
    2888:	f89b 3023 	ldrb.w	r3, [fp, #35]	; 0x23
    288c:	b11b      	cbz	r3, 2896 <FeatureCollector::getCentroid()+0x76>
    288e:	4630      	mov	r0, r6
    2890:	4639      	mov	r1, r7
    2892:	f7fd fe5f 	bl	554 <dprintln(int, double) [clone .part.4]>
    dprintln(print_centroid, mags);
    return mags;
}
    2896:	4630      	mov	r0, r6
    2898:	4639      	mov	r1, r7
    289a:	b005      	add	sp, #20
    289c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    28a0:	00011388 	.word	0x00011388
    28a4:	1fffbaf4 	.word	0x1fffbaf4

000028a8 <FeatureCollector::getSmoothedCentroid()>:
    dprint(print_centroid, "centroid : ");
    dprintln(print_centroid, mags);
    return mags;
}

double FeatureCollector::getSmoothedCentroid() {
    28a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    28ac:	f500 5386 	add.w	r3, r0, #4288	; 0x10c0
    28b0:	b089      	sub	sp, #36	; 0x24
    28b2:	e9d3 8906 	ldrd	r8, r9, [r3, #24]
    28b6:	9003      	str	r0, [sp, #12]
    28b8:	f100 0af0 	add.w	sl, r0, #240	; 0xf0
    28bc:	f500 659d 	add.w	r5, r0, #1256	; 0x4e8
    28c0:	2456      	movs	r4, #86	; 0x56
    double mags = 0.0;
    28c2:	2600      	movs	r6, #0
    28c4:	2700      	movs	r7, #0
    for (int i = 0; i < 127; i++) {
    28c6:	f245 5baa 	movw	fp, #21930	; 0x55aa
        // take the magnitude of all the bins
        // and multiply if by the mid frequency of the bin
        // then all it to the total cent value
        // we also have to remove the effect the FTT_SCALER has on the bins stored energy
        mags += fft_vals[i] * getBinsMidFreq256(i) / fft_scaler * 0.5;
    28ca:	4620      	mov	r0, r4
    28cc:	f00a f87a 	bl	c9c4 <__aeabi_ui2d>
    28d0:	e9fa 2302 	ldrd	r2, r3, [sl, #8]!
    28d4:	e9cd 0100 	strd	r0, r1, [sp]
    28d8:	f00a f8ea 	bl	cab0 <__aeabi_dmul>
    28dc:	4642      	mov	r2, r8
    28de:	464b      	mov	r3, r9
    28e0:	f00a fa10 	bl	cd04 <__aeabi_ddiv>
    28e4:	2200      	movs	r2, #0
    28e6:	4b1e      	ldr	r3, [pc, #120]	; (2960 <FeatureCollector::getSmoothedCentroid()+0xb8>)
    28e8:	f00a f8e2 	bl	cab0 <__aeabi_dmul>
    28ec:	4632      	mov	r2, r6
    28ee:	463b      	mov	r3, r7
    28f0:	f009 ff2c 	bl	c74c <__adddf3>
        mags += last_fft_vals[i] * getBinsMidFreq256(i) / fft_scaler * 0.5;
    28f4:	e9f5 2302 	ldrd	r2, r3, [r5, #8]!
    for (int i = 0; i < 127; i++) {
        // take the magnitude of all the bins
        // and multiply if by the mid frequency of the bin
        // then all it to the total cent value
        // we also have to remove the effect the FTT_SCALER has on the bins stored energy
        mags += fft_vals[i] * getBinsMidFreq256(i) / fft_scaler * 0.5;
    28f8:	4606      	mov	r6, r0
    28fa:	460f      	mov	r7, r1
        mags += last_fft_vals[i] * getBinsMidFreq256(i) / fft_scaler * 0.5;
    28fc:	e9dd 0100 	ldrd	r0, r1, [sp]
    2900:	f00a f8d6 	bl	cab0 <__aeabi_dmul>
    2904:	4642      	mov	r2, r8
    2906:	464b      	mov	r3, r9
    2908:	f00a f9fc 	bl	cd04 <__aeabi_ddiv>
    290c:	2200      	movs	r2, #0
    290e:	4b14      	ldr	r3, [pc, #80]	; (2960 <FeatureCollector::getSmoothedCentroid()+0xb8>)
    2910:	f00a f8ce 	bl	cab0 <__aeabi_dmul>
    2914:	4632      	mov	r2, r6
    2916:	463b      	mov	r3, r7
    2918:	f009 ff18 	bl	c74c <__adddf3>
    291c:	34ac      	adds	r4, #172	; 0xac
    return mags;
}

double FeatureCollector::getSmoothedCentroid() {
    double mags = 0.0;
    for (int i = 0; i < 127; i++) {
    291e:	455c      	cmp	r4, fp
        // take the magnitude of all the bins
        // and multiply if by the mid frequency of the bin
        // then all it to the total cent value
        // we also have to remove the effect the FTT_SCALER has on the bins stored energy
        mags += fft_vals[i] * getBinsMidFreq256(i) / fft_scaler * 0.5;
        mags += last_fft_vals[i] * getBinsMidFreq256(i) / fft_scaler * 0.5;
    2920:	4606      	mov	r6, r0
    2922:	460f      	mov	r7, r1
    return mags;
}

double FeatureCollector::getSmoothedCentroid() {
    double mags = 0.0;
    for (int i = 0; i < 127; i++) {
    2924:	d1d1      	bne.n	28ca <FeatureCollector::getSmoothedCentroid()+0x22>
        // then all it to the total cent value
        // we also have to remove the effect the FTT_SCALER has on the bins stored energy
        mags += fft_vals[i] * getBinsMidFreq256(i) / fft_scaler * 0.5;
        mags += last_fft_vals[i] * getBinsMidFreq256(i) / fft_scaler * 0.5;
    }
    dprint(print_centroid, "smoothed centroid : ");
    2926:	9b03      	ldr	r3, [sp, #12]
    2928:	490e      	ldr	r1, [pc, #56]	; (2964 <FeatureCollector::getSmoothedCentroid()+0xbc>)
    292a:	f893 4023 	ldrb.w	r4, [r3, #35]	; 0x23
    292e:	a804      	add	r0, sp, #16
    2930:	f006 fe12 	bl	9558 <String::String(char const*)>
  Serial.print("\t");
}

///////////////////////////////////////////////////////////
void dprint(int conditional, String data) {
  if (conditional > 0) {
    2934:	b11c      	cbz	r4, 293e <FeatureCollector::getSmoothedCentroid()+0x96>
    Serial.print(data);
    2936:	a904      	add	r1, sp, #16
    2938:	480b      	ldr	r0, [pc, #44]	; (2968 <FeatureCollector::getSmoothedCentroid()+0xc0>)
    293a:	f006 fc75 	bl	9228 <Print::print(String const&)>
    293e:	a804      	add	r0, sp, #16
    2940:	f006 fdca 	bl	94d8 <String::~String()>
    Serial.println(data);
  }
}

void dprintln(int conditional, double data) {
  if (conditional > 0) {
    2944:	9b03      	ldr	r3, [sp, #12]
    2946:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
    294a:	b11b      	cbz	r3, 2954 <FeatureCollector::getSmoothedCentroid()+0xac>
    294c:	4630      	mov	r0, r6
    294e:	4639      	mov	r1, r7
    2950:	f7fd fe00 	bl	554 <dprintln(int, double) [clone .part.4]>
    dprintln(print_centroid, mags);
    return mags;
}
    2954:	4630      	mov	r0, r6
    2956:	4639      	mov	r1, r7
    2958:	b009      	add	sp, #36	; 0x24
    295a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    295e:	bf00      	nop
    2960:	3fe00000 	.word	0x3fe00000
    2964:	00011394 	.word	0x00011394
    2968:	1fffbaf4 	.word	0x1fffbaf4

0000296c <FeatureCollector::calculateFFT()>:
    dprintln(print_centroid, mags);
    return mags;
}

void FeatureCollector::calculateFFT() {
    if (fft_active && fft_ana->available()) {
    296c:	f890 30f6 	ldrb.w	r3, [r0, #246]	; 0xf6
    2970:	2b00      	cmp	r3, #0
    2972:	f000 80be 	beq.w	2af2 <FeatureCollector::calculateFFT()+0x186>
    2976:	f8d0 30f0 	ldr.w	r3, [r0, #240]	; 0xf0
		prevblocks[1] = NULL;
		prevblocks[2] = NULL;
#endif
	}
	bool available() {
		if (outputflag == true) {
    297a:	f893 2722 	ldrb.w	r2, [r3, #1826]	; 0x722
    297e:	2a00      	cmp	r2, #0
    2980:	f000 80b7 	beq.w	2af2 <FeatureCollector::calculateFFT()+0x186>
    dprint(print_centroid, "centroid : ");
    dprintln(print_centroid, mags);
    return mags;
}

void FeatureCollector::calculateFFT() {
    2984:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			outputflag = false;
    2988:	2400      	movs	r4, #0
    298a:	b08b      	sub	sp, #44	; 0x2c
    298c:	4683      	mov	fp, r0
    298e:	f883 4722 	strb.w	r4, [r3, #1826]	; 0x722
    if (fft_active && fft_ana->available()) {
        dprint(PRINT_FFT_DEBUG, "FFT Available - ");
    2992:	495c      	ldr	r1, [pc, #368]	; (2b04 <FeatureCollector::calculateFFT()+0x198>)
    2994:	a806      	add	r0, sp, #24
    2996:	f006 fddf 	bl	9558 <String::String(char const*)>
    299a:	a806      	add	r0, sp, #24
    299c:	f006 fd9c 	bl	94d8 <String::~String()>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    29a0:	4b59      	ldr	r3, [pc, #356]	; (2b08 <FeatureCollector::calculateFFT()+0x19c>)
    29a2:	f8db 50f0 	ldr.w	r5, [fp, #240]	; 0xf0
    29a6:	681a      	ldr	r2, [r3, #0]
    29a8:	9204      	str	r2, [sp, #16]
	return ret;
    29aa:	9a04      	ldr	r2, [sp, #16]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    29ac:	681b      	ldr	r3, [r3, #0]
    29ae:	9305      	str	r3, [sp, #20]
	elapsedMillis(unsigned long val) { ms = millis() - val; }
	elapsedMillis(const elapsedMillis &orig) { ms = orig.ms; }
	operator unsigned long () const { return millis() - ms; }
	elapsedMillis & operator = (const elapsedMillis &rhs) { ms = rhs.ms; return *this; }
	elapsedMillis & operator = (unsigned long val) { ms = millis() - val; return *this; }
    29b0:	f241 1210 	movw	r2, #4368	; 0x1110
	return ret;
    29b4:	9905      	ldr	r1, [sp, #20]
    29b6:	f84b 1002 	str.w	r1, [fp, r2]
    29ba:	f50b 5386 	add.w	r3, fp, #4288	; 0x10c0
    29be:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
        dprint(PRINT_FFT_DEBUG, last_fft_reading);
        last_fft_reading = 0;
        fft_tot_energy = 0.0;
    29c2:	f50b 5287 	add.w	r2, fp, #4320	; 0x10e0
    29c6:	2600      	movs	r6, #0
    29c8:	2700      	movs	r7, #0
    29ca:	e9cd 0100 	strd	r0, r1, [sp]
    29ce:	e9c2 6700 	strd	r6, r7, [r2]
    29d2:	f10b 08f0 	add.w	r8, fp, #240	; 0xf0
    29d6:	9202      	str	r2, [sp, #8]
    29d8:	3516      	adds	r5, #22
    29da:	46c2      	mov	sl, r8
    29dc:	f50b 699d 	add.w	r9, fp, #1256	; 0x4e8
        // int highest = -1;
        // double highest_val = -1.0;
        for (int i = 0; i < 127; i++) {
            last_fft_vals[i] = fft_vals[i];
    29e0:	e9f8 2302 	ldrd	r2, r3, [r8, #8]!
            fft_vals[i] = fft_ana->read(i) * fft_scaler;
    29e4:	f835 0f02 	ldrh.w	r0, [r5, #2]!
        last_fft_reading = 0;
        fft_tot_energy = 0.0;
        // int highest = -1;
        // double highest_val = -1.0;
        for (int i = 0; i < 127; i++) {
            last_fft_vals[i] = fft_vals[i];
    29e8:	e9e9 2302 	strd	r2, r3, [r9, #8]!
            fft_vals[i] = fft_ana->read(i) * fft_scaler;
    29ec:	f00a fc5e 	bl	d2ac <__aeabi_ui2f>
    29f0:	f04f 5162 	mov.w	r1, #947912704	; 0x38800000
    29f4:	f00a fcb2 	bl	d35c <__aeabi_fmul>
    29f8:	f00a f806 	bl	ca08 <__aeabi_f2d>
    29fc:	e9dd 2300 	ldrd	r2, r3, [sp]
    2a00:	f00a f856 	bl	cab0 <__aeabi_dmul>
    2a04:	4602      	mov	r2, r0
    2a06:	460b      	mov	r3, r1
            fft_tot_energy += fft_vals[i];
    2a08:	4630      	mov	r0, r6
    2a0a:	4639      	mov	r1, r7
        fft_tot_energy = 0.0;
        // int highest = -1;
        // double highest_val = -1.0;
        for (int i = 0; i < 127; i++) {
            last_fft_vals[i] = fft_vals[i];
            fft_vals[i] = fft_ana->read(i) * fft_scaler;
    2a0c:	e9ea 2302 	strd	r2, r3, [sl, #8]!
            fft_tot_energy += fft_vals[i];
    2a10:	f009 fe9c 	bl	c74c <__adddf3>
        dprint(PRINT_FFT_DEBUG, last_fft_reading);
        last_fft_reading = 0;
        fft_tot_energy = 0.0;
        // int highest = -1;
        // double highest_val = -1.0;
        for (int i = 0; i < 127; i++) {
    2a14:	3401      	adds	r4, #1
    2a16:	2c7f      	cmp	r4, #127	; 0x7f
            last_fft_vals[i] = fft_vals[i];
            fft_vals[i] = fft_ana->read(i) * fft_scaler;
            fft_tot_energy += fft_vals[i];
    2a18:	4606      	mov	r6, r0
    2a1a:	460f      	mov	r7, r1
        dprint(PRINT_FFT_DEBUG, last_fft_reading);
        last_fft_reading = 0;
        fft_tot_energy = 0.0;
        // int highest = -1;
        // double highest_val = -1.0;
        for (int i = 0; i < 127; i++) {
    2a1c:	d1e0      	bne.n	29e0 <FeatureCollector::calculateFFT()+0x74>
                highest_val = fft_vals[i];
                highest = i;
            }
            */
        }
        if (scale_bin_values == true) {
    2a1e:	f89b 3020 	ldrb.w	r3, [fp, #32]
    2a22:	9a02      	ldr	r2, [sp, #8]
    2a24:	e9c2 6700 	strd	r6, r7, [r2]
    2a28:	2b00      	cmp	r3, #0
    2a2a:	d052      	beq.n	2ad2 <FeatureCollector::calculateFFT()+0x166>
            double scaler = 1.0 / fft_tot_energy;
    2a2c:	4602      	mov	r2, r0
    2a2e:	460b      	mov	r3, r1
    2a30:	2000      	movs	r0, #0
    2a32:	4936      	ldr	r1, [pc, #216]	; (2b0c <FeatureCollector::calculateFFT()+0x1a0>)
    2a34:	f00a f966 	bl	cd04 <__aeabi_ddiv>
            for (int i = min_bin; i < max_bin; i++) {
    2a38:	f241 02fa 	movw	r2, #4346	; 0x10fa
    2a3c:	f241 03f8 	movw	r3, #4344	; 0x10f8
    2a40:	f83b 5002 	ldrh.w	r5, [fp, r2]
    2a44:	f83b 3003 	ldrh.w	r3, [fp, r3]
    2a48:	429d      	cmp	r5, r3
                highest = i;
            }
            */
        }
        if (scale_bin_values == true) {
            double scaler = 1.0 / fft_tot_energy;
    2a4a:	e9cd 0100 	strd	r0, r1, [sp]
            for (int i = min_bin; i < max_bin; i++) {
    2a4e:	da40      	bge.n	2ad2 <FeatureCollector::calculateFFT()+0x166>
    2a50:	f205 141d 	addw	r4, r5, #285	; 0x11d
    2a54:	f505 79ce 	add.w	r9, r5, #412	; 0x19c
    2a58:	f105 081f 	add.w	r8, r5, #31
    2a5c:	f50b 5a87 	add.w	sl, fp, #4320	; 0x10e0
    2a60:	eb0b 04c4 	add.w	r4, fp, r4, lsl #3
    2a64:	eb0b 09c9 	add.w	r9, fp, r9, lsl #3
    2a68:	eb0b 08c8 	add.w	r8, fp, r8, lsl #3
    2a6c:	f8cd b00c 	str.w	fp, [sp, #12]
    2a70:	f8dd b008 	ldr.w	fp, [sp, #8]
    2a74:	f10a 0a18 	add.w	sl, sl, #24
                dprintln(PRINT_FFT_DEBUG, "Scaling FFT Magnitudes to the sum of 1.0 over bin range");
    2a78:	4925      	ldr	r1, [pc, #148]	; (2b10 <FeatureCollector::calculateFFT()+0x1a4>)
    2a7a:	a806      	add	r0, sp, #24
    2a7c:	f006 fd6c 	bl	9558 <String::String(char const*)>
    2a80:	a806      	add	r0, sp, #24
    2a82:	f006 fd29 	bl	94d8 <String::~String()>
                if (fft_tot_energy > 0) {
    2a86:	e9db 6700 	ldrd	r6, r7, [fp]
    2a8a:	2200      	movs	r2, #0
    2a8c:	2300      	movs	r3, #0
    2a8e:	4630      	mov	r0, r6
    2a90:	4639      	mov	r1, r7
    2a92:	f00a fa9d 	bl	cfd0 <__aeabi_dcmpgt>
            }
            */
        }
        if (scale_bin_values == true) {
            double scaler = 1.0 / fft_tot_energy;
            for (int i = min_bin; i < max_bin; i++) {
    2a96:	3501      	adds	r5, #1
                dprintln(PRINT_FFT_DEBUG, "Scaling FFT Magnitudes to the sum of 1.0 over bin range");
                if (fft_tot_energy > 0) {
                    last_scaled_fft_vals[i] = scaled_fft_vals[i];
                    scaled_fft_vals[i] = fft_vals[i] / fft_tot_energy * scaler;
    2a98:	4632      	mov	r2, r6
    2a9a:	463b      	mov	r3, r7
        }
        if (scale_bin_values == true) {
            double scaler = 1.0 / fft_tot_energy;
            for (int i = min_bin; i < max_bin; i++) {
                dprintln(PRINT_FFT_DEBUG, "Scaling FFT Magnitudes to the sum of 1.0 over bin range");
                if (fft_tot_energy > 0) {
    2a9c:	b168      	cbz	r0, 2aba <FeatureCollector::calculateFFT()+0x14e>
                    last_scaled_fft_vals[i] = scaled_fft_vals[i];
    2a9e:	e9d4 0100 	ldrd	r0, r1, [r4]
    2aa2:	e9c9 0100 	strd	r0, r1, [r9]
                    scaled_fft_vals[i] = fft_vals[i] / fft_tot_energy * scaler;
    2aa6:	e9d8 0100 	ldrd	r0, r1, [r8]
    2aaa:	f00a f92b 	bl	cd04 <__aeabi_ddiv>
    2aae:	e9dd 2300 	ldrd	r2, r3, [sp]
    2ab2:	f009 fffd 	bl	cab0 <__aeabi_dmul>
    2ab6:	e9c4 0100 	strd	r0, r1, [r4]
            }
            */
        }
        if (scale_bin_values == true) {
            double scaler = 1.0 / fft_tot_energy;
            for (int i = min_bin; i < max_bin; i++) {
    2aba:	f8ba 3000 	ldrh.w	r3, [sl]
    2abe:	42ab      	cmp	r3, r5
    2ac0:	f104 0408 	add.w	r4, r4, #8
    2ac4:	f109 0908 	add.w	r9, r9, #8
    2ac8:	f108 0808 	add.w	r8, r8, #8
    2acc:	dcd4      	bgt.n	2a78 <FeatureCollector::calculateFFT()+0x10c>
    2ace:	f8dd b00c 	ldr.w	fp, [sp, #12]
          printFFTVals();
        }
        // the 10 is to try and get more dynamic range out of the colour mapping
        //relative_bin_pos = (double)(highest_energy_idx - min_bin + ((max_bin - min_bin)*0.25) ) / (double)(max_bin - min_bin - ((max_bin - min_bin)*0.25));
        // if (relative_bin_pos > 1.0) { relative_bin_pos = 1.0;};
        if (calculate_centroid == true) {centroid = getCentroid();};
    2ad2:	f241 03fc 	movw	r3, #4348	; 0x10fc
    2ad6:	f81b 3003 	ldrb.w	r3, [fp, r3]
    2ada:	b95b      	cbnz	r3, 2af4 <FeatureCollector::calculateFFT()+0x188>
        if (calculate_flux == true) {calculateSpectralFlux();};
    2adc:	f241 03fd 	movw	r3, #4349	; 0x10fd
    2ae0:	f81b 3003 	ldrb.w	r3, [fp, r3]
    2ae4:	b113      	cbz	r3, 2aec <FeatureCollector::calculateFFT()+0x180>
    2ae6:	4658      	mov	r0, fp
    2ae8:	f7ff fe34 	bl	2754 <FeatureCollector::calculateSpectralFlux()>
    }
}
    2aec:	b00b      	add	sp, #44	; 0x2c
    2aee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2af2:	4770      	bx	lr
          printFFTVals();
        }
        // the 10 is to try and get more dynamic range out of the colour mapping
        //relative_bin_pos = (double)(highest_energy_idx - min_bin + ((max_bin - min_bin)*0.25) ) / (double)(max_bin - min_bin - ((max_bin - min_bin)*0.25));
        // if (relative_bin_pos > 1.0) { relative_bin_pos = 1.0;};
        if (calculate_centroid == true) {centroid = getCentroid();};
    2af4:	4658      	mov	r0, fp
    2af6:	f7ff fe93 	bl	2820 <FeatureCollector::getCentroid()>
    2afa:	f50b 5388 	add.w	r3, fp, #4352	; 0x1100
    2afe:	e9c3 0100 	strd	r0, r1, [r3]
    2b02:	e7eb      	b.n	2adc <FeatureCollector::calculateFFT()+0x170>
    2b04:	000113ac 	.word	0x000113ac
    2b08:	200045ec 	.word	0x200045ec
    2b0c:	3ff00000 	.word	0x3ff00000
    2b10:	000113c0 	.word	0x000113c0

00002b14 <FeatureCollector::calculateTone()>:
        if (calculate_flux == true) {calculateSpectralFlux();};
    }
}

void FeatureCollector::calculateTone() {
    if (tone_active && tone_ana->available()) {
    2b14:	f890 30cc 	ldrb.w	r3, [r0, #204]	; 0xcc
    2b18:	b1f3      	cbz	r3, 2b58 <FeatureCollector::calculateTone()+0x44>
    2b1a:	f8d0 20c8 	ldr.w	r2, [r0, #200]	; 0xc8
		  * (double)2147483647.999), cycles,
		  (float)AUDIO_SAMPLE_RATE_EXACT / freq * (float)cycles + 0.5f);
	}
	void set_params(int32_t coef, uint16_t cycles, uint16_t len);
	bool available(void) {
		__disable_irq();
    2b1e:	b672      	cpsid	i
		bool flag = new_output;
    2b20:	f892 3035 	ldrb.w	r3, [r2, #53]	; 0x35
		if (flag) new_output = false;
    2b24:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    2b28:	b113      	cbz	r3, 2b30 <FeatureCollector::calculateTone()+0x1c>
    2b2a:	2300      	movs	r3, #0
    2b2c:	f882 3035 	strb.w	r3, [r2, #53]	; 0x35
		__enable_irq();
    2b30:	b662      	cpsie	i
    2b32:	b189      	cbz	r1, 2b58 <FeatureCollector::calculateTone()+0x44>
        if (calculate_centroid == true) {centroid = getCentroid();};
        if (calculate_flux == true) {calculateSpectralFlux();};
    }
}

void FeatureCollector::calculateTone() {
    2b34:	b510      	push	{r4, lr}
    2b36:	4604      	mov	r4, r0
    if (tone_active && tone_ana->available()) {
        tone_level = tone_ana->read();
    2b38:	f8d0 00c8 	ldr.w	r0, [r0, #200]	; 0xc8
    2b3c:	f003 fc82 	bl	6444 <AudioAnalyzeToneDetect::read()>
    2b40:	f009 ff62 	bl	ca08 <__aeabi_f2d>
        printFFTVals();
    };
}

void FeatureCollector::printToneVals() {
    if (tone_active > 0) {
    2b44:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
    }
}

void FeatureCollector::calculateTone() {
    if (tone_active && tone_ana->available()) {
        tone_level = tone_ana->read();
    2b48:	e9c4 0134 	strd	r0, r1, [r4, #208]	; 0xd0
        printFFTVals();
    };
}

void FeatureCollector::printToneVals() {
    if (tone_active > 0) {
    2b4c:	b12b      	cbz	r3, 2b5a <FeatureCollector::calculateTone()+0x46>
    2b4e:	4620      	mov	r0, r4
void FeatureCollector::calculateTone() {
    if (tone_active && tone_ana->available()) {
        tone_level = tone_ana->read();
        printToneVals();
    }
}
    2b50:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    2b54:	f7fd bd26 	b.w	5a4 <FeatureCollector::printToneVals() [clone .part.38]>
    2b58:	4770      	bx	lr
    2b5a:	bd10      	pop	{r4, pc}

00002b5c <FeatureCollector::calculateFreq()>:

void FeatureCollector::calculateFreq() {
    if (freq_active  && freq_ana->available()) {
    2b5c:	f890 30dc 	ldrb.w	r3, [r0, #220]	; 0xdc
    2b60:	b903      	cbnz	r3, 2b64 <FeatureCollector::calculateFreq()+0x8>
    2b62:	4770      	bx	lr
        tone_level = tone_ana->read();
        printToneVals();
    }
}

void FeatureCollector::calculateFreq() {
    2b64:	b510      	push	{r4, lr}
    2b66:	4604      	mov	r4, r0
    if (freq_active  && freq_ana->available()) {
    2b68:	f8d0 00d8 	ldr.w	r0, [r0, #216]	; 0xd8
    2b6c:	f003 fbe2 	bl	6334 <AudioAnalyzeNoteFrequency::available()>
    2b70:	b1b8      	cbz	r0, 2ba2 <FeatureCollector::calculateFreq()+0x46>
        freq_val = freq_ana->read();
    2b72:	f8d4 00d8 	ldr.w	r0, [r4, #216]	; 0xd8
    2b76:	f003 fbe9 	bl	634c <AudioAnalyzeNoteFrequency::read()>
    2b7a:	f009 ff45 	bl	ca08 <__aeabi_f2d>
    2b7e:	e9c4 0138 	strd	r0, r1, [r4, #224]	; 0xe0
        freq_prob = freq_ana->probability();
    2b82:	f8d4 00d8 	ldr.w	r0, [r4, #216]	; 0xd8
    2b86:	f003 fbed 	bl	6364 <AudioAnalyzeNoteFrequency::probability()>
    2b8a:	f009 ff3d 	bl	ca08 <__aeabi_f2d>
        Serial.print("centroid: ");Serial.println(centroid);
    }
}

void FeatureCollector::printFreqVals() {
    if (freq_active > 0) {
    2b8e:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
}

void FeatureCollector::calculateFreq() {
    if (freq_active  && freq_ana->available()) {
        freq_val = freq_ana->read();
        freq_prob = freq_ana->probability();
    2b92:	e9c4 013a 	strd	r0, r1, [r4, #232]	; 0xe8
        Serial.print("centroid: ");Serial.println(centroid);
    }
}

void FeatureCollector::printFreqVals() {
    if (freq_active > 0) {
    2b96:	b12b      	cbz	r3, 2ba4 <FeatureCollector::calculateFreq()+0x48>
    2b98:	4620      	mov	r0, r4
    if (freq_active  && freq_ana->available()) {
        freq_val = freq_ana->read();
        freq_prob = freq_ana->probability();
        printFreqVals();
    }
}
    2b9a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    2b9e:	f7fd bd51 	b.w	644 <FeatureCollector::printFreqVals() [clone .part.41]>
    2ba2:	bd10      	pop	{r4, pc}
    2ba4:	bd10      	pop	{r4, pc}
    2ba6:	bf00      	nop

00002ba8 <FeatureCollector::calculatePeak()>:

void FeatureCollector::calculatePeak() {
    bool avail = peak_ana->available();
    2ba8:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
	AudioAnalyzePeak(void) : AudioStream(1, inputQueueArray) {
		min_sample = 32767;
		max_sample = -32768;
	}
	bool available(void) {
		__disable_irq();
    2bac:	b672      	cpsid	i
		bool flag = new_output;
    2bae:	7f13      	ldrb	r3, [r2, #28]
		if (flag) new_output = false;
    2bb0:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    2bb4:	b10b      	cbz	r3, 2bba <FeatureCollector::calculatePeak()+0x12>
    2bb6:	2300      	movs	r3, #0
    2bb8:	7713      	strb	r3, [r2, #28]
		__enable_irq();
    2bba:	b662      	cpsie	i
    if (peak_active && avail) {
    2bbc:	f890 30a0 	ldrb.w	r3, [r0, #160]	; 0xa0
    2bc0:	2b00      	cmp	r3, #0
    2bc2:	d06a      	beq.n	2c9a <FeatureCollector::calculatePeak()+0xf2>
    2bc4:	2900      	cmp	r1, #0
    2bc6:	d068      	beq.n	2c9a <FeatureCollector::calculatePeak()+0xf2>
        freq_prob = freq_ana->probability();
        printFreqVals();
    }
}

void FeatureCollector::calculatePeak() {
    2bc8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    bool avail = peak_ana->available();
    if (peak_active && avail) {
        double last = peak_val;
        peak_val =  peak_ana->read();
    2bcc:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
        freq_prob = freq_ana->probability();
        printFreqVals();
    }
}

void FeatureCollector::calculatePeak() {
    2bd0:	b085      	sub	sp, #20
    2bd2:	4604      	mov	r4, r0
    bool avail = peak_ana->available();
    if (peak_active && avail) {
        double last = peak_val;
    2bd4:	e9d0 672a 	ldrd	r6, r7, [r0, #168]	; 0xa8
		return flag;
	}
	float read(void) {
		__disable_irq();
    2bd8:	b672      	cpsid	i
		int min = min_sample;
		int max = max_sample;
		min_sample = 32767;
    2bda:	f647 75ff 	movw	r5, #32767	; 0x7fff
		max_sample = -32768;
    2bde:	f44f 4100 	mov.w	r1, #32768	; 0x8000
		__enable_irq();
		return flag;
	}
	float read(void) {
		__disable_irq();
		int min = min_sample;
    2be2:	f9b3 001e 	ldrsh.w	r0, [r3, #30]
		int max = max_sample;
    2be6:	f9b3 2020 	ldrsh.w	r2, [r3, #32]
		min_sample = 32767;
    2bea:	83dd      	strh	r5, [r3, #30]
		max_sample = -32768;
    2bec:	8419      	strh	r1, [r3, #32]
		__enable_irq();
    2bee:	b662      	cpsie	i
		min = abs(min);
		max = abs(max);
    2bf0:	ea82 73e2 	eor.w	r3, r2, r2, asr #31
		int min = min_sample;
		int max = max_sample;
		min_sample = 32767;
		max_sample = -32768;
		__enable_irq();
		min = abs(min);
    2bf4:	2800      	cmp	r0, #0
		max = abs(max);
    2bf6:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
		int min = min_sample;
		int max = max_sample;
		min_sample = 32767;
		max_sample = -32768;
		__enable_irq();
		min = abs(min);
    2bfa:	bfb8      	it	lt
    2bfc:	4240      	neglt	r0, r0
        peak_val =  peak_ana->read();
    2bfe:	4298      	cmp	r0, r3
    2c00:	bfb8      	it	lt
    2c02:	4618      	movlt	r0, r3
    2c04:	f00a fb56 	bl	d2b4 <__aeabi_i2f>
    2c08:	4928      	ldr	r1, [pc, #160]	; (2cac <FeatureCollector::calculatePeak()+0x104>)
    2c0a:	f00a fc5b 	bl	d4c4 <__aeabi_fdiv>
    2c0e:	f009 fefb 	bl	ca08 <__aeabi_f2d>
    2c12:	e9c4 012a 	strd	r0, r1, [r4, #168]	; 0xa8
        dprint(PRINT_PEAK_DEBUG, name);
    2c16:	f104 0128 	add.w	r1, r4, #40	; 0x28
    2c1a:	4668      	mov	r0, sp
    2c1c:	f006 fcb0 	bl	9580 <String::String(String const&)>
    2c20:	4668      	mov	r0, sp
    2c22:	f006 fc59 	bl	94d8 <String::~String()>
        dprint(PRINT_PEAK_DEBUG, " Peaks (normal, scaled, pos_delta):\t");
    2c26:	4922      	ldr	r1, [pc, #136]	; (2cb0 <FeatureCollector::calculatePeak()+0x108>)
    2c28:	4668      	mov	r0, sp
    2c2a:	f006 fc95 	bl	9558 <String::String(char const*)>
    2c2e:	4668      	mov	r0, sp
    2c30:	f006 fc52 	bl	94d8 <String::~String()>
        dprint(PRINT_PEAK_DEBUG, peak_val);
        peak_val *= peak_scaler;
    2c34:	e9d4 232c 	ldrd	r2, r3, [r4, #176]	; 0xb0
    2c38:	e9d4 012a 	ldrd	r0, r1, [r4, #168]	; 0xa8
    2c3c:	f009 ff38 	bl	cab0 <__aeabi_dmul>
    2c40:	e9c4 012a 	strd	r0, r1, [r4, #168]	; 0xa8
        dprint(PRINT_PEAK_DEBUG, "\t");
    2c44:	491b      	ldr	r1, [pc, #108]	; (2cb4 <FeatureCollector::calculatePeak()+0x10c>)
    2c46:	4668      	mov	r0, sp
    2c48:	f006 fc86 	bl	9558 <String::String(char const*)>
    2c4c:	4668      	mov	r0, sp
    2c4e:	f006 fc43 	bl	94d8 <String::~String()>
        dprint(PRINT_PEAK_DEBUG, peak_val);
        peak_pos_delta = getPosDelta(last, peak_val);
    2c52:	e9d4 892a 	ldrd	r8, r9, [r4, #168]	; 0xa8
#ifndef __AUDIO_UTILS__
#define __AUDIO_UTILS__

double getPosDelta(double last, double current) {
    if (current > last) {
    2c56:	4630      	mov	r0, r6
    2c58:	4639      	mov	r1, r7
    2c5a:	4642      	mov	r2, r8
    2c5c:	464b      	mov	r3, r9
    2c5e:	f00a f999 	bl	cf94 <__aeabi_dcmplt>
    2c62:	b9d8      	cbnz	r0, 2c9c <FeatureCollector::calculatePeak()+0xf4>
        return current - last;
    }
    return 0.0;
    2c64:	2000      	movs	r0, #0
    2c66:	2100      	movs	r1, #0
    2c68:	e9c4 0106 	strd	r0, r1, [r4, #24]
        dprint(PRINT_PEAK_DEBUG, "\t");
    2c6c:	4911      	ldr	r1, [pc, #68]	; (2cb4 <FeatureCollector::calculatePeak()+0x10c>)
    2c6e:	4668      	mov	r0, sp
    2c70:	f006 fc72 	bl	9558 <String::String(char const*)>
    2c74:	4668      	mov	r0, sp
    2c76:	f006 fc2f 	bl	94d8 <String::~String()>
        dprintln(PRINT_PEAK_DEBUG, peak_pos_delta);
        peak_totals += peak_val;
    2c7a:	e9d4 232a 	ldrd	r2, r3, [r4, #168]	; 0xa8
    2c7e:	e9d4 012e 	ldrd	r0, r1, [r4, #184]	; 0xb8
    2c82:	f009 fd63 	bl	c74c <__adddf3>
        peak_readings++;
    2c86:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
    2c8a:	3301      	adds	r3, #1
        dprint(PRINT_PEAK_DEBUG, "\t");
        dprint(PRINT_PEAK_DEBUG, peak_val);
        peak_pos_delta = getPosDelta(last, peak_val);
        dprint(PRINT_PEAK_DEBUG, "\t");
        dprintln(PRINT_PEAK_DEBUG, peak_pos_delta);
        peak_totals += peak_val;
    2c8c:	e9c4 012e 	strd	r0, r1, [r4, #184]	; 0xb8
        peak_readings++;
    2c90:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
    }
}
    2c94:	b005      	add	sp, #20
    2c96:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    2c9a:	4770      	bx	lr
#ifndef __AUDIO_UTILS__
#define __AUDIO_UTILS__

double getPosDelta(double last, double current) {
    if (current > last) {
        return current - last;
    2c9c:	4632      	mov	r2, r6
    2c9e:	463b      	mov	r3, r7
    2ca0:	4640      	mov	r0, r8
    2ca2:	4649      	mov	r1, r9
    2ca4:	f009 fd50 	bl	c748 <__aeabi_dsub>
    2ca8:	e7de      	b.n	2c68 <FeatureCollector::calculatePeak()+0xc0>
    2caa:	bf00      	nop
    2cac:	46fffe00 	.word	0x46fffe00
    2cb0:	000113f8 	.word	0x000113f8
    2cb4:	00010cc0 	.word	0x00010cc0

00002cb8 <FeatureCollector::calculateRMS()>:
        last_peak_reset = 0;
    }
}

void FeatureCollector::calculateRMS() {
    if (rms_active  && (rms_ana->available())) {
    2cb8:	f890 306c 	ldrb.w	r3, [r0, #108]	; 0x6c
    2cbc:	2b00      	cmp	r3, #0
    2cbe:	d038      	beq.n	2d32 <FeatureCollector::calculateRMS()+0x7a>
    2cc0:	6e83      	ldr	r3, [r0, #104]	; 0x68
    2cc2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    2cc4:	2a00      	cmp	r2, #0
    2cc6:	d034      	beq.n	2d32 <FeatureCollector::calculateRMS()+0x7a>
        peak_readings = 0;
        last_peak_reset = 0;
    }
}

void FeatureCollector::calculateRMS() {
    2cc8:	e92d 43d0 	stmdb	sp!, {r4, r6, r7, r8, r9, lr}
    2ccc:	4604      	mov	r4, r0
    if (rms_active  && (rms_ana->available())) {
            double _rms = rms_ana->read() * rms_scaler;
    2cce:	4618      	mov	r0, r3
    2cd0:	f003 fb9c 	bl	640c <AudioAnalyzeRMS::read()>
    2cd4:	f009 fe98 	bl	ca08 <__aeabi_f2d>
    2cd8:	e9d4 2322 	ldrd	r2, r3, [r4, #136]	; 0x88
    2cdc:	f009 fee8 	bl	cab0 <__aeabi_dmul>
        if (_rms > 0.0) {
    2ce0:	2200      	movs	r2, #0
    2ce2:	2300      	movs	r3, #0
    }
}

void FeatureCollector::calculateRMS() {
    if (rms_active  && (rms_ana->available())) {
            double _rms = rms_ana->read() * rms_scaler;
    2ce4:	4606      	mov	r6, r0
    2ce6:	460f      	mov	r7, r1
        if (_rms > 0.0) {
    2ce8:	f00a f972 	bl	cfd0 <__aeabi_dcmpgt>
    2cec:	b328      	cbz	r0, 2d3a <FeatureCollector::calculateRMS()+0x82>
            double temp = rms_val;
    2cee:	e9d4 891c 	ldrd	r8, r9, [r4, #112]	; 0x70
#ifndef __AUDIO_UTILS__
#define __AUDIO_UTILS__

double getPosDelta(double last, double current) {
    if (current > last) {
    2cf2:	4630      	mov	r0, r6
    2cf4:	4639      	mov	r1, r7
            rms_val = _rms;
    2cf6:	e9c4 671c 	strd	r6, r7, [r4, #112]	; 0x70
    2cfa:	4642      	mov	r2, r8
    2cfc:	464b      	mov	r3, r9
    2cfe:	f00a f967 	bl	cfd0 <__aeabi_dcmpgt>
    2d02:	b1b8      	cbz	r0, 2d34 <FeatureCollector::calculateRMS()+0x7c>
        return current - last;
    2d04:	4642      	mov	r2, r8
    2d06:	464b      	mov	r3, r9
    2d08:	4630      	mov	r0, r6
    2d0a:	4639      	mov	r1, r7
    2d0c:	f009 fd1c 	bl	c748 <__aeabi_dsub>
            rms_pos_delta = getPosDelta(temp, rms_val);
    2d10:	e9c4 0124 	strd	r0, r1, [r4, #144]	; 0x90
            rms_totals += rms_val;
    2d14:	463b      	mov	r3, r7
    2d16:	e9d4 011e 	ldrd	r0, r1, [r4, #120]	; 0x78
    2d1a:	4632      	mov	r2, r6
    2d1c:	f009 fd16 	bl	c74c <__adddf3>
            rms_readings++;
    2d20:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
    2d24:	3301      	adds	r3, #1
            double _rms = rms_ana->read() * rms_scaler;
        if (_rms > 0.0) {
            double temp = rms_val;
            rms_val = _rms;
            rms_pos_delta = getPosDelta(temp, rms_val);
            rms_totals += rms_val;
    2d26:	e9c4 011e 	strd	r0, r1, [r4, #120]	; 0x78
            rms_readings++;
    2d2a:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
    2d2e:	e8bd 83d0 	ldmia.w	sp!, {r4, r6, r7, r8, r9, pc}
    2d32:	4770      	bx	lr
    }
    return 0.0;
    2d34:	2000      	movs	r0, #0
    2d36:	2100      	movs	r1, #0
    2d38:	e7ea      	b.n	2d10 <FeatureCollector::calculateRMS()+0x58>
    2d3a:	2119      	movs	r1, #25
    2d3c:	4803      	ldr	r0, [pc, #12]	; (2d4c <FeatureCollector::calculateRMS()+0x94>)
    2d3e:	f008 fc5f 	bl	b600 <usb_serial_write>
    2d42:	4803      	ldr	r0, [pc, #12]	; (2d50 <FeatureCollector::calculateRMS()+0x98>)
        } else {
            Serial.println("WARNING RMS is equal to 0");
        }
    }
}
    2d44:	e8bd 43d0 	ldmia.w	sp!, {r4, r6, r7, r8, r9, lr}
    2d48:	f006 ba94 	b.w	9274 <Print::println()>
    2d4c:	00011420 	.word	0x00011420
    2d50:	1fffbaf4 	.word	0x1fffbaf4

00002d54 <FeatureCollector::printFeatures()>:
    return -1.0;
}

//////////////////////////////// Print Functions /////////////////////////////////////////
void FeatureCollector::printFeatures() {
    if (rms_active && print_rms) {
    2d54:	f890 306c 	ldrb.w	r3, [r0, #108]	; 0x6c
    Serial.println("ERROR  - FFT IS NOT AN ACTIVE AUDIO FEATURE : "); Serial.println(name);
    return -1.0;
}

//////////////////////////////// Print Functions /////////////////////////////////////////
void FeatureCollector::printFeatures() {
    2d58:	b510      	push	{r4, lr}
    2d5a:	4604      	mov	r4, r0
    if (rms_active && print_rms) {
    2d5c:	b113      	cbz	r3, 2d64 <FeatureCollector::printFeatures()+0x10>
    2d5e:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
    2d62:	b95b      	cbnz	r3, 2d7c <FeatureCollector::printFeatures()+0x28>
        printRMSVals();
    };
    if (peak_active && print_peak) {
    2d64:	f894 30a0 	ldrb.w	r3, [r4, #160]	; 0xa0
    2d68:	b13b      	cbz	r3, 2d7a <FeatureCollector::printFeatures()+0x26>
    2d6a:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
    2d6e:	b123      	cbz	r3, 2d7a <FeatureCollector::printFeatures()+0x26>
    2d70:	4620      	mov	r0, r4
        printToneVals();
    };
    if (fft_active && PRINT_FFT_VALS) {
        printFFTVals();
    };
}
    2d72:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    2d76:	f7fd bce3 	b.w	740 <FeatureCollector::printPeakVals() [clone .part.44]>
    2d7a:	bd10      	pop	{r4, pc}
    2d7c:	f7fd fc8c 	bl	698 <FeatureCollector::printRMSVals() [clone .part.43]>
    2d80:	e7f0      	b.n	2d64 <FeatureCollector::printFeatures()+0x10>
    2d82:	bf00      	nop

00002d84 <FeatureCollector::update()>:
        Serial.print(" average\t");Serial.println(getPeakAvg());
    }
}

/////////////////////////////////// UPDATE / INIT //////////////////////////////////////
void FeatureCollector::update() {
    2d84:	b530      	push	{r4, r5, lr}
    if (microphone_active == true) {
    2d86:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
        Serial.print(" average\t");Serial.println(getPeakAvg());
    }
}

/////////////////////////////////// UPDATE / INIT //////////////////////////////////////
void FeatureCollector::update() {
    2d8a:	b085      	sub	sp, #20
    2d8c:	4604      	mov	r4, r0
    if (microphone_active == true) {
    2d8e:	b14b      	cbz	r3, 2da4 <FeatureCollector::update()+0x20>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2d90:	4a1e      	ldr	r2, [pc, #120]	; (2e0c <FeatureCollector::update()+0x88>)
        if (last_update_timer > FC_UPDATE_RATE) {
    2d92:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
    2d94:	6813      	ldr	r3, [r2, #0]
    2d96:	9300      	str	r3, [sp, #0]
	return ret;
    2d98:	9b00      	ldr	r3, [sp, #0]
    2d9a:	1a5b      	subs	r3, r3, r1
    2d9c:	2b21      	cmp	r3, #33	; 0x21
    2d9e:	d81d      	bhi.n	2ddc <FeatureCollector::update()+0x58>
            Serial.print(name);
            Serial.println(" sorry the microphone does not work, not updating the feature collector");
            last_update_timer = 0;
        }
    }
}
    2da0:	b005      	add	sp, #20
    2da2:	bd30      	pop	{r4, r5, pc}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2da4:	4d19      	ldr	r5, [pc, #100]	; (2e0c <FeatureCollector::update()+0x88>)
            calculateFreq();
            printFeatures();
        }
    }
    else {
        if (last_update_timer > 3000){
    2da6:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
    2da8:	682b      	ldr	r3, [r5, #0]
    2daa:	9301      	str	r3, [sp, #4]
	return ret;
    2dac:	9b01      	ldr	r3, [sp, #4]
    2dae:	f640 32b8 	movw	r2, #3000	; 0xbb8
    2db2:	1a5b      	subs	r3, r3, r1
    2db4:	4293      	cmp	r3, r2
    2db6:	d9f3      	bls.n	2da0 <FeatureCollector::update()+0x1c>
            Serial.print(name);
    2db8:	f100 0128 	add.w	r1, r0, #40	; 0x28
    2dbc:	4814      	ldr	r0, [pc, #80]	; (2e10 <FeatureCollector::update()+0x8c>)
    2dbe:	f006 fa33 	bl	9228 <Print::print(String const&)>
    2dc2:	2147      	movs	r1, #71	; 0x47
    2dc4:	4813      	ldr	r0, [pc, #76]	; (2e14 <FeatureCollector::update()+0x90>)
    2dc6:	f008 fc1b 	bl	b600 <usb_serial_write>
    2dca:	4811      	ldr	r0, [pc, #68]	; (2e10 <FeatureCollector::update()+0x8c>)
    2dcc:	f006 fa52 	bl	9274 <Print::println()>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2dd0:	682b      	ldr	r3, [r5, #0]
    2dd2:	9302      	str	r3, [sp, #8]
	return ret;
    2dd4:	9b02      	ldr	r3, [sp, #8]
    2dd6:	63e3      	str	r3, [r4, #60]	; 0x3c
            Serial.println(" sorry the microphone does not work, not updating the feature collector");
            last_update_timer = 0;
        }
    }
}
    2dd8:	b005      	add	sp, #20
    2dda:	bd30      	pop	{r4, r5, pc}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2ddc:	6813      	ldr	r3, [r2, #0]
    2dde:	9303      	str	r3, [sp, #12]
	return ret;
    2de0:	9b03      	ldr	r3, [sp, #12]
    2de2:	63c3      	str	r3, [r0, #60]	; 0x3c
/////////////////////////////////// UPDATE / INIT //////////////////////////////////////
void FeatureCollector::update() {
    if (microphone_active == true) {
        if (last_update_timer > FC_UPDATE_RATE) {
            last_update_timer = 0;
            calculateRMS();
    2de4:	f7ff ff68 	bl	2cb8 <FeatureCollector::calculateRMS()>
            calculatePeak();
    2de8:	4620      	mov	r0, r4
    2dea:	f7ff fedd 	bl	2ba8 <FeatureCollector::calculatePeak()>
            calculateFFT();
    2dee:	4620      	mov	r0, r4
    2df0:	f7ff fdbc 	bl	296c <FeatureCollector::calculateFFT()>
            calculateTone();
    2df4:	4620      	mov	r0, r4
    2df6:	f7ff fe8d 	bl	2b14 <FeatureCollector::calculateTone()>
            calculateFreq();
    2dfa:	4620      	mov	r0, r4
    2dfc:	f7ff feae 	bl	2b5c <FeatureCollector::calculateFreq()>
            printFeatures();
    2e00:	4620      	mov	r0, r4
    2e02:	f7ff ffa7 	bl	2d54 <FeatureCollector::printFeatures()>
            Serial.print(name);
            Serial.println(" sorry the microphone does not work, not updating the feature collector");
            last_update_timer = 0;
        }
    }
}
    2e06:	b005      	add	sp, #20
    2e08:	bd30      	pop	{r4, r5, pc}
    2e0a:	bf00      	nop
    2e0c:	200045ec 	.word	0x200045ec
    2e10:	1fffbaf4 	.word	0x1fffbaf4
    2e14:	00011508 	.word	0x00011508

00002e18 <AutoGain::AutoGain(String, FeatureCollector*, FeatureCollector*, double, double, double)>:
    min_gain = min;
    max_gain = max;
    max_gain_adj = max_gain_a;
}

AutoGain::AutoGain(String _id, FeatureCollector *_fc, FeatureCollector *_fc2, double min, double max, double max_gain_a) {
    2e18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2e1c:	2500      	movs	r5, #0
    2e1e:	4604      	mov	r4, r0
    2e20:	b083      	sub	sp, #12
    2e22:	7005      	strb	r5, [r0, #0]
    2e24:	7045      	strb	r5, [r0, #1]
    2e26:	4689      	mov	r9, r1
    2e28:	3008      	adds	r0, #8
    2e2a:	4629      	mov	r1, r5
    2e2c:	f104 0850 	add.w	r8, r4, #80	; 0x50
    2e30:	4617      	mov	r7, r2
    2e32:	461e      	mov	r6, r3
    2e34:	e9dd ab0c 	ldrd	sl, fp, [sp, #48]	; 0x30
    2e38:	f006 fb8e 	bl	9558 <String::String(char const*)>
    2e3c:	4640      	mov	r0, r8
    2e3e:	4629      	mov	r1, r5
    2e40:	f006 fb8a 	bl	9558 <String::String(char const*)>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2e44:	4a12      	ldr	r2, [pc, #72]	; (2e90 <AutoGain::AutoGain(String, FeatureCollector*, FeatureCollector*, double, double, double)+0x78>)
    if (_fc->ampActive() == false) {
    2e46:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
    2e4a:	6812      	ldr	r2, [r2, #0]
    2e4c:	9201      	str	r2, [sp, #4]
	return ret;
    2e4e:	9a01      	ldr	r2, [sp, #4]
    min_gain = min;
    max_gain = max;
    max_gain_adj = max_gain_a;
}

AutoGain::AutoGain(String _id, FeatureCollector *_fc, FeatureCollector *_fc2, double min, double max, double max_gain_a) {
    2e50:	6665      	str	r5, [r4, #100]	; 0x64
class elapsedMillis
{
private:
	unsigned long ms;
public:
	elapsedMillis(void) { ms = millis(); }
    2e52:	6622      	str	r2, [r4, #96]	; 0x60
    if (_fc->ampActive() == false) {
    2e54:	b933      	cbnz	r3, 2e64 <AutoGain::AutoGain(String, FeatureCollector*, FeatureCollector*, double, double, double)+0x4c>
    2e56:	2156      	movs	r1, #86	; 0x56
    2e58:	480e      	ldr	r0, [pc, #56]	; (2e94 <AutoGain::AutoGain(String, FeatureCollector*, FeatureCollector*, double, double, double)+0x7c>)
    2e5a:	f008 fbd1 	bl	b600 <usb_serial_write>
    2e5e:	480e      	ldr	r0, [pc, #56]	; (2e98 <AutoGain::AutoGain(String, FeatureCollector*, FeatureCollector*, double, double, double)+0x80>)
    2e60:	f006 fa08 	bl	9274 <Print::println()>
        Serial.println("WARNING - \
                the passed feature collector does not have amplifiers active");
    }
    fc = _fc;
    fc2 = _fc2;
    id = _id;
    2e64:	4649      	mov	r1, r9
AutoGain::AutoGain(String _id, FeatureCollector *_fc, FeatureCollector *_fc2, double min, double max, double max_gain_a) {
    if (_fc->ampActive() == false) {
        Serial.println("WARNING - \
                the passed feature collector does not have amplifiers active");
    }
    fc = _fc;
    2e66:	66e7      	str	r7, [r4, #108]	; 0x6c
    fc2 = _fc2;
    2e68:	6726      	str	r6, [r4, #112]	; 0x70
    id = _id;
    2e6a:	4640      	mov	r0, r8
    2e6c:	f006 fbde 	bl	962c <String::operator=(String const&)>
    min_gain = min;
    max_gain = max;
    2e70:	e9dd 120e 	ldrd	r1, r2, [sp, #56]	; 0x38
    2e74:	e9c4 1208 	strd	r1, r2, [r4, #32]
    max_gain_adj = max_gain_a;
    2e78:	e9dd 1210 	ldrd	r1, r2, [sp, #64]	; 0x40
    second_collector = true;
    2e7c:	2301      	movs	r3, #1
}
    2e7e:	4620      	mov	r0, r4
                the passed feature collector does not have amplifiers active");
    }
    fc = _fc;
    fc2 = _fc2;
    id = _id;
    min_gain = min;
    2e80:	e9c4 ab06 	strd	sl, fp, [r4, #24]
    max_gain = max;
    max_gain_adj = max_gain_a;
    2e84:	e9c4 120a 	strd	r1, r2, [r4, #40]	; 0x28
    second_collector = true;
    2e88:	7063      	strb	r3, [r4, #1]
}
    2e8a:	b003      	add	sp, #12
    2e8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2e90:	200045ec 	.word	0x200045ec
    2e94:	00011550 	.word	0x00011550
    2e98:	1fffbaf4 	.word	0x1fffbaf4

00002e9c <AutoGain::calculateCost(double)>:
        }
    }
    return false;
}

double AutoGain::calculateCost(double val) {
    2e9c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    // the higher the cost, the more gain adjustment will happen
    // ranges from -1 to 1, with a neg value corresponding to a decrease in volume
    // if it is withen nominal range then simply return 0.0 for cost
    if (val < ext_min) {
    2ea0:	e9d0 670c 	ldrd	r6, r7, [r0, #48]	; 0x30
        }
    }
    return false;
}

double AutoGain::calculateCost(double val) {
    2ea4:	b086      	sub	sp, #24
    2ea6:	4682      	mov	sl, r0
    // the higher the cost, the more gain adjustment will happen
    // ranges from -1 to 1, with a neg value corresponding to a decrease in volume
    // if it is withen nominal range then simply return 0.0 for cost
    if (val < ext_min) {
    2ea8:	4639      	mov	r1, r7
    2eaa:	4630      	mov	r0, r6
        }
    }
    return false;
}

double AutoGain::calculateCost(double val) {
    2eac:	4614      	mov	r4, r2
    2eae:	461d      	mov	r5, r3
    // the higher the cost, the more gain adjustment will happen
    // ranges from -1 to 1, with a neg value corresponding to a decrease in volume
    // if it is withen nominal range then simply return 0.0 for cost
    if (val < ext_min) {
    2eb0:	f00a f88e 	bl	cfd0 <__aeabi_dcmpgt>
    2eb4:	2800      	cmp	r0, #0
    2eb6:	d154      	bne.n	2f62 <AutoGain::calculateCost(double)+0xc6>
        val = ext_min;
        dprint(PRINT_AUTO_GAIN, "Increasing ");
        dprint(PRINT_AUTO_GAIN, id);
        dprintln(PRINT_AUTO_GAIN, " autogain by the max amount due to external update");
        return 1.0;
    } else if (val > ext_max) {
    2eb8:	e9da 230e 	ldrd	r2, r3, [sl, #56]	; 0x38
    2ebc:	4620      	mov	r0, r4
    2ebe:	4629      	mov	r1, r5
    2ec0:	e9cd 2300 	strd	r2, r3, [sp]
    2ec4:	f00a f884 	bl	cfd0 <__aeabi_dcmpgt>
    2ec8:	2800      	cmp	r0, #0
    2eca:	f040 8082 	bne.w	2fd2 <AutoGain::calculateCost(double)+0x136>
        dprint(PRINT_AUTO_GAIN, "Decreasing");
        dprint(PRINT_AUTO_GAIN, id);
        dprintln(PRINT_AUTO_GAIN, " autogain by the max amount due to external update");
        return -1.0;
    }
    if (val > ext_low && val < ext_high) {
    2ece:	e9da 8910 	ldrd	r8, r9, [sl, #64]	; 0x40
    2ed2:	4620      	mov	r0, r4
    2ed4:	4629      	mov	r1, r5
    2ed6:	4642      	mov	r2, r8
    2ed8:	464b      	mov	r3, r9
    2eda:	f00a f879 	bl	cfd0 <__aeabi_dcmpgt>
    2ede:	b130      	cbz	r0, 2eee <AutoGain::calculateCost(double)+0x52>
    2ee0:	e9da 2312 	ldrd	r2, r3, [sl, #72]	; 0x48
    2ee4:	4620      	mov	r0, r4
    2ee6:	4629      	mov	r1, r5
    2ee8:	f00a f854 	bl	cf94 <__aeabi_dcmplt>
    2eec:	bb90      	cbnz	r0, 2f54 <AutoGain::calculateCost(double)+0xb8>
        return 0.0;
    }
    else if (val < ext_low) {
    2eee:	4642      	mov	r2, r8
    2ef0:	464b      	mov	r3, r9
    2ef2:	4620      	mov	r0, r4
    2ef4:	4629      	mov	r1, r5
    2ef6:	f00a f84d 	bl	cf94 <__aeabi_dcmplt>
    2efa:	2800      	cmp	r0, #0
    2efc:	d14e      	bne.n	2f9c <AutoGain::calculateCost(double)+0x100>
        // if thee gain needs to be raised
        return (val - ext_min) / (ext_low - ext_min);
    } else if (val > ext_high) {
    2efe:	e9da 6712 	ldrd	r6, r7, [sl, #72]	; 0x48
    2f02:	4620      	mov	r0, r4
    2f04:	4629      	mov	r1, r5
    2f06:	4632      	mov	r2, r6
    2f08:	463b      	mov	r3, r7
    2f0a:	f00a f861 	bl	cfd0 <__aeabi_dcmpgt>
    2f0e:	b308      	cbz	r0, 2f54 <AutoGain::calculateCost(double)+0xb8>
        return (1.0 - ((val - ext_high) / (ext_max- ext_high))) * -1;
    2f10:	4632      	mov	r2, r6
    2f12:	463b      	mov	r3, r7
    2f14:	4620      	mov	r0, r4
    2f16:	4629      	mov	r1, r5
    2f18:	f009 fc16 	bl	c748 <__aeabi_dsub>
    2f1c:	4632      	mov	r2, r6
    2f1e:	4604      	mov	r4, r0
    2f20:	460d      	mov	r5, r1
    2f22:	463b      	mov	r3, r7
    2f24:	e9dd 0100 	ldrd	r0, r1, [sp]
    2f28:	f009 fc0e 	bl	c748 <__aeabi_dsub>
    2f2c:	4602      	mov	r2, r0
    2f2e:	460b      	mov	r3, r1
    2f30:	4620      	mov	r0, r4
    2f32:	4629      	mov	r1, r5
    2f34:	f009 fee6 	bl	cd04 <__aeabi_ddiv>
    2f38:	4602      	mov	r2, r0
    2f3a:	460b      	mov	r3, r1
    2f3c:	2000      	movs	r0, #0
    2f3e:	4933      	ldr	r1, [pc, #204]	; (300c <AutoGain::calculateCost(double)+0x170>)
    2f40:	f009 fc02 	bl	c748 <__aeabi_dsub>
    2f44:	4603      	mov	r3, r0
    2f46:	f101 4200 	add.w	r2, r1, #2147483648	; 0x80000000
    }
    return 0.0;
}
    2f4a:	4618      	mov	r0, r3
    2f4c:	4611      	mov	r1, r2
    2f4e:	b006      	add	sp, #24
    2f50:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        dprint(PRINT_AUTO_GAIN, id);
        dprintln(PRINT_AUTO_GAIN, " autogain by the max amount due to external update");
        return -1.0;
    }
    if (val > ext_low && val < ext_high) {
        return 0.0;
    2f54:	2300      	movs	r3, #0
    2f56:	461a      	mov	r2, r3
        return (val - ext_min) / (ext_low - ext_min);
    } else if (val > ext_high) {
        return (1.0 - ((val - ext_high) / (ext_max- ext_high))) * -1;
    }
    return 0.0;
}
    2f58:	4618      	mov	r0, r3
    2f5a:	4611      	mov	r1, r2
    2f5c:	b006      	add	sp, #24
    2f5e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    // the higher the cost, the more gain adjustment will happen
    // ranges from -1 to 1, with a neg value corresponding to a decrease in volume
    // if it is withen nominal range then simply return 0.0 for cost
    if (val < ext_min) {
        val = ext_min;
        dprint(PRINT_AUTO_GAIN, "Increasing ");
    2f62:	492b      	ldr	r1, [pc, #172]	; (3010 <AutoGain::calculateCost(double)+0x174>)
    2f64:	a802      	add	r0, sp, #8
    2f66:	f006 faf7 	bl	9558 <String::String(char const*)>
    2f6a:	a802      	add	r0, sp, #8
    2f6c:	f006 fab4 	bl	94d8 <String::~String()>
        dprint(PRINT_AUTO_GAIN, id);
    2f70:	f10a 0150 	add.w	r1, sl, #80	; 0x50
    2f74:	a802      	add	r0, sp, #8
    2f76:	f006 fb03 	bl	9580 <String::String(String const&)>
    2f7a:	a802      	add	r0, sp, #8
    2f7c:	f006 faac 	bl	94d8 <String::~String()>
        dprintln(PRINT_AUTO_GAIN, " autogain by the max amount due to external update");
    2f80:	4924      	ldr	r1, [pc, #144]	; (3014 <AutoGain::calculateCost(double)+0x178>)
    2f82:	a802      	add	r0, sp, #8
    2f84:	f006 fae8 	bl	9558 <String::String(char const*)>
    2f88:	a802      	add	r0, sp, #8
    2f8a:	f006 faa5 	bl	94d8 <String::~String()>
        return 1.0;
    2f8e:	4a1f      	ldr	r2, [pc, #124]	; (300c <AutoGain::calculateCost(double)+0x170>)
    2f90:	2300      	movs	r3, #0
        return (val - ext_min) / (ext_low - ext_min);
    } else if (val > ext_high) {
        return (1.0 - ((val - ext_high) / (ext_max- ext_high))) * -1;
    }
    return 0.0;
}
    2f92:	4618      	mov	r0, r3
    2f94:	4611      	mov	r1, r2
    2f96:	b006      	add	sp, #24
    2f98:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (val > ext_low && val < ext_high) {
        return 0.0;
    }
    else if (val < ext_low) {
        // if thee gain needs to be raised
        return (val - ext_min) / (ext_low - ext_min);
    2f9c:	4632      	mov	r2, r6
    2f9e:	463b      	mov	r3, r7
    2fa0:	4620      	mov	r0, r4
    2fa2:	4629      	mov	r1, r5
    2fa4:	f009 fbd0 	bl	c748 <__aeabi_dsub>
    2fa8:	4632      	mov	r2, r6
    2faa:	4604      	mov	r4, r0
    2fac:	460d      	mov	r5, r1
    2fae:	463b      	mov	r3, r7
    2fb0:	4640      	mov	r0, r8
    2fb2:	4649      	mov	r1, r9
    2fb4:	f009 fbc8 	bl	c748 <__aeabi_dsub>
    2fb8:	4602      	mov	r2, r0
    2fba:	460b      	mov	r3, r1
    2fbc:	4620      	mov	r0, r4
    2fbe:	4629      	mov	r1, r5
    2fc0:	f009 fea0 	bl	cd04 <__aeabi_ddiv>
    2fc4:	4603      	mov	r3, r0
    2fc6:	460a      	mov	r2, r1
    } else if (val > ext_high) {
        return (1.0 - ((val - ext_high) / (ext_max- ext_high))) * -1;
    }
    return 0.0;
}
    2fc8:	4618      	mov	r0, r3
    2fca:	4611      	mov	r1, r2
    2fcc:	b006      	add	sp, #24
    2fce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        dprint(PRINT_AUTO_GAIN, id);
        dprintln(PRINT_AUTO_GAIN, " autogain by the max amount due to external update");
        return 1.0;
    } else if (val > ext_max) {
        val = ext_max;
        dprint(PRINT_AUTO_GAIN, "Decreasing");
    2fd2:	4911      	ldr	r1, [pc, #68]	; (3018 <AutoGain::calculateCost(double)+0x17c>)
    2fd4:	a802      	add	r0, sp, #8
    2fd6:	f006 fabf 	bl	9558 <String::String(char const*)>
    2fda:	a802      	add	r0, sp, #8
    2fdc:	f006 fa7c 	bl	94d8 <String::~String()>
        dprint(PRINT_AUTO_GAIN, id);
    2fe0:	f10a 0150 	add.w	r1, sl, #80	; 0x50
    2fe4:	a802      	add	r0, sp, #8
    2fe6:	f006 facb 	bl	9580 <String::String(String const&)>
    2fea:	a802      	add	r0, sp, #8
    2fec:	f006 fa74 	bl	94d8 <String::~String()>
        dprintln(PRINT_AUTO_GAIN, " autogain by the max amount due to external update");
    2ff0:	4908      	ldr	r1, [pc, #32]	; (3014 <AutoGain::calculateCost(double)+0x178>)
    2ff2:	a802      	add	r0, sp, #8
    2ff4:	f006 fab0 	bl	9558 <String::String(char const*)>
    2ff8:	a802      	add	r0, sp, #8
    2ffa:	f006 fa6d 	bl	94d8 <String::~String()>
        return -1.0;
    2ffe:	4a07      	ldr	r2, [pc, #28]	; (301c <AutoGain::calculateCost(double)+0x180>)
    3000:	2300      	movs	r3, #0
        return (val - ext_min) / (ext_low - ext_min);
    } else if (val > ext_high) {
        return (1.0 - ((val - ext_high) / (ext_max- ext_high))) * -1;
    }
    return 0.0;
}
    3002:	4618      	mov	r0, r3
    3004:	4611      	mov	r1, r2
    3006:	b006      	add	sp, #24
    3008:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    300c:	3ff00000 	.word	0x3ff00000
    3010:	000115a8 	.word	0x000115a8
    3014:	000115b4 	.word	0x000115b4
    3018:	000115e8 	.word	0x000115e8
    301c:	bff00000 	.word	0xbff00000

00003020 <AutoGain::updateExternal(double)>:
    ext_low = low;
    ext_high = high;
    ext_max = max;
}

bool AutoGain::updateExternal(double val) {
    3020:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3024:	4c4b      	ldr	r4, [pc, #300]	; (3154 <AutoGain::updateExternal(double)+0x134>)
	elapsedMillis(unsigned long val) { ms = millis() - val; }
	elapsedMillis(const elapsedMillis &orig) { ms = orig.ms; }
	operator unsigned long () const { return millis() - ms; }
    3026:	6e05      	ldr	r5, [r0, #96]	; 0x60
    3028:	6821      	ldr	r1, [r4, #0]
    // constrain the values
    if ((last_autogain > update_rate && read_once) || (read_once == false && last_autogain > start_delay)) {
    302a:	6e46      	ldr	r6, [r0, #100]	; 0x64
    ext_low = low;
    ext_high = high;
    ext_max = max;
}

bool AutoGain::updateExternal(double val) {
    302c:	b086      	sub	sp, #24
    302e:	9103      	str	r1, [sp, #12]
	return ret;
    3030:	9903      	ldr	r1, [sp, #12]
    // constrain the values
    if ((last_autogain > update_rate && read_once) || (read_once == false && last_autogain > start_delay)) {
    3032:	1b49      	subs	r1, r1, r5
    3034:	428e      	cmp	r6, r1
    3036:	7801      	ldrb	r1, [r0, #0]
    3038:	d277      	bcs.n	312a <AutoGain::updateExternal(double)+0x10a>
    303a:	2900      	cmp	r1, #0
    303c:	d07a      	beq.n	3134 <AutoGain::updateExternal(double)+0x114>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    303e:	6821      	ldr	r1, [r4, #0]
    3040:	9105      	str	r1, [sp, #20]
	return ret;
    3042:	9905      	ldr	r1, [sp, #20]
	elapsedMillis & operator = (const elapsedMillis &rhs) { ms = rhs.ms; return *this; }
	elapsedMillis & operator = (unsigned long val) { ms = millis() - val; return *this; }
    3044:	6601      	str	r1, [r0, #96]	; 0x60
        last_autogain = 0;
        read_once = true;
    3046:	2101      	movs	r1, #1
    3048:	7001      	strb	r1, [r0, #0]
    304a:	4682      	mov	sl, r0
        double cost = calculateCost(val);
    304c:	f7ff ff26 	bl	2e9c <AutoGain::calculateCost(double)>
        if (cost != 0.0) {
    3050:	2200      	movs	r2, #0
    3052:	2300      	movs	r3, #0
bool AutoGain::updateExternal(double val) {
    // constrain the values
    if ((last_autogain > update_rate && read_once) || (read_once == false && last_autogain > start_delay)) {
        last_autogain = 0;
        read_once = true;
        double cost = calculateCost(val);
    3054:	4604      	mov	r4, r0
    3056:	460d      	mov	r5, r1
        if (cost != 0.0) {
    3058:	f009 ff92 	bl	cf80 <__aeabi_dcmpeq>
    305c:	2800      	cmp	r0, #0
    305e:	d165      	bne.n	312c <AutoGain::updateExternal(double)+0x10c>
            double new_gain;
            new_gain = fc->gain + (fc->gain * cost * MAX_GAIN_ADJUSTMENT);
    3060:	f8da 306c 	ldr.w	r3, [sl, #108]	; 0x6c
    3064:	e9d3 6700 	ldrd	r6, r7, [r3]
    3068:	4620      	mov	r0, r4
    306a:	4632      	mov	r2, r6
    306c:	463b      	mov	r3, r7
    306e:	4629      	mov	r1, r5
    3070:	f009 fd1e 	bl	cab0 <__aeabi_dmul>
    3074:	2200      	movs	r2, #0
    3076:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
    307a:	f009 fd19 	bl	cab0 <__aeabi_dmul>
    307e:	4632      	mov	r2, r6
    3080:	463b      	mov	r3, r7
    3082:	f009 fb63 	bl	c74c <__adddf3>
//#include <algorithm> // this isn't really needed, is it?  (slows down compiling)
#include <utility>
// https://forum.pjrc.com/threads/44596-Teensyduino-1-37-Beta-2-(Arduino-1-8-3-support)?p=145150&viewfull=1#post145150
template<class A, class B>
constexpr auto min(A&& a, B&& b) -> decltype(a < b ? std::forward<A>(a) : std::forward<B>(b)) {
  return a < b ? std::forward<A>(a) : std::forward<B>(b);
    3086:	e9da 8908 	ldrd	r8, r9, [sl, #32]
    308a:	4642      	mov	r2, r8
    308c:	464b      	mov	r3, r9
    308e:	4606      	mov	r6, r0
    3090:	460f      	mov	r7, r1
    3092:	f009 ff9d 	bl	cfd0 <__aeabi_dcmpgt>
    3096:	b108      	cbz	r0, 309c <AutoGain::updateExternal(double)+0x7c>
            new_gain = min(max_gain, new_gain);
    3098:	4646      	mov	r6, r8
    309a:	464f      	mov	r7, r9
    309c:	2109      	movs	r1, #9
    309e:	482e      	ldr	r0, [pc, #184]	; (3158 <AutoGain::updateExternal(double)+0x138>)
    30a0:	f008 faae 	bl	b600 <usb_serial_write>
            Serial.print("updating ");Serial.print(id);Serial.print(" ");Serial.print(ext_id);
    30a4:	f10a 0150 	add.w	r1, sl, #80	; 0x50
    30a8:	482c      	ldr	r0, [pc, #176]	; (315c <AutoGain::updateExternal(double)+0x13c>)
    30aa:	f006 f8bd 	bl	9228 <Print::print(String const&)>
    30ae:	2101      	movs	r1, #1
    30b0:	482b      	ldr	r0, [pc, #172]	; (3160 <AutoGain::updateExternal(double)+0x140>)
    30b2:	f008 faa5 	bl	b600 <usb_serial_write>
    30b6:	f10a 0108 	add.w	r1, sl, #8
    30ba:	4828      	ldr	r0, [pc, #160]	; (315c <AutoGain::updateExternal(double)+0x13c>)
    30bc:	f006 f8b4 	bl	9228 <Print::print(String const&)>
    30c0:	210b      	movs	r1, #11
    30c2:	4828      	ldr	r0, [pc, #160]	; (3164 <AutoGain::updateExternal(double)+0x144>)
    30c4:	f008 fa9c 	bl	b600 <usb_serial_write>
            Serial.print(" gain from ");Serial.print(fc->gain);Serial.print(" to ");
    30c8:	f8da 306c 	ldr.w	r3, [sl, #108]	; 0x6c
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
    30cc:	4823      	ldr	r0, [pc, #140]	; (315c <AutoGain::updateExternal(double)+0x13c>)
    30ce:	f04f 0802 	mov.w	r8, #2
    30d2:	e9d3 2300 	ldrd	r2, r3, [r3]
    30d6:	f8cd 8000 	str.w	r8, [sp]
    30da:	f006 f925 	bl	9328 <Print::printFloat(double, unsigned char)>
    30de:	2104      	movs	r1, #4
    30e0:	4821      	ldr	r0, [pc, #132]	; (3168 <AutoGain::updateExternal(double)+0x148>)
    30e2:	f008 fa8d 	bl	b600 <usb_serial_write>
    30e6:	4632      	mov	r2, r6
    30e8:	463b      	mov	r3, r7
    30ea:	f8cd 8000 	str.w	r8, [sp]
    30ee:	481b      	ldr	r0, [pc, #108]	; (315c <AutoGain::updateExternal(double)+0x13c>)
    30f0:	f006 f91a 	bl	9328 <Print::printFloat(double, unsigned char)>
    30f4:	2110      	movs	r1, #16
    30f6:	481d      	ldr	r0, [pc, #116]	; (316c <AutoGain::updateExternal(double)+0x14c>)
    30f8:	f008 fa82 	bl	b600 <usb_serial_write>
    30fc:	4622      	mov	r2, r4
    30fe:	462b      	mov	r3, r5
    3100:	f8cd 8000 	str.w	r8, [sp]
    3104:	4815      	ldr	r0, [pc, #84]	; (315c <AutoGain::updateExternal(double)+0x13c>)
    3106:	f006 f90f 	bl	9328 <Print::printFloat(double, unsigned char)>
	size_t println(int n, int base)			{ return print(n, base) + println(); }
	size_t println(unsigned int n, int base)	{ return print(n, base) + println(); }
	size_t println(long n, int base)		{ return print(n, base) + println(); }
	size_t println(unsigned long n, int base)	{ return print(n, base) + println(); }

	size_t println(double n, int digits = 2)	{ return print(n, digits) + println(); }
    310a:	4814      	ldr	r0, [pc, #80]	; (315c <AutoGain::updateExternal(double)+0x13c>)
    310c:	f006 f8b2 	bl	9274 <Print::println()>
            Serial.print(new_gain);
            Serial.print(" with a cost of ");Serial.println(cost);// Serial.print(" auto_gain timer");Serial.print(last_autogain);
            // Serial.println(" / ");Serial.println(update_rate);
            // if there is a cost, then the gain needs to be adjusted
            fc->updateGain(new_gain);
    3110:	463b      	mov	r3, r7
    3112:	4632      	mov	r2, r6
    3114:	f8da 006c 	ldr.w	r0, [sl, #108]	; 0x6c
    3118:	f7ff f940 	bl	239c <FeatureCollector::updateGain(double)>
            if (second_collector) {
    311c:	f89a 3001 	ldrb.w	r3, [sl, #1]
    3120:	b98b      	cbnz	r3, 3146 <AutoGain::updateExternal(double)+0x126>
                fc2->updateGain(new_gain);
            }
            return true;
    3122:	2001      	movs	r0, #1
        }
    }
    return false;
}
    3124:	b006      	add	sp, #24
    3126:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ext_max = max;
}

bool AutoGain::updateExternal(double val) {
    // constrain the values
    if ((last_autogain > update_rate && read_once) || (read_once == false && last_autogain > start_delay)) {
    312a:	b119      	cbz	r1, 3134 <AutoGain::updateExternal(double)+0x114>
                fc2->updateGain(new_gain);
            }
            return true;
        }
    }
    return false;
    312c:	2000      	movs	r0, #0
}
    312e:	b006      	add	sp, #24
    3130:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    3134:	6821      	ldr	r1, [r4, #0]
    3136:	9104      	str	r1, [sp, #16]
	return ret;
    3138:	9904      	ldr	r1, [sp, #16]
    ext_max = max;
}

bool AutoGain::updateExternal(double val) {
    // constrain the values
    if ((last_autogain > update_rate && read_once) || (read_once == false && last_autogain > start_delay)) {
    313a:	6e86      	ldr	r6, [r0, #104]	; 0x68
    313c:	1b4d      	subs	r5, r1, r5
    313e:	42ae      	cmp	r6, r5
    3140:	f4ff af7d 	bcc.w	303e <AutoGain::updateExternal(double)+0x1e>
    3144:	e7f2      	b.n	312c <AutoGain::updateExternal(double)+0x10c>
            Serial.print(" with a cost of ");Serial.println(cost);// Serial.print(" auto_gain timer");Serial.print(last_autogain);
            // Serial.println(" / ");Serial.println(update_rate);
            // if there is a cost, then the gain needs to be adjusted
            fc->updateGain(new_gain);
            if (second_collector) {
                fc2->updateGain(new_gain);
    3146:	4632      	mov	r2, r6
    3148:	463b      	mov	r3, r7
    314a:	f8da 0070 	ldr.w	r0, [sl, #112]	; 0x70
    314e:	f7ff f925 	bl	239c <FeatureCollector::updateGain(double)>
    3152:	e7e6      	b.n	3122 <AutoGain::updateExternal(double)+0x102>
    3154:	200045ec 	.word	0x200045ec
    3158:	000115f4 	.word	0x000115f4
    315c:	1fffbaf4 	.word	0x1fffbaf4
    3160:	00010d30 	.word	0x00010d30
    3164:	00011600 	.word	0x00011600
    3168:	0001160c 	.word	0x0001160c
    316c:	00011614 	.word	0x00011614

00003170 <initAutoGain()>:
AudioConnection          patchCord29(song_post_amp1, song_rms1);
AudioConnection          patchCord30(song_post_amp1, song_peak1);
AudioConnection          patchCord31(song_post_amp1, 0, usb1, 1);
AudioConnection          patchCord32(click_input_amp1, input_fft);

void initAutoGain() {
    3170:	e92d 43d0 	stmdb	sp!, {r4, r6, r7, r8, r9, lr}
        fc2 = _fc;
    }
}

void AutoGain::setExternalThresholds(String _id, double min, double low, double high, double max) {
    ext_id = _id;
    3174:	4c2c      	ldr	r4, [pc, #176]	; (3228 <initAutoGain()+0xb8>)
  auto_gain[0].setExternalThresholds((String)"Led ON Ratio", MIN_ON_RATIO_THRESH, LOW_ON_RATIO_THRESH,
    3176:	492d      	ldr	r1, [pc, #180]	; (322c <initAutoGain()+0xbc>)
    ext_min = min;
    ext_low = low;
    3178:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 3240 <initAutoGain()+0xd0>
AudioConnection          patchCord29(song_post_amp1, song_rms1);
AudioConnection          patchCord30(song_post_amp1, song_peak1);
AudioConnection          patchCord31(song_post_amp1, 0, usb1, 1);
AudioConnection          patchCord32(click_input_amp1, input_fft);

void initAutoGain() {
    317c:	b084      	sub	sp, #16
  auto_gain[0].setExternalThresholds((String)"Led ON Ratio", MIN_ON_RATIO_THRESH, LOW_ON_RATIO_THRESH,
    317e:	4668      	mov	r0, sp
    3180:	f006 f9ea 	bl	9558 <String::String(char const*)>
        fc2 = _fc;
    }
}

void AutoGain::setExternalThresholds(String _id, double min, double low, double high, double max) {
    ext_id = _id;
    3184:	4669      	mov	r1, sp
    3186:	f104 0008 	add.w	r0, r4, #8
    318a:	f006 fa4f 	bl	962c <String::operator=(String const&)>
    ext_min = min;
    ext_low = low;
    318e:	a31e      	add	r3, pc, #120	; (adr r3, 3208 <initAutoGain()+0x98>)
    3190:	e9d3 2300 	ldrd	r2, r3, [r3]
    ext_high = high;
    3194:	a11e      	add	r1, pc, #120	; (adr r1, 3210 <initAutoGain()+0xa0>)
    3196:	e9d1 0100 	ldrd	r0, r1, [r1]
    }
}

void AutoGain::setExternalThresholds(String _id, double min, double low, double high, double max) {
    ext_id = _id;
    ext_min = min;
    319a:	a71f      	add	r7, pc, #124	; (adr r7, 3218 <initAutoGain()+0xa8>)
    319c:	e9d7 6700 	ldrd	r6, r7, [r7]
    ext_low = low;
    31a0:	e9c4 2310 	strd	r2, r3, [r4, #64]	; 0x40
    ext_high = high;
    ext_max = max;
    31a4:	a31e      	add	r3, pc, #120	; (adr r3, 3220 <initAutoGain()+0xb0>)
    31a6:	e9d3 2300 	ldrd	r2, r3, [r3]

void AutoGain::setExternalThresholds(String _id, double min, double low, double high, double max) {
    ext_id = _id;
    ext_min = min;
    ext_low = low;
    ext_high = high;
    31aa:	e9c4 0112 	strd	r0, r1, [r4, #72]	; 0x48
    31ae:	4668      	mov	r0, sp
    ext_max = max;
    31b0:	e9c4 230e 	strd	r2, r3, [r4, #56]	; 0x38
    }
}

void AutoGain::setExternalThresholds(String _id, double min, double low, double high, double max) {
    ext_id = _id;
    ext_min = min;
    31b4:	e9c4 670c 	strd	r6, r7, [r4, #48]	; 0x30
    31b8:	f006 f98e 	bl	94d8 <String::~String()>
                                     HIGH_ON_RATIO_THRESH, MAX_ON_RATIO_THRESH);
  auto_gain[1].setExternalThresholds((String)"FPM", MIN_FPM_THRESH, LOW_FPM_THRESH,
    31bc:	4668      	mov	r0, sp
    31be:	491c      	ldr	r1, [pc, #112]	; (3230 <initAutoGain()+0xc0>)
    31c0:	f006 f9ca 	bl	9558 <String::String(char const*)>
        fc2 = _fc;
    }
}

void AutoGain::setExternalThresholds(String _id, double min, double low, double high, double max) {
    ext_id = _id;
    31c4:	4669      	mov	r1, sp
    31c6:	f104 0080 	add.w	r0, r4, #128	; 0x80
    31ca:	f006 fa2f 	bl	962c <String::operator=(String const&)>
    ext_min = min;
    31ce:	e9c4 672a 	strd	r6, r7, [r4, #168]	; 0xa8
    ext_low = low;
    ext_high = high;
    31d2:	4b18      	ldr	r3, [pc, #96]	; (3234 <initAutoGain()+0xc4>)
    ext_max = max;
    31d4:	4f18      	ldr	r7, [pc, #96]	; (3238 <initAutoGain()+0xc8>)

void AutoGain::setExternalThresholds(String _id, double min, double low, double high, double max) {
    ext_id = _id;
    ext_min = min;
    ext_low = low;
    ext_high = high;
    31d6:	2200      	movs	r2, #0
    31d8:	4668      	mov	r0, sp
}

void AutoGain::setExternalThresholds(String _id, double min, double low, double high, double max) {
    ext_id = _id;
    ext_min = min;
    ext_low = low;
    31da:	f04f 0800 	mov.w	r8, #0
    ext_high = high;
    ext_max = max;
    31de:	2600      	movs	r6, #0

void AutoGain::setExternalThresholds(String _id, double min, double low, double high, double max) {
    ext_id = _id;
    ext_min = min;
    ext_low = low;
    ext_high = high;
    31e0:	e9c4 2330 	strd	r2, r3, [r4, #192]	; 0xc0
}

void AutoGain::setExternalThresholds(String _id, double min, double low, double high, double max) {
    ext_id = _id;
    ext_min = min;
    ext_low = low;
    31e4:	e9c4 892e 	strd	r8, r9, [r4, #184]	; 0xb8
    ext_high = high;
    ext_max = max;
    31e8:	e9c4 672c 	strd	r6, r7, [r4, #176]	; 0xb0
    31ec:	f006 f974 	bl	94d8 <String::~String()>
class AutoGain {
  public:
    // feature collector with gain objects already added to it
    AutoGain(String, FeatureCollector *, double, double, double);
    AutoGain(String, FeatureCollector *, FeatureCollector *, double, double, double);
    void setUpdateRate(uint32_t r) {update_rate = r;};
    31f0:	4a12      	ldr	r2, [pc, #72]	; (323c <initAutoGain()+0xcc>)
    31f2:	6662      	str	r2, [r4, #100]	; 0x64
    void setStartDelay(uint32_t d) {start_delay = d;};
    31f4:	f64e 2360 	movw	r3, #60000	; 0xea60
class AutoGain {
  public:
    // feature collector with gain objects already added to it
    AutoGain(String, FeatureCollector *, double, double, double);
    AutoGain(String, FeatureCollector *, FeatureCollector *, double, double, double);
    void setUpdateRate(uint32_t r) {update_rate = r;};
    31f8:	f8c4 20dc 	str.w	r2, [r4, #220]	; 0xdc
    void setStartDelay(uint32_t d) {start_delay = d;};
    31fc:	66a3      	str	r3, [r4, #104]	; 0x68
    31fe:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
                                     HIGH_FPM_THRESH, MAX_FPM_THRESH);
  auto_gain[0].setUpdateRate(AUTOGAIN_FREQUENCY);
  auto_gain[1].setUpdateRate(AUTOGAIN_FREQUENCY);
  auto_gain[0].setStartDelay(AUTOGAIN_START_DELAY);
  auto_gain[1].setStartDelay(AUTOGAIN_START_DELAY);
}
    3202:	b004      	add	sp, #16
    3204:	e8bd 83d0 	ldmia.w	sp!, {r4, r6, r7, r8, r9, pc}
    3208:	a0000000 	.word	0xa0000000
    320c:	3fd99999 	.word	0x3fd99999
    3210:	40000000 	.word	0x40000000
    3214:	3fe33333 	.word	0x3fe33333
    3218:	a0000000 	.word	0xa0000000
    321c:	3fb99999 	.word	0x3fb99999
    3220:	c0000000 	.word	0xc0000000
    3224:	3feccccc 	.word	0x3feccccc
    3228:	20003fa0 	.word	0x20003fa0
    322c:	00011660 	.word	0x00011660
    3230:	00011670 	.word	0x00011670
    3234:	40440000 	.word	0x40440000
    3238:	404e0000 	.word	0x404e0000
    323c:	000493e0 	.word	0x000493e0
    3240:	3ff00000 	.word	0x3ff00000

00003244 <linkFeatureCollectors()>:

void linkFeatureCollectors() {
    3244:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  fc[0].linkAmplifier(&song_input_amp1, MIN_SONG_GAIN * MASTER_GAIN_SCALER, MAX_SONG_GAIN * MASTER_GAIN_SCALER);
    3248:	4db6      	ldr	r5, [pc, #728]	; (3524 <linkFeatureCollectors()+0x2e0>)
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    324a:	4bb7      	ldr	r3, [pc, #732]	; (3528 <linkFeatureCollectors()+0x2e4>)
    324c:	4cb7      	ldr	r4, [pc, #732]	; (352c <linkFeatureCollectors()+0x2e8>)
    324e:	e9d5 6700 	ldrd	r6, r7, [r5]
    3252:	2200      	movs	r2, #0
    3254:	4630      	mov	r0, r6
    3256:	4639      	mov	r1, r7
    3258:	f009 fc2a 	bl	cab0 <__aeabi_dmul>
    gain_upper_limit = high;
    325c:	4bb4      	ldr	r3, [pc, #720]	; (3530 <linkFeatureCollectors()+0x2ec>)
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    325e:	e9c4 0116 	strd	r0, r1, [r4, #88]	; 0x58
    gain_upper_limit = high;
    3262:	2200      	movs	r2, #0
    3264:	4630      	mov	r0, r6
    3266:	4639      	mov	r1, r7
    3268:	f009 fc22 	bl	cab0 <__aeabi_dmul>
    if (audio_amp_add_idx < 4) {
    326c:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
    3270:	2b03      	cmp	r3, #3
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    gain_upper_limit = high;
    3272:	e9c4 0118 	strd	r0, r1, [r4, #96]	; 0x60
    if (audio_amp_add_idx < 4) {
    3276:	f200 8241 	bhi.w	36fc <linkFeatureCollectors()+0x4b8>
    327a:	49ae      	ldr	r1, [pc, #696]	; (3534 <linkFeatureCollectors()+0x2f0>)
    327c:	4620      	mov	r0, r4
    327e:	f7fd f9af 	bl	5e0 <FeatureCollector::linkAmplifier(AudioAmplifier*, double, double) [clone .part.31]>
  fc[0].linkAmplifier(&song_mid_amp1, MIN_SONG_GAIN * MASTER_GAIN_SCALER, MAX_SONG_GAIN * MASTER_GAIN_SCALER);
    3282:	e9d5 6700 	ldrd	r6, r7, [r5]
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    3286:	2200      	movs	r2, #0
    3288:	4ba7      	ldr	r3, [pc, #668]	; (3528 <linkFeatureCollectors()+0x2e4>)
    328a:	4630      	mov	r0, r6
    328c:	4639      	mov	r1, r7
    328e:	f009 fc0f 	bl	cab0 <__aeabi_dmul>
    gain_upper_limit = high;
    3292:	4ba7      	ldr	r3, [pc, #668]	; (3530 <linkFeatureCollectors()+0x2ec>)
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    3294:	e9c4 0116 	strd	r0, r1, [r4, #88]	; 0x58
    gain_upper_limit = high;
    3298:	2200      	movs	r2, #0
    329a:	4630      	mov	r0, r6
    329c:	4639      	mov	r1, r7
    329e:	f009 fc07 	bl	cab0 <__aeabi_dmul>
    if (audio_amp_add_idx < 4) {
    32a2:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
    32a6:	2b03      	cmp	r3, #3
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    gain_upper_limit = high;
    32a8:	e9c4 0118 	strd	r0, r1, [r4, #96]	; 0x60
    if (audio_amp_add_idx < 4) {
    32ac:	f200 8276 	bhi.w	379c <linkFeatureCollectors()+0x558>
    32b0:	49a1      	ldr	r1, [pc, #644]	; (3538 <linkFeatureCollectors()+0x2f4>)
    32b2:	489e      	ldr	r0, [pc, #632]	; (352c <linkFeatureCollectors()+0x2e8>)
    32b4:	f7fd f994 	bl	5e0 <FeatureCollector::linkAmplifier(AudioAmplifier*, double, double) [clone .part.31]>
  fc[0].linkAmplifier(&song_post_amp1, MIN_SONG_GAIN * MASTER_GAIN_SCALER, MAX_SONG_GAIN * MASTER_GAIN_SCALER);
    32b8:	e9d5 6700 	ldrd	r6, r7, [r5]
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    32bc:	2200      	movs	r2, #0
    32be:	4b9a      	ldr	r3, [pc, #616]	; (3528 <linkFeatureCollectors()+0x2e4>)
    32c0:	4630      	mov	r0, r6
    32c2:	4639      	mov	r1, r7
    32c4:	f009 fbf4 	bl	cab0 <__aeabi_dmul>
    gain_upper_limit = high;
    32c8:	4b99      	ldr	r3, [pc, #612]	; (3530 <linkFeatureCollectors()+0x2ec>)
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    32ca:	e9c4 0116 	strd	r0, r1, [r4, #88]	; 0x58
    gain_upper_limit = high;
    32ce:	2200      	movs	r2, #0
    32d0:	4630      	mov	r0, r6
    32d2:	4639      	mov	r1, r7
    32d4:	f009 fbec 	bl	cab0 <__aeabi_dmul>
    if (audio_amp_add_idx < 4) {
    32d8:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
    32dc:	2b03      	cmp	r3, #3
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    gain_upper_limit = high;
    32de:	e9c4 0118 	strd	r0, r1, [r4, #96]	; 0x60
    if (audio_amp_add_idx < 4) {
    32e2:	f200 8253 	bhi.w	378c <linkFeatureCollectors()+0x548>
    32e6:	4995      	ldr	r1, [pc, #596]	; (353c <linkFeatureCollectors()+0x2f8>)
    32e8:	4890      	ldr	r0, [pc, #576]	; (352c <linkFeatureCollectors()+0x2e8>)
    32ea:	f7fd f979 	bl	5e0 <FeatureCollector::linkAmplifier(AudioAmplifier*, double, double) [clone .part.31]>
  fc[1].linkAmplifier(&song_input_amp2, MIN_SONG_GAIN * MASTER_GAIN_SCALER, MAX_SONG_GAIN * MASTER_GAIN_SCALER);
    32ee:	e9d5 8900 	ldrd	r8, r9, [r5]
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    32f2:	2200      	movs	r2, #0
    32f4:	4b8c      	ldr	r3, [pc, #560]	; (3528 <linkFeatureCollectors()+0x2e4>)
    32f6:	4e92      	ldr	r6, [pc, #584]	; (3540 <linkFeatureCollectors()+0x2fc>)
    32f8:	4640      	mov	r0, r8
    32fa:	4649      	mov	r1, r9
    32fc:	f009 fbd8 	bl	cab0 <__aeabi_dmul>
    gain_upper_limit = high;
    3300:	4b8b      	ldr	r3, [pc, #556]	; (3530 <linkFeatureCollectors()+0x2ec>)
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    3302:	e9c6 0100 	strd	r0, r1, [r6]
    gain_upper_limit = high;
    3306:	2200      	movs	r2, #0
    3308:	4640      	mov	r0, r8
    330a:	4649      	mov	r1, r9
    330c:	f009 fbd0 	bl	cab0 <__aeabi_dmul>
    if (audio_amp_add_idx < 4) {
    3310:	f241 1369 	movw	r3, #4457	; 0x1169
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    gain_upper_limit = high;
    3314:	4637      	mov	r7, r6
    if (audio_amp_add_idx < 4) {
    3316:	5ce3      	ldrb	r3, [r4, r3]
    3318:	2b03      	cmp	r3, #3
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    gain_upper_limit = high;
    331a:	e9e7 0102 	strd	r0, r1, [r7, #8]!
    if (audio_amp_add_idx < 4) {
    331e:	f200 822d 	bhi.w	377c <linkFeatureCollectors()+0x538>
    3322:	4988      	ldr	r1, [pc, #544]	; (3544 <linkFeatureCollectors()+0x300>)
    3324:	f1a6 0058 	sub.w	r0, r6, #88	; 0x58
    3328:	f7fd f95a 	bl	5e0 <FeatureCollector::linkAmplifier(AudioAmplifier*, double, double) [clone .part.31]>
  fc[1].linkAmplifier(&song_mid_amp2, MIN_SONG_GAIN * MASTER_GAIN_SCALER, MAX_SONG_GAIN * MASTER_GAIN_SCALER);
    332c:	e9d5 8900 	ldrd	r8, r9, [r5]
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    3330:	2200      	movs	r2, #0
    3332:	4b7d      	ldr	r3, [pc, #500]	; (3528 <linkFeatureCollectors()+0x2e4>)
    3334:	4640      	mov	r0, r8
    3336:	4649      	mov	r1, r9
    3338:	f009 fbba 	bl	cab0 <__aeabi_dmul>
    gain_upper_limit = high;
    333c:	4b7c      	ldr	r3, [pc, #496]	; (3530 <linkFeatureCollectors()+0x2ec>)
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    333e:	e9c6 0100 	strd	r0, r1, [r6]
    gain_upper_limit = high;
    3342:	2200      	movs	r2, #0
    3344:	4640      	mov	r0, r8
    3346:	4649      	mov	r1, r9
    3348:	f009 fbb2 	bl	cab0 <__aeabi_dmul>
    if (audio_amp_add_idx < 4) {
    334c:	f241 1369 	movw	r3, #4457	; 0x1169
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    gain_upper_limit = high;
    3350:	e9c7 0100 	strd	r0, r1, [r7]
    if (audio_amp_add_idx < 4) {
    3354:	5ce3      	ldrb	r3, [r4, r3]
    3356:	2b03      	cmp	r3, #3
    3358:	f200 8208 	bhi.w	376c <linkFeatureCollectors()+0x528>
    335c:	497a      	ldr	r1, [pc, #488]	; (3548 <linkFeatureCollectors()+0x304>)
    335e:	487b      	ldr	r0, [pc, #492]	; (354c <linkFeatureCollectors()+0x308>)
    3360:	f7fd f93e 	bl	5e0 <FeatureCollector::linkAmplifier(AudioAmplifier*, double, double) [clone .part.31]>
  fc[1].linkAmplifier(&song_post_amp2, MIN_SONG_GAIN * MASTER_GAIN_SCALER, MAX_SONG_GAIN * MASTER_GAIN_SCALER);
    3364:	e9d5 8900 	ldrd	r8, r9, [r5]
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    3368:	2200      	movs	r2, #0
    336a:	4b6f      	ldr	r3, [pc, #444]	; (3528 <linkFeatureCollectors()+0x2e4>)
    336c:	4640      	mov	r0, r8
    336e:	4649      	mov	r1, r9
    3370:	f009 fb9e 	bl	cab0 <__aeabi_dmul>
    gain_upper_limit = high;
    3374:	4b6e      	ldr	r3, [pc, #440]	; (3530 <linkFeatureCollectors()+0x2ec>)
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    3376:	e9c6 0100 	strd	r0, r1, [r6]
    gain_upper_limit = high;
    337a:	2200      	movs	r2, #0
    337c:	4640      	mov	r0, r8
    337e:	4649      	mov	r1, r9
    3380:	f009 fb96 	bl	cab0 <__aeabi_dmul>
    if (audio_amp_add_idx < 4) {
    3384:	f241 1369 	movw	r3, #4457	; 0x1169
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    gain_upper_limit = high;
    3388:	e9c7 0100 	strd	r0, r1, [r7]
    if (audio_amp_add_idx < 4) {
    338c:	5ce3      	ldrb	r3, [r4, r3]
    338e:	2b03      	cmp	r3, #3
    3390:	f200 81e4 	bhi.w	375c <linkFeatureCollectors()+0x518>
    3394:	496e      	ldr	r1, [pc, #440]	; (3550 <linkFeatureCollectors()+0x30c>)
    3396:	486d      	ldr	r0, [pc, #436]	; (354c <linkFeatureCollectors()+0x308>)
    3398:	f7fd f922 	bl	5e0 <FeatureCollector::linkAmplifier(AudioAmplifier*, double, double) [clone .part.31]>
  fc[2].linkAmplifier(&click_input_amp1, MIN_CLICK_GAIN * MASTER_GAIN_SCALER, MAX_CLICK_GAIN * MASTER_GAIN_SCALER);
    339c:	e9d5 8900 	ldrd	r8, r9, [r5]
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    33a0:	2200      	movs	r2, #0
    33a2:	4b6c      	ldr	r3, [pc, #432]	; (3554 <linkFeatureCollectors()+0x310>)
    33a4:	4e6c      	ldr	r6, [pc, #432]	; (3558 <linkFeatureCollectors()+0x314>)
    33a6:	4640      	mov	r0, r8
    33a8:	4649      	mov	r1, r9
    33aa:	f009 fb81 	bl	cab0 <__aeabi_dmul>
    gain_upper_limit = high;
    33ae:	4b6b      	ldr	r3, [pc, #428]	; (355c <linkFeatureCollectors()+0x318>)
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    33b0:	e9c6 0100 	strd	r0, r1, [r6]
    gain_upper_limit = high;
    33b4:	2200      	movs	r2, #0
    33b6:	4640      	mov	r0, r8
    33b8:	4649      	mov	r1, r9
    33ba:	f009 fb79 	bl	cab0 <__aeabi_dmul>
    if (audio_amp_add_idx < 4) {
    33be:	f242 2381 	movw	r3, #8833	; 0x2281
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    gain_upper_limit = high;
    33c2:	4637      	mov	r7, r6
    if (audio_amp_add_idx < 4) {
    33c4:	5ce3      	ldrb	r3, [r4, r3]
    33c6:	2b03      	cmp	r3, #3
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    gain_upper_limit = high;
    33c8:	e9e7 0102 	strd	r0, r1, [r7, #8]!
    if (audio_amp_add_idx < 4) {
    33cc:	f200 81be 	bhi.w	374c <linkFeatureCollectors()+0x508>
    33d0:	4963      	ldr	r1, [pc, #396]	; (3560 <linkFeatureCollectors()+0x31c>)
    33d2:	f1a6 0058 	sub.w	r0, r6, #88	; 0x58
    33d6:	f7fd f903 	bl	5e0 <FeatureCollector::linkAmplifier(AudioAmplifier*, double, double) [clone .part.31]>
  fc[2].linkAmplifier(&click_mid_amp1, MIN_CLICK_GAIN * MASTER_GAIN_SCALER, MAX_CLICK_GAIN * MASTER_GAIN_SCALER);
    33da:	e9d5 8900 	ldrd	r8, r9, [r5]
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    33de:	2200      	movs	r2, #0
    33e0:	4b5c      	ldr	r3, [pc, #368]	; (3554 <linkFeatureCollectors()+0x310>)
    33e2:	4640      	mov	r0, r8
    33e4:	4649      	mov	r1, r9
    33e6:	f009 fb63 	bl	cab0 <__aeabi_dmul>
    gain_upper_limit = high;
    33ea:	4b5c      	ldr	r3, [pc, #368]	; (355c <linkFeatureCollectors()+0x318>)
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    33ec:	e9c6 0100 	strd	r0, r1, [r6]
    gain_upper_limit = high;
    33f0:	2200      	movs	r2, #0
    33f2:	4640      	mov	r0, r8
    33f4:	4649      	mov	r1, r9
    33f6:	f009 fb5b 	bl	cab0 <__aeabi_dmul>
    if (audio_amp_add_idx < 4) {
    33fa:	f242 2381 	movw	r3, #8833	; 0x2281
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    gain_upper_limit = high;
    33fe:	e9c7 0100 	strd	r0, r1, [r7]
    if (audio_amp_add_idx < 4) {
    3402:	5ce3      	ldrb	r3, [r4, r3]
    3404:	2b03      	cmp	r3, #3
    3406:	f200 8199 	bhi.w	373c <linkFeatureCollectors()+0x4f8>
    340a:	4956      	ldr	r1, [pc, #344]	; (3564 <linkFeatureCollectors()+0x320>)
    340c:	4856      	ldr	r0, [pc, #344]	; (3568 <linkFeatureCollectors()+0x324>)
    340e:	f7fd f8e7 	bl	5e0 <FeatureCollector::linkAmplifier(AudioAmplifier*, double, double) [clone .part.31]>
  fc[2].linkAmplifier(&click_post_amp1, MIN_CLICK_GAIN * MASTER_GAIN_SCALER, MAX_CLICK_GAIN * MASTER_GAIN_SCALER);
    3412:	e9d5 8900 	ldrd	r8, r9, [r5]
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    3416:	2200      	movs	r2, #0
    3418:	4b4e      	ldr	r3, [pc, #312]	; (3554 <linkFeatureCollectors()+0x310>)
    341a:	4640      	mov	r0, r8
    341c:	4649      	mov	r1, r9
    341e:	f009 fb47 	bl	cab0 <__aeabi_dmul>
    gain_upper_limit = high;
    3422:	4b4e      	ldr	r3, [pc, #312]	; (355c <linkFeatureCollectors()+0x318>)
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    3424:	e9c6 0100 	strd	r0, r1, [r6]
    gain_upper_limit = high;
    3428:	2200      	movs	r2, #0
    342a:	4640      	mov	r0, r8
    342c:	4649      	mov	r1, r9
    342e:	f009 fb3f 	bl	cab0 <__aeabi_dmul>
    if (audio_amp_add_idx < 4) {
    3432:	f242 2381 	movw	r3, #8833	; 0x2281
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    gain_upper_limit = high;
    3436:	e9c7 0100 	strd	r0, r1, [r7]
    if (audio_amp_add_idx < 4) {
    343a:	5ce3      	ldrb	r3, [r4, r3]
    343c:	2b03      	cmp	r3, #3
    343e:	f200 8175 	bhi.w	372c <linkFeatureCollectors()+0x4e8>
    3442:	494a      	ldr	r1, [pc, #296]	; (356c <linkFeatureCollectors()+0x328>)
    3444:	4848      	ldr	r0, [pc, #288]	; (3568 <linkFeatureCollectors()+0x324>)
    3446:	f7fd f8cb 	bl	5e0 <FeatureCollector::linkAmplifier(AudioAmplifier*, double, double) [clone .part.31]>
  fc[3].linkAmplifier(&click_input_amp2, MIN_CLICK_GAIN * MASTER_GAIN_SCALER, MAX_CLICK_GAIN * MASTER_GAIN_SCALER);
    344a:	e9d5 8900 	ldrd	r8, r9, [r5]
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    344e:	2200      	movs	r2, #0
    3450:	4b40      	ldr	r3, [pc, #256]	; (3554 <linkFeatureCollectors()+0x310>)
    3452:	4e47      	ldr	r6, [pc, #284]	; (3570 <linkFeatureCollectors()+0x32c>)
    3454:	4640      	mov	r0, r8
    3456:	4649      	mov	r1, r9
    3458:	f009 fb2a 	bl	cab0 <__aeabi_dmul>
    gain_upper_limit = high;
    345c:	4b3f      	ldr	r3, [pc, #252]	; (355c <linkFeatureCollectors()+0x318>)
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    345e:	e9c6 0100 	strd	r0, r1, [r6]
    gain_upper_limit = high;
    3462:	2200      	movs	r2, #0
    3464:	4640      	mov	r0, r8
    3466:	4649      	mov	r1, r9
    3468:	f009 fb22 	bl	cab0 <__aeabi_dmul>
    if (audio_amp_add_idx < 4) {
    346c:	f243 3399 	movw	r3, #13209	; 0x3399
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    gain_upper_limit = high;
    3470:	4637      	mov	r7, r6
    if (audio_amp_add_idx < 4) {
    3472:	5ce3      	ldrb	r3, [r4, r3]
    3474:	2b03      	cmp	r3, #3
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    gain_upper_limit = high;
    3476:	e9e7 0102 	strd	r0, r1, [r7, #8]!
    if (audio_amp_add_idx < 4) {
    347a:	f200 814f 	bhi.w	371c <linkFeatureCollectors()+0x4d8>
    347e:	493d      	ldr	r1, [pc, #244]	; (3574 <linkFeatureCollectors()+0x330>)
    3480:	f1a6 0058 	sub.w	r0, r6, #88	; 0x58
    3484:	f7fd f8ac 	bl	5e0 <FeatureCollector::linkAmplifier(AudioAmplifier*, double, double) [clone .part.31]>
  fc[3].linkAmplifier(&click_mid_amp2, MIN_CLICK_GAIN * MASTER_GAIN_SCALER, MAX_CLICK_GAIN * MASTER_GAIN_SCALER);
    3488:	e9d5 8900 	ldrd	r8, r9, [r5]
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    348c:	2200      	movs	r2, #0
    348e:	4b31      	ldr	r3, [pc, #196]	; (3554 <linkFeatureCollectors()+0x310>)
    3490:	4640      	mov	r0, r8
    3492:	4649      	mov	r1, r9
    3494:	f009 fb0c 	bl	cab0 <__aeabi_dmul>
    gain_upper_limit = high;
    3498:	4b30      	ldr	r3, [pc, #192]	; (355c <linkFeatureCollectors()+0x318>)
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    349a:	e9c6 0100 	strd	r0, r1, [r6]
    gain_upper_limit = high;
    349e:	2200      	movs	r2, #0
    34a0:	4640      	mov	r0, r8
    34a2:	4649      	mov	r1, r9
    34a4:	f009 fb04 	bl	cab0 <__aeabi_dmul>
    if (audio_amp_add_idx < 4) {
    34a8:	f243 3399 	movw	r3, #13209	; 0x3399
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    gain_upper_limit = high;
    34ac:	e9c7 0100 	strd	r0, r1, [r7]
    if (audio_amp_add_idx < 4) {
    34b0:	5ce3      	ldrb	r3, [r4, r3]
    34b2:	2b03      	cmp	r3, #3
    34b4:	f200 812a 	bhi.w	370c <linkFeatureCollectors()+0x4c8>
    34b8:	492f      	ldr	r1, [pc, #188]	; (3578 <linkFeatureCollectors()+0x334>)
    34ba:	4830      	ldr	r0, [pc, #192]	; (357c <linkFeatureCollectors()+0x338>)
    34bc:	f7fd f890 	bl	5e0 <FeatureCollector::linkAmplifier(AudioAmplifier*, double, double) [clone .part.31]>
  fc[3].linkAmplifier(&click_post_amp2, MIN_CLICK_GAIN * MASTER_GAIN_SCALER, MAX_CLICK_GAIN * MASTER_GAIN_SCALER);
    34c0:	e9d5 8900 	ldrd	r8, r9, [r5]
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    34c4:	2200      	movs	r2, #0
    34c6:	4b23      	ldr	r3, [pc, #140]	; (3554 <linkFeatureCollectors()+0x310>)
    34c8:	4640      	mov	r0, r8
    34ca:	4649      	mov	r1, r9
    34cc:	f009 faf0 	bl	cab0 <__aeabi_dmul>
    gain_upper_limit = high;
    34d0:	4b22      	ldr	r3, [pc, #136]	; (355c <linkFeatureCollectors()+0x318>)
    calculate_centroid = c;
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    34d2:	e9c6 0100 	strd	r0, r1, [r6]
    gain_upper_limit = high;
    34d6:	2200      	movs	r2, #0
    34d8:	4640      	mov	r0, r8
    34da:	4649      	mov	r1, r9
    34dc:	f009 fae8 	bl	cab0 <__aeabi_dmul>
    if (audio_amp_add_idx < 4) {
    34e0:	f243 3399 	movw	r3, #13209	; 0x3399
    calculate_flux = f;
};

void FeatureCollector::linkAmplifier(AudioAmplifier * amp, double low, double high) { 
    gain_lower_limit = low;
    gain_upper_limit = high;
    34e4:	e9c7 0100 	strd	r0, r1, [r7]
    if (audio_amp_add_idx < 4) {
    34e8:	5ce3      	ldrb	r3, [r4, r3]
    34ea:	2b03      	cmp	r3, #3
    34ec:	f240 815e 	bls.w	37ac <linkFeatureCollectors()+0x568>
    34f0:	2147      	movs	r1, #71	; 0x47
    34f2:	4823      	ldr	r0, [pc, #140]	; (3580 <linkFeatureCollectors()+0x33c>)
    34f4:	f008 f884 	bl	b600 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    34f8:	4822      	ldr	r0, [pc, #136]	; (3584 <linkFeatureCollectors()+0x340>)
    34fa:	f005 febb 	bl	9274 <Print::println()>
    peak_scaler = s;
};

void FeatureCollector::linkRMS(AudioAnalyzeRMS *r, double s, bool print) {
    print_rms = print;
    rms_ana = r;
    34fe:	4922      	ldr	r1, [pc, #136]	; (3588 <linkFeatureCollectors()+0x344>)

  if (RMS_FEATURE_ACTIVE) {
    // fc 0-1 are for the song front/rear
    fc[0].linkRMS(&song_rms1, global_rms_scaler, PRINT_RMS_VALS);
    3500:	4b22      	ldr	r3, [pc, #136]	; (358c <linkFeatureCollectors()+0x348>)
    fc[2].linkRMS(&click_rms1, global_rms_scaler, PRINT_RMS_VALS);
    fc[3].linkRMS(&click_rms2, global_rms_scaler, PRINT_RMS_VALS);
  }
  if (PEAK_FEATURE_ACTIVE) {
    // fc 0-1 are for the song front/rear
    fc[0].linkPeak(&song_peak1, global_peak_scaler, PRINT_PEAK_VALS);
    3502:	4e23      	ldr	r6, [pc, #140]	; (3590 <linkFeatureCollectors()+0x34c>)
    3504:	4f23      	ldr	r7, [pc, #140]	; (3594 <linkFeatureCollectors()+0x350>)
    rms_active = true;
    rms_scaler = s;
    3506:	f8df c094 	ldr.w	ip, [pc, #148]	; 359c <linkFeatureCollectors()+0x358>
    350a:	f8df e094 	ldr.w	lr, [pc, #148]	; 35a0 <linkFeatureCollectors()+0x35c>
    fc[3].linkPeak(&click_peak2, global_peak_scaler, PRINT_PEAK_VALS);
  }
  if (FFT_FEATURE_ACTIVE) {
    // fc 0-1 are for the song front/rear
    // this equates to about 4k - 16k, perhaps I shoul
    fc[0].linkFFT(&input_fft, 23, 93, (double)global_fft_scaler, SCALE_FFT_BIN_RANGE, true, false);
    350e:	4d22      	ldr	r5, [pc, #136]	; (3598 <linkFeatureCollectors()+0x354>)
    peak_scaler = s;
};

void FeatureCollector::linkRMS(AudioAnalyzeRMS *r, double s, bool print) {
    print_rms = print;
    rms_ana = r;
    3510:	4608      	mov	r0, r1
  fc[3].linkAmplifier(&click_mid_amp2, MIN_CLICK_GAIN * MASTER_GAIN_SCALER, MAX_CLICK_GAIN * MASTER_GAIN_SCALER);
  fc[3].linkAmplifier(&click_post_amp2, MIN_CLICK_GAIN * MASTER_GAIN_SCALER, MAX_CLICK_GAIN * MASTER_GAIN_SCALER);

  if (RMS_FEATURE_ACTIVE) {
    // fc 0-1 are for the song front/rear
    fc[0].linkRMS(&song_rms1, global_rms_scaler, PRINT_RMS_VALS);
    3512:	e9d3 2300 	ldrd	r2, r3, [r3]
    3516:	f840 7b20 	str.w	r7, [r0], #32
    fc[2].linkRMS(&click_rms1, global_rms_scaler, PRINT_RMS_VALS);
    fc[3].linkRMS(&click_rms2, global_rms_scaler, PRINT_RMS_VALS);
  }
  if (PEAK_FEATURE_ACTIVE) {
    // fc 0-1 are for the song front/rear
    fc[0].linkPeak(&song_peak1, global_peak_scaler, PRINT_PEAK_VALS);
    351a:	e9d6 6700 	ldrd	r6, r7, [r6]
    rms_active = true;
    rms_scaler = s;
    351e:	e9c0 2300 	strd	r2, r3, [r0]
    3522:	e03f      	b.n	35a4 <linkFeatureCollectors()+0x360>
    3524:	1fffb890 	.word	0x1fffb890
    3528:	40080000 	.word	0x40080000
    352c:	1ffffa30 	.word	0x1ffffa30
    3530:	40220000 	.word	0x40220000
    3534:	20003f78 	.word	0x20003f78
    3538:	1ffff938 	.word	0x1ffff938
    353c:	1ffff978 	.word	0x1ffff978
    3540:	20000ba0 	.word	0x20000ba0
    3544:	1ffff9f0 	.word	0x1ffff9f0
    3548:	1ffff958 	.word	0x1ffff958
    354c:	20000b48 	.word	0x20000b48
    3550:	1ffff998 	.word	0x1ffff998
    3554:	401e0000 	.word	0x401e0000
    3558:	20001cb8 	.word	0x20001cb8
    355c:	40368000 	.word	0x40368000
    3560:	1ffff8f8 	.word	0x1ffff8f8
    3564:	1ffffa10 	.word	0x1ffffa10
    3568:	20001c60 	.word	0x20001c60
    356c:	1ffff75c 	.word	0x1ffff75c
    3570:	20002dd0 	.word	0x20002dd0
    3574:	1ffff918 	.word	0x1ffff918
    3578:	1fffc780 	.word	0x1fffc780
    357c:	20002d78 	.word	0x20002d78
    3580:	00011248 	.word	0x00011248
    3584:	1fffbaf4 	.word	0x1fffbaf4
    3588:	20000bb0 	.word	0x20000bb0
    358c:	1fffb898 	.word	0x1fffb898
    3590:	1fffb8b0 	.word	0x1fffb8b0
    3594:	1fffc9d8 	.word	0x1fffc9d8
    3598:	1fffb8c8 	.word	0x1fffb8c8
    359c:	20002e00 	.word	0x20002e00
    35a0:	20001ce8 	.word	0x20001ce8
    35a4:	e9ce 2300 	strd	r2, r3, [lr]
    35a8:	e9c4 2322 	strd	r2, r3, [r4, #136]	; 0x88
    35ac:	e9cc 2300 	strd	r2, r3, [ip]
    peak_active = true;
    peak_scaler = s;
};

void FeatureCollector::linkRMS(AudioAnalyzeRMS *r, double s, bool print) {
    print_rms = print;
    35b0:	f241 1e39 	movw	lr, #4409	; 0x1139

void FeatureCollector::linkPeak(AudioAnalyzePeak *r, double s, bool print) {
    print_peak = print;
    peak_ana = r;
    peak_active = true;
    peak_scaler = s;
    35b4:	f501 528b 	add.w	r2, r1, #4448	; 0x1160
    35b8:	e9c2 6700 	strd	r6, r7, [r2]
};

void FeatureCollector::linkRMS(AudioAnalyzeRMS *r, double s, bool print) {
    print_rms = print;
    35bc:	f242 2051 	movw	r0, #8785	; 0x2251
    35c0:	2200      	movs	r2, #0
    35c2:	f243 3369 	movw	r3, #13161	; 0x3369
    35c6:	f804 200e 	strb.w	r2, [r4, lr]
    tone_ana = r;
    tone_active = true;
};

void FeatureCollector::linkPeak(AudioAnalyzePeak *r, double s, bool print) {
    print_peak = print;
    35ca:	f241 1e3a 	movw	lr, #4410	; 0x113a
    peak_active = true;
    peak_scaler = s;
};

void FeatureCollector::linkRMS(AudioAnalyzeRMS *r, double s, bool print) {
    print_rms = print;
    35ce:	5422      	strb	r2, [r4, r0]
    35d0:	54e2      	strb	r2, [r4, r3]
    tone_ana = r;
    tone_active = true;
};

void FeatureCollector::linkPeak(AudioAnalyzePeak *r, double s, bool print) {
    print_peak = print;
    35d2:	f242 2052 	movw	r0, #8786	; 0x2252
    35d6:	f243 336a 	movw	r3, #13162	; 0x336a
    35da:	f804 200e 	strb.w	r2, [r4, lr]
};

void FeatureCollector::linkRMS(AudioAnalyzeRMS *r, double s, bool print) {
    print_rms = print;
    rms_ana = r;
    rms_active = true;
    35de:	f241 1e84 	movw	lr, #4484	; 0x1184
    tone_ana = r;
    tone_active = true;
};

void FeatureCollector::linkPeak(AudioAnalyzePeak *r, double s, bool print) {
    print_peak = print;
    35e2:	5422      	strb	r2, [r4, r0]
    35e4:	54e2      	strb	r2, [r4, r3]
};

void FeatureCollector::linkRMS(AudioAnalyzeRMS *r, double s, bool print) {
    print_rms = print;
    rms_ana = r;
    rms_active = true;
    35e6:	f242 209c 	movw	r0, #8860	; 0x229c
    35ea:	2301      	movs	r3, #1
    35ec:	f804 300e 	strb.w	r3, [r4, lr]
    35f0:	f243 3eb4 	movw	lr, #13236	; 0x33b4
    35f4:	5423      	strb	r3, [r4, r0]
};

void FeatureCollector::linkPeak(AudioAnalyzePeak *r, double s, bool print) {
    print_peak = print;
    peak_ana = r;
    peak_active = true;
    35f6:	f241 10b8 	movw	r0, #4536	; 0x11b8
};

void FeatureCollector::linkRMS(AudioAnalyzeRMS *r, double s, bool print) {
    print_rms = print;
    rms_ana = r;
    rms_active = true;
    35fa:	f804 300e 	strb.w	r3, [r4, lr]
};

void FeatureCollector::linkPeak(AudioAnalyzePeak *r, double s, bool print) {
    print_peak = print;
    peak_ana = r;
    peak_active = true;
    35fe:	f242 2ed0 	movw	lr, #8912	; 0x22d0
    3602:	5423      	strb	r3, [r4, r0]
    peak_scaler = s;
};

void FeatureCollector::linkRMS(AudioAnalyzeRMS *r, double s, bool print) {
    print_rms = print;
    rms_ana = r;
    3604:	f242 2098 	movw	r0, #8856	; 0x2298
};

void FeatureCollector::linkPeak(AudioAnalyzePeak *r, double s, bool print) {
    print_peak = print;
    peak_ana = r;
    peak_active = true;
    3608:	f804 300e 	strb.w	r3, [r4, lr]
    peak_scaler = s;
};

void FeatureCollector::linkRMS(AudioAnalyzeRMS *r, double s, bool print) {
    print_rms = print;
    rms_ana = r;
    360c:	f8df e1bc 	ldr.w	lr, [pc, #444]	; 37cc <linkFeatureCollectors()+0x588>
    3610:	f844 e000 	str.w	lr, [r4, r0]
    3614:	f243 30b0 	movw	r0, #13232	; 0x33b0
    3618:	f8df e1b4 	ldr.w	lr, [pc, #436]	; 37d0 <linkFeatureCollectors()+0x58c>
    361c:	f844 e000 	str.w	lr, [r4, r0]
    tone_active = true;
};

void FeatureCollector::linkPeak(AudioAnalyzePeak *r, double s, bool print) {
    print_peak = print;
    peak_ana = r;
    3620:	f241 10b4 	movw	r0, #4532	; 0x11b4
    3624:	f8df e1ac 	ldr.w	lr, [pc, #428]	; 37d4 <linkFeatureCollectors()+0x590>
    3628:	f844 e000 	str.w	lr, [r4, r0]
    362c:	f242 20cc 	movw	r0, #8908	; 0x22cc
    3630:	f8df e1a4 	ldr.w	lr, [pc, #420]	; 37d8 <linkFeatureCollectors()+0x594>
    3634:	f844 e000 	str.w	lr, [r4, r0]
    3638:	f243 30e4 	movw	r0, #13284	; 0x33e4
    363c:	f8df e19c 	ldr.w	lr, [pc, #412]	; 37dc <linkFeatureCollectors()+0x598>
    3640:	f844 e000 	str.w	lr, [r4, r0]
    peak_active = true;
    3644:	f243 30e8 	movw	r0, #13288	; 0x33e8
    peak_scaler = s;
};

void FeatureCollector::linkRMS(AudioAnalyzeRMS *r, double s, bool print) {
    print_rms = print;
    rms_ana = r;
    3648:	f8df e194 	ldr.w	lr, [pc, #404]	; 37e0 <linkFeatureCollectors()+0x59c>
    364c:	f8c4 e068 	str.w	lr, [r4, #104]	; 0x68
    tone_active = true;
};

void FeatureCollector::linkPeak(AudioAnalyzePeak *r, double s, bool print) {
    print_peak = print;
    peak_ana = r;
    3650:	f8df e190 	ldr.w	lr, [pc, #400]	; 37e4 <linkFeatureCollectors()+0x5a0>
};

void FeatureCollector::linkRMS(AudioAnalyzeRMS *r, double s, bool print) {
    print_rms = print;
    rms_ana = r;
    rms_active = true;
    3654:	f884 306c 	strb.w	r3, [r4, #108]	; 0x6c

void FeatureCollector::linkPeak(AudioAnalyzePeak *r, double s, bool print) {
    print_peak = print;
    peak_ana = r;
    peak_active = true;
    peak_scaler = s;
    3658:	e9c1 6712 	strd	r6, r7, [r1, #72]	; 0x48
    365c:	e9c4 672c 	strd	r6, r7, [r4, #176]	; 0xb0
};

void FeatureCollector::linkPeak(AudioAnalyzePeak *r, double s, bool print) {
    print_peak = print;
    peak_ana = r;
    peak_active = true;
    3660:	f884 30a0 	strb.w	r3, [r4, #160]	; 0xa0
    tone_active = true;
};

void FeatureCollector::linkPeak(AudioAnalyzePeak *r, double s, bool print) {
    print_peak = print;
    peak_ana = r;
    3664:	f8c4 e09c 	str.w	lr, [r4, #156]	; 0x9c
    peak_active = true;
    peak_scaler = s;
};

void FeatureCollector::linkRMS(AudioAnalyzeRMS *r, double s, bool print) {
    print_rms = print;
    3668:	f884 2021 	strb.w	r2, [r4, #33]	; 0x21
    tone_ana = r;
    tone_active = true;
};

void FeatureCollector::linkPeak(AudioAnalyzePeak *r, double s, bool print) {
    print_peak = print;
    366c:	f884 2022 	strb.w	r2, [r4, #34]	; 0x22
    peak_ana = r;
    peak_active = true;
    3670:	5423      	strb	r3, [r4, r0]
    fc[3].linkPeak(&click_peak2, global_peak_scaler, PRINT_PEAK_VALS);
  }
  if (FFT_FEATURE_ACTIVE) {
    // fc 0-1 are for the song front/rear
    // this equates to about 4k - 16k, perhaps I shoul
    fc[0].linkFFT(&input_fft, 23, 93, (double)global_fft_scaler, SCALE_FFT_BIN_RANGE, true, false);
    3672:	e9d5 8900 	ldrd	r8, r9, [r5]
    max_bin = h;
    min_bin = l;
    fft_num_bins = h - l;
    fft_scaler = s;
    scale_bin_values = scale_bin_v;
    calculate_centroid = c;
    3676:	f241 0efc 	movw	lr, #4348	; 0x10fc
    fft_ana = r;
    fft_active = true;
    max_bin = h;
    min_bin = l;
    fft_num_bins = h - l;
    fft_scaler = s;
    367a:	f1ac 05c8 	sub.w	r5, ip, #200	; 0xc8
    rms_scaler = s;
};

void FeatureCollector::linkFFT(AudioAnalyzeFFT256*r, uint16_t l, uint16_t h, double s, bool scale_bin_v, bool c, bool f) {
    fft_ana = r;
    fft_active = true;
    367e:	f242 3026 	movw	r0, #8998	; 0x2326
    max_bin = h;
    min_bin = l;
    fft_num_bins = h - l;
    fft_scaler = s;
    3682:	e941 892a 	strd	r8, r9, [r1, #-168]	; 0xa8
    3686:	e9c5 8900 	strd	r8, r9, [r5]
    scale_bin_values = scale_bin_v;
    calculate_centroid = c;
    calculate_flux = f;
    368a:	f243 312d 	movw	r1, #13101	; 0x332d
    max_bin = h;
    min_bin = l;
    fft_num_bins = h - l;
    fft_scaler = s;
    scale_bin_values = scale_bin_v;
    calculate_centroid = c;
    368e:	f243 352c 	movw	r5, #13100	; 0x332c
    3692:	f804 300e 	strb.w	r3, [r4, lr]

void FeatureCollector::linkPeak(AudioAnalyzePeak *r, double s, bool print) {
    print_peak = print;
    peak_ana = r;
    peak_active = true;
    peak_scaler = s;
    3696:	e9cc 670a 	strd	r6, r7, [ip, #40]	; 0x28
};

void FeatureCollector::linkFFT(AudioAnalyzeFFT256*r, uint16_t l, uint16_t h, double s, bool scale_bin_v, bool c, bool f) {
    fft_ana = r;
    fft_active = true;
    max_bin = h;
    369a:	f241 0ef8 	movw	lr, #4344	; 0x10f8
    min_bin = l;
    fft_num_bins = h - l;
    fft_scaler = s;
    scale_bin_values = scale_bin_v;
    calculate_centroid = c;
    calculate_flux = f;
    369e:	f241 06fd 	movw	r6, #4349	; 0x10fd
    rms_scaler = s;
};

void FeatureCollector::linkFFT(AudioAnalyzeFFT256*r, uint16_t l, uint16_t h, double s, bool scale_bin_v, bool c, bool f) {
    fft_ana = r;
    fft_active = true;
    36a2:	5423      	strb	r3, [r4, r0]
    max_bin = h;
    min_bin = l;
    fft_num_bins = h - l;
    fft_scaler = s;
    scale_bin_values = scale_bin_v;
    calculate_centroid = c;
    36a4:	5563      	strb	r3, [r4, r5]
    calculate_flux = f;
    36a6:	5463      	strb	r3, [r4, r1]
    fft_active = true;
    max_bin = h;
    min_bin = l;
    fft_num_bins = h - l;
    fft_scaler = s;
    scale_bin_values = scale_bin_v;
    36a8:	f242 2750 	movw	r7, #8784	; 0x2250
    rms_active = true;
    rms_scaler = s;
};

void FeatureCollector::linkFFT(AudioAnalyzeFFT256*r, uint16_t l, uint16_t h, double s, bool scale_bin_v, bool c, bool f) {
    fft_ana = r;
    36ac:	f242 3020 	movw	r0, #8992	; 0x2320
    fft_active = true;
    36b0:	f884 30f6 	strb.w	r3, [r4, #246]	; 0xf6
    max_bin = h;
    36b4:	235d      	movs	r3, #93	; 0x5d
    min_bin = l;
    fft_num_bins = h - l;
    fft_scaler = s;
    scale_bin_values = scale_bin_v;
    calculate_centroid = c;
    calculate_flux = f;
    36b6:	55a2      	strb	r2, [r4, r6]
void FeatureCollector::linkFFT(AudioAnalyzeFFT256*r, uint16_t l, uint16_t h, double s, bool scale_bin_v, bool c, bool f) {
    fft_ana = r;
    fft_active = true;
    max_bin = h;
    min_bin = l;
    fft_num_bins = h - l;
    36b8:	f242 3124 	movw	r1, #8996	; 0x2324

void FeatureCollector::linkFFT(AudioAnalyzeFFT256*r, uint16_t l, uint16_t h, double s, bool scale_bin_v, bool c, bool f) {
    fft_ana = r;
    fft_active = true;
    max_bin = h;
    min_bin = l;
    36bc:	f241 06fa 	movw	r6, #4346	; 0x10fa
};

void FeatureCollector::linkFFT(AudioAnalyzeFFT256*r, uint16_t l, uint16_t h, double s, bool scale_bin_v, bool c, bool f) {
    fft_ana = r;
    fft_active = true;
    max_bin = h;
    36c0:	f824 300e 	strh.w	r3, [r4, lr]
    rms_active = true;
    rms_scaler = s;
};

void FeatureCollector::linkFFT(AudioAnalyzeFFT256*r, uint16_t l, uint16_t h, double s, bool scale_bin_v, bool c, bool f) {
    fft_ana = r;
    36c4:	4b3c      	ldr	r3, [pc, #240]	; (37b8 <linkFeatureCollectors()+0x574>)
    fft_active = true;
    max_bin = h;
    min_bin = l;
    fft_num_bins = h - l;
    fft_scaler = s;
    scale_bin_values = scale_bin_v;
    36c6:	55e2      	strb	r2, [r4, r7]

void FeatureCollector::linkFFT(AudioAnalyzeFFT256*r, uint16_t l, uint16_t h, double s, bool scale_bin_v, bool c, bool f) {
    fft_ana = r;
    fft_active = true;
    max_bin = h;
    min_bin = l;
    36c8:	f04f 0e17 	mov.w	lr, #23
};

void FeatureCollector::linkFFT(AudioAnalyzeFFT256*r, uint16_t l, uint16_t h, double s, bool scale_bin_v, bool c, bool f) {
    fft_ana = r;
    fft_active = true;
    max_bin = h;
    36cc:	f243 3728 	movw	r7, #13096	; 0x3328
    min_bin = l;
    36d0:	f243 352a 	movw	r5, #13098	; 0x332a
    rms_active = true;
    rms_scaler = s;
};

void FeatureCollector::linkFFT(AudioAnalyzeFFT256*r, uint16_t l, uint16_t h, double s, bool scale_bin_v, bool c, bool f) {
    fft_ana = r;
    36d4:	5023      	str	r3, [r4, r0]
    fft_active = true;
    max_bin = h;
    min_bin = l;
    fft_num_bins = h - l;
    36d6:	2008      	movs	r0, #8

void FeatureCollector::linkFFT(AudioAnalyzeFFT256*r, uint16_t l, uint16_t h, double s, bool scale_bin_v, bool c, bool f) {
    fft_ana = r;
    fft_active = true;
    max_bin = h;
    min_bin = l;
    36d8:	f824 e006 	strh.w	lr, [r4, r6]
    fft_num_bins = h - l;
    36dc:	5260      	strh	r0, [r4, r1]
};

void FeatureCollector::linkFFT(AudioAnalyzeFFT256*r, uint16_t l, uint16_t h, double s, bool scale_bin_v, bool c, bool f) {
    fft_ana = r;
    fft_active = true;
    max_bin = h;
    36de:	f04f 0e14 	mov.w	lr, #20
    min_bin = l;
    36e2:	260c      	movs	r6, #12
    fft_num_bins = h - l;
    36e4:	2146      	movs	r1, #70	; 0x46
};

void FeatureCollector::linkFFT(AudioAnalyzeFFT256*r, uint16_t l, uint16_t h, double s, bool scale_bin_v, bool c, bool f) {
    fft_ana = r;
    fft_active = true;
    max_bin = h;
    36e6:	f824 e007 	strh.w	lr, [r4, r7]
    min_bin = l;
    36ea:	5366      	strh	r6, [r4, r5]
    fft_num_bins = h - l;
    fft_scaler = s;
    scale_bin_values = scale_bin_v;
    36ec:	f884 2020 	strb.w	r2, [r4, #32]
    rms_active = true;
    rms_scaler = s;
};

void FeatureCollector::linkFFT(AudioAnalyzeFFT256*r, uint16_t l, uint16_t h, double s, bool scale_bin_v, bool c, bool f) {
    fft_ana = r;
    36f0:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
    fft_active = true;
    max_bin = h;
    min_bin = l;
    fft_num_bins = h - l;
    36f4:	f8a4 10f4 	strh.w	r1, [r4, #244]	; 0xf4
    36f8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    36fc:	2147      	movs	r1, #71	; 0x47
    36fe:	482f      	ldr	r0, [pc, #188]	; (37bc <linkFeatureCollectors()+0x578>)
    3700:	f007 ff7e 	bl	b600 <usb_serial_write>
    3704:	482e      	ldr	r0, [pc, #184]	; (37c0 <linkFeatureCollectors()+0x57c>)
    3706:	f005 fdb5 	bl	9274 <Print::println()>
    370a:	e5ba      	b.n	3282 <linkFeatureCollectors()+0x3e>
    370c:	2147      	movs	r1, #71	; 0x47
    370e:	482b      	ldr	r0, [pc, #172]	; (37bc <linkFeatureCollectors()+0x578>)
    3710:	f007 ff76 	bl	b600 <usb_serial_write>
    3714:	482a      	ldr	r0, [pc, #168]	; (37c0 <linkFeatureCollectors()+0x57c>)
    3716:	f005 fdad 	bl	9274 <Print::println()>
    371a:	e6d1      	b.n	34c0 <linkFeatureCollectors()+0x27c>
    371c:	2147      	movs	r1, #71	; 0x47
    371e:	4827      	ldr	r0, [pc, #156]	; (37bc <linkFeatureCollectors()+0x578>)
    3720:	f007 ff6e 	bl	b600 <usb_serial_write>
    3724:	4826      	ldr	r0, [pc, #152]	; (37c0 <linkFeatureCollectors()+0x57c>)
    3726:	f005 fda5 	bl	9274 <Print::println()>
    372a:	e6ad      	b.n	3488 <linkFeatureCollectors()+0x244>
    372c:	2147      	movs	r1, #71	; 0x47
    372e:	4823      	ldr	r0, [pc, #140]	; (37bc <linkFeatureCollectors()+0x578>)
    3730:	f007 ff66 	bl	b600 <usb_serial_write>
    3734:	4822      	ldr	r0, [pc, #136]	; (37c0 <linkFeatureCollectors()+0x57c>)
    3736:	f005 fd9d 	bl	9274 <Print::println()>
    373a:	e686      	b.n	344a <linkFeatureCollectors()+0x206>
    373c:	2147      	movs	r1, #71	; 0x47
    373e:	481f      	ldr	r0, [pc, #124]	; (37bc <linkFeatureCollectors()+0x578>)
    3740:	f007 ff5e 	bl	b600 <usb_serial_write>
    3744:	481e      	ldr	r0, [pc, #120]	; (37c0 <linkFeatureCollectors()+0x57c>)
    3746:	f005 fd95 	bl	9274 <Print::println()>
    374a:	e662      	b.n	3412 <linkFeatureCollectors()+0x1ce>
    374c:	2147      	movs	r1, #71	; 0x47
    374e:	481b      	ldr	r0, [pc, #108]	; (37bc <linkFeatureCollectors()+0x578>)
    3750:	f007 ff56 	bl	b600 <usb_serial_write>
    3754:	481a      	ldr	r0, [pc, #104]	; (37c0 <linkFeatureCollectors()+0x57c>)
    3756:	f005 fd8d 	bl	9274 <Print::println()>
    375a:	e63e      	b.n	33da <linkFeatureCollectors()+0x196>
    375c:	2147      	movs	r1, #71	; 0x47
    375e:	4817      	ldr	r0, [pc, #92]	; (37bc <linkFeatureCollectors()+0x578>)
    3760:	f007 ff4e 	bl	b600 <usb_serial_write>
    3764:	4816      	ldr	r0, [pc, #88]	; (37c0 <linkFeatureCollectors()+0x57c>)
    3766:	f005 fd85 	bl	9274 <Print::println()>
    376a:	e617      	b.n	339c <linkFeatureCollectors()+0x158>
    376c:	2147      	movs	r1, #71	; 0x47
    376e:	4813      	ldr	r0, [pc, #76]	; (37bc <linkFeatureCollectors()+0x578>)
    3770:	f007 ff46 	bl	b600 <usb_serial_write>
    3774:	4812      	ldr	r0, [pc, #72]	; (37c0 <linkFeatureCollectors()+0x57c>)
    3776:	f005 fd7d 	bl	9274 <Print::println()>
    377a:	e5f3      	b.n	3364 <linkFeatureCollectors()+0x120>
    377c:	2147      	movs	r1, #71	; 0x47
    377e:	480f      	ldr	r0, [pc, #60]	; (37bc <linkFeatureCollectors()+0x578>)
    3780:	f007 ff3e 	bl	b600 <usb_serial_write>
    3784:	480e      	ldr	r0, [pc, #56]	; (37c0 <linkFeatureCollectors()+0x57c>)
    3786:	f005 fd75 	bl	9274 <Print::println()>
    378a:	e5cf      	b.n	332c <linkFeatureCollectors()+0xe8>
    378c:	2147      	movs	r1, #71	; 0x47
    378e:	480b      	ldr	r0, [pc, #44]	; (37bc <linkFeatureCollectors()+0x578>)
    3790:	f007 ff36 	bl	b600 <usb_serial_write>
    3794:	480a      	ldr	r0, [pc, #40]	; (37c0 <linkFeatureCollectors()+0x57c>)
    3796:	f005 fd6d 	bl	9274 <Print::println()>
    379a:	e5a8      	b.n	32ee <linkFeatureCollectors()+0xaa>
    379c:	2147      	movs	r1, #71	; 0x47
    379e:	4807      	ldr	r0, [pc, #28]	; (37bc <linkFeatureCollectors()+0x578>)
    37a0:	f007 ff2e 	bl	b600 <usb_serial_write>
    37a4:	4806      	ldr	r0, [pc, #24]	; (37c0 <linkFeatureCollectors()+0x57c>)
    37a6:	f005 fd65 	bl	9274 <Print::println()>
    37aa:	e585      	b.n	32b8 <linkFeatureCollectors()+0x74>
    37ac:	4905      	ldr	r1, [pc, #20]	; (37c4 <linkFeatureCollectors()+0x580>)
    37ae:	4806      	ldr	r0, [pc, #24]	; (37c8 <linkFeatureCollectors()+0x584>)
    37b0:	f7fc ff16 	bl	5e0 <FeatureCollector::linkAmplifier(AudioAmplifier*, double, double) [clone .part.31]>
    37b4:	e6a3      	b.n	34fe <linkFeatureCollectors()+0x2ba>
    37b6:	bf00      	nop
    37b8:	1fffca6c 	.word	0x1fffca6c
    37bc:	00011248 	.word	0x00011248
    37c0:	1fffbaf4 	.word	0x1fffbaf4
    37c4:	1ffff77c 	.word	0x1ffff77c
    37c8:	20002d78 	.word	0x20002d78
    37cc:	20003ea8 	.word	0x20003ea8
    37d0:	20003ed8 	.word	0x20003ed8
    37d4:	1fffc55c 	.word	0x1fffc55c
    37d8:	20003f08 	.word	0x20003f08
    37dc:	20003f2c 	.word	0x20003f2c
    37e0:	1fffc9a8 	.word	0x1fffc9a8
    37e4:	1fffc538 	.word	0x1fffc538

000037e8 <setupAudio()>:
      // fc[3].setFluxActive(true);
    }
  }
}

void setupAudio() {
    37e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  ////////////// Audio ////////////
  AudioMemory(AUDIO_MEMORY);
    37ec:	2128      	movs	r1, #40	; 0x28
      // fc[3].setFluxActive(true);
    }
  }
}

void setupAudio() {
    37ee:	b089      	sub	sp, #36	; 0x24
  ////////////// Audio ////////////
  AudioMemory(AUDIO_MEMORY);
    37f0:	48bd      	ldr	r0, [pc, #756]	; (3ae8 <setupAudio()+0x300>)
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
    37f2:	f8df 9358 	ldr.w	r9, [pc, #856]	; 3b4c <setupAudio()+0x364>
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
    37f6:	f8df 8358 	ldr.w	r8, [pc, #856]	; 3b50 <setupAudio()+0x368>
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    37fa:	4fbc      	ldr	r7, [pc, #752]	; (3aec <setupAudio()+0x304>)
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    37fc:	4ebc      	ldr	r6, [pc, #752]	; (3af0 <setupAudio()+0x308>)
		//generate three helper-values (intermediate results):
		double sinsq = sinW0 * sqrt( (pow(a,2.0)+1.0)*(1.0/slope-1.0)+2.0*a );
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) + aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) - aMinus + sinsq	) * scale;
    37fe:	f8df b354 	ldr.w	fp, [pc, #852]	; 3b54 <setupAudio()+0x36c>
		/* b1 */ coef[1] =  2.0*a * ( (a-1.0) - aPlus  			) * scale;
    3802:	f8df a354 	ldr.w	sl, [pc, #852]	; 3b58 <setupAudio()+0x370>
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
    3806:	4cbb      	ldr	r4, [pc, #748]	; (3af4 <setupAudio()+0x30c>)
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
    3808:	4dbb      	ldr	r5, [pc, #748]	; (3af8 <setupAudio()+0x310>)
    380a:	f005 f9cb 	bl	8ba4 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)>
  linkFeatureCollectors();
    380e:	f7ff fd19 	bl	3244 <linkFeatureCollectors()>
    3812:	2127      	movs	r1, #39	; 0x27
    3814:	48b9      	ldr	r0, [pc, #740]	; (3afc <setupAudio()+0x314>)
    3816:	f007 fef3 	bl	b600 <usb_serial_write>
    381a:	48b9      	ldr	r0, [pc, #740]	; (3b00 <setupAudio()+0x318>)
    381c:	f005 fd2a 	bl	9274 <Print::println()>
    3820:	2129      	movs	r1, #41	; 0x29
    3822:	48b8      	ldr	r0, [pc, #736]	; (3b04 <setupAudio()+0x31c>)
    3824:	f007 feec 	bl	b600 <usb_serial_write>
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
		setCoefficients(stage, coef);
    3828:	aa03      	add	r2, sp, #12
    382a:	2100      	movs	r1, #0
    382c:	48b6      	ldr	r0, [pc, #728]	; (3b08 <setupAudio()+0x320>)
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
    382e:	f8cd 900c 	str.w	r9, [sp, #12]
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
    3832:	f8cd 9014 	str.w	r9, [sp, #20]
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
    3836:	f8cd 8010 	str.w	r8, [sp, #16]
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    383a:	9706      	str	r7, [sp, #24]
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    383c:	9607      	str	r6, [sp, #28]
		setCoefficients(stage, coef);
    383e:	f002 fe9f 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
    3842:	aa03      	add	r2, sp, #12
    3844:	2101      	movs	r1, #1
    3846:	48b0      	ldr	r0, [pc, #704]	; (3b08 <setupAudio()+0x320>)
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
    3848:	f8cd 900c 	str.w	r9, [sp, #12]
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
    384c:	f8cd 8010 	str.w	r8, [sp, #16]
		/* b2 */ coef[2] = coef[0];
    3850:	f8cd 9014 	str.w	r9, [sp, #20]
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    3854:	9706      	str	r7, [sp, #24]
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3856:	9607      	str	r6, [sp, #28]
		setCoefficients(stage, coef);
    3858:	f002 fe92 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
    385c:	aa03      	add	r2, sp, #12
    385e:	2102      	movs	r1, #2
    3860:	48a9      	ldr	r0, [pc, #676]	; (3b08 <setupAudio()+0x320>)
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
    3862:	f8cd 900c 	str.w	r9, [sp, #12]
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
    3866:	f8cd 8010 	str.w	r8, [sp, #16]
		/* b2 */ coef[2] = coef[0];
    386a:	f8cd 9014 	str.w	r9, [sp, #20]
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    386e:	9706      	str	r7, [sp, #24]
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3870:	9607      	str	r6, [sp, #28]
		setCoefficients(stage, coef);
    3872:	f002 fe85 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) + aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) - aMinus + sinsq	) * scale;
		/* b1 */ coef[1] =  2.0*a * ( (a-1.0) - aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) - aMinus - sinsq 	) * scale;
    3876:	4ba5      	ldr	r3, [pc, #660]	; (3b0c <setupAudio()+0x324>)
    3878:	9305      	str	r3, [sp, #20]
		/* a1 */ coef[3] = -2.0*	( (a-1.0) + aPlus			) * scale;
    387a:	f103 43c8 	add.w	r3, r3, #1677721600	; 0x64000000
    387e:	f503 13b6 	add.w	r3, r3, #1490944	; 0x16c000
    3882:	f203 639f 	addw	r3, r3, #1695	; 0x69f
		/* a2 */ coef[4] =  		( (a+1.0) + aMinus - sinsq	) * scale;
		setCoefficients(stage, coef);
    3886:	aa03      	add	r2, sp, #12
    3888:	2103      	movs	r1, #3
    388a:	489f      	ldr	r0, [pc, #636]	; (3b08 <setupAudio()+0x320>)
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) + aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) - aMinus + sinsq	) * scale;
		/* b1 */ coef[1] =  2.0*a * ( (a-1.0) - aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) - aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] = -2.0*	( (a-1.0) + aPlus			) * scale;
    388c:	9306      	str	r3, [sp, #24]
		/* a2 */ coef[4] =  		( (a+1.0) + aMinus - sinsq	) * scale;
    388e:	4ba0      	ldr	r3, [pc, #640]	; (3b10 <setupAudio()+0x328>)
    3890:	9307      	str	r3, [sp, #28]
		//generate three helper-values (intermediate results):
		double sinsq = sinW0 * sqrt( (pow(a,2.0)+1.0)*(1.0/slope-1.0)+2.0*a );
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) + aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) - aMinus + sinsq	) * scale;
    3892:	f8cd b00c 	str.w	fp, [sp, #12]
		/* b1 */ coef[1] =  2.0*a * ( (a-1.0) - aPlus  			) * scale;
    3896:	f8cd a010 	str.w	sl, [sp, #16]
		/* b2 */ coef[2] =		a * ( (a+1.0) - aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] = -2.0*	( (a-1.0) + aPlus			) * scale;
		/* a2 */ coef[4] =  		( (a+1.0) + aMinus - sinsq	) * scale;
		setCoefficients(stage, coef);
    389a:	f002 fe71 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
		setCoefficients(stage, coef);
    389e:	aa03      	add	r2, sp, #12
    38a0:	2100      	movs	r1, #0
    38a2:	489c      	ldr	r0, [pc, #624]	; (3b14 <setupAudio()+0x32c>)
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
    38a4:	f8cd 900c 	str.w	r9, [sp, #12]
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
    38a8:	f8cd 8010 	str.w	r8, [sp, #16]
		/* b2 */ coef[2] = coef[0];
    38ac:	f8cd 9014 	str.w	r9, [sp, #20]
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    38b0:	9706      	str	r7, [sp, #24]
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    38b2:	9607      	str	r6, [sp, #28]
		setCoefficients(stage, coef);
    38b4:	f002 fe64 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
    38b8:	aa03      	add	r2, sp, #12
    38ba:	2101      	movs	r1, #1
    38bc:	4895      	ldr	r0, [pc, #596]	; (3b14 <setupAudio()+0x32c>)
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
    38be:	f8cd 900c 	str.w	r9, [sp, #12]
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
    38c2:	f8cd 8010 	str.w	r8, [sp, #16]
		/* b2 */ coef[2] = coef[0];
    38c6:	f8cd 9014 	str.w	r9, [sp, #20]
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    38ca:	9706      	str	r7, [sp, #24]
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    38cc:	9607      	str	r6, [sp, #28]
		setCoefficients(stage, coef);
    38ce:	f002 fe57 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
    38d2:	aa03      	add	r2, sp, #12
    38d4:	2102      	movs	r1, #2
    38d6:	488f      	ldr	r0, [pc, #572]	; (3b14 <setupAudio()+0x32c>)
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
    38d8:	f8cd 8010 	str.w	r8, [sp, #16]
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
    38dc:	f8cd 900c 	str.w	r9, [sp, #12]
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
    38e0:	f8cd 9014 	str.w	r9, [sp, #20]
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    38e4:	9706      	str	r7, [sp, #24]
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    38e6:	9607      	str	r6, [sp, #28]
		setCoefficients(stage, coef);
    38e8:	f002 fe4a 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) + aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) - aMinus + sinsq	) * scale;
		/* b1 */ coef[1] =  2.0*a * ( (a-1.0) - aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) - aMinus - sinsq 	) * scale;
    38ec:	4b87      	ldr	r3, [pc, #540]	; (3b0c <setupAudio()+0x324>)
    38ee:	9305      	str	r3, [sp, #20]
		/* a1 */ coef[3] = -2.0*	( (a-1.0) + aPlus			) * scale;
    38f0:	f103 43c8 	add.w	r3, r3, #1677721600	; 0x64000000
    38f4:	f503 13b6 	add.w	r3, r3, #1490944	; 0x16c000
    38f8:	f203 639f 	addw	r3, r3, #1695	; 0x69f
		/* a2 */ coef[4] =  		( (a+1.0) + aMinus - sinsq	) * scale;
		setCoefficients(stage, coef);
    38fc:	aa03      	add	r2, sp, #12
    38fe:	2103      	movs	r1, #3
    3900:	4884      	ldr	r0, [pc, #528]	; (3b14 <setupAudio()+0x32c>)
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) + aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) - aMinus + sinsq	) * scale;
		/* b1 */ coef[1] =  2.0*a * ( (a-1.0) - aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) - aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] = -2.0*	( (a-1.0) + aPlus			) * scale;
    3902:	9306      	str	r3, [sp, #24]
		/* a2 */ coef[4] =  		( (a+1.0) + aMinus - sinsq	) * scale;
    3904:	4b82      	ldr	r3, [pc, #520]	; (3b10 <setupAudio()+0x328>)
    3906:	9307      	str	r3, [sp, #28]
		//generate three helper-values (intermediate results):
		double sinsq = sinW0 * sqrt( (pow(a,2.0)+1.0)*(1.0/slope-1.0)+2.0*a );
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) + aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) - aMinus + sinsq	) * scale;
    3908:	f8cd b00c 	str.w	fp, [sp, #12]
		/* b1 */ coef[1] =  2.0*a * ( (a-1.0) - aPlus  			) * scale;
    390c:	f8cd a010 	str.w	sl, [sp, #16]
		/* b2 */ coef[2] =		a * ( (a+1.0) - aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] = -2.0*	( (a-1.0) + aPlus			) * scale;
		/* a2 */ coef[4] =  		( (a+1.0) + aMinus - sinsq	) * scale;
		setCoefficients(stage, coef);
    3910:	f002 fe36 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
    3914:	2128      	movs	r1, #40	; 0x28
    3916:	4880      	ldr	r0, [pc, #512]	; (3b18 <setupAudio()+0x330>)
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    3918:	f8df 9240 	ldr.w	r9, [pc, #576]	; 3b5c <setupAudio()+0x374>
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    391c:	f8df 8240 	ldr.w	r8, [pc, #576]	; 3b60 <setupAudio()+0x378>
		//generate three helper-values (intermediate results):
		double sinsq = sinW0 * sqrt( (pow(a,2.0)+1.0)*(1.0/slope-1.0)+2.0*a );
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) - aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) + aMinus + sinsq	) * scale;
    3920:	f8df b240 	ldr.w	fp, [pc, #576]	; 3b64 <setupAudio()+0x37c>
		/* b1 */ coef[1] = -2.0*a * ( (a-1.0) + aPlus  			) * scale;
    3924:	f8df a240 	ldr.w	sl, [pc, #576]	; 3b68 <setupAudio()+0x380>
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
    3928:	4e7c      	ldr	r6, [pc, #496]	; (3b1c <setupAudio()+0x334>)
    392a:	f007 fe69 	bl	b600 <usb_serial_write>
    392e:	2108      	movs	r1, #8
    3930:	487b      	ldr	r0, [pc, #492]	; (3b20 <setupAudio()+0x338>)
    3932:	f007 fe65 	bl	b600 <usb_serial_write>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    3936:	f44f 6196 	mov.w	r1, #1200	; 0x4b0
    393a:	4871      	ldr	r0, [pc, #452]	; (3b00 <setupAudio()+0x318>)
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
    393c:	2702      	movs	r7, #2
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    393e:	f005 fce9 	bl	9314 <Print::print(long)>
    3942:	2103      	movs	r1, #3
    3944:	4877      	ldr	r0, [pc, #476]	; (3b24 <setupAudio()+0x33c>)
    3946:	f007 fe5b 	bl	b600 <usb_serial_write>
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
    394a:	a365      	add	r3, pc, #404	; (adr r3, 3ae0 <setupAudio()+0x2f8>)
    394c:	e9d3 2300 	ldrd	r2, r3, [r3]
    3950:	9700      	str	r7, [sp, #0]
    3952:	486b      	ldr	r0, [pc, #428]	; (3b00 <setupAudio()+0x318>)
    3954:	f005 fce8 	bl	9328 <Print::printFloat(double, unsigned char)>
    3958:	2103      	movs	r1, #3
    395a:	4873      	ldr	r0, [pc, #460]	; (3b28 <setupAudio()+0x340>)
    395c:	f007 fe50 	bl	b600 <usb_serial_write>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    3960:	f06f 010b 	mvn.w	r1, #11
    3964:	4866      	ldr	r0, [pc, #408]	; (3b00 <setupAudio()+0x318>)
    3966:	f005 fcd5 	bl	9314 <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    396a:	4865      	ldr	r0, [pc, #404]	; (3b00 <setupAudio()+0x318>)
    396c:	f005 fc82 	bl	9274 <Print::println()>
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
		setCoefficients(stage, coef);
    3970:	aa03      	add	r2, sp, #12
    3972:	2100      	movs	r1, #0
    3974:	486d      	ldr	r0, [pc, #436]	; (3b2c <setupAudio()+0x344>)
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
    3976:	9403      	str	r4, [sp, #12]
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
    3978:	9405      	str	r4, [sp, #20]
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
    397a:	9504      	str	r5, [sp, #16]
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    397c:	f8cd 9018 	str.w	r9, [sp, #24]
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3980:	f8cd 801c 	str.w	r8, [sp, #28]
		setCoefficients(stage, coef);
    3984:	f002 fdfc 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
    3988:	aa03      	add	r2, sp, #12
    398a:	2101      	movs	r1, #1
    398c:	4867      	ldr	r0, [pc, #412]	; (3b2c <setupAudio()+0x344>)
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
    398e:	9403      	str	r4, [sp, #12]
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
    3990:	9504      	str	r5, [sp, #16]
		/* b2 */ coef[2] = coef[0];
    3992:	9405      	str	r4, [sp, #20]
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    3994:	f8cd 9018 	str.w	r9, [sp, #24]
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3998:	f8cd 801c 	str.w	r8, [sp, #28]
		setCoefficients(stage, coef);
    399c:	f002 fdf0 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
    39a0:	aa03      	add	r2, sp, #12
    39a2:	4639      	mov	r1, r7
    39a4:	4861      	ldr	r0, [pc, #388]	; (3b2c <setupAudio()+0x344>)
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
    39a6:	9403      	str	r4, [sp, #12]
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
    39a8:	9504      	str	r5, [sp, #16]
		/* b2 */ coef[2] = coef[0];
    39aa:	9405      	str	r4, [sp, #20]
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    39ac:	f8cd 9018 	str.w	r9, [sp, #24]
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    39b0:	f8cd 801c 	str.w	r8, [sp, #28]
		setCoefficients(stage, coef);
    39b4:	f002 fde4 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) - aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) + aMinus + sinsq	) * scale;
		/* b1 */ coef[1] = -2.0*a * ( (a-1.0) + aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) + aMinus - sinsq 	) * scale;
    39b8:	4b5d      	ldr	r3, [pc, #372]	; (3b30 <setupAudio()+0x348>)
    39ba:	9305      	str	r3, [sp, #20]
		/* a1 */ coef[3] =  2.0*	( (a-1.0) - aPlus			) * scale;
    39bc:	4b5d      	ldr	r3, [pc, #372]	; (3b34 <setupAudio()+0x34c>)
		/* a2 */ coef[4] =  		( (a+1.0) - aMinus - sinsq	) * scale;
		setCoefficients(stage, coef);
    39be:	485b      	ldr	r0, [pc, #364]	; (3b2c <setupAudio()+0x344>)
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) - aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) + aMinus + sinsq	) * scale;
		/* b1 */ coef[1] = -2.0*a * ( (a-1.0) + aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) + aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] =  2.0*	( (a-1.0) - aPlus			) * scale;
    39c0:	9306      	str	r3, [sp, #24]
		/* a2 */ coef[4] =  		( (a+1.0) - aMinus - sinsq	) * scale;
		setCoefficients(stage, coef);
    39c2:	aa03      	add	r2, sp, #12
		double scale = 1073741824.0 / ( (a+1.0) - aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) + aMinus + sinsq	) * scale;
		/* b1 */ coef[1] = -2.0*a * ( (a-1.0) + aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) + aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] =  2.0*	( (a-1.0) - aPlus			) * scale;
		/* a2 */ coef[4] =  		( (a+1.0) - aMinus - sinsq	) * scale;
    39c4:	4b5c      	ldr	r3, [pc, #368]	; (3b38 <setupAudio()+0x350>)
    39c6:	9307      	str	r3, [sp, #28]
		setCoefficients(stage, coef);
    39c8:	2103      	movs	r1, #3
		//generate three helper-values (intermediate results):
		double sinsq = sinW0 * sqrt( (pow(a,2.0)+1.0)*(1.0/slope-1.0)+2.0*a );
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) - aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) + aMinus + sinsq	) * scale;
    39ca:	f8cd b00c 	str.w	fp, [sp, #12]
		/* b1 */ coef[1] = -2.0*a * ( (a-1.0) + aPlus  			) * scale;
    39ce:	f8cd a010 	str.w	sl, [sp, #16]
		/* b2 */ coef[2] =		a * ( (a+1.0) + aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] =  2.0*	( (a-1.0) - aPlus			) * scale;
		/* a2 */ coef[4] =  		( (a+1.0) - aMinus - sinsq	) * scale;
		setCoefficients(stage, coef);
    39d2:	f002 fdd5 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
		setCoefficients(stage, coef);
    39d6:	aa03      	add	r2, sp, #12
    39d8:	2100      	movs	r1, #0
    39da:	4858      	ldr	r0, [pc, #352]	; (3b3c <setupAudio()+0x354>)
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
    39dc:	9403      	str	r4, [sp, #12]
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
    39de:	9504      	str	r5, [sp, #16]
		/* b2 */ coef[2] = coef[0];
    39e0:	9405      	str	r4, [sp, #20]
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    39e2:	f8cd 9018 	str.w	r9, [sp, #24]
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    39e6:	f8cd 801c 	str.w	r8, [sp, #28]
		setCoefficients(stage, coef);
    39ea:	f002 fdc9 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
    39ee:	aa03      	add	r2, sp, #12
    39f0:	2101      	movs	r1, #1
    39f2:	4852      	ldr	r0, [pc, #328]	; (3b3c <setupAudio()+0x354>)
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
    39f4:	9403      	str	r4, [sp, #12]
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
    39f6:	9504      	str	r5, [sp, #16]
		/* b2 */ coef[2] = coef[0];
    39f8:	9405      	str	r4, [sp, #20]
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    39fa:	f8cd 9018 	str.w	r9, [sp, #24]
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    39fe:	f8cd 801c 	str.w	r8, [sp, #28]
		setCoefficients(stage, coef);
    3a02:	f002 fdbd 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
    3a06:	aa03      	add	r2, sp, #12
    3a08:	4639      	mov	r1, r7
    3a0a:	484c      	ldr	r0, [pc, #304]	; (3b3c <setupAudio()+0x354>)
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
    3a0c:	9504      	str	r5, [sp, #16]
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
    3a0e:	9403      	str	r4, [sp, #12]
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
    3a10:	9405      	str	r4, [sp, #20]
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    3a12:	f8cd 9018 	str.w	r9, [sp, #24]
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3a16:	f8cd 801c 	str.w	r8, [sp, #28]
		setCoefficients(stage, coef);
    3a1a:	f002 fdb1 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) - aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) + aMinus + sinsq	) * scale;
		/* b1 */ coef[1] = -2.0*a * ( (a-1.0) + aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) + aMinus - sinsq 	) * scale;
    3a1e:	4b44      	ldr	r3, [pc, #272]	; (3b30 <setupAudio()+0x348>)
    3a20:	9305      	str	r3, [sp, #20]
		/* a1 */ coef[3] =  2.0*	( (a-1.0) - aPlus			) * scale;
    3a22:	4b44      	ldr	r3, [pc, #272]	; (3b34 <setupAudio()+0x34c>)
		/* a2 */ coef[4] =  		( (a+1.0) - aMinus - sinsq	) * scale;
		setCoefficients(stage, coef);
    3a24:	4845      	ldr	r0, [pc, #276]	; (3b3c <setupAudio()+0x354>)
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) - aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) + aMinus + sinsq	) * scale;
		/* b1 */ coef[1] = -2.0*a * ( (a-1.0) + aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) + aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] =  2.0*	( (a-1.0) - aPlus			) * scale;
    3a26:	9306      	str	r3, [sp, #24]
		/* a2 */ coef[4] =  		( (a+1.0) - aMinus - sinsq	) * scale;
		setCoefficients(stage, coef);
    3a28:	aa03      	add	r2, sp, #12
		double scale = 1073741824.0 / ( (a+1.0) - aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) + aMinus + sinsq	) * scale;
		/* b1 */ coef[1] = -2.0*a * ( (a-1.0) + aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) + aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] =  2.0*	( (a-1.0) - aPlus			) * scale;
		/* a2 */ coef[4] =  		( (a+1.0) - aMinus - sinsq	) * scale;
    3a2a:	4b43      	ldr	r3, [pc, #268]	; (3b38 <setupAudio()+0x350>)
    3a2c:	9307      	str	r3, [sp, #28]
		setCoefficients(stage, coef);
    3a2e:	2103      	movs	r1, #3
		//generate three helper-values (intermediate results):
		double sinsq = sinW0 * sqrt( (pow(a,2.0)+1.0)*(1.0/slope-1.0)+2.0*a );
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) - aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) + aMinus + sinsq	) * scale;
    3a30:	f8cd b00c 	str.w	fp, [sp, #12]
		/* b1 */ coef[1] = -2.0*a * ( (a-1.0) + aPlus  			) * scale;
    3a34:	f8cd a010 	str.w	sl, [sp, #16]
		/* b2 */ coef[2] =		a * ( (a+1.0) + aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] =  2.0*	( (a-1.0) - aPlus			) * scale;
		/* a2 */ coef[4] =  		( (a+1.0) - aMinus - sinsq	) * scale;
		setCoefficients(stage, coef);
    3a38:	f002 fda2 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
    3a3c:	2128      	movs	r1, #40	; 0x28
    3a3e:	4840      	ldr	r0, [pc, #256]	; (3b40 <setupAudio()+0x358>)
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    3a40:	f8df 8128 	ldr.w	r8, [pc, #296]	; 3b6c <setupAudio()+0x384>
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
    3a44:	4c3f      	ldr	r4, [pc, #252]	; (3b44 <setupAudio()+0x35c>)
    3a46:	f007 fddb 	bl	b600 <usb_serial_write>
    3a4a:	2108      	movs	r1, #8
    3a4c:	4834      	ldr	r0, [pc, #208]	; (3b20 <setupAudio()+0x338>)
    3a4e:	f007 fdd7 	bl	b600 <usb_serial_write>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    3a52:	f640 31b8 	movw	r1, #3000	; 0xbb8
    3a56:	482a      	ldr	r0, [pc, #168]	; (3b00 <setupAudio()+0x318>)
    3a58:	f005 fc5c 	bl	9314 <Print::print(long)>
    3a5c:	2103      	movs	r1, #3
    3a5e:	4831      	ldr	r0, [pc, #196]	; (3b24 <setupAudio()+0x33c>)
    3a60:	f007 fdce 	bl	b600 <usb_serial_write>
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
    3a64:	a31e      	add	r3, pc, #120	; (adr r3, 3ae0 <setupAudio()+0x2f8>)
    3a66:	e9d3 2300 	ldrd	r2, r3, [r3]
    3a6a:	9700      	str	r7, [sp, #0]
    3a6c:	4824      	ldr	r0, [pc, #144]	; (3b00 <setupAudio()+0x318>)
    3a6e:	f005 fc5b 	bl	9328 <Print::printFloat(double, unsigned char)>
    3a72:	2103      	movs	r1, #3
    3a74:	482c      	ldr	r0, [pc, #176]	; (3b28 <setupAudio()+0x340>)
    3a76:	f007 fdc3 	bl	b600 <usb_serial_write>
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
    3a7a:	f109 6985 	add.w	r9, r9, #69730304	; 0x4280000
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    3a7e:	f06f 010b 	mvn.w	r1, #11
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3a82:	f105 55e4 	add.w	r5, r5, #478150656	; 0x1c800000
    3a86:	481e      	ldr	r0, [pc, #120]	; (3b00 <setupAudio()+0x318>)
    3a88:	f005 fc44 	bl	9314 <Print::print(long)>
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
    3a8c:	f509 3913 	add.w	r9, r9, #150528	; 0x24c00
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3a90:	f505 2538 	add.w	r5, r5, #753664	; 0xb8000
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    3a94:	481a      	ldr	r0, [pc, #104]	; (3b00 <setupAudio()+0x318>)
    3a96:	f005 fbed 	bl	9274 <Print::println()>
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
    3a9a:	f509 7907 	add.w	r9, r9, #540	; 0x21c
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3a9e:	f205 354a 	addw	r5, r5, #842	; 0x34a
		setCoefficients(stage, coef);
    3aa2:	aa03      	add	r2, sp, #12
    3aa4:	2100      	movs	r1, #0
    3aa6:	4828      	ldr	r0, [pc, #160]	; (3b48 <setupAudio()+0x360>)
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
    3aa8:	9603      	str	r6, [sp, #12]
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
    3aaa:	9605      	str	r6, [sp, #20]
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
    3aac:	f8cd 9010 	str.w	r9, [sp, #16]
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    3ab0:	f8cd 8018 	str.w	r8, [sp, #24]
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3ab4:	9507      	str	r5, [sp, #28]
		setCoefficients(stage, coef);
    3ab6:	f002 fd63 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
    3aba:	aa03      	add	r2, sp, #12
    3abc:	2101      	movs	r1, #1
    3abe:	4822      	ldr	r0, [pc, #136]	; (3b48 <setupAudio()+0x360>)
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
    3ac0:	9603      	str	r6, [sp, #12]
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
    3ac2:	f8cd 9010 	str.w	r9, [sp, #16]
		/* b2 */ coef[2] = coef[0];
    3ac6:	9605      	str	r6, [sp, #20]
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    3ac8:	f8cd 8018 	str.w	r8, [sp, #24]
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3acc:	9507      	str	r5, [sp, #28]
		setCoefficients(stage, coef);
    3ace:	f002 fd57 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
    3ad2:	aa03      	add	r2, sp, #12
    3ad4:	4639      	mov	r1, r7
    3ad6:	481c      	ldr	r0, [pc, #112]	; (3b48 <setupAudio()+0x360>)
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
    3ad8:	9603      	str	r6, [sp, #12]
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
    3ada:	f8cd 9010 	str.w	r9, [sp, #16]
    3ade:	e047      	b.n	3b70 <setupAudio()+0x388>
    3ae0:	40000000 	.word	0x40000000
    3ae4:	3feb3333 	.word	0x3feb3333
    3ae8:	1fff8200 	.word	0x1fff8200
    3aec:	8d5603fb 	.word	0x8d5603fb
    3af0:	345bf20e 	.word	0x345bf20e
    3af4:	025016ff 	.word	0x025016ff
    3af8:	04a02dfe 	.word	0x04a02dfe
    3afc:	00011674 	.word	0x00011674
    3b00:	1fffbaf4 	.word	0x1fffbaf4
    3b04:	0001169c 	.word	0x0001169c
    3b08:	1ffff85c 	.word	0x1ffff85c
    3b0c:	318b25ee 	.word	0x318b25ee
    3b10:	2d873ece 	.word	0x2d873ece
    3b14:	1ffff5e8 	.word	0x1ffff5e8
    3b18:	000116c8 	.word	0x000116c8
    3b1c:	2cbfbabf 	.word	0x2cbfbabf
    3b20:	000116f4 	.word	0x000116f4
    3b24:	00011700 	.word	0x00011700
    3b28:	00011704 	.word	0x00011704
    3b2c:	1ffff2fc 	.word	0x1ffff2fc
    3b30:	088ee63d 	.word	0x088ee63d
    3b34:	9b45c844 	.word	0x9b45c844
    3b38:	29980b47 	.word	0x29980b47
    3b3c:	1fffd1b8 	.word	0x1fffd1b8
    3b40:	00011708 	.word	0x00011708
    3b44:	247f4d31 	.word	0x247f4d31
    3b48:	1fffc7a4 	.word	0x1fffc7a4
    3b4c:	39c17b85 	.word	0x39c17b85
    3b50:	8c7d08f6 	.word	0x8c7d08f6
    3b54:	3acd23ba 	.word	0x3acd23ba
    3b58:	9472f767 	.word	0x9472f767
    3b5c:	a2563c66 	.word	0xa2563c66
    3b60:	26ea1f97 	.word	0x26ea1f97
    3b64:	13c9afeb 	.word	0x13c9afeb
    3b68:	e8853d62 	.word	0xe8853d62
    3b6c:	ae2cc64c 	.word	0xae2cc64c
		/* b2 */ coef[2] = coef[0];
    3b70:	9605      	str	r6, [sp, #20]
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    3b72:	f8cd 8018 	str.w	r8, [sp, #24]
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3b76:	9507      	str	r5, [sp, #28]
		setCoefficients(stage, coef);
    3b78:	f002 fd02 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) + aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) - aMinus + sinsq	) * scale;
		/* b1 */ coef[1] =  2.0*a * ( (a-1.0) - aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) - aMinus - sinsq 	) * scale;
    3b7c:	4bb2      	ldr	r3, [pc, #712]	; (3e48 <setupAudio()+0x660>)
    3b7e:	9305      	str	r3, [sp, #20]
		/* a1 */ coef[3] = -2.0*	( (a-1.0) + aPlus			) * scale;
    3b80:	4bb2      	ldr	r3, [pc, #712]	; (3e4c <setupAudio()+0x664>)
    3b82:	9306      	str	r3, [sp, #24]
		//generate three helper-values (intermediate results):
		double sinsq = sinW0 * sqrt( (pow(a,2.0)+1.0)*(1.0/slope-1.0)+2.0*a );
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) + aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) - aMinus + sinsq	) * scale;
    3b84:	f10b 5be7 	add.w	fp, fp, #484442112	; 0x1ce00000
		/* b1 */ coef[1] =  2.0*a * ( (a-1.0) - aPlus  			) * scale;
    3b88:	f1aa 5a39 	sub.w	sl, sl, #775946240	; 0x2e400000
		//generate three helper-values (intermediate results):
		double sinsq = sinW0 * sqrt( (pow(a,2.0)+1.0)*(1.0/slope-1.0)+2.0*a );
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) + aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) - aMinus + sinsq	) * scale;
    3b8c:	f50b 2b0e 	add.w	fp, fp, #581632	; 0x8e000
		/* b1 */ coef[1] =  2.0*a * ( (a-1.0) - aPlus  			) * scale;
    3b90:	f5aa 2a06 	sub.w	sl, sl, #548864	; 0x86000
		/* b2 */ coef[2] =		a * ( (a+1.0) - aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] = -2.0*	( (a-1.0) + aPlus			) * scale;
		/* a2 */ coef[4] =  		( (a+1.0) + aMinus - sinsq	) * scale;
    3b94:	f103 43a3 	add.w	r3, r3, #1367343104	; 0x51800000
    3b98:	f503 0394 	add.w	r3, r3, #4849664	; 0x4a0000
		//generate three helper-values (intermediate results):
		double sinsq = sinW0 * sqrt( (pow(a,2.0)+1.0)*(1.0/slope-1.0)+2.0*a );
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) + aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) - aMinus + sinsq	) * scale;
    3b9c:	f60b 5b7e 	addw	fp, fp, #3454	; 0xd7e
		/* b1 */ coef[1] =  2.0*a * ( (a-1.0) - aPlus  			) * scale;
    3ba0:	f6aa 4a39 	subw	sl, sl, #3129	; 0xc39
		/* b2 */ coef[2] =		a * ( (a+1.0) - aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] = -2.0*	( (a-1.0) + aPlus			) * scale;
		/* a2 */ coef[4] =  		( (a+1.0) + aMinus - sinsq	) * scale;
		setCoefficients(stage, coef);
    3ba4:	aa03      	add	r2, sp, #12
    3ba6:	2103      	movs	r1, #3
    3ba8:	48a9      	ldr	r0, [pc, #676]	; (3e50 <setupAudio()+0x668>)
		double scale = 1073741824.0 / ( (a+1.0) + aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) - aMinus + sinsq	) * scale;
		/* b1 */ coef[1] =  2.0*a * ( (a-1.0) - aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) - aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] = -2.0*	( (a-1.0) + aPlus			) * scale;
		/* a2 */ coef[4] =  		( (a+1.0) + aMinus - sinsq	) * scale;
    3baa:	9307      	str	r3, [sp, #28]
		//generate three helper-values (intermediate results):
		double sinsq = sinW0 * sqrt( (pow(a,2.0)+1.0)*(1.0/slope-1.0)+2.0*a );
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) + aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) - aMinus + sinsq	) * scale;
    3bac:	f8cd b00c 	str.w	fp, [sp, #12]
		/* b1 */ coef[1] =  2.0*a * ( (a-1.0) - aPlus  			) * scale;
    3bb0:	f8cd a010 	str.w	sl, [sp, #16]
		/* b2 */ coef[2] =		a * ( (a+1.0) - aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] = -2.0*	( (a-1.0) + aPlus			) * scale;
		/* a2 */ coef[4] =  		( (a+1.0) + aMinus - sinsq	) * scale;
		setCoefficients(stage, coef);
    3bb4:	f002 fce4 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
		setCoefficients(stage, coef);
    3bb8:	aa03      	add	r2, sp, #12
    3bba:	2100      	movs	r1, #0
    3bbc:	48a5      	ldr	r0, [pc, #660]	; (3e54 <setupAudio()+0x66c>)
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
    3bbe:	9603      	str	r6, [sp, #12]
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
    3bc0:	f8cd 9010 	str.w	r9, [sp, #16]
		/* b2 */ coef[2] = coef[0];
    3bc4:	9605      	str	r6, [sp, #20]
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    3bc6:	f8cd 8018 	str.w	r8, [sp, #24]
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3bca:	9507      	str	r5, [sp, #28]
		setCoefficients(stage, coef);
    3bcc:	f002 fcd8 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
    3bd0:	aa03      	add	r2, sp, #12
    3bd2:	2101      	movs	r1, #1
    3bd4:	489f      	ldr	r0, [pc, #636]	; (3e54 <setupAudio()+0x66c>)
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
    3bd6:	9603      	str	r6, [sp, #12]
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
    3bd8:	f8cd 9010 	str.w	r9, [sp, #16]
		/* b2 */ coef[2] = coef[0];
    3bdc:	9605      	str	r6, [sp, #20]
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    3bde:	f8cd 8018 	str.w	r8, [sp, #24]
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3be2:	9507      	str	r5, [sp, #28]
		setCoefficients(stage, coef);
    3be4:	f002 fccc 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
    3be8:	aa03      	add	r2, sp, #12
    3bea:	4639      	mov	r1, r7
    3bec:	4899      	ldr	r0, [pc, #612]	; (3e54 <setupAudio()+0x66c>)
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
    3bee:	f8cd 9010 	str.w	r9, [sp, #16]
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 + cosW0) / 2.0) * scale;
    3bf2:	9603      	str	r6, [sp, #12]
		/* b1 */ coef[1] = -(1.0 + cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
    3bf4:	9605      	str	r6, [sp, #20]
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    3bf6:	f8cd 8018 	str.w	r8, [sp, #24]
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3bfa:	9507      	str	r5, [sp, #28]
		setCoefficients(stage, coef);
    3bfc:	f002 fcc0 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) + aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) - aMinus + sinsq	) * scale;
		/* b1 */ coef[1] =  2.0*a * ( (a-1.0) - aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) - aMinus - sinsq 	) * scale;
    3c00:	4b91      	ldr	r3, [pc, #580]	; (3e48 <setupAudio()+0x660>)
    3c02:	9305      	str	r3, [sp, #20]
		/* a1 */ coef[3] = -2.0*	( (a-1.0) + aPlus			) * scale;
    3c04:	4b91      	ldr	r3, [pc, #580]	; (3e4c <setupAudio()+0x664>)
    3c06:	9306      	str	r3, [sp, #24]
		/* a2 */ coef[4] =  		( (a+1.0) + aMinus - sinsq	) * scale;
    3c08:	f103 43a3 	add.w	r3, r3, #1367343104	; 0x51800000
		setCoefficients(stage, coef);
    3c0c:	aa03      	add	r2, sp, #12
		double scale = 1073741824.0 / ( (a+1.0) + aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) - aMinus + sinsq	) * scale;
		/* b1 */ coef[1] =  2.0*a * ( (a-1.0) - aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) - aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] = -2.0*	( (a-1.0) + aPlus			) * scale;
		/* a2 */ coef[4] =  		( (a+1.0) + aMinus - sinsq	) * scale;
    3c0e:	f503 0394 	add.w	r3, r3, #4849664	; 0x4a0000
		setCoefficients(stage, coef);
    3c12:	2103      	movs	r1, #3
    3c14:	488f      	ldr	r0, [pc, #572]	; (3e54 <setupAudio()+0x66c>)
		//generate three helper-values (intermediate results):
		double sinsq = sinW0 * sqrt( (pow(a,2.0)+1.0)*(1.0/slope-1.0)+2.0*a );
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) + aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) - aMinus + sinsq	) * scale;
    3c16:	f8cd b00c 	str.w	fp, [sp, #12]
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3c1a:	f1a5 650b 	sub.w	r5, r5, #145752064	; 0x8b00000
		double sinsq = sinW0 * sqrt( (pow(a,2.0)+1.0)*(1.0/slope-1.0)+2.0*a );
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) + aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) - aMinus + sinsq	) * scale;
		/* b1 */ coef[1] =  2.0*a * ( (a-1.0) - aPlus  			) * scale;
    3c1e:	f8cd a010 	str.w	sl, [sp, #16]
		/* b2 */ coef[2] =		a * ( (a+1.0) - aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] = -2.0*	( (a-1.0) + aPlus			) * scale;
		/* a2 */ coef[4] =  		( (a+1.0) + aMinus - sinsq	) * scale;
    3c22:	9307      	str	r3, [sp, #28]
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3c24:	f5a5 2593 	sub.w	r5, r5, #301056	; 0x49800
		/* b0 */ coef[0] =		a *	( (a+1.0) - aMinus + sinsq	) * scale;
		/* b1 */ coef[1] =  2.0*a * ( (a-1.0) - aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) - aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] = -2.0*	( (a-1.0) + aPlus			) * scale;
		/* a2 */ coef[4] =  		( (a+1.0) + aMinus - sinsq	) * scale;
		setCoefficients(stage, coef);
    3c28:	f002 fcaa 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3c2c:	f46f 6399 	mvn.w	r3, #1224	; 0x4c8
    3c30:	2129      	movs	r1, #41	; 0x29
    3c32:	4889      	ldr	r0, [pc, #548]	; (3e58 <setupAudio()+0x670>)
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    3c34:	4e89      	ldr	r6, [pc, #548]	; (3e5c <setupAudio()+0x674>)
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
    3c36:	f8df 8278 	ldr.w	r8, [pc, #632]	; 3eb0 <setupAudio()+0x6c8>
		//generate three helper-values (intermediate results):
		double sinsq = sinW0 * sqrt( (pow(a,2.0)+1.0)*(1.0/slope-1.0)+2.0*a );
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) - aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) + aMinus + sinsq	) * scale;
    3c3a:	f8df b278 	ldr.w	fp, [pc, #632]	; 3eb4 <setupAudio()+0x6cc>
		/* b1 */ coef[1] = -2.0*a * ( (a-1.0) + aPlus  			) * scale;
    3c3e:	f8df a278 	ldr.w	sl, [pc, #632]	; 3eb8 <setupAudio()+0x6d0>

  Serial.print("Second Song BiQuads HP-HP-HP-LS       :\t");
  Serial.print("thresh:\t"); Serial.print(SONG_BQ1_THRESH); Serial.print("\tQ\t");
  Serial.print(SONG_BQ2_Q); Serial.print("\tdB"); Serial.println(SONG_BQ2_DB);

  fc[0].updateGain(STARTING_SONG_GAIN * MASTER_GAIN_SCALER);
    3c42:	f8df 9278 	ldr.w	r9, [pc, #632]	; 3ebc <setupAudio()+0x6d4>
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3c46:	441d      	add	r5, r3
    3c48:	f007 fcda 	bl	b600 <usb_serial_write>
    3c4c:	2108      	movs	r1, #8
    3c4e:	4884      	ldr	r0, [pc, #528]	; (3e60 <setupAudio()+0x678>)
    3c50:	f007 fcd6 	bl	b600 <usb_serial_write>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    3c54:	f44f 617a 	mov.w	r1, #4000	; 0xfa0
    3c58:	4882      	ldr	r0, [pc, #520]	; (3e64 <setupAudio()+0x67c>)
    3c5a:	f005 fb5b 	bl	9314 <Print::print(long)>
    3c5e:	2103      	movs	r1, #3
    3c60:	4881      	ldr	r0, [pc, #516]	; (3e68 <setupAudio()+0x680>)
    3c62:	f007 fccd 	bl	b600 <usb_serial_write>
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
    3c66:	a376      	add	r3, pc, #472	; (adr r3, 3e40 <setupAudio()+0x658>)
    3c68:	e9d3 2300 	ldrd	r2, r3, [r3]
    3c6c:	9700      	str	r7, [sp, #0]
    3c6e:	487d      	ldr	r0, [pc, #500]	; (3e64 <setupAudio()+0x67c>)
    3c70:	f005 fb5a 	bl	9328 <Print::printFloat(double, unsigned char)>
    3c74:	2103      	movs	r1, #3
    3c76:	487d      	ldr	r0, [pc, #500]	; (3e6c <setupAudio()+0x684>)
    3c78:	f007 fcc2 	bl	b600 <usb_serial_write>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    3c7c:	f06f 010b 	mvn.w	r1, #11
    3c80:	4878      	ldr	r0, [pc, #480]	; (3e64 <setupAudio()+0x67c>)
    3c82:	f005 fb47 	bl	9314 <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    3c86:	4877      	ldr	r0, [pc, #476]	; (3e64 <setupAudio()+0x67c>)
    3c88:	f005 faf4 	bl	9274 <Print::println()>
		setCoefficients(stage, coef);
    3c8c:	aa03      	add	r2, sp, #12
    3c8e:	2100      	movs	r1, #0
    3c90:	4877      	ldr	r0, [pc, #476]	; (3e70 <setupAudio()+0x688>)
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    3c92:	9606      	str	r6, [sp, #24]
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
    3c94:	9403      	str	r4, [sp, #12]
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
    3c96:	9405      	str	r4, [sp, #20]
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
    3c98:	f8cd 8010 	str.w	r8, [sp, #16]
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3c9c:	9507      	str	r5, [sp, #28]
		setCoefficients(stage, coef);
    3c9e:	f002 fc6f 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
    3ca2:	aa03      	add	r2, sp, #12
    3ca4:	2101      	movs	r1, #1
    3ca6:	4872      	ldr	r0, [pc, #456]	; (3e70 <setupAudio()+0x688>)
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    3ca8:	9606      	str	r6, [sp, #24]
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
    3caa:	9403      	str	r4, [sp, #12]
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
    3cac:	f8cd 8010 	str.w	r8, [sp, #16]
		/* b2 */ coef[2] = coef[0];
    3cb0:	9405      	str	r4, [sp, #20]
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3cb2:	9507      	str	r5, [sp, #28]
		setCoefficients(stage, coef);
    3cb4:	f002 fc64 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
    3cb8:	aa03      	add	r2, sp, #12
    3cba:	4639      	mov	r1, r7
    3cbc:	486c      	ldr	r0, [pc, #432]	; (3e70 <setupAudio()+0x688>)
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    3cbe:	9606      	str	r6, [sp, #24]
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
    3cc0:	9403      	str	r4, [sp, #12]
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
    3cc2:	f8cd 8010 	str.w	r8, [sp, #16]
		/* b2 */ coef[2] = coef[0];
    3cc6:	9405      	str	r4, [sp, #20]
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3cc8:	9507      	str	r5, [sp, #28]
		setCoefficients(stage, coef);
    3cca:	f002 fc59 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) - aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) + aMinus + sinsq	) * scale;
		/* b1 */ coef[1] = -2.0*a * ( (a-1.0) + aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) + aMinus - sinsq 	) * scale;
    3cce:	4b69      	ldr	r3, [pc, #420]	; (3e74 <setupAudio()+0x68c>)
    3cd0:	9305      	str	r3, [sp, #20]
		/* a1 */ coef[3] =  2.0*	( (a-1.0) - aPlus			) * scale;
    3cd2:	4b69      	ldr	r3, [pc, #420]	; (3e78 <setupAudio()+0x690>)
		/* a2 */ coef[4] =  		( (a+1.0) - aMinus - sinsq	) * scale;
		setCoefficients(stage, coef);
    3cd4:	4866      	ldr	r0, [pc, #408]	; (3e70 <setupAudio()+0x688>)
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) - aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) + aMinus + sinsq	) * scale;
		/* b1 */ coef[1] = -2.0*a * ( (a-1.0) + aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) + aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] =  2.0*	( (a-1.0) - aPlus			) * scale;
    3cd6:	9306      	str	r3, [sp, #24]
		/* a2 */ coef[4] =  		( (a+1.0) - aMinus - sinsq	) * scale;
		setCoefficients(stage, coef);
    3cd8:	aa03      	add	r2, sp, #12
		double scale = 1073741824.0 / ( (a+1.0) - aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) + aMinus + sinsq	) * scale;
		/* b1 */ coef[1] = -2.0*a * ( (a-1.0) + aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) + aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] =  2.0*	( (a-1.0) - aPlus			) * scale;
		/* a2 */ coef[4] =  		( (a+1.0) - aMinus - sinsq	) * scale;
    3cda:	4b68      	ldr	r3, [pc, #416]	; (3e7c <setupAudio()+0x694>)
    3cdc:	9307      	str	r3, [sp, #28]
		setCoefficients(stage, coef);
    3cde:	2103      	movs	r1, #3
		//generate three helper-values (intermediate results):
		double sinsq = sinW0 * sqrt( (pow(a,2.0)+1.0)*(1.0/slope-1.0)+2.0*a );
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) - aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) + aMinus + sinsq	) * scale;
    3ce0:	f8cd b00c 	str.w	fp, [sp, #12]
		/* b1 */ coef[1] = -2.0*a * ( (a-1.0) + aPlus  			) * scale;
    3ce4:	f8cd a010 	str.w	sl, [sp, #16]
		/* b2 */ coef[2] =		a * ( (a+1.0) + aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] =  2.0*	( (a-1.0) - aPlus			) * scale;
		/* a2 */ coef[4] =  		( (a+1.0) - aMinus - sinsq	) * scale;
		setCoefficients(stage, coef);
    3ce8:	f002 fc4a 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
		setCoefficients(stage, coef);
    3cec:	aa03      	add	r2, sp, #12
    3cee:	2100      	movs	r1, #0
    3cf0:	4863      	ldr	r0, [pc, #396]	; (3e80 <setupAudio()+0x698>)
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    3cf2:	9606      	str	r6, [sp, #24]
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
    3cf4:	9403      	str	r4, [sp, #12]
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
    3cf6:	f8cd 8010 	str.w	r8, [sp, #16]
		/* b2 */ coef[2] = coef[0];
    3cfa:	9405      	str	r4, [sp, #20]
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3cfc:	9507      	str	r5, [sp, #28]
		setCoefficients(stage, coef);
    3cfe:	f002 fc3f 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
    3d02:	aa03      	add	r2, sp, #12
    3d04:	2101      	movs	r1, #1
    3d06:	485e      	ldr	r0, [pc, #376]	; (3e80 <setupAudio()+0x698>)
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    3d08:	9606      	str	r6, [sp, #24]
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
    3d0a:	9403      	str	r4, [sp, #12]
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
    3d0c:	f8cd 8010 	str.w	r8, [sp, #16]
		/* b2 */ coef[2] = coef[0];
    3d10:	9405      	str	r4, [sp, #20]
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3d12:	9507      	str	r5, [sp, #28]
		setCoefficients(stage, coef);
    3d14:	f002 fc34 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
    3d18:	aa03      	add	r2, sp, #12
    3d1a:	4639      	mov	r1, r7
    3d1c:	4858      	ldr	r0, [pc, #352]	; (3e80 <setupAudio()+0x698>)
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
    3d1e:	9606      	str	r6, [sp, #24]
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
    3d20:	f8cd 8010 	str.w	r8, [sp, #16]
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1073741824.0 / (1.0 + alpha);
		/* b0 */ coef[0] = ((1.0 - cosW0) / 2.0) * scale;
    3d24:	9403      	str	r4, [sp, #12]
		/* b1 */ coef[1] = (1.0 - cosW0) * scale;
		/* b2 */ coef[2] = coef[0];
    3d26:	9405      	str	r4, [sp, #20]
		/* a1 */ coef[3] = (-2.0 * cosW0) * scale;
		/* a2 */ coef[4] = (1.0 - alpha) * scale;
    3d28:	9507      	str	r5, [sp, #28]
		setCoefficients(stage, coef);
    3d2a:	f002 fc29 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) - aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) + aMinus + sinsq	) * scale;
		/* b1 */ coef[1] = -2.0*a * ( (a-1.0) + aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) + aMinus - sinsq 	) * scale;
    3d2e:	4b51      	ldr	r3, [pc, #324]	; (3e74 <setupAudio()+0x68c>)
    3d30:	9305      	str	r3, [sp, #20]
		/* a1 */ coef[3] =  2.0*	( (a-1.0) - aPlus			) * scale;
    3d32:	4b51      	ldr	r3, [pc, #324]	; (3e78 <setupAudio()+0x690>)
		/* a2 */ coef[4] =  		( (a+1.0) - aMinus - sinsq	) * scale;
		setCoefficients(stage, coef);
    3d34:	4852      	ldr	r0, [pc, #328]	; (3e80 <setupAudio()+0x698>)
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) - aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) + aMinus + sinsq	) * scale;
		/* b1 */ coef[1] = -2.0*a * ( (a-1.0) + aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) + aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] =  2.0*	( (a-1.0) - aPlus			) * scale;
    3d36:	9306      	str	r3, [sp, #24]
		/* a2 */ coef[4] =  		( (a+1.0) - aMinus - sinsq	) * scale;
		setCoefficients(stage, coef);
    3d38:	aa03      	add	r2, sp, #12
		double scale = 1073741824.0 / ( (a+1.0) - aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) + aMinus + sinsq	) * scale;
		/* b1 */ coef[1] = -2.0*a * ( (a-1.0) + aPlus  			) * scale;
		/* b2 */ coef[2] =		a * ( (a+1.0) + aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] =  2.0*	( (a-1.0) - aPlus			) * scale;
		/* a2 */ coef[4] =  		( (a+1.0) - aMinus - sinsq	) * scale;
    3d3a:	4b50      	ldr	r3, [pc, #320]	; (3e7c <setupAudio()+0x694>)
    3d3c:	9307      	str	r3, [sp, #28]
		setCoefficients(stage, coef);
    3d3e:	2103      	movs	r1, #3
		//generate three helper-values (intermediate results):
		double sinsq = sinW0 * sqrt( (pow(a,2.0)+1.0)*(1.0/slope-1.0)+2.0*a );
		double aMinus = (a-1.0)*cosW0;
		double aPlus = (a+1.0)*cosW0;
		double scale = 1073741824.0 / ( (a+1.0) - aMinus + sinsq);
		/* b0 */ coef[0] =		a *	( (a+1.0) + aMinus + sinsq	) * scale;
    3d40:	f8cd b00c 	str.w	fp, [sp, #12]
		/* b1 */ coef[1] = -2.0*a * ( (a-1.0) + aPlus  			) * scale;
    3d44:	f8cd a010 	str.w	sl, [sp, #16]
		/* b2 */ coef[2] =		a * ( (a+1.0) + aMinus - sinsq 	) * scale;
		/* a1 */ coef[3] =  2.0*	( (a-1.0) - aPlus			) * scale;
		/* a2 */ coef[4] =  		( (a+1.0) - aMinus - sinsq	) * scale;
		setCoefficients(stage, coef);
    3d48:	f002 fc1a 	bl	6580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>
    3d4c:	2128      	movs	r1, #40	; 0x28
    3d4e:	484d      	ldr	r0, [pc, #308]	; (3e84 <setupAudio()+0x69c>)

  Serial.println("Testing Microphones");
  printTeensyDivide();

  // todo make this adapt to when microphones are broken on one or more side...
  for (int i = 0; i < num_channels; i++) {
    3d50:	4e4d      	ldr	r6, [pc, #308]	; (3e88 <setupAudio()+0x6a0>)
    3d52:	f007 fc55 	bl	b600 <usb_serial_write>
    3d56:	2108      	movs	r1, #8
    3d58:	4841      	ldr	r0, [pc, #260]	; (3e60 <setupAudio()+0x678>)
    3d5a:	f007 fc51 	bl	b600 <usb_serial_write>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    3d5e:	f44f 617a 	mov.w	r1, #4000	; 0xfa0
    3d62:	4840      	ldr	r0, [pc, #256]	; (3e64 <setupAudio()+0x67c>)
    3d64:	f005 fad6 	bl	9314 <Print::print(long)>
    3d68:	2103      	movs	r1, #3
    3d6a:	483f      	ldr	r0, [pc, #252]	; (3e68 <setupAudio()+0x680>)
    3d6c:	f007 fc48 	bl	b600 <usb_serial_write>
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
    3d70:	a333      	add	r3, pc, #204	; (adr r3, 3e40 <setupAudio()+0x658>)
    3d72:	e9d3 2300 	ldrd	r2, r3, [r3]
    3d76:	9700      	str	r7, [sp, #0]
    3d78:	483a      	ldr	r0, [pc, #232]	; (3e64 <setupAudio()+0x67c>)
    3d7a:	f005 fad5 	bl	9328 <Print::printFloat(double, unsigned char)>
    3d7e:	2103      	movs	r1, #3
    3d80:	483a      	ldr	r0, [pc, #232]	; (3e6c <setupAudio()+0x684>)
    3d82:	f007 fc3d 	bl	b600 <usb_serial_write>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    3d86:	f06f 010b 	mvn.w	r1, #11
    3d8a:	4836      	ldr	r0, [pc, #216]	; (3e64 <setupAudio()+0x67c>)
    3d8c:	f005 fac2 	bl	9314 <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    3d90:	4834      	ldr	r0, [pc, #208]	; (3e64 <setupAudio()+0x67c>)
    3d92:	f005 fa6f 	bl	9274 <Print::println()>

  Serial.print("Second Song BiQuads HP-HP-HP-LS       :\t");
  Serial.print("thresh:\t"); Serial.print(SONG_BQ1_THRESH); Serial.print("\tQ\t");
  Serial.print(SONG_BQ2_Q); Serial.print("\tdB"); Serial.println(SONG_BQ2_DB);

  fc[0].updateGain(STARTING_SONG_GAIN * MASTER_GAIN_SCALER);
    3d96:	e9d9 0100 	ldrd	r0, r1, [r9]
    3d9a:	2200      	movs	r2, #0
    3d9c:	4b3b      	ldr	r3, [pc, #236]	; (3e8c <setupAudio()+0x6a4>)
    3d9e:	f008 fe87 	bl	cab0 <__aeabi_dmul>
    3da2:	4602      	mov	r2, r0
    3da4:	460b      	mov	r3, r1
    3da6:	483a      	ldr	r0, [pc, #232]	; (3e90 <setupAudio()+0x6a8>)
    3da8:	f7fe faf8 	bl	239c <FeatureCollector::updateGain(double)>
  fc[1].updateGain(STARTING_SONG_GAIN * MASTER_GAIN_SCALER);
    3dac:	e9d9 0100 	ldrd	r0, r1, [r9]
    3db0:	2200      	movs	r2, #0
    3db2:	4b36      	ldr	r3, [pc, #216]	; (3e8c <setupAudio()+0x6a4>)
    3db4:	f008 fe7c 	bl	cab0 <__aeabi_dmul>
    3db8:	4602      	mov	r2, r0
    3dba:	460b      	mov	r3, r1
    3dbc:	4835      	ldr	r0, [pc, #212]	; (3e94 <setupAudio()+0x6ac>)
    3dbe:	f7fe faed 	bl	239c <FeatureCollector::updateGain(double)>
  fc[2].updateGain(STARTING_CLICK_GAIN * MASTER_GAIN_SCALER);
    3dc2:	e9d9 0100 	ldrd	r0, r1, [r9]
    3dc6:	2200      	movs	r2, #0
    3dc8:	4b33      	ldr	r3, [pc, #204]	; (3e98 <setupAudio()+0x6b0>)
    3dca:	f008 fe71 	bl	cab0 <__aeabi_dmul>
    3dce:	4602      	mov	r2, r0
    3dd0:	460b      	mov	r3, r1
    3dd2:	4832      	ldr	r0, [pc, #200]	; (3e9c <setupAudio()+0x6b4>)
    3dd4:	f7fe fae2 	bl	239c <FeatureCollector::updateGain(double)>
  fc[3].updateGain(STARTING_CLICK_GAIN * MASTER_GAIN_SCALER);
    3dd8:	e9d9 0100 	ldrd	r0, r1, [r9]
    3ddc:	2200      	movs	r2, #0
    3dde:	4b2e      	ldr	r3, [pc, #184]	; (3e98 <setupAudio()+0x6b0>)
    3de0:	f008 fe66 	bl	cab0 <__aeabi_dmul>
    3de4:	460b      	mov	r3, r1
    3de6:	4602      	mov	r2, r0
    3de8:	482d      	ldr	r0, [pc, #180]	; (3ea0 <setupAudio()+0x6b8>)
    3dea:	f7fe fad7 	bl	239c <FeatureCollector::updateGain(double)>
    3dee:	2113      	movs	r1, #19
    3df0:	482c      	ldr	r0, [pc, #176]	; (3ea4 <setupAudio()+0x6bc>)
    3df2:	f007 fc05 	bl	b600 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    3df6:	481b      	ldr	r0, [pc, #108]	; (3e64 <setupAudio()+0x67c>)
    3df8:	f005 fa3c 	bl	9274 <Print::println()>
    3dfc:	2125      	movs	r1, #37	; 0x25
    3dfe:	482a      	ldr	r0, [pc, #168]	; (3ea8 <setupAudio()+0x6c0>)
    3e00:	f007 fbfe 	bl	b600 <usb_serial_write>
    3e04:	4817      	ldr	r0, [pc, #92]	; (3e64 <setupAudio()+0x67c>)
    3e06:	f005 fa35 	bl	9274 <Print::println()>

  Serial.println("Testing Microphones");
  printTeensyDivide();

  // todo make this adapt to when microphones are broken on one or more side...
  for (int i = 0; i < num_channels; i++) {
    3e0a:	7833      	ldrb	r3, [r6, #0]
    3e0c:	b163      	cbz	r3, 3e28 <setupAudio()+0x640>
    3e0e:	4c20      	ldr	r4, [pc, #128]	; (3e90 <setupAudio()+0x6a8>)
    3e10:	2500      	movs	r5, #0
    fc[i].testMicrophone();
    3e12:	4620      	mov	r0, r4
    3e14:	f7fe fc84 	bl	2720 <FeatureCollector::testMicrophone()>

  Serial.println("Testing Microphones");
  printTeensyDivide();

  // todo make this adapt to when microphones are broken on one or more side...
  for (int i = 0; i < num_channels; i++) {
    3e18:	7833      	ldrb	r3, [r6, #0]
    3e1a:	3501      	adds	r5, #1
    3e1c:	f504 5488 	add.w	r4, r4, #4352	; 0x1100
    3e20:	42ab      	cmp	r3, r5
    3e22:	f104 0418 	add.w	r4, r4, #24
    3e26:	dcf4      	bgt.n	3e12 <setupAudio()+0x62a>
    fc[i].testMicrophone();
  }
  initAutoGain();
    3e28:	f7ff f9a2 	bl	3170 <initAutoGain()>
    3e2c:	2125      	movs	r1, #37	; 0x25
    3e2e:	481f      	ldr	r0, [pc, #124]	; (3eac <setupAudio()+0x6c4>)
    3e30:	f007 fbe6 	bl	b600 <usb_serial_write>
    3e34:	480b      	ldr	r0, [pc, #44]	; (3e64 <setupAudio()+0x67c>)
    3e36:	f005 fa1d 	bl	9274 <Print::println()>
  printDivide();
}
    3e3a:	b009      	add	sp, #36	; 0x24
    3e3c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3e40:	40000000 	.word	0x40000000
    3e44:	3feb3333 	.word	0x3feb3333
    3e48:	1b5433c0 	.word	0x1b5433c0
    3e4c:	c3931760 	.word	0xc3931760
    3e50:	1fffc7a4 	.word	0x1fffc7a4
    3e54:	1ffff7c0 	.word	0x1ffff7c0
    3e58:	00011734 	.word	0x00011734
    3e5c:	39862048 	.word	0x39862048
    3e60:	000116f4 	.word	0x000116f4
    3e64:	1fffbaf4 	.word	0x1fffbaf4
    3e68:	00011700 	.word	0x00011700
    3e6c:	00011704 	.word	0x00011704
    3e70:	1fffc854 	.word	0x1fffc854
    3e74:	11a15a41 	.word	0x11a15a41
    3e78:	1f88eadb 	.word	0x1f88eadb
    3e7c:	0dbfa599 	.word	0x0dbfa599
    3e80:	1ffff398 	.word	0x1ffff398
    3e84:	00011760 	.word	0x00011760
    3e88:	1fffb8a2 	.word	0x1fffb8a2
    3e8c:	40180000 	.word	0x40180000
    3e90:	1ffffa30 	.word	0x1ffffa30
    3e94:	20000b48 	.word	0x20000b48
    3e98:	402e0000 	.word	0x402e0000
    3e9c:	20001c60 	.word	0x20001c60
    3ea0:	20002d78 	.word	0x20002d78
    3ea4:	0001178c 	.word	0x0001178c
    3ea8:	00010784 	.word	0x00010784
    3eac:	000107ac 	.word	0x000107ac
    3eb0:	48fe9a63 	.word	0x48fe9a63
    3eb4:	2ad0cd4b 	.word	0x2ad0cd4b
    3eb8:	30d668e7 	.word	0x30d668e7
    3ebc:	1fffb890 	.word	0x1fffb890

00003ec0 <calculateRMSWeighted(FeatureCollector*)>:
    }
    return -1.0;
}

double FeatureCollector::getRMS() {
    if (rms_active) {
    3ec0:	f890 306c 	ldrb.w	r3, [r0, #108]	; 0x6c

uint8_t calculateRMSWeighted(FeatureCollector *f) {
    3ec4:	b5d0      	push	{r4, r6, r7, lr}
    3ec6:	4604      	mov	r4, r0
    3ec8:	b33b      	cbz	r3, 3f1a <calculateRMSWeighted(FeatureCollector*)+0x5a>
        return rms_val;
    3eca:	e9d0 011c 	ldrd	r0, r1, [r0, #112]	; 0x70
  double rms = 0;
  rms = f->getRMS() * global_rms_scaler - RMS_LOW_THRESH;
    3ece:	4b22      	ldr	r3, [pc, #136]	; (3f58 <calculateRMSWeighted(FeatureCollector*)+0x98>)
    3ed0:	e9d3 2300 	ldrd	r2, r3, [r3]
    3ed4:	f008 fdec 	bl	cab0 <__aeabi_dmul>
    3ed8:	a31b      	add	r3, pc, #108	; (adr r3, 3f48 <calculateRMSWeighted(FeatureCollector*)+0x88>)
    3eda:	e9d3 2300 	ldrd	r2, r3, [r3]
    3ede:	f008 fc33 	bl	c748 <__aeabi_dsub>
  if (rms > 1.0) {
    3ee2:	2200      	movs	r2, #0
    3ee4:	4b1d      	ldr	r3, [pc, #116]	; (3f5c <calculateRMSWeighted(FeatureCollector*)+0x9c>)
  printDivide();
}

uint8_t calculateRMSWeighted(FeatureCollector *f) {
  double rms = 0;
  rms = f->getRMS() * global_rms_scaler - RMS_LOW_THRESH;
    3ee6:	4606      	mov	r6, r0
    3ee8:	460f      	mov	r7, r1
  if (rms > 1.0) {
    3eea:	f009 f871 	bl	cfd0 <__aeabi_dcmpgt>
    3eee:	4604      	mov	r4, r0
    3ef0:	b108      	cbz	r0, 3ef6 <calculateRMSWeighted(FeatureCollector*)+0x36>
    3ef2:	20ff      	movs	r0, #255	; 0xff
    3ef4:	bdd0      	pop	{r4, r6, r7, pc}
    rms = 1.0;
  } else if (rms < 0.0) {
    3ef6:	2200      	movs	r2, #0
    3ef8:	2300      	movs	r3, #0
    3efa:	4630      	mov	r0, r6
    3efc:	4639      	mov	r1, r7
    3efe:	f009 f849 	bl	cf94 <__aeabi_dcmplt>
    3f02:	b9e0      	cbnz	r0, 3f3e <calculateRMSWeighted(FeatureCollector*)+0x7e>
    3f04:	a312      	add	r3, pc, #72	; (adr r3, 3f50 <calculateRMSWeighted(FeatureCollector*)+0x90>)
    3f06:	e9d3 2300 	ldrd	r2, r3, [r3]
    3f0a:	4630      	mov	r0, r6
    3f0c:	4639      	mov	r1, r7
    3f0e:	f008 fdcf 	bl	cab0 <__aeabi_dmul>
    3f12:	f009 f8a5 	bl	d060 <__aeabi_d2uiz>
    3f16:	b2c0      	uxtb	r0, r0
    3f18:	bdd0      	pop	{r4, r6, r7, pc}
    3f1a:	212e      	movs	r1, #46	; 0x2e
    3f1c:	4810      	ldr	r0, [pc, #64]	; (3f60 <calculateRMSWeighted(FeatureCollector*)+0xa0>)
    3f1e:	f007 fb6f 	bl	b600 <usb_serial_write>
    3f22:	4810      	ldr	r0, [pc, #64]	; (3f64 <calculateRMSWeighted(FeatureCollector*)+0xa4>)
    3f24:	f005 f9a6 	bl	9274 <Print::println()>
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
    3f28:	f104 0128 	add.w	r1, r4, #40	; 0x28
    3f2c:	480d      	ldr	r0, [pc, #52]	; (3f64 <calculateRMSWeighted(FeatureCollector*)+0xa4>)
    3f2e:	f005 f97b 	bl	9228 <Print::print(String const&)>
    3f32:	480c      	ldr	r0, [pc, #48]	; (3f64 <calculateRMSWeighted(FeatureCollector*)+0xa4>)
    3f34:	f005 f99e 	bl	9274 <Print::println()>
    3f38:	2000      	movs	r0, #0
    3f3a:	490b      	ldr	r1, [pc, #44]	; (3f68 <calculateRMSWeighted(FeatureCollector*)+0xa8>)
    3f3c:	e7c7      	b.n	3ece <calculateRMSWeighted(FeatureCollector*)+0xe>
    3f3e:	4620      	mov	r0, r4
    rms = 0.0;
  }
  uint8_t scaler = (uint8_t)(rms * (double)MAX_BRIGHTNESS);
  return scaler;
}
    3f40:	bdd0      	pop	{r4, r6, r7, pc}
    3f42:	bf00      	nop
    3f44:	f3af 8000 	nop.w
    3f48:	a0000000 	.word	0xa0000000
    3f4c:	3fb99999 	.word	0x3fb99999
    3f50:	00000000 	.word	0x00000000
    3f54:	406fe000 	.word	0x406fe000
    3f58:	1fffb898 	.word	0x1fffb898
    3f5c:	3ff00000 	.word	0x3ff00000
    3f60:	0001143c 	.word	0x0001143c
    3f64:	1fffbaf4 	.word	0x1fffbaf4
    3f68:	bff00000 	.word	0xbff00000
    3f6c:	ffffffff 	.word	0xffffffff

00003f70 <calculatePeakWeighted(FeatureCollector*)>:
    Serial.println("ERROR  - RMS IS NOT AN ACTIVE AUDIO FEATURE : "); Serial.println(name);
    return -1.0;
}

double FeatureCollector::getPeak() {
    if (peak_active) {
    3f70:	f890 30a0 	ldrb.w	r3, [r0, #160]	; 0xa0

uint8_t calculatePeakWeighted(FeatureCollector *f) {
    3f74:	b5d0      	push	{r4, r6, r7, lr}
    3f76:	4604      	mov	r4, r0
    3f78:	b33b      	cbz	r3, 3fca <calculatePeakWeighted(FeatureCollector*)+0x5a>
        return peak_val;
    3f7a:	e9d0 012a 	ldrd	r0, r1, [r0, #168]	; 0xa8
  double peak = 0;
  peak = f->getPeak() * global_peak_scaler - PEAK_LOW_THRESH;
    3f7e:	4b22      	ldr	r3, [pc, #136]	; (4008 <calculatePeakWeighted(FeatureCollector*)+0x98>)
    3f80:	e9d3 2300 	ldrd	r2, r3, [r3]
    3f84:	f008 fd94 	bl	cab0 <__aeabi_dmul>
    3f88:	a31b      	add	r3, pc, #108	; (adr r3, 3ff8 <calculatePeakWeighted(FeatureCollector*)+0x88>)
    3f8a:	e9d3 2300 	ldrd	r2, r3, [r3]
    3f8e:	f008 fbdb 	bl	c748 <__aeabi_dsub>
  if (peak > 1.0) {
    3f92:	2200      	movs	r2, #0
    3f94:	4b1d      	ldr	r3, [pc, #116]	; (400c <calculatePeakWeighted(FeatureCollector*)+0x9c>)
  return scaler;
}

uint8_t calculatePeakWeighted(FeatureCollector *f) {
  double peak = 0;
  peak = f->getPeak() * global_peak_scaler - PEAK_LOW_THRESH;
    3f96:	4606      	mov	r6, r0
    3f98:	460f      	mov	r7, r1
  if (peak > 1.0) {
    3f9a:	f009 f819 	bl	cfd0 <__aeabi_dcmpgt>
    3f9e:	4604      	mov	r4, r0
    3fa0:	b108      	cbz	r0, 3fa6 <calculatePeakWeighted(FeatureCollector*)+0x36>
    3fa2:	20ff      	movs	r0, #255	; 0xff
    3fa4:	bdd0      	pop	{r4, r6, r7, pc}
    peak = 1.0;
  } else if (peak < 0.0) {
    3fa6:	2200      	movs	r2, #0
    3fa8:	2300      	movs	r3, #0
    3faa:	4630      	mov	r0, r6
    3fac:	4639      	mov	r1, r7
    3fae:	f008 fff1 	bl	cf94 <__aeabi_dcmplt>
    3fb2:	b9e0      	cbnz	r0, 3fee <calculatePeakWeighted(FeatureCollector*)+0x7e>
    3fb4:	a312      	add	r3, pc, #72	; (adr r3, 4000 <calculatePeakWeighted(FeatureCollector*)+0x90>)
    3fb6:	e9d3 2300 	ldrd	r2, r3, [r3]
    3fba:	4630      	mov	r0, r6
    3fbc:	4639      	mov	r1, r7
    3fbe:	f008 fd77 	bl	cab0 <__aeabi_dmul>
    3fc2:	f009 f84d 	bl	d060 <__aeabi_d2uiz>
    3fc6:	b2c0      	uxtb	r0, r0
    3fc8:	bdd0      	pop	{r4, r6, r7, pc}
    3fca:	212f      	movs	r1, #47	; 0x2f
    3fcc:	4810      	ldr	r0, [pc, #64]	; (4010 <calculatePeakWeighted(FeatureCollector*)+0xa0>)
    3fce:	f007 fb17 	bl	b600 <usb_serial_write>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    3fd2:	4810      	ldr	r0, [pc, #64]	; (4014 <calculatePeakWeighted(FeatureCollector*)+0xa4>)
    3fd4:	f005 f94e 	bl	9274 <Print::println()>
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
    3fd8:	f104 0128 	add.w	r1, r4, #40	; 0x28
    3fdc:	480d      	ldr	r0, [pc, #52]	; (4014 <calculatePeakWeighted(FeatureCollector*)+0xa4>)
    3fde:	f005 f923 	bl	9228 <Print::print(String const&)>
    3fe2:	480c      	ldr	r0, [pc, #48]	; (4014 <calculatePeakWeighted(FeatureCollector*)+0xa4>)
    3fe4:	f005 f946 	bl	9274 <Print::println()>
    3fe8:	2000      	movs	r0, #0
    3fea:	490b      	ldr	r1, [pc, #44]	; (4018 <calculatePeakWeighted(FeatureCollector*)+0xa8>)
    3fec:	e7c7      	b.n	3f7e <calculatePeakWeighted(FeatureCollector*)+0xe>
    3fee:	4620      	mov	r0, r4
    peak = 0.0;
  }
  uint8_t scaler = uint8_t(peak * (double)MAX_BRIGHTNESS);
  return scaler;
}
    3ff0:	bdd0      	pop	{r4, r6, r7, pc}
    3ff2:	bf00      	nop
    3ff4:	f3af 8000 	nop.w
    3ff8:	a0000000 	.word	0xa0000000
    3ffc:	3fb99999 	.word	0x3fb99999
    4000:	00000000 	.word	0x00000000
    4004:	406fe000 	.word	0x406fe000
    4008:	1fffb8b0 	.word	0x1fffb8b0
    400c:	3ff00000 	.word	0x3ff00000
    4010:	0001146c 	.word	0x0001146c
    4014:	1fffbaf4 	.word	0x1fffbaf4
    4018:	bff00000 	.word	0xbff00000

0000401c <setupDLManager()>:

void setupDLManager() {
    401c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  // log data to EEPROM if datalogging is active
  if (data_logging_active) {
    4020:	4b08      	ldr	r3, [pc, #32]	; (4044 <setupDLManager()+0x28>)
    4022:	781a      	ldrb	r2, [r3, #0]
  }
  uint8_t scaler = uint8_t(peak * (double)MAX_BRIGHTNESS);
  return scaler;
}

void setupDLManager() {
    4024:	b087      	sub	sp, #28
  // log data to EEPROM if datalogging is active
  if (data_logging_active) {
    4026:	b9aa      	cbnz	r2, 4054 <setupDLManager()+0x38>
    } else {
      Serial.println("Not printing the EEPROM Datalog Contents");
    }
  } else {
    if (PRINT_EEPROM_CONTENTS > 0) {
      datalog_manager.printAllLogs();
    4028:	4807      	ldr	r0, [pc, #28]	; (4048 <setupDLManager()+0x2c>)
    402a:	f7fd f98b 	bl	1344 <DLManager::printAllLogs()>
    402e:	2128      	movs	r1, #40	; 0x28
    4030:	4806      	ldr	r0, [pc, #24]	; (404c <setupDLManager()+0x30>)
    4032:	f007 fae5 	bl	b600 <usb_serial_write>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    4036:	4806      	ldr	r0, [pc, #24]	; (4050 <setupDLManager()+0x34>)
    4038:	f005 f91c 	bl	9274 <Print::println()>
    delay(100);
    datalog_manager.clearLogs();
  } else {
    Serial.println("Not clearing the EEPROM Datalog Contents");
  }
}
    403c:	b007      	add	sp, #28
    403e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4042:	bf00      	nop
    4044:	1fffb8a0 	.word	0x1fffb8a0
    4048:	1fffd278 	.word	0x1fffd278
    404c:	00011b64 	.word	0x00011b64
    4050:	1fffbaf4 	.word	0x1fffbaf4
    }
}
//
/////////////////////////////////// Utility Functions /////////////////////////////////////////
void DLManager::configureAutoTimer(uint8_t num, uint32_t start_delay, uint32_t log_time, uint32_t logs_requested) {
    log_refresh_length[num] = log_time / logs_requested;
    4054:	4cc0      	ldr	r4, [pc, #768]	; (4358 <setupDLManager()+0x33c>)
    4056:	48c1      	ldr	r0, [pc, #772]	; (435c <setupDLManager()+0x340>)
    4058:	9301      	str	r3, [sp, #4]
    405a:	2122      	movs	r1, #34	; 0x22
    405c:	f007 fad0 	bl	b600 <usb_serial_write>
    4060:	48bf      	ldr	r0, [pc, #764]	; (4360 <setupDLManager()+0x344>)
    4062:	f005 f907 	bl	9274 <Print::println()>
}

void DLManager::configureStaticTimer(uint8_t num, uint32_t start_delay, uint32_t logging_rate) {
    log_refresh_length[num] = logging_rate;
    start_delays[num] = start_delay;
    remaining_logs[num] = 100000;// the number of writes which are allowed before the EEPROM turns bad
    4066:	f504 5302 	add.w	r3, r4, #8320	; 0x2080
    406a:	49be      	ldr	r1, [pc, #760]	; (4364 <setupDLManager()+0x348>)
    406c:	6019      	str	r1, [r3, #0]
    406e:	f242 037c 	movw	r3, #8316	; 0x207c
    start_delays[num] = start_delay;
    remaining_logs[num] = logs_requested;
}

void DLManager::configureStaticTimer(uint8_t num, uint32_t start_delay, uint32_t logging_rate) {
    log_refresh_length[num] = logging_rate;
    4072:	f242 0560 	movw	r5, #8288	; 0x2060
    start_delays[num] = start_delay;
    remaining_logs[num] = 100000;// the number of writes which are allowed before the EEPROM turns bad
    4076:	50e1      	str	r1, [r4, r3]
    start_delays[num] = start_delay;
    remaining_logs[num] = logs_requested;
}

void DLManager::configureStaticTimer(uint8_t num, uint32_t start_delay, uint32_t logging_rate) {
    log_refresh_length[num] = logging_rate;
    4078:	f8df e36c 	ldr.w	lr, [pc, #876]	; 43e8 <setupDLManager()+0x3cc>
    407c:	f844 e005 	str.w	lr, [r4, r5]
//
/////////////////////////////////// Utility Functions /////////////////////////////////////////
void DLManager::configureAutoTimer(uint8_t num, uint32_t start_delay, uint32_t log_time, uint32_t logs_requested) {
    log_refresh_length[num] = log_time / logs_requested;
    start_delays[num] = start_delay;
    remaining_logs[num] = logs_requested;
    4080:	f242 0374 	movw	r3, #8308	; 0x2074
    4084:	f04f 0e14 	mov.w	lr, #20
    4088:	f844 e003 	str.w	lr, [r4, r3]
    408c:	f242 0378 	movw	r3, #8312	; 0x2078
    }
}
//
/////////////////////////////////// Utility Functions /////////////////////////////////////////
void DLManager::configureAutoTimer(uint8_t num, uint32_t start_delay, uint32_t log_time, uint32_t logs_requested) {
    log_refresh_length[num] = log_time / logs_requested;
    4090:	f242 0a54 	movw	sl, #8276	; 0x2054
    start_delays[num] = start_delay;
    4094:	f242 0b64 	movw	fp, #8292	; 0x2064
    remaining_logs[num] = logs_requested;
}

void DLManager::configureStaticTimer(uint8_t num, uint32_t start_delay, uint32_t logging_rate) {
    log_refresh_length[num] = logging_rate;
    start_delays[num] = start_delay;
    4098:	f242 076c 	movw	r7, #8300	; 0x206c
//
/////////////////////////////////// Utility Functions /////////////////////////////////////////
void DLManager::configureAutoTimer(uint8_t num, uint32_t start_delay, uint32_t log_time, uint32_t logs_requested) {
    log_refresh_length[num] = log_time / logs_requested;
    start_delays[num] = start_delay;
    remaining_logs[num] = logs_requested;
    409c:	f844 e003 	str.w	lr, [r4, r3]
    }
}
//
/////////////////////////////////// Utility Functions /////////////////////////////////////////
void DLManager::configureAutoTimer(uint8_t num, uint32_t start_delay, uint32_t log_time, uint32_t logs_requested) {
    log_refresh_length[num] = log_time / logs_requested;
    40a0:	f242 0858 	movw	r8, #8280	; 0x2058
    remaining_logs[num] = logs_requested;
}

void DLManager::configureStaticTimer(uint8_t num, uint32_t start_delay, uint32_t logging_rate) {
    log_refresh_length[num] = logging_rate;
    start_delays[num] = start_delay;
    40a4:	f242 0370 	movw	r3, #8304	; 0x2070
    start_delays[num] = start_delay;
    remaining_logs[num] = logs_requested;
}

void DLManager::configureStaticTimer(uint8_t num, uint32_t start_delay, uint32_t logging_rate) {
    log_refresh_length[num] = logging_rate;
    40a8:	f242 065c 	movw	r6, #8284	; 0x205c
}
//
/////////////////////////////////// Utility Functions /////////////////////////////////////////
void DLManager::configureAutoTimer(uint8_t num, uint32_t start_delay, uint32_t log_time, uint32_t logs_requested) {
    log_refresh_length[num] = log_time / logs_requested;
    start_delays[num] = start_delay;
    40ac:	f242 0968 	movw	r9, #8296	; 0x2068
    40b0:	4aad      	ldr	r2, [pc, #692]	; (4368 <setupDLManager()+0x34c>)
    }
}
//
/////////////////////////////////// Utility Functions /////////////////////////////////////////
void DLManager::configureAutoTimer(uint8_t num, uint32_t start_delay, uint32_t log_time, uint32_t logs_requested) {
    log_refresh_length[num] = log_time / logs_requested;
    40b2:	49ae      	ldr	r1, [pc, #696]	; (436c <setupDLManager()+0x350>)
    start_delays[num] = start_delay;
    40b4:	f844 200b 	str.w	r2, [r4, fp]
    }
}
//
/////////////////////////////////// Utility Functions /////////////////////////////////////////
void DLManager::configureAutoTimer(uint8_t num, uint32_t start_delay, uint32_t log_time, uint32_t logs_requested) {
    log_refresh_length[num] = log_time / logs_requested;
    40b8:	f244 6050 	movw	r0, #18000	; 0x4650
    40bc:	f844 000a 	str.w	r0, [r4, sl]
    remaining_logs[num] = logs_requested;
}

void DLManager::configureStaticTimer(uint8_t num, uint32_t start_delay, uint32_t logging_rate) {
    log_refresh_length[num] = logging_rate;
    start_delays[num] = start_delay;
    40c0:	51e2      	str	r2, [r4, r7]
    Serial.println("configuring datalog_manager timers");
    datalog_manager.configureAutoTimer(0, DATALOG_START_DELAY_1, DATALOG_TIME_FRAME_1, DATALOG_1_LENGTH);
    datalog_manager.configureAutoTimer(1, DATALOG_START_DELAY_2, DATALOG_TIME_FRAME_2, DATALOG_2_LENGTH);
    datalog_manager.configureStaticTimer(2, DATALOG_START_DELAY_3, STATICLOG_RATE_FAST);
    datalog_manager.configureStaticTimer(3, DATALOG_START_DELAY_4, STATICLOG_RATE_SLOW);
    datalog_manager.printTimerConfigs();
    40c2:	4620      	mov	r0, r4
}
//
/////////////////////////////////// Utility Functions /////////////////////////////////////////
void DLManager::configureAutoTimer(uint8_t num, uint32_t start_delay, uint32_t log_time, uint32_t logs_requested) {
    log_refresh_length[num] = log_time / logs_requested;
    start_delays[num] = start_delay;
    40c4:	4aaa      	ldr	r2, [pc, #680]	; (4370 <setupDLManager()+0x354>)
    remaining_logs[num] = logs_requested;
}

void DLManager::configureStaticTimer(uint8_t num, uint32_t start_delay, uint32_t logging_rate) {
    log_refresh_length[num] = logging_rate;
    start_delays[num] = start_delay;
    40c6:	50e2      	str	r2, [r4, r3]
}
//
/////////////////////////////////// Utility Functions /////////////////////////////////////////
void DLManager::configureAutoTimer(uint8_t num, uint32_t start_delay, uint32_t log_time, uint32_t logs_requested) {
    log_refresh_length[num] = log_time / logs_requested;
    start_delays[num] = start_delay;
    40c8:	f844 2009 	str.w	r2, [r4, r9]
    }
}
//
/////////////////////////////////// Utility Functions /////////////////////////////////////////
void DLManager::configureAutoTimer(uint8_t num, uint32_t start_delay, uint32_t log_time, uint32_t logs_requested) {
    log_refresh_length[num] = log_time / logs_requested;
    40cc:	f844 1008 	str.w	r1, [r4, r8]
    start_delays[num] = start_delay;
    remaining_logs[num] = logs_requested;
}

void DLManager::configureStaticTimer(uint8_t num, uint32_t start_delay, uint32_t logging_rate) {
    log_refresh_length[num] = logging_rate;
    40d0:	51a1      	str	r1, [r4, r6]
    40d2:	f7fd f979 	bl	13c8 <DLManager::printTimerConfigs()>

    // Hardware / Software / Serial Numbers
    datalog_manager.logSetupConfigByte("Hardware Version major      : ", H_VERSION_MAJOR);
    40d6:	a802      	add	r0, sp, #8
    40d8:	49a6      	ldr	r1, [pc, #664]	; (4374 <setupDLManager()+0x358>)
    40da:	f005 fa3d 	bl	9558 <String::String(char const*)>
    40de:	a902      	add	r1, sp, #8
    40e0:	2202      	movs	r2, #2
    40e2:	4620      	mov	r0, r4
    40e4:	f7fc fdca 	bl	c7c <DLManager::logSetupConfigByte(String, unsigned char)>
    40e8:	a802      	add	r0, sp, #8
    40ea:	f005 f9f5 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigByte("Hardware Version minor      : ", H_VERSION_MINOR);
    40ee:	a802      	add	r0, sp, #8
    40f0:	49a1      	ldr	r1, [pc, #644]	; (4378 <setupDLManager()+0x35c>)
    40f2:	f005 fa31 	bl	9558 <String::String(char const*)>
    40f6:	a902      	add	r1, sp, #8
    40f8:	2201      	movs	r2, #1
    40fa:	4620      	mov	r0, r4
    40fc:	f7fc fdbe 	bl	c7c <DLManager::logSetupConfigByte(String, unsigned char)>
    4100:	a802      	add	r0, sp, #8
    4102:	f005 f9e9 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigByte("Software Version major      : ", S_VERSION_MAJOR);
    4106:	a802      	add	r0, sp, #8
    4108:	499c      	ldr	r1, [pc, #624]	; (437c <setupDLManager()+0x360>)
    410a:	f005 fa25 	bl	9558 <String::String(char const*)>
    410e:	a902      	add	r1, sp, #8
    4110:	2200      	movs	r2, #0
    4112:	4620      	mov	r0, r4
    4114:	f7fc fdb2 	bl	c7c <DLManager::logSetupConfigByte(String, unsigned char)>
    4118:	a802      	add	r0, sp, #8
    411a:	f005 f9dd 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigByte("Software Version major      : ", S_VERSION_MINOR);
    411e:	a802      	add	r0, sp, #8
    4120:	4996      	ldr	r1, [pc, #600]	; (437c <setupDLManager()+0x360>)
    4122:	f005 fa19 	bl	9558 <String::String(char const*)>
    4126:	a902      	add	r1, sp, #8
    4128:	2200      	movs	r2, #0
    412a:	4620      	mov	r0, r4
    412c:	f7fc fda6 	bl	c7c <DLManager::logSetupConfigByte(String, unsigned char)>
    4130:	a802      	add	r0, sp, #8
    4132:	f005 f9d1 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigByte("Software Version major      : ", S_SUBVERSION);
    4136:	a802      	add	r0, sp, #8
    4138:	4990      	ldr	r1, [pc, #576]	; (437c <setupDLManager()+0x360>)
    413a:	f005 fa0d 	bl	9558 <String::String(char const*)>
    413e:	a902      	add	r1, sp, #8
    4140:	2205      	movs	r2, #5
    4142:	4620      	mov	r0, r4
    4144:	f7fc fd9a 	bl	c7c <DLManager::logSetupConfigByte(String, unsigned char)>
    4148:	a802      	add	r0, sp, #8
    414a:	f005 f9c5 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigByte("Bot ID Number               : ", SERIAL_ID);
    414e:	a802      	add	r0, sp, #8
    4150:	498b      	ldr	r1, [pc, #556]	; (4380 <setupDLManager()+0x364>)
    4152:	f005 fa01 	bl	9558 <String::String(char const*)>
    4156:	a902      	add	r1, sp, #8
    4158:	220b      	movs	r2, #11
    415a:	4620      	mov	r0, r4
    415c:	f7fc fd8e 	bl	c7c <DLManager::logSetupConfigByte(String, unsigned char)>
    4160:	a802      	add	r0, sp, #8
    4162:	f005 f9b9 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigByte("Datalog Active              : ", data_logging_active);
    4166:	a802      	add	r0, sp, #8
    4168:	4986      	ldr	r1, [pc, #536]	; (4384 <setupDLManager()+0x368>)
    416a:	f005 f9f5 	bl	9558 <String::String(char const*)>
    416e:	9b01      	ldr	r3, [sp, #4]
    4170:	a902      	add	r1, sp, #8
    4172:	781a      	ldrb	r2, [r3, #0]
    4174:	4620      	mov	r0, r4
    4176:	f7fc fd81 	bl	c7c <DLManager::logSetupConfigByte(String, unsigned char)>
    417a:	a802      	add	r0, sp, #8
    417c:	f005 f9ac 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigByte("Firmware Mode               : ", FIRMWARE_MODE);
    4180:	a802      	add	r0, sp, #8
    4182:	4981      	ldr	r1, [pc, #516]	; (4388 <setupDLManager()+0x36c>)
    4184:	f005 f9e8 	bl	9558 <String::String(char const*)>
    4188:	2201      	movs	r2, #1
    418a:	a902      	add	r1, sp, #8
    418c:	4620      	mov	r0, r4
    418e:	f7fc fd75 	bl	c7c <DLManager::logSetupConfigByte(String, unsigned char)>
    4192:	a802      	add	r0, sp, #8
    4194:	f005 f9a0 	bl	94d8 <String::~String()>
    4198:	2125      	movs	r1, #37	; 0x25
    419a:	487c      	ldr	r0, [pc, #496]	; (438c <setupDLManager()+0x370>)
    419c:	f007 fa30 	bl	b600 <usb_serial_write>
    41a0:	486f      	ldr	r0, [pc, #444]	; (4360 <setupDLManager()+0x344>)
    41a2:	f005 f867 	bl	9274 <Print::println()>
    // Lux Sensors
    printMinorDivide();
    datalog_manager.logSetupConfigByte("Smooth Lux Readings         : ", SMOOTH_LUX_READINGS);
    41a6:	a802      	add	r0, sp, #8
    41a8:	4979      	ldr	r1, [pc, #484]	; (4390 <setupDLManager()+0x374>)
    41aa:	f005 f9d5 	bl	9558 <String::String(char const*)>
    41ae:	a902      	add	r1, sp, #8
    41b0:	2200      	movs	r2, #0
    41b2:	4620      	mov	r0, r4
    41b4:	f7fc fd62 	bl	c7c <DLManager::logSetupConfigByte(String, unsigned char)>
    41b8:	a802      	add	r0, sp, #8
    41ba:	f005 f98d 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigDouble("Lux Low Threshold           : ", LOW_LUX_THRESHOLD);
    41be:	a802      	add	r0, sp, #8
    41c0:	4974      	ldr	r1, [pc, #464]	; (4394 <setupDLManager()+0x378>)
    41c2:	f005 f9c9 	bl	9558 <String::String(char const*)>
    41c6:	a902      	add	r1, sp, #8
    41c8:	2200      	movs	r2, #0
    41ca:	4b73      	ldr	r3, [pc, #460]	; (4398 <setupDLManager()+0x37c>)
    41cc:	4620      	mov	r0, r4
    41ce:	f7fc fe97 	bl	f00 <DLManager::logSetupConfigDouble(String, double)>
    41d2:	a802      	add	r0, sp, #8
    41d4:	f005 f980 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigDouble("Lux Mid Threshold           : ", MID_LUX_THRESHOLD);
    41d8:	a802      	add	r0, sp, #8
    41da:	4970      	ldr	r1, [pc, #448]	; (439c <setupDLManager()+0x380>)
    41dc:	f005 f9bc 	bl	9558 <String::String(char const*)>
    41e0:	a902      	add	r1, sp, #8
    41e2:	2200      	movs	r2, #0
    41e4:	4b6e      	ldr	r3, [pc, #440]	; (43a0 <setupDLManager()+0x384>)
    41e6:	4620      	mov	r0, r4
    41e8:	f7fc fe8a 	bl	f00 <DLManager::logSetupConfigDouble(String, double)>
    41ec:	a802      	add	r0, sp, #8
    41ee:	f005 f973 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigDouble("Lux High Threshold          : ", HIGH_LUX_THRESHOLD);
    41f2:	a802      	add	r0, sp, #8
    41f4:	496b      	ldr	r1, [pc, #428]	; (43a4 <setupDLManager()+0x388>)
    41f6:	f005 f9af 	bl	9558 <String::String(char const*)>
    41fa:	a902      	add	r1, sp, #8
    41fc:	2200      	movs	r2, #0
    41fe:	4b6a      	ldr	r3, [pc, #424]	; (43a8 <setupDLManager()+0x38c>)
    4200:	4620      	mov	r0, r4
    4202:	f7fc fe7d 	bl	f00 <DLManager::logSetupConfigDouble(String, double)>
    4206:	a802      	add	r0, sp, #8
    4208:	f005 f966 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigDouble("Brightness Scaler Min       : ", BRIGHTNESS_SCALER_MIN);
    420c:	a802      	add	r0, sp, #8
    420e:	4967      	ldr	r1, [pc, #412]	; (43ac <setupDLManager()+0x390>)
    4210:	f005 f9a2 	bl	9558 <String::String(char const*)>
    4214:	a902      	add	r1, sp, #8
    4216:	2200      	movs	r2, #0
    4218:	4b65      	ldr	r3, [pc, #404]	; (43b0 <setupDLManager()+0x394>)
    421a:	4620      	mov	r0, r4
    421c:	f7fc fe70 	bl	f00 <DLManager::logSetupConfigDouble(String, double)>
    4220:	a802      	add	r0, sp, #8
    4222:	f005 f959 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigDouble("Brightness Scaler Max       : ", BRIGHTNESS_SCALER_MAX);
    4226:	a802      	add	r0, sp, #8
    4228:	4962      	ldr	r1, [pc, #392]	; (43b4 <setupDLManager()+0x398>)
    422a:	f005 f995 	bl	9558 <String::String(char const*)>
    422e:	4b62      	ldr	r3, [pc, #392]	; (43b8 <setupDLManager()+0x39c>)
    4230:	a902      	add	r1, sp, #8
    4232:	2200      	movs	r2, #0
    4234:	4620      	mov	r0, r4
    4236:	f7fc fe63 	bl	f00 <DLManager::logSetupConfigDouble(String, double)>
    423a:	a802      	add	r0, sp, #8
    423c:	f005 f94c 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigByte("Min Brightness              : ", MIN_BRIGHTNESS);
    4240:	a802      	add	r0, sp, #8
    4242:	495e      	ldr	r1, [pc, #376]	; (43bc <setupDLManager()+0x3a0>)
    4244:	f005 f988 	bl	9558 <String::String(char const*)>
    4248:	a902      	add	r1, sp, #8
    424a:	2200      	movs	r2, #0
    424c:	4620      	mov	r0, r4
    424e:	f7fc fd15 	bl	c7c <DLManager::logSetupConfigByte(String, unsigned char)>
    4252:	a802      	add	r0, sp, #8
    4254:	f005 f940 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigByte("Max Brightness              : ", MAX_BRIGHTNESS);
    4258:	a802      	add	r0, sp, #8
    425a:	4959      	ldr	r1, [pc, #356]	; (43c0 <setupDLManager()+0x3a4>)
    425c:	f005 f97c 	bl	9558 <String::String(char const*)>
    4260:	22ff      	movs	r2, #255	; 0xff
    4262:	a902      	add	r1, sp, #8
    4264:	4620      	mov	r0, r4
    4266:	f7fc fd09 	bl	c7c <DLManager::logSetupConfigByte(String, unsigned char)>
    426a:	a802      	add	r0, sp, #8
    426c:	f005 f934 	bl	94d8 <String::~String()>
    4270:	2125      	movs	r1, #37	; 0x25
    4272:	4846      	ldr	r0, [pc, #280]	; (438c <setupDLManager()+0x370>)
    4274:	f007 f9c4 	bl	b600 <usb_serial_write>
    4278:	4839      	ldr	r0, [pc, #228]	; (4360 <setupDLManager()+0x344>)
    427a:	f004 fffb 	bl	9274 <Print::println()>
    // Auto Gain
    printMinorDivide();
    datalog_manager.logSetupConfigByte("Autogain Active             : ", BRIGHTNESS_SCALER_MAX);
    427e:	a802      	add	r0, sp, #8
    4280:	4950      	ldr	r1, [pc, #320]	; (43c4 <setupDLManager()+0x3a8>)
    4282:	f005 f969 	bl	9558 <String::String(char const*)>
    4286:	a902      	add	r1, sp, #8
    4288:	2201      	movs	r2, #1
    428a:	4620      	mov	r0, r4
    428c:	f7fc fcf6 	bl	c7c <DLManager::logSetupConfigByte(String, unsigned char)>
    4290:	a802      	add	r0, sp, #8
    4292:	f005 f921 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigDouble("Max Autogain Adjustment     : ", MAX_GAIN_ADJUSTMENT);
    4296:	a802      	add	r0, sp, #8
    4298:	494b      	ldr	r1, [pc, #300]	; (43c8 <setupDLManager()+0x3ac>)
    429a:	f005 f95d 	bl	9558 <String::String(char const*)>
    429e:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
    42a2:	a902      	add	r1, sp, #8
    42a4:	2200      	movs	r2, #0
    42a6:	4620      	mov	r0, r4
    42a8:	f7fc fe2a 	bl	f00 <DLManager::logSetupConfigDouble(String, double)>
    42ac:	a802      	add	r0, sp, #8
    42ae:	f005 f913 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigLong("Autogain Frequency          : ", AUTOGAIN_FREQUENCY);
    42b2:	a802      	add	r0, sp, #8
    42b4:	4945      	ldr	r1, [pc, #276]	; (43cc <setupDLManager()+0x3b0>)
    42b6:	f005 f94f 	bl	9558 <String::String(char const*)>
    42ba:	4a45      	ldr	r2, [pc, #276]	; (43d0 <setupDLManager()+0x3b4>)
    42bc:	a902      	add	r1, sp, #8
    42be:	4620      	mov	r0, r4
    42c0:	f7fc fd74 	bl	dac <DLManager::logSetupConfigLong(String, unsigned long)>
    42c4:	a802      	add	r0, sp, #8
    42c6:	f005 f907 	bl	94d8 <String::~String()>
    42ca:	2125      	movs	r1, #37	; 0x25
    42cc:	482f      	ldr	r0, [pc, #188]	; (438c <setupDLManager()+0x370>)
    42ce:	f007 f997 	bl	b600 <usb_serial_write>
    42d2:	4823      	ldr	r0, [pc, #140]	; (4360 <setupDLManager()+0x344>)
    42d4:	f004 ffce 	bl	9274 <Print::println()>
    // Autolog settings
    printMinorDivide();
    datalog_manager.logSetupConfigLong("Timer 0 Start Time          : ", datalog_manager.getTimerStart(0));
    42d8:	a802      	add	r0, sp, #8
    42da:	493e      	ldr	r1, [pc, #248]	; (43d4 <setupDLManager()+0x3b8>)
    42dc:	f005 f93c 	bl	9558 <String::String(char const*)>
    42e0:	f854 200b 	ldr.w	r2, [r4, fp]
    42e4:	a902      	add	r1, sp, #8
    42e6:	4620      	mov	r0, r4
    42e8:	f7fc fd60 	bl	dac <DLManager::logSetupConfigLong(String, unsigned long)>
    42ec:	a802      	add	r0, sp, #8
    42ee:	f005 f8f3 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigLong("Timer 0 End Time            : ", datalog_manager.getTimerEnd(0));
    42f2:	a802      	add	r0, sp, #8
    42f4:	4938      	ldr	r1, [pc, #224]	; (43d8 <setupDLManager()+0x3bc>)
    42f6:	f005 f92f 	bl	9558 <String::String(char const*)>
    42fa:	f242 0374 	movw	r3, #8308	; 0x2074
    42fe:	f854 000a 	ldr.w	r0, [r4, sl]
    4302:	58e2      	ldr	r2, [r4, r3]
    4304:	f854 300b 	ldr.w	r3, [r4, fp]
    4308:	a902      	add	r1, sp, #8
    430a:	fb00 3202 	mla	r2, r0, r2, r3
    430e:	4620      	mov	r0, r4
    4310:	f7fc fd4c 	bl	dac <DLManager::logSetupConfigLong(String, unsigned long)>
    4314:	a802      	add	r0, sp, #8
    4316:	f005 f8df 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigLong("Timer 0 Logging Rate        : ", datalog_manager.getTimerRate(0));
    431a:	a802      	add	r0, sp, #8
    431c:	492f      	ldr	r1, [pc, #188]	; (43dc <setupDLManager()+0x3c0>)
    431e:	f005 f91b 	bl	9558 <String::String(char const*)>
    4322:	f854 200a 	ldr.w	r2, [r4, sl]
    4326:	a902      	add	r1, sp, #8
    4328:	4620      	mov	r0, r4
    432a:	f7fc fd3f 	bl	dac <DLManager::logSetupConfigLong(String, unsigned long)>
    432e:	a802      	add	r0, sp, #8
    4330:	f005 f8d2 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigLong("Timer 1 Start Time          : ", datalog_manager.getTimerStart(1));
    4334:	a802      	add	r0, sp, #8
    4336:	492a      	ldr	r1, [pc, #168]	; (43e0 <setupDLManager()+0x3c4>)
    4338:	f005 f90e 	bl	9558 <String::String(char const*)>
    433c:	f854 2009 	ldr.w	r2, [r4, r9]
    4340:	a902      	add	r1, sp, #8
    4342:	4620      	mov	r0, r4
    4344:	f7fc fd32 	bl	dac <DLManager::logSetupConfigLong(String, unsigned long)>
    4348:	a802      	add	r0, sp, #8
    434a:	f005 f8c5 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigLong("Timer 1 End Time            : ", datalog_manager.getTimerEnd(1));
    434e:	a802      	add	r0, sp, #8
    4350:	4924      	ldr	r1, [pc, #144]	; (43e4 <setupDLManager()+0x3c8>)
    4352:	f005 f901 	bl	9558 <String::String(char const*)>
    4356:	e049      	b.n	43ec <setupDLManager()+0x3d0>
    4358:	1fffd278 	.word	0x1fffd278
    435c:	000117a0 	.word	0x000117a0
    4360:	1fffbaf4 	.word	0x1fffbaf4
    4364:	000186a0 	.word	0x000186a0
    4368:	0036ee80 	.word	0x0036ee80
    436c:	0002bf20 	.word	0x0002bf20
    4370:	000dbba0 	.word	0x000dbba0
    4374:	000117c4 	.word	0x000117c4
    4378:	000117e4 	.word	0x000117e4
    437c:	00011804 	.word	0x00011804
    4380:	00011824 	.word	0x00011824
    4384:	00011844 	.word	0x00011844
    4388:	00011864 	.word	0x00011864
    438c:	00010734 	.word	0x00010734
    4390:	00011884 	.word	0x00011884
    4394:	000118a4 	.word	0x000118a4
    4398:	40490000 	.word	0x40490000
    439c:	000118c4 	.word	0x000118c4
    43a0:	408f4000 	.word	0x408f4000
    43a4:	000118e4 	.word	0x000118e4
    43a8:	409f4000 	.word	0x409f4000
    43ac:	00011904 	.word	0x00011904
    43b0:	3fe80000 	.word	0x3fe80000
    43b4:	00011924 	.word	0x00011924
    43b8:	3ffc0000 	.word	0x3ffc0000
    43bc:	00011944 	.word	0x00011944
    43c0:	00011964 	.word	0x00011964
    43c4:	00011984 	.word	0x00011984
    43c8:	000119a4 	.word	0x000119a4
    43cc:	000119c4 	.word	0x000119c4
    43d0:	000493e0 	.word	0x000493e0
    43d4:	000119e4 	.word	0x000119e4
    43d8:	00011a04 	.word	0x00011a04
    43dc:	00011a24 	.word	0x00011a24
    43e0:	00011a44 	.word	0x00011a44
    43e4:	00011a64 	.word	0x00011a64
    43e8:	000afc80 	.word	0x000afc80
    43ec:	f242 0378 	movw	r3, #8312	; 0x2078
    43f0:	f854 0008 	ldr.w	r0, [r4, r8]
    43f4:	58e2      	ldr	r2, [r4, r3]
    43f6:	f854 3009 	ldr.w	r3, [r4, r9]
    43fa:	a902      	add	r1, sp, #8
    43fc:	fb00 3202 	mla	r2, r0, r2, r3
    4400:	4620      	mov	r0, r4
    4402:	f7fc fcd3 	bl	dac <DLManager::logSetupConfigLong(String, unsigned long)>
    4406:	a802      	add	r0, sp, #8
    4408:	f005 f866 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigLong("Timer 1 Logging Rate        : ", datalog_manager.getTimerRate(1));
    440c:	a802      	add	r0, sp, #8
    440e:	4939      	ldr	r1, [pc, #228]	; (44f4 <setupDLManager()+0x4d8>)
    4410:	f005 f8a2 	bl	9558 <String::String(char const*)>
    4414:	f854 2008 	ldr.w	r2, [r4, r8]
    4418:	a902      	add	r1, sp, #8
    441a:	4620      	mov	r0, r4
    441c:	f7fc fcc6 	bl	dac <DLManager::logSetupConfigLong(String, unsigned long)>
    4420:	a802      	add	r0, sp, #8
    4422:	f005 f859 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigLong("Timer 2 Start Time          : ", datalog_manager.getTimerStart(2));
    4426:	a802      	add	r0, sp, #8
    4428:	4933      	ldr	r1, [pc, #204]	; (44f8 <setupDLManager()+0x4dc>)
    442a:	f005 f895 	bl	9558 <String::String(char const*)>
    442e:	59e2      	ldr	r2, [r4, r7]
    4430:	a902      	add	r1, sp, #8
    4432:	4620      	mov	r0, r4
    4434:	f7fc fcba 	bl	dac <DLManager::logSetupConfigLong(String, unsigned long)>
    4438:	a802      	add	r0, sp, #8
    443a:	f005 f84d 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigLong("Timer 2 End Time            : ", datalog_manager.getTimerEnd(2));
    443e:	a802      	add	r0, sp, #8
    4440:	492e      	ldr	r1, [pc, #184]	; (44fc <setupDLManager()+0x4e0>)
    4442:	f005 f889 	bl	9558 <String::String(char const*)>
    4446:	f242 037c 	movw	r3, #8316	; 0x207c
    444a:	59a0      	ldr	r0, [r4, r6]
    444c:	58e2      	ldr	r2, [r4, r3]
    444e:	59e3      	ldr	r3, [r4, r7]
    4450:	a902      	add	r1, sp, #8
    4452:	fb00 3202 	mla	r2, r0, r2, r3
    4456:	4620      	mov	r0, r4
    4458:	f7fc fca8 	bl	dac <DLManager::logSetupConfigLong(String, unsigned long)>
    445c:	a802      	add	r0, sp, #8
    445e:	f005 f83b 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigLong("Timer 2 Logging Rate        : ", datalog_manager.getTimerRate(2));
    4462:	a802      	add	r0, sp, #8
    4464:	4926      	ldr	r1, [pc, #152]	; (4500 <setupDLManager()+0x4e4>)
    4466:	f005 f877 	bl	9558 <String::String(char const*)>
    446a:	59a2      	ldr	r2, [r4, r6]
    446c:	a902      	add	r1, sp, #8
    446e:	4620      	mov	r0, r4
    4470:	f7fc fc9c 	bl	dac <DLManager::logSetupConfigLong(String, unsigned long)>
    4474:	a802      	add	r0, sp, #8
    4476:	f005 f82f 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigLong("Timer 3 Start Time          : ", datalog_manager.getTimerStart(3));
    447a:	a802      	add	r0, sp, #8
    447c:	4921      	ldr	r1, [pc, #132]	; (4504 <setupDLManager()+0x4e8>)
    447e:	f005 f86b 	bl	9558 <String::String(char const*)>
    4482:	f242 0370 	movw	r3, #8304	; 0x2070
    4486:	a902      	add	r1, sp, #8
    4488:	58e2      	ldr	r2, [r4, r3]
    448a:	4620      	mov	r0, r4
    448c:	f7fc fc8e 	bl	dac <DLManager::logSetupConfigLong(String, unsigned long)>
    4490:	a802      	add	r0, sp, #8
    4492:	f005 f821 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigLong("Timer 3 End Time            : ", datalog_manager.getTimerEnd(3));
    4496:	a802      	add	r0, sp, #8
    4498:	491b      	ldr	r1, [pc, #108]	; (4508 <setupDLManager()+0x4ec>)
    449a:	f005 f85d 	bl	9558 <String::String(char const*)>
    449e:	f504 5302 	add.w	r3, r4, #8320	; 0x2080
    44a2:	5962      	ldr	r2, [r4, r5]
    44a4:	6818      	ldr	r0, [r3, #0]
    44a6:	f242 0370 	movw	r3, #8304	; 0x2070
    44aa:	a902      	add	r1, sp, #8
    44ac:	58e3      	ldr	r3, [r4, r3]
    44ae:	fb00 3202 	mla	r2, r0, r2, r3
    44b2:	4620      	mov	r0, r4
    44b4:	f7fc fc7a 	bl	dac <DLManager::logSetupConfigLong(String, unsigned long)>
    44b8:	a802      	add	r0, sp, #8
    44ba:	f005 f80d 	bl	94d8 <String::~String()>
    datalog_manager.logSetupConfigLong("Timer 3 Logging Rate        : ", datalog_manager.getTimerRate(3));
    44be:	a802      	add	r0, sp, #8
    44c0:	4912      	ldr	r1, [pc, #72]	; (450c <setupDLManager()+0x4f0>)
    44c2:	f005 f849 	bl	9558 <String::String(char const*)>
    44c6:	5962      	ldr	r2, [r4, r5]
    44c8:	a902      	add	r1, sp, #8
    44ca:	4620      	mov	r0, r4
    44cc:	f7fc fc6e 	bl	dac <DLManager::logSetupConfigLong(String, unsigned long)>
    44d0:	a802      	add	r0, sp, #8
    44d2:	f005 f801 	bl	94d8 <String::~String()>
    44d6:	2125      	movs	r1, #37	; 0x25
    44d8:	480d      	ldr	r0, [pc, #52]	; (4510 <setupDLManager()+0x4f4>)
    44da:	f007 f891 	bl	b600 <usb_serial_write>
    44de:	480d      	ldr	r0, [pc, #52]	; (4514 <setupDLManager()+0x4f8>)
    44e0:	f004 fec8 	bl	9274 <Print::println()>
      }
    */

    // printing needs to be at the end so that everything actually displays
    if (PRINT_EEPROM_CONTENTS > 0) {
      delay(100);
    44e4:	2064      	movs	r0, #100	; 0x64
    44e6:	f005 fe13 	bl	a110 <delay>
      datalog_manager.printAllLogs();
    44ea:	4620      	mov	r0, r4
    44ec:	f7fc ff2a 	bl	1344 <DLManager::printAllLogs()>
    44f0:	e59d      	b.n	402e <setupDLManager()+0x12>
    44f2:	bf00      	nop
    44f4:	00011a84 	.word	0x00011a84
    44f8:	00011aa4 	.word	0x00011aa4
    44fc:	00011ac4 	.word	0x00011ac4
    4500:	00011ae4 	.word	0x00011ae4
    4504:	00011b04 	.word	0x00011b04
    4508:	00011b24 	.word	0x00011b24
    450c:	00011b44 	.word	0x00011b44
    4510:	00010734 	.word	0x00010734
    4514:	1fffbaf4 	.word	0x1fffbaf4

00004518 <updateSong()>:
double feature_max = 0.0000001;
elapsedMillis feature_reset_tmr;
const unsigned long feature_reset_time = (1000 * 300);// every minute?

void updateSong() {
  for (int i = 0; i < num_channels; i++) {
    4518:	4b93      	ldr	r3, [pc, #588]	; (4768 <updateSong()+0x250>)
    451a:	781b      	ldrb	r3, [r3, #0]
    451c:	2b00      	cmp	r3, #0
    451e:	f000 811a 	beq.w	4756 <updateSong()+0x23e>
double feature_min = 9999999.99;
double feature_max = 0.0000001;
elapsedMillis feature_reset_tmr;
const unsigned long feature_reset_time = (1000 * 300);// every minute?

void updateSong() {
    4522:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
    4526:	f8df 8290 	ldr.w	r8, [pc, #656]	; 47b8 <updateSong()+0x2a0>
    452a:	f8df 9260 	ldr.w	r9, [pc, #608]	; 478c <updateSong()+0x274>
    452e:	b08e      	sub	sp, #56	; 0x38
  for (int i = 0; i < num_channels; i++) {
    4530:	f04f 0b00 	mov.w	fp, #0
    4534:	e018      	b.n	4568 <updateSong()+0x50>
    dprint(PRINT_SONG_DEBUG, "\tg:");
    dprintln(PRINT_SONG_DEBUG, green);
    // dprint(PRINT_SONG_DEBUG, "\tb:");
    // dprintln(PRINT_SONG_DEBUG, blue);

    if (stereo_audio == false || front_mic_active == false || rear_mic_active == false) {
    4536:	4b8d      	ldr	r3, [pc, #564]	; (476c <updateSong()+0x254>)
    4538:	781b      	ldrb	r3, [r3, #0]
    453a:	2b00      	cmp	r3, #0
    453c:	d044      	beq.n	45c8 <updateSong()+0xb0>
    453e:	4b8c      	ldr	r3, [pc, #560]	; (4770 <updateSong()+0x258>)
    4540:	781b      	ldrb	r3, [r3, #0]
    4542:	2b00      	cmp	r3, #0
    4544:	f040 80e5 	bne.w	4712 <updateSong()+0x1fa>
      if (front_mic_active == true && i == 0) {
    4548:	f1bb 0f00 	cmp.w	fp, #0
    454c:	d043      	beq.n	45d6 <updateSong()+0xbe>
double feature_max = 0.0000001;
elapsedMillis feature_reset_tmr;
const unsigned long feature_reset_time = (1000 * 300);// every minute?

void updateSong() {
  for (int i = 0; i < num_channels; i++) {
    454e:	4b86      	ldr	r3, [pc, #536]	; (4768 <updateSong()+0x250>)
    4550:	781b      	ldrb	r3, [r3, #0]
    4552:	f10b 0b01 	add.w	fp, fp, #1
    4556:	f508 5888 	add.w	r8, r8, #4352	; 0x1100
    455a:	455b      	cmp	r3, fp
    455c:	f108 0818 	add.w	r8, r8, #24
    4560:	f109 09d8 	add.w	r9, r9, #216	; 0xd8
    4564:	f340 80d2 	ble.w	470c <updateSong()+0x1f4>
    uint8_t brightness = 0;
    uint16_t red, green;
    if (SONG_FEATURE == PEAK_RAW) {
    4568:	4b82      	ldr	r3, [pc, #520]	; (4774 <updateSong()+0x25c>)
    456a:	681b      	ldr	r3, [r3, #0]
    456c:	2b01      	cmp	r3, #1
    456e:	f000 80c8 	beq.w	4702 <updateSong()+0x1ea>
      brightness = calculatePeakWeighted(&fc[i]);
    } else if (SONG_FEATURE == RMS_RAW) {
    4572:	2b00      	cmp	r3, #0
    4574:	d04c      	beq.n	4610 <updateSong()+0xf8>
elapsedMillis feature_reset_tmr;
const unsigned long feature_reset_time = (1000 * 300);// every minute?

void updateSong() {
  for (int i = 0; i < num_channels; i++) {
    uint8_t brightness = 0;
    4576:	2600      	movs	r6, #0
    if (SONG_FEATURE == PEAK_RAW) {
      brightness = calculatePeakWeighted(&fc[i]);
    } else if (SONG_FEATURE == RMS_RAW) {
      brightness = calculateRMSWeighted(&fc[i]);
    }
    if (SONG_COLOR_FEATURE == SPECTRAL_CENTROID) {
    4578:	4b7f      	ldr	r3, [pc, #508]	; (4778 <updateSong()+0x260>)
    457a:	681b      	ldr	r3, [r3, #0]
    457c:	2b08      	cmp	r3, #8
    457e:	d04f      	beq.n	4620 <updateSong()+0x108>
        Serial.print(" / ");
        Serial.println(feature_max);
      }
      red = brightness * cent ;
      green = brightness * (1.0 - cent);
    } else if (SONG_COLOR_FEATURE == MAX_ENERGY_BIN) {
    4580:	2b07      	cmp	r3, #7
    4582:	f000 80a0 	beq.w	46c6 <updateSong()+0x1ae>
      double bin_pos = fc[i].getRelativeBinPos();
      red = brightness * bin_pos;
      green = brightness * (1.0 - bin_pos);
    } else {
      red = brightness;
    4586:	b2b4      	uxth	r4, r6
      green = 0;
    4588:	2500      	movs	r5, #0
    }

    dprint(PRINT_SONG_DEBUG, "brightness - ");
    458a:	497c      	ldr	r1, [pc, #496]	; (477c <updateSong()+0x264>)
    458c:	a80a      	add	r0, sp, #40	; 0x28
    458e:	f004 ffe3 	bl	9558 <String::String(char const*)>
    4592:	a80a      	add	r0, sp, #40	; 0x28
    4594:	f004 ffa0 	bl	94d8 <String::~String()>
    dprint(PRINT_SONG_DEBUG, brightness);
    dprint(PRINT_SONG_DEBUG, "\tr:");
    4598:	4979      	ldr	r1, [pc, #484]	; (4780 <updateSong()+0x268>)
    459a:	a80a      	add	r0, sp, #40	; 0x28
    459c:	f004 ffdc 	bl	9558 <String::String(char const*)>
    45a0:	a80a      	add	r0, sp, #40	; 0x28
    45a2:	f004 ff99 	bl	94d8 <String::~String()>
    dprint(PRINT_SONG_DEBUG, red);
    dprint(PRINT_SONG_DEBUG, "\tg:");
    45a6:	4977      	ldr	r1, [pc, #476]	; (4784 <updateSong()+0x26c>)
    45a8:	a80a      	add	r0, sp, #40	; 0x28
    45aa:	f004 ffd5 	bl	9558 <String::String(char const*)>
    45ae:	a80a      	add	r0, sp, #40	; 0x28
    45b0:	f004 ff92 	bl	94d8 <String::~String()>
    dprintln(PRINT_SONG_DEBUG, green);
    // dprint(PRINT_SONG_DEBUG, "\tb:");
    // dprintln(PRINT_SONG_DEBUG, blue);

    if (stereo_audio == false || front_mic_active == false || rear_mic_active == false) {
    45b4:	4b74      	ldr	r3, [pc, #464]	; (4788 <updateSong()+0x270>)
    45b6:	781b      	ldrb	r3, [r3, #0]
    45b8:	2b00      	cmp	r3, #0
    45ba:	d1bc      	bne.n	4536 <updateSong()+0x1e>
      if (front_mic_active == true && i == 0) {
    45bc:	4b6b      	ldr	r3, [pc, #428]	; (476c <updateSong()+0x254>)
    45be:	781b      	ldrb	r3, [r3, #0]
    45c0:	b113      	cbz	r3, 45c8 <updateSong()+0xb0>
    45c2:	f1bb 0f00 	cmp.w	fp, #0
    45c6:	d006      	beq.n	45d6 <updateSong()+0xbe>
        neos[0].colorWipe(red, green, 0);
        neos[1].colorWipe(red, green, 0);
      } else if (rear_mic_active == true && i == 1) {
    45c8:	4b69      	ldr	r3, [pc, #420]	; (4770 <updateSong()+0x258>)
    45ca:	781b      	ldrb	r3, [r3, #0]
    45cc:	2b00      	cmp	r3, #0
    45ce:	d0be      	beq.n	454e <updateSong()+0x36>
    45d0:	f1bb 0f01 	cmp.w	fp, #1
    45d4:	d1bb      	bne.n	454e <updateSong()+0x36>
  HsbToRgb(h, s, b);
  colorWipe(rgb[0], rgb[1], rgb[2]);
}

void NeoGroup::colorWipe(uint8_t red, uint8_t green, uint8_t blue) {
  colorWipe(red, green, blue, brightness_scaler);
    45d6:	4b6d      	ldr	r3, [pc, #436]	; (478c <updateSong()+0x274>)
    45d8:	486c      	ldr	r0, [pc, #432]	; (478c <updateSong()+0x274>)
    45da:	e9d3 2330 	ldrd	r2, r3, [r3, #192]	; 0xc0
    45de:	e9cd 2302 	strd	r2, r3, [sp, #8]
        neos[0].colorWipe(red, green, 0);
    45e2:	b2e6      	uxtb	r6, r4
    45e4:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
    45e8:	b2ed      	uxtb	r5, r5
    45ea:	e9cd 3400 	strd	r3, r4, [sp]
    45ee:	462a      	mov	r2, r5
    45f0:	4631      	mov	r1, r6
    45f2:	2300      	movs	r3, #0
    45f4:	f7fd f914 	bl	1820 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)>
    45f8:	4b65      	ldr	r3, [pc, #404]	; (4790 <updateSong()+0x278>)
    45fa:	4866      	ldr	r0, [pc, #408]	; (4794 <updateSong()+0x27c>)
    45fc:	e9d3 3400 	ldrd	r3, r4, [r3]
    4600:	462a      	mov	r2, r5
    4602:	e9cd 3400 	strd	r3, r4, [sp]
    4606:	4631      	mov	r1, r6
    4608:	2300      	movs	r3, #0
    460a:	f7fd f909 	bl	1820 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)>
    460e:	e79e      	b.n	454e <updateSong()+0x36>
    uint8_t brightness = 0;
    uint16_t red, green;
    if (SONG_FEATURE == PEAK_RAW) {
      brightness = calculatePeakWeighted(&fc[i]);
    } else if (SONG_FEATURE == RMS_RAW) {
      brightness = calculateRMSWeighted(&fc[i]);
    4610:	4640      	mov	r0, r8
    4612:	f7ff fc55 	bl	3ec0 <calculateRMSWeighted(FeatureCollector*)>
    }
    if (SONG_COLOR_FEATURE == SPECTRAL_CENTROID) {
    4616:	4b58      	ldr	r3, [pc, #352]	; (4778 <updateSong()+0x260>)
    4618:	681b      	ldr	r3, [r3, #0]
    461a:	2b08      	cmp	r3, #8
    uint8_t brightness = 0;
    uint16_t red, green;
    if (SONG_FEATURE == PEAK_RAW) {
      brightness = calculatePeakWeighted(&fc[i]);
    } else if (SONG_FEATURE == RMS_RAW) {
      brightness = calculateRMSWeighted(&fc[i]);
    461c:	4606      	mov	r6, r0
    }
    if (SONG_COLOR_FEATURE == SPECTRAL_CENTROID) {
    461e:	d1af      	bne.n	4580 <updateSong()+0x68>
      double cent = fc[i].getSmoothedCentroid();
    4620:	4640      	mov	r0, r8
    4622:	f7fe f941 	bl	28a8 <FeatureCollector::getSmoothedCentroid()>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4626:	4b5c      	ldr	r3, [pc, #368]	; (4798 <updateSong()+0x280>)
	unsigned long ms;
public:
	elapsedMillis(void) { ms = millis(); }
	elapsedMillis(unsigned long val) { ms = millis() - val; }
	elapsedMillis(const elapsedMillis &orig) { ms = orig.ms; }
	operator unsigned long () const { return millis() - ms; }
    4628:	4d5c      	ldr	r5, [pc, #368]	; (479c <updateSong()+0x284>)
    462a:	681b      	ldr	r3, [r3, #0]
    462c:	9308      	str	r3, [sp, #32]
    462e:	e9cd 0102 	strd	r0, r1, [sp, #8]
	return ret;
    4632:	9b08      	ldr	r3, [sp, #32]
      if (feature_reset_tmr > feature_reset_time) {
    4634:	6829      	ldr	r1, [r5, #0]
    4636:	4a5a      	ldr	r2, [pc, #360]	; (47a0 <updateSong()+0x288>)
        feature_min = 999999.999;
    4638:	4f5a      	ldr	r7, [pc, #360]	; (47a4 <updateSong()+0x28c>)
        feature_max = 0.00000001;
    463a:	4c5b      	ldr	r4, [pc, #364]	; (47a8 <updateSong()+0x290>)
    } else if (SONG_FEATURE == RMS_RAW) {
      brightness = calculateRMSWeighted(&fc[i]);
    }
    if (SONG_COLOR_FEATURE == SPECTRAL_CENTROID) {
      double cent = fc[i].getSmoothedCentroid();
      if (feature_reset_tmr > feature_reset_time) {
    463c:	1a5b      	subs	r3, r3, r1
    463e:	4293      	cmp	r3, r2
    4640:	d872      	bhi.n	4728 <updateSong()+0x210>
        feature_min = 999999.999;
        feature_max = 0.00000001;
        Serial.println("reset feature min and max");
        feature_reset_tmr = 0;
      }
      if (cent < feature_min) {
    4642:	e9d7 2300 	ldrd	r2, r3, [r7]
    4646:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    464a:	e9cd 2304 	strd	r2, r3, [sp, #16]
    464e:	4d55      	ldr	r5, [pc, #340]	; (47a4 <updateSong()+0x28c>)
    4650:	f008 fca0 	bl	cf94 <__aeabi_dcmplt>
    4654:	b128      	cbz	r0, 4662 <updateSong()+0x14a>
        feature_min = cent;
    4656:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    465a:	e9c5 2300 	strd	r2, r3, [r5]
    465e:	e9cd 2304 	strd	r2, r3, [sp, #16]
      };
      if (cent > feature_max) {
    4662:	e9d4 3400 	ldrd	r3, r4, [r4]
    4666:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    466a:	e9cd 3406 	strd	r3, r4, [sp, #24]
    466e:	461a      	mov	r2, r3
    4670:	4623      	mov	r3, r4
    4672:	4c4d      	ldr	r4, [pc, #308]	; (47a8 <updateSong()+0x290>)
    4674:	f008 fcac 	bl	cfd0 <__aeabi_dcmpgt>
    4678:	b128      	cbz	r0, 4686 <updateSong()+0x16e>
        feature_max = cent;
    467a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    467e:	e9c4 2300 	strd	r2, r3, [r4]
    4682:	e9cd 2306 	strd	r2, r3, [sp, #24]
        Serial.print(brightness);
        Serial.print("\tcent : ");
        Serial.print(cent);
      }

      cent = (cent - feature_min) / (feature_max - feature_min);
    4686:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    468a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    468e:	f008 f85b 	bl	c748 <__aeabi_dsub>
    4692:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    4696:	4604      	mov	r4, r0
    4698:	460d      	mov	r5, r1
    469a:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    469e:	f008 f853 	bl	c748 <__aeabi_dsub>
    46a2:	4602      	mov	r2, r0
    46a4:	460b      	mov	r3, r1
    46a6:	4620      	mov	r0, r4
    46a8:	4629      	mov	r1, r5
    46aa:	f008 fb2b 	bl	cd04 <__aeabi_ddiv>
    46ae:	4604      	mov	r4, r0
        Serial.print("\tmin/max:\t");
        Serial.print(feature_min);
        Serial.print(" / ");
        Serial.println(feature_max);
      }
      red = brightness * cent ;
    46b0:	4630      	mov	r0, r6
        Serial.print(brightness);
        Serial.print("\tcent : ");
        Serial.print(cent);
      }

      cent = (cent - feature_min) / (feature_max - feature_min);
    46b2:	460d      	mov	r5, r1
        Serial.print("\tmin/max:\t");
        Serial.print(feature_min);
        Serial.print(" / ");
        Serial.println(feature_max);
      }
      red = brightness * cent ;
    46b4:	f008 f996 	bl	c9e4 <__aeabi_i2d>
    46b8:	4606      	mov	r6, r0
    46ba:	460f      	mov	r7, r1
    46bc:	4602      	mov	r2, r0
    46be:	460b      	mov	r3, r1
    46c0:	4620      	mov	r0, r4
    46c2:	4629      	mov	r1, r5
    46c4:	e00a      	b.n	46dc <updateSong()+0x1c4>
    46c6:	f508 5387 	add.w	r3, r8, #4320	; 0x10e0
      green = brightness * (1.0 - cent);
    } else if (SONG_COLOR_FEATURE == MAX_ENERGY_BIN) {
      double bin_pos = fc[i].getRelativeBinPos();
      red = brightness * bin_pos;
    46ca:	4630      	mov	r0, r6
    46cc:	e9d3 4504 	ldrd	r4, r5, [r3, #16]
    46d0:	f008 f988 	bl	c9e4 <__aeabi_i2d>
    46d4:	4622      	mov	r2, r4
    46d6:	4606      	mov	r6, r0
    46d8:	460f      	mov	r7, r1
    46da:	462b      	mov	r3, r5
    46dc:	f008 f9e8 	bl	cab0 <__aeabi_dmul>
    46e0:	f008 fcbe 	bl	d060 <__aeabi_d2uiz>
      green = brightness * (1.0 - bin_pos);
    46e4:	4622      	mov	r2, r4
    46e6:	462b      	mov	r3, r5
      }
      red = brightness * cent ;
      green = brightness * (1.0 - cent);
    } else if (SONG_COLOR_FEATURE == MAX_ENERGY_BIN) {
      double bin_pos = fc[i].getRelativeBinPos();
      red = brightness * bin_pos;
    46e8:	b284      	uxth	r4, r0
      green = brightness * (1.0 - bin_pos);
    46ea:	4930      	ldr	r1, [pc, #192]	; (47ac <updateSong()+0x294>)
    46ec:	2000      	movs	r0, #0
    46ee:	f008 f82b 	bl	c748 <__aeabi_dsub>
    46f2:	4632      	mov	r2, r6
    46f4:	463b      	mov	r3, r7
    46f6:	f008 f9db 	bl	cab0 <__aeabi_dmul>
    46fa:	f008 fcb1 	bl	d060 <__aeabi_d2uiz>
    46fe:	b285      	uxth	r5, r0
    4700:	e743      	b.n	458a <updateSong()+0x72>
void updateSong() {
  for (int i = 0; i < num_channels; i++) {
    uint8_t brightness = 0;
    uint16_t red, green;
    if (SONG_FEATURE == PEAK_RAW) {
      brightness = calculatePeakWeighted(&fc[i]);
    4702:	4640      	mov	r0, r8
    4704:	f7ff fc34 	bl	3f70 <calculatePeakWeighted(FeatureCollector*)>
    4708:	4606      	mov	r6, r0
    470a:	e735      	b.n	4578 <updateSong()+0x60>
      }
    } else {
      neos[i].colorWipe(red, green, 0);
    }
  }
}
    470c:	b00e      	add	sp, #56	; 0x38
    470e:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
    4712:	e9d9 6730 	ldrd	r6, r7, [r9, #192]	; 0xc0
    4716:	b2ea      	uxtb	r2, r5
    4718:	b2e1      	uxtb	r1, r4
    471a:	e9cd 6700 	strd	r6, r7, [sp]
    471e:	2300      	movs	r3, #0
    4720:	4648      	mov	r0, r9
    4722:	f7fd f87d 	bl	1820 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)>
    4726:	e712      	b.n	454e <updateSong()+0x36>
      brightness = calculateRMSWeighted(&fc[i]);
    }
    if (SONG_COLOR_FEATURE == SPECTRAL_CENTROID) {
      double cent = fc[i].getSmoothedCentroid();
      if (feature_reset_tmr > feature_reset_time) {
        feature_min = 999999.999;
    4728:	a30b      	add	r3, pc, #44	; (adr r3, 4758 <updateSong()+0x240>)
    472a:	e9d3 2300 	ldrd	r2, r3, [r3]
    472e:	e9c7 2300 	strd	r2, r3, [r7]
        feature_max = 0.00000001;
    4732:	a30b      	add	r3, pc, #44	; (adr r3, 4760 <updateSong()+0x248>)
    4734:	e9d3 2300 	ldrd	r2, r3, [r3]
    4738:	2119      	movs	r1, #25
    473a:	481d      	ldr	r0, [pc, #116]	; (47b0 <updateSong()+0x298>)
    473c:	e9c4 2300 	strd	r2, r3, [r4]
    4740:	f006 ff5e 	bl	b600 <usb_serial_write>
    4744:	481b      	ldr	r0, [pc, #108]	; (47b4 <updateSong()+0x29c>)
    4746:	f004 fd95 	bl	9274 <Print::println()>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    474a:	4b13      	ldr	r3, [pc, #76]	; (4798 <updateSong()+0x280>)
    474c:	681b      	ldr	r3, [r3, #0]
    474e:	9309      	str	r3, [sp, #36]	; 0x24
	return ret;
    4750:	9b09      	ldr	r3, [sp, #36]	; 0x24
	elapsedMillis & operator = (const elapsedMillis &rhs) { ms = rhs.ms; return *this; }
	elapsedMillis & operator = (unsigned long val) { ms = millis() - val; return *this; }
    4752:	602b      	str	r3, [r5, #0]
    4754:	e775      	b.n	4642 <updateSong()+0x12a>
    4756:	4770      	bx	lr
    4758:	00000000 	.word	0x00000000
    475c:	412e8480 	.word	0x412e8480
    4760:	e0000000 	.word	0xe0000000
    4764:	3e45798e 	.word	0x3e45798e
    4768:	1fffb8a2 	.word	0x1fffb8a2
    476c:	1fffb8a8 	.word	0x1fffb8a8
    4770:	1fffb8a1 	.word	0x1fffb8a1
    4774:	1fffb880 	.word	0x1fffb880
    4778:	1fffb8c4 	.word	0x1fffb8c4
    477c:	00011bac 	.word	0x00011bac
    4780:	00011bbc 	.word	0x00011bbc
    4784:	00011bc0 	.word	0x00011bc0
    4788:	1fffb8c0 	.word	0x1fffb8c0
    478c:	1ffff438 	.word	0x1ffff438
    4790:	1ffff5d0 	.word	0x1ffff5d0
    4794:	1ffff510 	.word	0x1ffff510
    4798:	200045ec 	.word	0x200045ec
    479c:	1ffff79c 	.word	0x1ffff79c
    47a0:	000493e0 	.word	0x000493e0
    47a4:	1fffb888 	.word	0x1fffb888
    47a8:	1fffb878 	.word	0x1fffb878
    47ac:	3ff00000 	.word	0x3ff00000
    47b0:	00011b90 	.word	0x00011b90
    47b4:	1fffbaf4 	.word	0x1fffbaf4
    47b8:	1ffffa30 	.word	0x1ffffa30

000047bc <updateClick()>:
  }
}
double last_feature[2];
double current_feature[2];

void updateClick() {
    47bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  double flux = fc[2].getSpectralFlux();
    47c0:	4874      	ldr	r0, [pc, #464]	; (4994 <updateClick()+0x1d8>)
  for (int i = 0; i < num_channels; i++) {
    47c2:	4f75      	ldr	r7, [pc, #468]	; (4998 <updateClick()+0x1dc>)
  }
}
double last_feature[2];
double current_feature[2];

void updateClick() {
    47c4:	b08d      	sub	sp, #52	; 0x34
  double flux = fc[2].getSpectralFlux();
    47c6:	f7fe f807 	bl	27d8 <FeatureCollector::getSpectralFlux()>
  for (int i = 0; i < num_channels; i++) {
    47ca:	783b      	ldrb	r3, [r7, #0]
}
double last_feature[2];
double current_feature[2];

void updateClick() {
  double flux = fc[2].getSpectralFlux();
    47cc:	e9cd 0104 	strd	r0, r1, [sp, #16]
  for (int i = 0; i < num_channels; i++) {
    47d0:	2b00      	cmp	r3, #0
    47d2:	d042      	beq.n	485a <updateClick()+0x9e>
    47d4:	f8df 91e4 	ldr.w	r9, [pc, #484]	; 49bc <updateClick()+0x200>
    47d8:	f8df 81c8 	ldr.w	r8, [pc, #456]	; 49a4 <updateClick()+0x1e8>
    47dc:	4e6f      	ldr	r6, [pc, #444]	; (499c <updateClick()+0x1e0>)
    47de:	f8df a200 	ldr.w	sl, [pc, #512]	; 49e0 <updateClick()+0x224>
    47e2:	f04f 0b00 	mov.w	fp, #0
    47e6:	465c      	mov	r4, fp
    47e8:	4645      	mov	r5, r8
    47ea:	46cb      	mov	fp, r9
    Serial.println("ERROR  - RMS IS NOT AN ACTIVE AUDIO FEATURE : "); Serial.println(name);
    return -1.0;
}

double FeatureCollector::getPeak() {
    if (peak_active) {
    47ec:	f89a 3078 	ldrb.w	r3, [sl, #120]	; 0x78
    47f0:	2b00      	cmp	r3, #0
    47f2:	d035      	beq.n	4860 <updateClick()+0xa4>
        return peak_val;
    47f4:	e9da 2320 	ldrd	r2, r3, [sl, #128]	; 0x80
    47f8:	e9cd 2302 	strd	r2, r3, [sp, #8]
      // Serial.println(feature);
      }
    */
    // past_rms[i] = rms[i];
    double peak = fc[i + 2].getPeak();
    current_feature[i] = peak * flux;
    47fc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    4800:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    4804:	f008 f954 	bl	cab0 <__aeabi_dmul>
    4808:	4680      	mov	r8, r0
    480a:	4689      	mov	r9, r1
    if (current_feature[i] != last_feature[i]) {
    480c:	e8f6 2302 	ldrd	r2, r3, [r6], #8
      // Serial.println(feature);
      }
    */
    // past_rms[i] = rms[i];
    double peak = fc[i + 2].getPeak();
    current_feature[i] = peak * flux;
    4810:	e8eb 8902 	strd	r8, r9, [fp], #8
    if (current_feature[i] != last_feature[i]) {
    4814:	f008 fbb4 	bl	cf80 <__aeabi_dcmpeq>
    4818:	b978      	cbnz	r0, 483a <updateClick()+0x7e>
      last_feature[i] = current_feature[i];
      // Serial.print("last feature : ");
      // Serial.println(last_feature);
      // last_feature = 0;
      double threshold = CLICK_THRESH;
    481a:	4b61      	ldr	r3, [pc, #388]	; (49a0 <updateClick()+0x1e4>)
    481c:	e9d3 2300 	ldrd	r2, r3, [r3]
    */
    // past_rms[i] = rms[i];
    double peak = fc[i + 2].getPeak();
    current_feature[i] = peak * flux;
    if (current_feature[i] != last_feature[i]) {
      last_feature[i] = current_feature[i];
    4820:	e946 8902 	strd	r8, r9, [r6, #-8]
      // Serial.print("last feature : ");
      // Serial.println(last_feature);
      // last_feature = 0;
      double threshold = CLICK_THRESH;
    4824:	e9cd 2306 	strd	r2, r3, [sp, #24]
      if (i == 0) {
    4828:	b36c      	cbz	r4, 4886 <updateClick()+0xca>
        Serial.print("peak         : ");
        Serial.println(peak, 12);
        Serial.println("----------------------");
      }
      // Serial.print(rms_pos_delta
      if (current_feature[i] > threshold) {
    482a:	4642      	mov	r2, r8
    482c:	464b      	mov	r3, r9
    482e:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    4832:	f008 fbaf 	bl	cf94 <__aeabi_dcmplt>
    4836:	2800      	cmp	r0, #0
    4838:	d162      	bne.n	4900 <updateClick()+0x144>
          }
        }
      }
    }
    for (unsigned int i = 0; i < sizeof(neos) / sizeof(neos[0]); i++) {
      neos[i].update();
    483a:	485a      	ldr	r0, [pc, #360]	; (49a4 <updateClick()+0x1e8>)
    483c:	f7fd f9ca 	bl	1bd4 <NeoGroup::update()>
    4840:	4859      	ldr	r0, [pc, #356]	; (49a8 <updateClick()+0x1ec>)
    4842:	f7fd f9c7 	bl	1bd4 <NeoGroup::update()>
double last_feature[2];
double current_feature[2];

void updateClick() {
  double flux = fc[2].getSpectralFlux();
  for (int i = 0; i < num_channels; i++) {
    4846:	783b      	ldrb	r3, [r7, #0]
    4848:	3401      	adds	r4, #1
    484a:	f50a 5a88 	add.w	sl, sl, #4352	; 0x1100
    484e:	42a3      	cmp	r3, r4
    4850:	f10a 0a18 	add.w	sl, sl, #24
    4854:	f105 05d8 	add.w	r5, r5, #216	; 0xd8
    4858:	dcc8      	bgt.n	47ec <updateClick()+0x30>
    }
    for (unsigned int i = 0; i < sizeof(neos) / sizeof(neos[0]); i++) {
      neos[i].update();
    }
  }
}
    485a:	b00d      	add	sp, #52	; 0x34
    485c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4860:	212f      	movs	r1, #47	; 0x2f
    4862:	4852      	ldr	r0, [pc, #328]	; (49ac <updateClick()+0x1f0>)
    4864:	f006 fecc 	bl	b600 <usb_serial_write>
    4868:	4851      	ldr	r0, [pc, #324]	; (49b0 <updateClick()+0x1f4>)
    486a:	f004 fd03 	bl	9274 <Print::println()>
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
    486e:	4651      	mov	r1, sl
    4870:	484f      	ldr	r0, [pc, #316]	; (49b0 <updateClick()+0x1f4>)
    4872:	f004 fcd9 	bl	9228 <Print::print(String const&)>
    4876:	484e      	ldr	r0, [pc, #312]	; (49b0 <updateClick()+0x1f4>)
    4878:	f004 fcfc 	bl	9274 <Print::println()>
    487c:	4b4d      	ldr	r3, [pc, #308]	; (49b4 <updateClick()+0x1f8>)
    487e:	2200      	movs	r2, #0
    4880:	e9cd 2302 	strd	r2, r3, [sp, #8]
    4884:	e7ba      	b.n	47fc <updateClick()+0x40>
    4886:	210f      	movs	r1, #15
    4888:	484b      	ldr	r0, [pc, #300]	; (49b8 <updateClick()+0x1fc>)
    488a:	f006 feb9 	bl	b600 <usb_serial_write>
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
    488e:	4b4b      	ldr	r3, [pc, #300]	; (49bc <updateClick()+0x200>)
    4890:	4847      	ldr	r0, [pc, #284]	; (49b0 <updateClick()+0x1f4>)
    4892:	f04f 080c 	mov.w	r8, #12
    4896:	e9d3 2300 	ldrd	r2, r3, [r3]
    489a:	f8cd 8000 	str.w	r8, [sp]
    489e:	f004 fd43 	bl	9328 <Print::printFloat(double, unsigned char)>
	size_t println(int n, int base)			{ return print(n, base) + println(); }
	size_t println(unsigned int n, int base)	{ return print(n, base) + println(); }
	size_t println(long n, int base)		{ return print(n, base) + println(); }
	size_t println(unsigned long n, int base)	{ return print(n, base) + println(); }

	size_t println(double n, int digits = 2)	{ return print(n, digits) + println(); }
    48a2:	4843      	ldr	r0, [pc, #268]	; (49b0 <updateClick()+0x1f4>)
    48a4:	f004 fce6 	bl	9274 <Print::println()>
    48a8:	210f      	movs	r1, #15
    48aa:	4845      	ldr	r0, [pc, #276]	; (49c0 <updateClick()+0x204>)
    48ac:	f006 fea8 	bl	b600 <usb_serial_write>
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
    48b0:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    48b4:	4602      	mov	r2, r0
    48b6:	460b      	mov	r3, r1
    48b8:	f007 ff48 	bl	c74c <__adddf3>
    48bc:	f8cd 8000 	str.w	r8, [sp]
    48c0:	4602      	mov	r2, r0
    48c2:	460b      	mov	r3, r1
    48c4:	483a      	ldr	r0, [pc, #232]	; (49b0 <updateClick()+0x1f4>)
    48c6:	f004 fd2f 	bl	9328 <Print::printFloat(double, unsigned char)>
	size_t println(int n, int base)			{ return print(n, base) + println(); }
	size_t println(unsigned int n, int base)	{ return print(n, base) + println(); }
	size_t println(long n, int base)		{ return print(n, base) + println(); }
	size_t println(unsigned long n, int base)	{ return print(n, base) + println(); }

	size_t println(double n, int digits = 2)	{ return print(n, digits) + println(); }
    48ca:	4839      	ldr	r0, [pc, #228]	; (49b0 <updateClick()+0x1f4>)
    48cc:	f004 fcd2 	bl	9274 <Print::println()>
    48d0:	210f      	movs	r1, #15
    48d2:	483c      	ldr	r0, [pc, #240]	; (49c4 <updateClick()+0x208>)
    48d4:	f006 fe94 	bl	b600 <usb_serial_write>
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
    48d8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    48dc:	f8cd 8000 	str.w	r8, [sp]
    48e0:	4833      	ldr	r0, [pc, #204]	; (49b0 <updateClick()+0x1f4>)
    48e2:	f004 fd21 	bl	9328 <Print::printFloat(double, unsigned char)>
	size_t println(int n, int base)			{ return print(n, base) + println(); }
	size_t println(unsigned int n, int base)	{ return print(n, base) + println(); }
	size_t println(long n, int base)		{ return print(n, base) + println(); }
	size_t println(unsigned long n, int base)	{ return print(n, base) + println(); }

	size_t println(double n, int digits = 2)	{ return print(n, digits) + println(); }
    48e6:	4832      	ldr	r0, [pc, #200]	; (49b0 <updateClick()+0x1f4>)
    48e8:	f004 fcc4 	bl	9274 <Print::println()>
    48ec:	2116      	movs	r1, #22
    48ee:	4836      	ldr	r0, [pc, #216]	; (49c8 <updateClick()+0x20c>)
    48f0:	f006 fe86 	bl	b600 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    48f4:	482e      	ldr	r0, [pc, #184]	; (49b0 <updateClick()+0x1f4>)
    48f6:	f004 fcbd 	bl	9274 <Print::println()>
    48fa:	e95b 8902 	ldrd	r8, r9, [fp, #-8]
    48fe:	e794      	b.n	482a <updateClick()+0x6e>
    4900:	2137      	movs	r1, #55	; 0x37
    4902:	4832      	ldr	r0, [pc, #200]	; (49cc <updateClick()+0x210>)
    4904:	f006 fe7c 	bl	b600 <usb_serial_write>
    4908:	4829      	ldr	r0, [pc, #164]	; (49b0 <updateClick()+0x1f4>)
    490a:	f004 fcb3 	bl	9274 <Print::println()>
        Serial.println("----------------------");
      }
      // Serial.print(rms_pos_delta
      if (current_feature[i] > threshold) {
        Serial.println("____________________ CLICK ________________________ 3.0");
        dprint(PRINT_CLICK_DEBUG, "click feature is above threshold: ");
    490e:	4930      	ldr	r1, [pc, #192]	; (49d0 <updateClick()+0x214>)
    4910:	a808      	add	r0, sp, #32
    4912:	f004 fe21 	bl	9558 <String::String(char const*)>
    4916:	a808      	add	r0, sp, #32
    4918:	f004 fdde 	bl	94d8 <String::~String()>
        dprint(PRINT_CLICK_DEBUG, current_feature[i]);
        dprint(PRINT_CLICK_DEBUG, " - ");
    491c:	492d      	ldr	r1, [pc, #180]	; (49d4 <updateClick()+0x218>)
    491e:	a808      	add	r0, sp, #32
    4920:	f004 fe1a 	bl	9558 <String::String(char const*)>
    4924:	a808      	add	r0, sp, #32
    4926:	f004 fdd7 	bl	94d8 <String::~String()>
  }
  return false;
}

bool NeoGroup::flashOn() {
  return flashOn(flash_red, flash_green, flash_blue);
    492a:	f895 304e 	ldrb.w	r3, [r5, #78]	; 0x4e
    492e:	f895 204d 	ldrb.w	r2, [r5, #77]	; 0x4d
    4932:	f895 104c 	ldrb.w	r1, [r5, #76]	; 0x4c
    4936:	4628      	mov	r0, r5
    4938:	f7fd f8a0 	bl	1a7c <NeoGroup::flashOn(unsigned char, unsigned char, unsigned char)>
        dprint(PRINT_CLICK_DEBUG, threshold);
        if (neos[i].flashOn()) {
    493c:	2800      	cmp	r0, #0
    493e:	f43f af7c 	beq.w	483a <updateClick()+0x7e>
          // num_flashes[i]++;
          // total_flashes[i]++;
          // fpm[i] = num_flashes[i] / fpm_timer;
          if (INDEPENDENT_FLASHES == false && i == 0 && ENCLOSURE_TYPE != GROUND_ENCLOSURE) {
    4942:	4b25      	ldr	r3, [pc, #148]	; (49d8 <updateClick()+0x21c>)
    4944:	781b      	ldrb	r3, [r3, #0]
    4946:	2b00      	cmp	r3, #0
    4948:	f47f af77 	bne.w	483a <updateClick()+0x7e>
    494c:	b98c      	cbnz	r4, 4972 <updateClick()+0x1b6>
    494e:	4b23      	ldr	r3, [pc, #140]	; (49dc <updateClick()+0x220>)
    4950:	781b      	ldrb	r3, [r3, #0]
    4952:	2b00      	cmp	r3, #0
    4954:	f43f af71 	beq.w	483a <updateClick()+0x7e>
    4958:	4b12      	ldr	r3, [pc, #72]	; (49a4 <updateClick()+0x1e8>)
    495a:	4a12      	ldr	r2, [pc, #72]	; (49a4 <updateClick()+0x1e8>)
    495c:	4911      	ldr	r1, [pc, #68]	; (49a4 <updateClick()+0x1e8>)
    495e:	f893 3126 	ldrb.w	r3, [r3, #294]	; 0x126
    4962:	f892 2125 	ldrb.w	r2, [r2, #293]	; 0x125
    4966:	f891 1124 	ldrb.w	r1, [r1, #292]	; 0x124
    496a:	480f      	ldr	r0, [pc, #60]	; (49a8 <updateClick()+0x1ec>)
    496c:	f7fd f886 	bl	1a7c <NeoGroup::flashOn(unsigned char, unsigned char, unsigned char)>
    4970:	e763      	b.n	483a <updateClick()+0x7e>
              // num_flashes[1]++;
              // total_flashes[1]++;
              // fpm[1] = num_flashes[1] / fpm_timer;
            }
          }
          if (INDEPENDENT_FLASHES == false && i == 1) {
    4972:	2c01      	cmp	r4, #1
    4974:	f47f af61 	bne.w	483a <updateClick()+0x7e>
    4978:	4b0a      	ldr	r3, [pc, #40]	; (49a4 <updateClick()+0x1e8>)
    497a:	4a0a      	ldr	r2, [pc, #40]	; (49a4 <updateClick()+0x1e8>)
    497c:	4909      	ldr	r1, [pc, #36]	; (49a4 <updateClick()+0x1e8>)
    497e:	f893 304e 	ldrb.w	r3, [r3, #78]	; 0x4e
    4982:	f892 204d 	ldrb.w	r2, [r2, #77]	; 0x4d
    4986:	f891 104c 	ldrb.w	r1, [r1, #76]	; 0x4c
    498a:	4806      	ldr	r0, [pc, #24]	; (49a4 <updateClick()+0x1e8>)
    498c:	f7fd f876 	bl	1a7c <NeoGroup::flashOn(unsigned char, unsigned char, unsigned char)>
    4990:	e753      	b.n	483a <updateClick()+0x7e>
    4992:	bf00      	nop
    4994:	20001c60 	.word	0x20001c60
    4998:	1fffb8a2 	.word	0x1fffb8a2
    499c:	1ffff9e0 	.word	0x1ffff9e0
    49a0:	1fffb8b8 	.word	0x1fffb8b8
    49a4:	1ffff438 	.word	0x1ffff438
    49a8:	1ffff510 	.word	0x1ffff510
    49ac:	0001146c 	.word	0x0001146c
    49b0:	1fffbaf4 	.word	0x1fffbaf4
    49b4:	bff00000 	.word	0xbff00000
    49b8:	00011bc4 	.word	0x00011bc4
    49bc:	1fffd268 	.word	0x1fffd268
    49c0:	00011bd4 	.word	0x00011bd4
    49c4:	00011be4 	.word	0x00011be4
    49c8:	00011bf4 	.word	0x00011bf4
    49cc:	00011c0c 	.word	0x00011c0c
    49d0:	00011c44 	.word	0x00011c44
    49d4:	00010e58 	.word	0x00010e58
    49d8:	20003f98 	.word	0x20003f98
    49dc:	1fffc8f0 	.word	0x1fffc8f0
    49e0:	20001c88 	.word	0x20001c88

000049e4 <updateAutogain()>:
    }
  }
}


void updateAutogain() {
    49e4:	b570      	push	{r4, r5, r6, lr}
    49e6:	4c12      	ldr	r4, [pc, #72]	; (4a30 <updateAutogain()+0x4c>)
#if (AUTOGAIN_ACTIVE)
  auto_gain[0].updateExternal((neos[0].getOnRatio() + neos[1].getOnRatio()) * 0.5);
    49e8:	4d12      	ldr	r5, [pc, #72]	; (4a34 <updateAutogain()+0x50>)
    49ea:	f504 7380 	add.w	r3, r4, #256	; 0x100
    49ee:	e9d3 2300 	ldrd	r2, r3, [r3]
    49f2:	e9d4 010a 	ldrd	r0, r1, [r4, #40]	; 0x28
    49f6:	f007 fea9 	bl	c74c <__adddf3>
    49fa:	2200      	movs	r2, #0
    49fc:	4b0e      	ldr	r3, [pc, #56]	; (4a38 <updateAutogain()+0x54>)
    49fe:	f008 f857 	bl	cab0 <__aeabi_dmul>
    4a02:	4602      	mov	r2, r0
    4a04:	460b      	mov	r3, r1
    4a06:	4628      	mov	r0, r5
    4a08:	f7fe fb0a 	bl	3020 <AutoGain::updateExternal(double)>
  auto_gain[1].updateExternal((neos[0].fpm + neos[1].fpm) * 0.5);
    4a0c:	e9d4 233e 	ldrd	r2, r3, [r4, #248]	; 0xf8
    4a10:	e9d4 0108 	ldrd	r0, r1, [r4, #32]
    4a14:	f007 fe9a 	bl	c74c <__adddf3>
    4a18:	2200      	movs	r2, #0
    4a1a:	4b07      	ldr	r3, [pc, #28]	; (4a38 <updateAutogain()+0x54>)
    4a1c:	f008 f848 	bl	cab0 <__aeabi_dmul>
    4a20:	4602      	mov	r2, r0
    4a22:	460b      	mov	r3, r1
    4a24:	f105 0078 	add.w	r0, r5, #120	; 0x78
  return;
#endif
}
    4a28:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}


void updateAutogain() {
#if (AUTOGAIN_ACTIVE)
  auto_gain[0].updateExternal((neos[0].getOnRatio() + neos[1].getOnRatio()) * 0.5);
  auto_gain[1].updateExternal((neos[0].fpm + neos[1].fpm) * 0.5);
    4a2c:	f7fe baf8 	b.w	3020 <AutoGain::updateExternal(double)>
    4a30:	1ffff438 	.word	0x1ffff438
    4a34:	20003fa0 	.word	0x20003fa0
    4a38:	3fe00000 	.word	0x3fe00000
    4a3c:	ffffffff 	.word	0xffffffff

00004a40 <updateDatalog()>:
      }
#endif
    }
  }
}
void updateDatalog() {
    4a40:	b510      	push	{r4, lr}
  datalog_manager.update();
    4a42:	480d      	ldr	r0, [pc, #52]	; (4a78 <updateDatalog()+0x38>)
  runtime = (double)millis() / 60000;
    4a44:	4c0d      	ldr	r4, [pc, #52]	; (4a7c <updateDatalog()+0x3c>)
      }
#endif
    }
  }
}
void updateDatalog() {
    4a46:	b082      	sub	sp, #8
  datalog_manager.update();
    4a48:	f7fc faec 	bl	1024 <DLManager::update()>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4a4c:	4b0c      	ldr	r3, [pc, #48]	; (4a80 <updateDatalog()+0x40>)
    4a4e:	681b      	ldr	r3, [r3, #0]
    4a50:	9301      	str	r3, [sp, #4]
	return ret;
    4a52:	9801      	ldr	r0, [sp, #4]
  runtime = (double)millis() / 60000;
    4a54:	f007 ffb6 	bl	c9c4 <__aeabi_ui2d>
    4a58:	a305      	add	r3, pc, #20	; (adr r3, 4a70 <updateDatalog()+0x30>)
    4a5a:	e9d3 2300 	ldrd	r2, r3, [r3]
    4a5e:	f008 f951 	bl	cd04 <__aeabi_ddiv>
    4a62:	e9c4 0100 	strd	r0, r1, [r4]
}
    4a66:	b002      	add	sp, #8
    4a68:	bd10      	pop	{r4, pc}
    4a6a:	bf00      	nop
    4a6c:	f3af 8000 	nop.w
    4a70:	00000000 	.word	0x00000000
    4a74:	40ed4c00 	.word	0x40ed4c00
    4a78:	1fffd278 	.word	0x1fffd278
    4a7c:	1fffc530 	.word	0x1fffc530
    4a80:	200045ec 	.word	0x200045ec

00004a84 <testJumpers()>:

bool testJumpers() {
    4a84:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  bool populated = true;
  bool values[6];
  values[0] = digitalRead(JMP1_PIN);
    4a88:	200c      	movs	r0, #12
    4a8a:	f005 fb0b 	bl	a0a4 <digitalRead>
    4a8e:	4683      	mov	fp, r0
  values[1] = digitalRead(JMP2_PIN);
    4a90:	200b      	movs	r0, #11
    4a92:	f005 fb07 	bl	a0a4 <digitalRead>
    4a96:	4682      	mov	sl, r0
  values[2] = digitalRead(JMP3_PIN);
    4a98:	200e      	movs	r0, #14
    4a9a:	f005 fb03 	bl	a0a4 <digitalRead>
    4a9e:	4681      	mov	r9, r0
  values[3] = digitalRead(JMP4_PIN);
    4aa0:	200f      	movs	r0, #15
    4aa2:	f005 faff 	bl	a0a4 <digitalRead>
    4aa6:	4680      	mov	r8, r0
  values[4] = digitalRead(JMP5_PIN);
    4aa8:	2010      	movs	r0, #16
    4aaa:	f005 fafb 	bl	a0a4 <digitalRead>
    4aae:	4607      	mov	r7, r0
  values[5] = digitalRead(JMP6_PIN);
    4ab0:	2011      	movs	r0, #17
    4ab2:	f005 faf7 	bl	a0a4 <digitalRead>
    4ab6:	211b      	movs	r1, #27
    4ab8:	4606      	mov	r6, r0
    4aba:	483c      	ldr	r0, [pc, #240]	; (4bac <testJumpers()+0x128>)
    4abc:	f006 fda0 	bl	b600 <usb_serial_write>
    4ac0:	483b      	ldr	r0, [pc, #236]	; (4bb0 <testJumpers()+0x12c>)
    4ac2:	f004 fbd7 	bl	9274 <Print::println()>
    4ac6:	f11b 0b00 	adds.w	fp, fp, #0
    4aca:	bf18      	it	ne
    4acc:	f04f 0b01 	movne.w	fp, #1
    4ad0:	f11a 0a00 	adds.w	sl, sl, #0
    4ad4:	bf18      	it	ne
    4ad6:	f04f 0a01 	movne.w	sl, #1
    4ada:	f119 0900 	adds.w	r9, r9, #0
    4ade:	bf18      	it	ne
    4ae0:	f04f 0901 	movne.w	r9, #1
    4ae4:	f118 0800 	adds.w	r8, r8, #0
    4ae8:	bf18      	it	ne
    4aea:	f04f 0801 	movne.w	r8, #1
    4aee:	3700      	adds	r7, #0
    4af0:	bf18      	it	ne
    4af2:	2701      	movne	r7, #1
    4af4:	3600      	adds	r6, #0
    4af6:	bf18      	it	ne
    4af8:	2601      	movne	r6, #1
    4afa:	250a      	movs	r5, #10
  datalog_manager.update();
  runtime = (double)millis() / 60000;
}

bool testJumpers() {
  bool populated = true;
    4afc:	2401      	movs	r4, #1
  values[3] = digitalRead(JMP4_PIN);
  values[4] = digitalRead(JMP5_PIN);
  values[5] = digitalRead(JMP6_PIN);
  Serial.println("Testing the PCB for jumpers");
  for (int i = 0; i < 10; i++) {
    if (values[0] != digitalRead(JMP1_PIN)){
    4afe:	200c      	movs	r0, #12
    4b00:	f005 fad0 	bl	a0a4 <digitalRead>
    4b04:	4558      	cmp	r0, fp
    4b06:	d007      	beq.n	4b18 <testJumpers()+0x94>
    4b08:	2121      	movs	r1, #33	; 0x21
    4b0a:	482a      	ldr	r0, [pc, #168]	; (4bb4 <testJumpers()+0x130>)
    4b0c:	f006 fd78 	bl	b600 <usb_serial_write>
    4b10:	4827      	ldr	r0, [pc, #156]	; (4bb0 <testJumpers()+0x12c>)
    4b12:	f004 fbaf 	bl	9274 <Print::println()>
        populated = false;
    4b16:	2400      	movs	r4, #0
        Serial.println("JMP1_PIN returned multiple values");
    }
        if (values[1] != digitalRead(JMP2_PIN)){
    4b18:	200b      	movs	r0, #11
    4b1a:	f005 fac3 	bl	a0a4 <digitalRead>
    4b1e:	4582      	cmp	sl, r0
    4b20:	d007      	beq.n	4b32 <testJumpers()+0xae>
    4b22:	2121      	movs	r1, #33	; 0x21
    4b24:	4824      	ldr	r0, [pc, #144]	; (4bb8 <testJumpers()+0x134>)
    4b26:	f006 fd6b 	bl	b600 <usb_serial_write>
    4b2a:	4821      	ldr	r0, [pc, #132]	; (4bb0 <testJumpers()+0x12c>)
    4b2c:	f004 fba2 	bl	9274 <Print::println()>
        populated = false;
    4b30:	2400      	movs	r4, #0
        Serial.println("JMP2_PIN returned multiple values");
    }
        if (values[2] != digitalRead(JMP3_PIN)){
    4b32:	200e      	movs	r0, #14
    4b34:	f005 fab6 	bl	a0a4 <digitalRead>
    4b38:	4581      	cmp	r9, r0
    4b3a:	d007      	beq.n	4b4c <testJumpers()+0xc8>
    4b3c:	2121      	movs	r1, #33	; 0x21
    4b3e:	481f      	ldr	r0, [pc, #124]	; (4bbc <testJumpers()+0x138>)
    4b40:	f006 fd5e 	bl	b600 <usb_serial_write>
    4b44:	481a      	ldr	r0, [pc, #104]	; (4bb0 <testJumpers()+0x12c>)
    4b46:	f004 fb95 	bl	9274 <Print::println()>
        populated = false;
    4b4a:	2400      	movs	r4, #0
        Serial.println("JMP3_PIN returned multiple values");
    }
        if (values[3] != digitalRead(JMP4_PIN)){
    4b4c:	200f      	movs	r0, #15
    4b4e:	f005 faa9 	bl	a0a4 <digitalRead>
    4b52:	4540      	cmp	r0, r8
    4b54:	d007      	beq.n	4b66 <testJumpers()+0xe2>
    4b56:	2121      	movs	r1, #33	; 0x21
    4b58:	4819      	ldr	r0, [pc, #100]	; (4bc0 <testJumpers()+0x13c>)
    4b5a:	f006 fd51 	bl	b600 <usb_serial_write>
    4b5e:	4814      	ldr	r0, [pc, #80]	; (4bb0 <testJumpers()+0x12c>)
    4b60:	f004 fb88 	bl	9274 <Print::println()>
        populated = false;
    4b64:	2400      	movs	r4, #0
        Serial.println("JMP4_PIN returned multiple values");
    }
        if (values[4] != digitalRead(JMP5_PIN)){
    4b66:	2010      	movs	r0, #16
    4b68:	f005 fa9c 	bl	a0a4 <digitalRead>
    4b6c:	42b8      	cmp	r0, r7
    4b6e:	d007      	beq.n	4b80 <testJumpers()+0xfc>
    4b70:	2121      	movs	r1, #33	; 0x21
    4b72:	4814      	ldr	r0, [pc, #80]	; (4bc4 <testJumpers()+0x140>)
    4b74:	f006 fd44 	bl	b600 <usb_serial_write>
    4b78:	480d      	ldr	r0, [pc, #52]	; (4bb0 <testJumpers()+0x12c>)
    4b7a:	f004 fb7b 	bl	9274 <Print::println()>
        populated = false;
    4b7e:	2400      	movs	r4, #0
        Serial.println("JMP5_PIN returned multiple values");
    }
        if (values[5] != digitalRead(JMP6_PIN)){
    4b80:	2011      	movs	r0, #17
    4b82:	f005 fa8f 	bl	a0a4 <digitalRead>
    4b86:	42b0      	cmp	r0, r6
    4b88:	d007      	beq.n	4b9a <testJumpers()+0x116>
    4b8a:	2121      	movs	r1, #33	; 0x21
    4b8c:	480e      	ldr	r0, [pc, #56]	; (4bc8 <testJumpers()+0x144>)
    4b8e:	f006 fd37 	bl	b600 <usb_serial_write>
    4b92:	4807      	ldr	r0, [pc, #28]	; (4bb0 <testJumpers()+0x12c>)
    4b94:	f004 fb6e 	bl	9274 <Print::println()>
        populated = false;
    4b98:	2400      	movs	r4, #0
        Serial.println("JMP6_PIN returned multiple values");
    }
    delay(10);
    4b9a:	200a      	movs	r0, #10
    4b9c:	f005 fab8 	bl	a110 <delay>
  values[2] = digitalRead(JMP3_PIN);
  values[3] = digitalRead(JMP4_PIN);
  values[4] = digitalRead(JMP5_PIN);
  values[5] = digitalRead(JMP6_PIN);
  Serial.println("Testing the PCB for jumpers");
  for (int i = 0; i < 10; i++) {
    4ba0:	3d01      	subs	r5, #1
    4ba2:	d1ac      	bne.n	4afe <testJumpers()+0x7a>
        Serial.println("JMP6_PIN returned multiple values");
    }
    delay(10);
  }
  return populated;
}
    4ba4:	4620      	mov	r0, r4
    4ba6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4baa:	bf00      	nop
    4bac:	00011c68 	.word	0x00011c68
    4bb0:	1fffbaf4 	.word	0x1fffbaf4
    4bb4:	00011c84 	.word	0x00011c84
    4bb8:	00011ca8 	.word	0x00011ca8
    4bbc:	00011ccc 	.word	0x00011ccc
    4bc0:	00011cf0 	.word	0x00011cf0
    4bc4:	00011d14 	.word	0x00011d14
    4bc8:	00011d38 	.word	0x00011d38

00004bcc <readJumpers()>:

void readJumpers() {
    4bcc:	b510      	push	{r4, lr}
    4bce:	b082      	sub	sp, #8
  if (testJumpers() == true) {
    4bd0:	f7ff ff58 	bl	4a84 <testJumpers()>
    4bd4:	2800      	cmp	r0, #0
    4bd6:	f000 809c 	beq.w	4d12 <readJumpers()+0x146>
    4bda:	2121      	movs	r1, #33	; 0x21
    4bdc:	4852      	ldr	r0, [pc, #328]	; (4d28 <readJumpers()+0x15c>)
    Serial.print("\t");
    Serial.println(digitalRead(JMP6_PIN));

    //////////// Jumper 1 ///////////////////////
    bool temp_b;
    ENCLOSURE_TYPE = digitalRead(JMP1_PIN);
    4bde:	4c53      	ldr	r4, [pc, #332]	; (4d2c <readJumpers()+0x160>)
    4be0:	f006 fd0e 	bl	b600 <usb_serial_write>
    4be4:	4852      	ldr	r0, [pc, #328]	; (4d30 <readJumpers()+0x164>)
    4be6:	f004 fb45 	bl	9274 <Print::println()>
}

void readJumpers() {
  if (testJumpers() == true) {
    Serial.println("Jumpers passed continuity test...");
    pinMode(JMP1_PIN, INPUT);
    4bea:	2100      	movs	r1, #0
    4bec:	200c      	movs	r0, #12
    4bee:	f005 fa67 	bl	a0c0 <pinMode>
    pinMode(JMP2_PIN, INPUT);
    4bf2:	2100      	movs	r1, #0
    4bf4:	200b      	movs	r0, #11
    4bf6:	f005 fa63 	bl	a0c0 <pinMode>
    pinMode(JMP3_PIN, INPUT);
    4bfa:	2100      	movs	r1, #0
    4bfc:	200e      	movs	r0, #14
    4bfe:	f005 fa5f 	bl	a0c0 <pinMode>
    pinMode(JMP4_PIN, INPUT);
    4c02:	2100      	movs	r1, #0
    4c04:	200f      	movs	r0, #15
    4c06:	f005 fa5b 	bl	a0c0 <pinMode>
    pinMode(JMP5_PIN, INPUT);
    4c0a:	2100      	movs	r1, #0
    4c0c:	2010      	movs	r0, #16
    4c0e:	f005 fa57 	bl	a0c0 <pinMode>
    pinMode(JMP6_PIN, INPUT);
    4c12:	2100      	movs	r1, #0
    4c14:	2011      	movs	r0, #17
    4c16:	f005 fa53 	bl	a0c0 <pinMode>
    Serial.print(digitalRead(JMP1_PIN));
    4c1a:	200c      	movs	r0, #12
    4c1c:	f005 fa42 	bl	a0a4 <digitalRead>
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    4c20:	2300      	movs	r3, #0
    4c22:	220a      	movs	r2, #10
    4c24:	4601      	mov	r1, r0
    4c26:	4842      	ldr	r0, [pc, #264]	; (4d30 <readJumpers()+0x164>)
    4c28:	f004 fb34 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    4c2c:	2101      	movs	r1, #1
    4c2e:	4841      	ldr	r0, [pc, #260]	; (4d34 <readJumpers()+0x168>)
    4c30:	f006 fce6 	bl	b600 <usb_serial_write>
    Serial.print("\t");
    Serial.print(digitalRead(JMP2_PIN));
    4c34:	200b      	movs	r0, #11
    4c36:	f005 fa35 	bl	a0a4 <digitalRead>
    4c3a:	2300      	movs	r3, #0
    4c3c:	220a      	movs	r2, #10
    4c3e:	4601      	mov	r1, r0
    4c40:	483b      	ldr	r0, [pc, #236]	; (4d30 <readJumpers()+0x164>)
    4c42:	f004 fb27 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    4c46:	2101      	movs	r1, #1
    4c48:	483a      	ldr	r0, [pc, #232]	; (4d34 <readJumpers()+0x168>)
    4c4a:	f006 fcd9 	bl	b600 <usb_serial_write>
    Serial.print("\t");
    Serial.print(digitalRead(JMP3_PIN));
    4c4e:	200e      	movs	r0, #14
    4c50:	f005 fa28 	bl	a0a4 <digitalRead>
    4c54:	2300      	movs	r3, #0
    4c56:	220a      	movs	r2, #10
    4c58:	4601      	mov	r1, r0
    4c5a:	4835      	ldr	r0, [pc, #212]	; (4d30 <readJumpers()+0x164>)
    4c5c:	f004 fb1a 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    4c60:	2101      	movs	r1, #1
    4c62:	4834      	ldr	r0, [pc, #208]	; (4d34 <readJumpers()+0x168>)
    4c64:	f006 fccc 	bl	b600 <usb_serial_write>
    Serial.print("\t");
    Serial.print(digitalRead(JMP4_PIN));
    4c68:	200f      	movs	r0, #15
    4c6a:	f005 fa1b 	bl	a0a4 <digitalRead>
    4c6e:	2300      	movs	r3, #0
    4c70:	220a      	movs	r2, #10
    4c72:	4601      	mov	r1, r0
    4c74:	482e      	ldr	r0, [pc, #184]	; (4d30 <readJumpers()+0x164>)
    4c76:	f004 fb0d 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    4c7a:	2101      	movs	r1, #1
    4c7c:	482d      	ldr	r0, [pc, #180]	; (4d34 <readJumpers()+0x168>)
    4c7e:	f006 fcbf 	bl	b600 <usb_serial_write>
    Serial.print("\t");
    Serial.print(digitalRead(JMP5_PIN));
    4c82:	2010      	movs	r0, #16
    4c84:	f005 fa0e 	bl	a0a4 <digitalRead>
    4c88:	2300      	movs	r3, #0
    4c8a:	220a      	movs	r2, #10
    4c8c:	4601      	mov	r1, r0
    4c8e:	4828      	ldr	r0, [pc, #160]	; (4d30 <readJumpers()+0x164>)
    4c90:	f004 fb00 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    4c94:	2101      	movs	r1, #1
    4c96:	4827      	ldr	r0, [pc, #156]	; (4d34 <readJumpers()+0x168>)
    4c98:	f006 fcb2 	bl	b600 <usb_serial_write>
    Serial.print("\t");
    Serial.println(digitalRead(JMP6_PIN));
    4c9c:	2011      	movs	r0, #17
    4c9e:	f005 fa01 	bl	a0a4 <digitalRead>
    4ca2:	2300      	movs	r3, #0
    4ca4:	4601      	mov	r1, r0
    4ca6:	220a      	movs	r2, #10
    4ca8:	4821      	ldr	r0, [pc, #132]	; (4d30 <readJumpers()+0x164>)
    4caa:	f004 faf3 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
    4cae:	4820      	ldr	r0, [pc, #128]	; (4d30 <readJumpers()+0x164>)
    4cb0:	f004 fae0 	bl	9274 <Print::println()>

    //////////// Jumper 1 ///////////////////////
    bool temp_b;
    ENCLOSURE_TYPE = digitalRead(JMP1_PIN);
    4cb4:	200c      	movs	r0, #12
    4cb6:	f005 f9f5 	bl	a0a4 <digitalRead>
    4cba:	2128      	movs	r1, #40	; 0x28
    4cbc:	7020      	strb	r0, [r4, #0]
    4cbe:	481e      	ldr	r0, [pc, #120]	; (4d38 <readJumpers()+0x16c>)
    4cc0:	f006 fc9e 	bl	b600 <usb_serial_write>
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    4cc4:	7821      	ldrb	r1, [r4, #0]
    4cc6:	481a      	ldr	r0, [pc, #104]	; (4d30 <readJumpers()+0x164>)
    Serial.println(CLICK_FEATURE);
    */
    ///////////// Jumper 6 //////////////////////
    temp_b = digitalRead(JMP6_PIN);
    if (temp_b == 1) {
      MASTER_GAIN_SCALER *= 1.5;
    4cc8:	4c1c      	ldr	r4, [pc, #112]	; (4d3c <readJumpers()+0x170>)
    4cca:	2300      	movs	r3, #0
    4ccc:	220a      	movs	r2, #10
    4cce:	f004 fae1 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
    4cd2:	4817      	ldr	r0, [pc, #92]	; (4d30 <readJumpers()+0x164>)
    4cd4:	f004 face 	bl	9274 <Print::println()>
    }
    Serial.print("(pin5) Click Feature                 : ");
    Serial.println(CLICK_FEATURE);
    */
    ///////////// Jumper 6 //////////////////////
    temp_b = digitalRead(JMP6_PIN);
    4cd8:	2011      	movs	r0, #17
    4cda:	f005 f9e3 	bl	a0a4 <digitalRead>
    if (temp_b == 1) {
    4cde:	b138      	cbz	r0, 4cf0 <readJumpers()+0x124>
      MASTER_GAIN_SCALER *= 1.5;
    4ce0:	e9d4 0100 	ldrd	r0, r1, [r4]
    4ce4:	2200      	movs	r2, #0
    4ce6:	4b16      	ldr	r3, [pc, #88]	; (4d40 <readJumpers()+0x174>)
    4ce8:	f007 fee2 	bl	cab0 <__aeabi_dmul>
    4cec:	e9c4 0100 	strd	r0, r1, [r4]
    4cf0:	212d      	movs	r1, #45	; 0x2d
    4cf2:	4814      	ldr	r0, [pc, #80]	; (4d44 <readJumpers()+0x178>)
    4cf4:	f006 fc84 	bl	b600 <usb_serial_write>
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
    4cf8:	2102      	movs	r1, #2
    4cfa:	e9d4 2300 	ldrd	r2, r3, [r4]
    4cfe:	480c      	ldr	r0, [pc, #48]	; (4d30 <readJumpers()+0x164>)
    4d00:	9100      	str	r1, [sp, #0]
    4d02:	f004 fb11 	bl	9328 <Print::printFloat(double, unsigned char)>
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    4d06:	480a      	ldr	r0, [pc, #40]	; (4d30 <readJumpers()+0x164>)
    Serial.print("(pin6) MASTER_GAIN_SCALER increased by 50% : ");
    Serial.println(MASTER_GAIN_SCALER);
  } else {
    Serial.println("ERROR - this PCB does not contain jumpers, or jumper pins are not populated");
  }
}
    4d08:	b002      	add	sp, #8
    4d0a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    4d0e:	f004 bab1 	b.w	9274 <Print::println()>
    4d12:	214b      	movs	r1, #75	; 0x4b
    4d14:	480c      	ldr	r0, [pc, #48]	; (4d48 <readJumpers()+0x17c>)
    4d16:	f006 fc73 	bl	b600 <usb_serial_write>
    4d1a:	4805      	ldr	r0, [pc, #20]	; (4d30 <readJumpers()+0x164>)
    4d1c:	b002      	add	sp, #8
    4d1e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    4d22:	f004 baa7 	b.w	9274 <Print::println()>
    4d26:	bf00      	nop
    4d28:	00011d5c 	.word	0x00011d5c
    4d2c:	1fffc8f0 	.word	0x1fffc8f0
    4d30:	1fffbaf4 	.word	0x1fffbaf4
    4d34:	00010cc0 	.word	0x00010cc0
    4d38:	00011d80 	.word	0x00011d80
    4d3c:	1fffb890 	.word	0x1fffb890
    4d40:	3ff80000 	.word	0x3ff80000
    4d44:	00011dac 	.word	0x00011dac
    4d48:	00011ddc 	.word	0x00011ddc

00004d4c <_GLOBAL__sub_I__Z8printTabv>:
  updateMode();
  updateAutogain();
  updateDatalog();
  listenForSerialCommands();
  //updateLoopLength();
}
    4d4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4d50:	4a72      	ldr	r2, [pc, #456]	; (4f1c <_GLOBAL__sub_I__Z8printTabv+0x1d0>)
{
private:
	unsigned long ms;
public:
	elapsedMillis(void) { ms = millis(); }
	elapsedMillis(unsigned long val) { ms = millis() - val; }
    4d52:	4b73      	ldr	r3, [pc, #460]	; (4f20 <_GLOBAL__sub_I__Z8printTabv+0x1d4>)
    4d54:	6812      	ldr	r2, [r2, #0]
WS2812Serial leds(NUM_LED, LED_DISPLAY_MEMORY, LED_DRAWING_MEMORY, LED_PIN, WS2812_GRB);

NeoGroup neos[2] = {
  NeoGroup(&leds, 0, (NUM_LED / 2) - 1, "Front", MIN_FLASH_TIME, MAX_FLASH_TIME),
  NeoGroup(&leds, NUM_LED / 2, NUM_LED - 1, "Rear", MIN_FLASH_TIME, MAX_FLASH_TIME)
};
    4d56:	4d73      	ldr	r5, [pc, #460]	; (4f24 <_GLOBAL__sub_I__Z8printTabv+0x1d8>)

// lux managers to keep track of the VEML readings
LuxManager lux_managers[NUM_LUX_SENSORS] = {
  LuxManager(lux_min_reading_delay, lux_max_reading_delay, 0, (String)"Front", &neos[0]),
  LuxManager(lux_min_reading_delay, lux_max_reading_delay, 1, (String)"Rear ", &neos[1])
};
    4d58:	f8df 824c 	ldr.w	r8, [pc, #588]	; 4fa8 <_GLOBAL__sub_I__Z8printTabv+0x25c>
    4d5c:	4f72      	ldr	r7, [pc, #456]	; (4f28 <_GLOBAL__sub_I__Z8printTabv+0x1dc>)
    4d5e:	b08f      	sub	sp, #60	; 0x3c
WS2812Serial leds(NUM_LED, LED_DISPLAY_MEMORY, LED_DRAWING_MEMORY, LED_PIN, WS2812_GRB);

NeoGroup neos[2] = {
  NeoGroup(&leds, 0, (NUM_LED / 2) - 1, "Front", MIN_FLASH_TIME, MAX_FLASH_TIME),
  NeoGroup(&leds, NUM_LED / 2, NUM_LED - 1, "Rear", MIN_FLASH_TIME, MAX_FLASH_TIME)
};
    4d60:	ac0a      	add	r4, sp, #40	; 0x28
    4d62:	9209      	str	r2, [sp, #36]	; 0x24
	return ret;
    4d64:	9a09      	ldr	r2, [sp, #36]	; 0x24
    4d66:	601a      	str	r2, [r3, #0]
    4d68:	f04f 0a3c 	mov.w	sl, #60	; 0x3c
***/

struct EEPROMClass{

#if defined(__arm__) && defined(TEENSYDUINO)
    EEPROMClass()                        { eeprom_initialize(); }
    4d6c:	f004 fd0e 	bl	978c <eeprom_initialize>
    4d70:	f04f 0928 	mov.w	r9, #40	; 0x28
    4d74:	496d      	ldr	r1, [pc, #436]	; (4f2c <_GLOBAL__sub_I__Z8printTabv+0x1e0>)
    4d76:	4620      	mov	r0, r4
    4d78:	f004 fbee 	bl	9558 <String::String(char const*)>
    4d7c:	2304      	movs	r3, #4
    4d7e:	2200      	movs	r2, #0
    4d80:	496b      	ldr	r1, [pc, #428]	; (4f30 <_GLOBAL__sub_I__Z8printTabv+0x1e4>)
    4d82:	f8cd a008 	str.w	sl, [sp, #8]
    4d86:	4628      	mov	r0, r5
    4d88:	f8cd 9004 	str.w	r9, [sp, #4]
    4d8c:	9400      	str	r4, [sp, #0]
    4d8e:	f7fc fbfd 	bl	158c <NeoGroup::NeoGroup(WS2812Serial*, int, int, String, unsigned long, unsigned long)>
    4d92:	4620      	mov	r0, r4
    4d94:	f004 fba0 	bl	94d8 <String::~String()>
    4d98:	f105 06d8 	add.w	r6, r5, #216	; 0xd8
    4d9c:	4965      	ldr	r1, [pc, #404]	; (4f34 <_GLOBAL__sub_I__Z8printTabv+0x1e8>)
    4d9e:	4620      	mov	r0, r4
    4da0:	f004 fbda 	bl	9558 <String::String(char const*)>
    4da4:	2309      	movs	r3, #9
    4da6:	e88d 0610 	stmia.w	sp, {r4, r9, sl}
    4daa:	2205      	movs	r2, #5
    4dac:	4960      	ldr	r1, [pc, #384]	; (4f30 <_GLOBAL__sub_I__Z8printTabv+0x1e4>)
    4dae:	4630      	mov	r0, r6
    4db0:	f7fc fbec 	bl	158c <NeoGroup::NeoGroup(WS2812Serial*, int, int, String, unsigned long, unsigned long)>
    4db4:	4620      	mov	r0, r4
    4db6:	f004 fb8f 	bl	94d8 <String::~String()>
  uint32_t num_song_peaks[2];
*/
//////////////////////////////// Global Objects /////////////////////////
WS2812Serial leds(NUM_LED, LED_DISPLAY_MEMORY, LED_DRAWING_MEMORY, LED_PIN, WS2812_GRB);

NeoGroup neos[2] = {
    4dba:	4a5f      	ldr	r2, [pc, #380]	; (4f38 <_GLOBAL__sub_I__Z8printTabv+0x1ec>)
    4dbc:	495f      	ldr	r1, [pc, #380]	; (4f3c <_GLOBAL__sub_I__Z8printTabv+0x1f0>)
    4dbe:	2000      	movs	r0, #0
    4dc0:	f008 fe92 	bl	dae8 <__aeabi_atexit>

// lux managers to keep track of the VEML readings
LuxManager lux_managers[NUM_LUX_SENSORS] = {
  LuxManager(lux_min_reading_delay, lux_max_reading_delay, 0, (String)"Front", &neos[0]),
  LuxManager(lux_min_reading_delay, lux_max_reading_delay, 1, (String)"Rear ", &neos[1])
};
    4dc4:	f8d8 9000 	ldr.w	r9, [r8]
    4dc8:	f8d7 a000 	ldr.w	sl, [r7]
    4dcc:	4957      	ldr	r1, [pc, #348]	; (4f2c <_GLOBAL__sub_I__Z8printTabv+0x1e0>)
    4dce:	4620      	mov	r0, r4
    4dd0:	f004 fbc2 	bl	9558 <String::String(char const*)>
    4dd4:	4652      	mov	r2, sl
    4dd6:	2300      	movs	r3, #0
    4dd8:	4649      	mov	r1, r9
    4dda:	9501      	str	r5, [sp, #4]
    4ddc:	9400      	str	r4, [sp, #0]
    4dde:	4858      	ldr	r0, [pc, #352]	; (4f40 <_GLOBAL__sub_I__Z8printTabv+0x1f4>)

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
    4de0:	4d58      	ldr	r5, [pc, #352]	; (4f44 <_GLOBAL__sub_I__Z8printTabv+0x1f8>)
    4de2:	f7fd f801 	bl	1de8 <LuxManager::LuxManager(long, long, int, String, NeoGroup*)>
    4de6:	4620      	mov	r0, r4
    4de8:	f004 fb76 	bl	94d8 <String::~String()>
    4dec:	683f      	ldr	r7, [r7, #0]
    4dee:	f8d8 8000 	ldr.w	r8, [r8]
    4df2:	4955      	ldr	r1, [pc, #340]	; (4f48 <_GLOBAL__sub_I__Z8printTabv+0x1fc>)
    4df4:	4620      	mov	r0, r4
    4df6:	f004 fbaf 	bl	9558 <String::String(char const*)>
    4dfa:	2301      	movs	r3, #1
    4dfc:	463a      	mov	r2, r7
    4dfe:	4641      	mov	r1, r8
    4e00:	9601      	str	r6, [sp, #4]
    4e02:	9400      	str	r4, [sp, #0]
    4e04:	4851      	ldr	r0, [pc, #324]	; (4f4c <_GLOBAL__sub_I__Z8printTabv+0x200>)
    4e06:	f7fc ffef 	bl	1de8 <LuxManager::LuxManager(long, long, int, String, NeoGroup*)>
    4e0a:	4620      	mov	r0, r4
    4e0c:	f004 fb64 	bl	94d8 <String::~String()>
  NeoGroup(&leds, 0, (NUM_LED / 2) - 1, "Front", MIN_FLASH_TIME, MAX_FLASH_TIME),
  NeoGroup(&leds, NUM_LED / 2, NUM_LED - 1, "Rear", MIN_FLASH_TIME, MAX_FLASH_TIME)
};

// lux managers to keep track of the VEML readings
LuxManager lux_managers[NUM_LUX_SENSORS] = {
    4e10:	4a49      	ldr	r2, [pc, #292]	; (4f38 <_GLOBAL__sub_I__Z8printTabv+0x1ec>)
    4e12:	494f      	ldr	r1, [pc, #316]	; (4f50 <_GLOBAL__sub_I__Z8printTabv+0x204>)
    4e14:	2000      	movs	r0, #0
    4e16:	f008 fe67 	bl	dae8 <__aeabi_atexit>
  LuxManager(lux_min_reading_delay, lux_max_reading_delay, 0, (String)"Front", &neos[0]),
  LuxManager(lux_min_reading_delay, lux_max_reading_delay, 1, (String)"Rear ", &neos[1])
};


DLManager datalog_manager = DLManager((String)"Datalog Manager");
    4e1a:	494e      	ldr	r1, [pc, #312]	; (4f54 <_GLOBAL__sub_I__Z8printTabv+0x208>)
    4e1c:	4620      	mov	r0, r4
    4e1e:	f004 fb9b 	bl	9558 <String::String(char const*)>
    4e22:	4621      	mov	r1, r4
    4e24:	484c      	ldr	r0, [pc, #304]	; (4f58 <_GLOBAL__sub_I__Z8printTabv+0x20c>)
    4e26:	f7fb feab 	bl	b80 <DLManager::DLManager(String)>
    4e2a:	4620      	mov	r0, r4
    4e2c:	f004 fb54 	bl	94d8 <String::~String()>
    4e30:	4a41      	ldr	r2, [pc, #260]	; (4f38 <_GLOBAL__sub_I__Z8printTabv+0x1ec>)
    4e32:	494a      	ldr	r1, [pc, #296]	; (4f5c <_GLOBAL__sub_I__Z8printTabv+0x210>)
    4e34:	4848      	ldr	r0, [pc, #288]	; (4f58 <_GLOBAL__sub_I__Z8printTabv+0x20c>)
    4e36:	f008 fe57 	bl	dae8 <__aeabi_atexit>

FeatureCollector fc[4] = {FeatureCollector("front song"), FeatureCollector("rear song"), FeatureCollector("front click"), FeatureCollector("rear click")};
    4e3a:	4949      	ldr	r1, [pc, #292]	; (4f60 <_GLOBAL__sub_I__Z8printTabv+0x214>)
    4e3c:	4620      	mov	r0, r4
    4e3e:	f004 fb8b 	bl	9558 <String::String(char const*)>
    4e42:	4621      	mov	r1, r4
    4e44:	4847      	ldr	r0, [pc, #284]	; (4f64 <_GLOBAL__sub_I__Z8printTabv+0x218>)
    4e46:	f7fd fa33 	bl	22b0 <FeatureCollector::FeatureCollector(String)>
    4e4a:	4620      	mov	r0, r4
    4e4c:	f004 fb44 	bl	94d8 <String::~String()>
    4e50:	4945      	ldr	r1, [pc, #276]	; (4f68 <_GLOBAL__sub_I__Z8printTabv+0x21c>)
    4e52:	4620      	mov	r0, r4
    4e54:	f004 fb80 	bl	9558 <String::String(char const*)>
    4e58:	4621      	mov	r1, r4
    4e5a:	4844      	ldr	r0, [pc, #272]	; (4f6c <_GLOBAL__sub_I__Z8printTabv+0x220>)
    4e5c:	f7fd fa28 	bl	22b0 <FeatureCollector::FeatureCollector(String)>
    4e60:	4620      	mov	r0, r4
    4e62:	f004 fb39 	bl	94d8 <String::~String()>
    4e66:	4942      	ldr	r1, [pc, #264]	; (4f70 <_GLOBAL__sub_I__Z8printTabv+0x224>)
    4e68:	4620      	mov	r0, r4
    4e6a:	f004 fb75 	bl	9558 <String::String(char const*)>
    4e6e:	4621      	mov	r1, r4
    4e70:	4840      	ldr	r0, [pc, #256]	; (4f74 <_GLOBAL__sub_I__Z8printTabv+0x228>)
    4e72:	f7fd fa1d 	bl	22b0 <FeatureCollector::FeatureCollector(String)>
    4e76:	4620      	mov	r0, r4
    4e78:	f004 fb2e 	bl	94d8 <String::~String()>
    4e7c:	493e      	ldr	r1, [pc, #248]	; (4f78 <_GLOBAL__sub_I__Z8printTabv+0x22c>)
    4e7e:	4620      	mov	r0, r4
    4e80:	f004 fb6a 	bl	9558 <String::String(char const*)>
    4e84:	4621      	mov	r1, r4
    4e86:	483d      	ldr	r0, [pc, #244]	; (4f7c <_GLOBAL__sub_I__Z8printTabv+0x230>)
    4e88:	f7fd fa12 	bl	22b0 <FeatureCollector::FeatureCollector(String)>
    4e8c:	4620      	mov	r0, r4
    4e8e:	f004 fb23 	bl	94d8 <String::~String()>
    4e92:	4a29      	ldr	r2, [pc, #164]	; (4f38 <_GLOBAL__sub_I__Z8printTabv+0x1ec>)
    4e94:	493a      	ldr	r1, [pc, #232]	; (4f80 <_GLOBAL__sub_I__Z8printTabv+0x234>)
    4e96:	2000      	movs	r0, #0
    4e98:	f008 fe26 	bl	dae8 <__aeabi_atexit>

AutoGain auto_gain[2] = {AutoGain("Song", &fc[0], &fc[1], STARTING_SONG_GAIN, STARTING_SONG_GAIN, MAX_GAIN_ADJUSTMENT),
                         AutoGain("Click", &fc[2], &fc[3], STARTING_CLICK_GAIN, STARTING_CLICK_GAIN, MAX_GAIN_ADJUSTMENT)
                        };
    4e9c:	4939      	ldr	r1, [pc, #228]	; (4f84 <_GLOBAL__sub_I__Z8printTabv+0x238>)
    4e9e:	4620      	mov	r0, r4
    4ea0:	f004 fb5a 	bl	9558 <String::String(char const*)>
    4ea4:	4b38      	ldr	r3, [pc, #224]	; (4f88 <_GLOBAL__sub_I__Z8printTabv+0x23c>)
    4ea6:	4839      	ldr	r0, [pc, #228]	; (4f8c <_GLOBAL__sub_I__Z8printTabv+0x240>)
    4ea8:	2200      	movs	r2, #0
    4eaa:	2600      	movs	r6, #0
    4eac:	f04f 577f 	mov.w	r7, #1069547520	; 0x3fc00000
    4eb0:	4621      	mov	r1, r4
    4eb2:	e9cd 2302 	strd	r2, r3, [sp, #8]
    4eb6:	e9cd 2300 	strd	r2, r3, [sp]
    4eba:	e9cd 6704 	strd	r6, r7, [sp, #16]
    4ebe:	4b2b      	ldr	r3, [pc, #172]	; (4f6c <_GLOBAL__sub_I__Z8printTabv+0x220>)
    4ec0:	4a28      	ldr	r2, [pc, #160]	; (4f64 <_GLOBAL__sub_I__Z8printTabv+0x218>)
    4ec2:	f7fd ffa9 	bl	2e18 <AutoGain::AutoGain(String, FeatureCollector*, FeatureCollector*, double, double, double)>
    4ec6:	4620      	mov	r0, r4
    4ec8:	f004 fb06 	bl	94d8 <String::~String()>
    4ecc:	4930      	ldr	r1, [pc, #192]	; (4f90 <_GLOBAL__sub_I__Z8printTabv+0x244>)
    4ece:	4620      	mov	r0, r4
    4ed0:	f004 fb42 	bl	9558 <String::String(char const*)>
    4ed4:	4b2f      	ldr	r3, [pc, #188]	; (4f94 <_GLOBAL__sub_I__Z8printTabv+0x248>)
    4ed6:	4830      	ldr	r0, [pc, #192]	; (4f98 <_GLOBAL__sub_I__Z8printTabv+0x24c>)
    4ed8:	2200      	movs	r2, #0
    4eda:	4621      	mov	r1, r4
    4edc:	e9cd 2302 	strd	r2, r3, [sp, #8]
    4ee0:	e9cd 2300 	strd	r2, r3, [sp]
    4ee4:	e9cd 6704 	strd	r6, r7, [sp, #16]
    4ee8:	4b24      	ldr	r3, [pc, #144]	; (4f7c <_GLOBAL__sub_I__Z8printTabv+0x230>)
    4eea:	4a22      	ldr	r2, [pc, #136]	; (4f74 <_GLOBAL__sub_I__Z8printTabv+0x228>)
    4eec:	f7fd ff94 	bl	2e18 <AutoGain::AutoGain(String, FeatureCollector*, FeatureCollector*, double, double, double)>
    4ef0:	4620      	mov	r0, r4
    4ef2:	f004 faf1 	bl	94d8 <String::~String()>

DLManager datalog_manager = DLManager((String)"Datalog Manager");

FeatureCollector fc[4] = {FeatureCollector("front song"), FeatureCollector("rear song"), FeatureCollector("front click"), FeatureCollector("rear click")};

AutoGain auto_gain[2] = {AutoGain("Song", &fc[0], &fc[1], STARTING_SONG_GAIN, STARTING_SONG_GAIN, MAX_GAIN_ADJUSTMENT),
    4ef6:	4a10      	ldr	r2, [pc, #64]	; (4f38 <_GLOBAL__sub_I__Z8printTabv+0x1ec>)
    4ef8:	4928      	ldr	r1, [pc, #160]	; (4f9c <_GLOBAL__sub_I__Z8printTabv+0x250>)
    4efa:	2000      	movs	r0, #0
    4efc:	f008 fdf4 	bl	dae8 <__aeabi_atexit>
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
    4f00:	4b27      	ldr	r3, [pc, #156]	; (4fa0 <_GLOBAL__sub_I__Z8printTabv+0x254>)
    4f02:	681a      	ldr	r2, [r3, #0]

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
    4f04:	4b27      	ldr	r3, [pc, #156]	; (4fa4 <_GLOBAL__sub_I__Z8printTabv+0x258>)
    4f06:	602b      	str	r3, [r5, #0]
    4f08:	2300      	movs	r3, #0
    4f0a:	726b      	strb	r3, [r5, #9]
    4f0c:	612b      	str	r3, [r5, #16]
			active = false;
    4f0e:	722b      	strb	r3, [r5, #8]
			destination_list = NULL;
    4f10:	60eb      	str	r3, [r5, #12]
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
    4f12:	2a00      	cmp	r2, #0
    4f14:	d14b      	bne.n	4fae <_GLOBAL__sub_I__Z8printTabv+0x262>
    4f16:	f000 bd34 	b.w	5982 <_GLOBAL__sub_I__Z8printTabv+0xc36>
    4f1a:	bf00      	nop
    4f1c:	200045ec 	.word	0x200045ec
    4f20:	1fffc7a0 	.word	0x1fffc7a0
    4f24:	1ffff438 	.word	0x1ffff438
    4f28:	1fffb8d0 	.word	0x1fffb8d0
    4f2c:	00011e28 	.word	0x00011e28
    4f30:	1fffb8d4 	.word	0x1fffb8d4
    4f34:	00011e30 	.word	0x00011e30
    4f38:	1fffb874 	.word	0x1fffb874
    4f3c:	000004b5 	.word	0x000004b5
    4f40:	1fffc580 	.word	0x1fffc580
    4f44:	1ffff6d4 	.word	0x1ffff6d4
    4f48:	00011e38 	.word	0x00011e38
    4f4c:	1fffc680 	.word	0x1fffc680
    4f50:	000004d1 	.word	0x000004d1
    4f54:	00011e40 	.word	0x00011e40
    4f58:	1fffd278 	.word	0x1fffd278
    4f5c:	0000046d 	.word	0x0000046d
    4f60:	00011e50 	.word	0x00011e50
    4f64:	1ffffa30 	.word	0x1ffffa30
    4f68:	00011e5c 	.word	0x00011e5c
    4f6c:	20000b48 	.word	0x20000b48
    4f70:	00011e68 	.word	0x00011e68
    4f74:	20001c60 	.word	0x20001c60
    4f78:	00011e74 	.word	0x00011e74
    4f7c:	20002d78 	.word	0x20002d78
    4f80:	000004ed 	.word	0x000004ed
    4f84:	00011e80 	.word	0x00011e80
    4f88:	40180000 	.word	0x40180000
    4f8c:	20003fa0 	.word	0x20003fa0
    4f90:	00011e88 	.word	0x00011e88
    4f94:	402e0000 	.word	0x402e0000
    4f98:	20004018 	.word	0x20004018
    4f9c:	0000051d 	.word	0x0000051d
    4fa0:	20004598 	.word	0x20004598
    4fa4:	000105d0 	.word	0x000105d0
    4fa8:	1fffb8a4 	.word	0x1fffb8a4
				first_update = this;
			} else {
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
    4fac:	461a      	mov	r2, r3
    4fae:	6953      	ldr	r3, [r2, #20]
    4fb0:	2b00      	cmp	r3, #0
    4fb2:	d1fb      	bne.n	4fac <_GLOBAL__sub_I__Z8printTabv+0x260>
				p->next_update = this;
    4fb4:	6155      	str	r5, [r2, #20]
			}
			next_update = NULL;
    4fb6:	2700      	movs	r7, #0
#include "DMAChannel.h"

class AudioInputI2S : public AudioStream
{
public:
	AudioInputI2S(void) : AudioStream(0, NULL) { begin(); }
    4fb8:	4b9a      	ldr	r3, [pc, #616]	; (5224 <_GLOBAL__sub_I__Z8printTabv+0x4d8>)
    4fba:	489b      	ldr	r0, [pc, #620]	; (5228 <_GLOBAL__sub_I__Z8printTabv+0x4dc>)
    4fbc:	616f      	str	r7, [r5, #20]
			cpu_cycles = 0;
    4fbe:	80af      	strh	r7, [r5, #4]
			cpu_cycles_max = 0;
    4fc0:	80ef      	strh	r7, [r5, #6]
			numConnections = 0;
    4fc2:	72af      	strb	r7, [r5, #10]
    4fc4:	602b      	str	r3, [r5, #0]
    4fc6:	f001 fbc1 	bl	674c <AudioInputI2S::begin()>
};

class AudioAmplifier : public AudioStream
{
public:
	AudioAmplifier(void) : AudioStream(1, inputQueueArray), multiplier(65536) {
    4fca:	4b98      	ldr	r3, [pc, #608]	; (522c <_GLOBAL__sub_I__Z8printTabv+0x4e0>)
    4fcc:	f8df b2bc 	ldr.w	fp, [pc, #700]	; 528c <_GLOBAL__sub_I__Z8printTabv+0x540>
    4fd0:	4c97      	ldr	r4, [pc, #604]	; (5230 <_GLOBAL__sub_I__Z8printTabv+0x4e4>)
    4fd2:	f103 021c 	add.w	r2, r3, #28
    4fd6:	4618      	mov	r0, r3
    4fd8:	2101      	movs	r1, #1
    4fda:	f7fb fc05 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    4fde:	4b95      	ldr	r3, [pc, #596]	; (5234 <_GLOBAL__sub_I__Z8printTabv+0x4e8>)
    4fe0:	f103 021c 	add.w	r2, r3, #28
    4fe4:	4618      	mov	r0, r3
    4fe6:	4b91      	ldr	r3, [pc, #580]	; (522c <_GLOBAL__sub_I__Z8printTabv+0x4e0>)
    4fe8:	f44f 3680 	mov.w	r6, #65536	; 0x10000
    4fec:	2101      	movs	r1, #1
    4fee:	619e      	str	r6, [r3, #24]
    4ff0:	601c      	str	r4, [r3, #0]
    4ff2:	f7fb fbf9 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    4ff6:	4b8f      	ldr	r3, [pc, #572]	; (5234 <_GLOBAL__sub_I__Z8printTabv+0x4e8>)
    4ff8:	f10b 021c 	add.w	r2, fp, #28
    4ffc:	2101      	movs	r1, #1
    4ffe:	4658      	mov	r0, fp
    5000:	619e      	str	r6, [r3, #24]
    5002:	601c      	str	r4, [r3, #0]
    5004:	f7fb fbf0 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    5008:	4b8b      	ldr	r3, [pc, #556]	; (5238 <_GLOBAL__sub_I__Z8printTabv+0x4ec>)
    500a:	f8cb 6018 	str.w	r6, [fp, #24]
    500e:	f103 021c 	add.w	r2, r3, #28
    5012:	4618      	mov	r0, r3
    5014:	2101      	movs	r1, #1
    5016:	f8cb 4000 	str.w	r4, [fp]
    501a:	f7fb fbe5 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
#include "AudioStream.h"

class AudioFilterBiquad : public AudioStream
{
public:
	AudioFilterBiquad(void) : AudioStream(1, inputQueueArray) {
    501e:	4b87      	ldr	r3, [pc, #540]	; (523c <_GLOBAL__sub_I__Z8printTabv+0x4f0>)
    5020:	f103 0298 	add.w	r2, r3, #152	; 0x98
    5024:	4618      	mov	r0, r3
    5026:	4b84      	ldr	r3, [pc, #528]	; (5238 <_GLOBAL__sub_I__Z8printTabv+0x4ec>)
    5028:	2101      	movs	r1, #1
    502a:	619e      	str	r6, [r3, #24]
    502c:	601c      	str	r4, [r3, #0]
    502e:	f7fb fbdb 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    5032:	4b82      	ldr	r3, [pc, #520]	; (523c <_GLOBAL__sub_I__Z8printTabv+0x4f0>)
    5034:	4e82      	ldr	r6, [pc, #520]	; (5240 <_GLOBAL__sub_I__Z8printTabv+0x4f4>)
    5036:	4a81      	ldr	r2, [pc, #516]	; (523c <_GLOBAL__sub_I__Z8printTabv+0x4f0>)
    5038:	f843 6b14 	str.w	r6, [r3], #20
    503c:	3294      	adds	r2, #148	; 0x94
		// by default, the filter will not pass anything
		for (int i=0; i<32; i++) definition[i] = 0;
    503e:	f843 7f04 	str.w	r7, [r3, #4]!
    5042:	4293      	cmp	r3, r2
    5044:	d1fb      	bne.n	503e <_GLOBAL__sub_I__Z8printTabv+0x2f2>
#include "AudioStream.h"

class AudioFilterBiquad : public AudioStream
{
public:
	AudioFilterBiquad(void) : AudioStream(1, inputQueueArray) {
    5046:	4b7f      	ldr	r3, [pc, #508]	; (5244 <_GLOBAL__sub_I__Z8printTabv+0x4f8>)
    5048:	2101      	movs	r1, #1
    504a:	f103 0298 	add.w	r2, r3, #152	; 0x98
    504e:	4618      	mov	r0, r3
    5050:	f7fb fbca 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    5054:	4b7b      	ldr	r3, [pc, #492]	; (5244 <_GLOBAL__sub_I__Z8printTabv+0x4f8>)
    5056:	f103 0194 	add.w	r1, r3, #148	; 0x94
    505a:	f843 6b14 	str.w	r6, [r3], #20
		// by default, the filter will not pass anything
		for (int i=0; i<32; i++) definition[i] = 0;
    505e:	2200      	movs	r2, #0
    5060:	f843 2f04 	str.w	r2, [r3, #4]!
    5064:	428b      	cmp	r3, r1
    5066:	d1fb      	bne.n	5060 <_GLOBAL__sub_I__Z8printTabv+0x314>
#include "AudioStream.h"

class AudioFilterBiquad : public AudioStream
{
public:
	AudioFilterBiquad(void) : AudioStream(1, inputQueueArray) {
    5068:	4b77      	ldr	r3, [pc, #476]	; (5248 <_GLOBAL__sub_I__Z8printTabv+0x4fc>)
    506a:	2101      	movs	r1, #1
    506c:	f103 0298 	add.w	r2, r3, #152	; 0x98
    5070:	4618      	mov	r0, r3
    5072:	f7fb fbb9 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    5076:	4b74      	ldr	r3, [pc, #464]	; (5248 <_GLOBAL__sub_I__Z8printTabv+0x4fc>)
    5078:	f103 0194 	add.w	r1, r3, #148	; 0x94
    507c:	f843 6b14 	str.w	r6, [r3], #20
		// by default, the filter will not pass anything
		for (int i=0; i<32; i++) definition[i] = 0;
    5080:	2200      	movs	r2, #0
    5082:	f843 2f04 	str.w	r2, [r3, #4]!
    5086:	428b      	cmp	r3, r1
    5088:	d1fb      	bne.n	5082 <_GLOBAL__sub_I__Z8printTabv+0x336>
#include "AudioStream.h"

class AudioFilterBiquad : public AudioStream
{
public:
	AudioFilterBiquad(void) : AudioStream(1, inputQueueArray) {
    508a:	4b70      	ldr	r3, [pc, #448]	; (524c <_GLOBAL__sub_I__Z8printTabv+0x500>)
    508c:	2101      	movs	r1, #1
    508e:	f103 0298 	add.w	r2, r3, #152	; 0x98
    5092:	4618      	mov	r0, r3
    5094:	f7fb fba8 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    5098:	4b6c      	ldr	r3, [pc, #432]	; (524c <_GLOBAL__sub_I__Z8printTabv+0x500>)
    509a:	f103 0194 	add.w	r1, r3, #148	; 0x94
    509e:	f843 6b14 	str.w	r6, [r3], #20
		// by default, the filter will not pass anything
		for (int i=0; i<32; i++) definition[i] = 0;
    50a2:	2200      	movs	r2, #0
    50a4:	f843 2f04 	str.w	r2, [r3, #4]!
    50a8:	4299      	cmp	r1, r3
    50aa:	d1fb      	bne.n	50a4 <_GLOBAL__sub_I__Z8printTabv+0x358>
    50ac:	4b68      	ldr	r3, [pc, #416]	; (5250 <_GLOBAL__sub_I__Z8printTabv+0x504>)
    50ae:	2101      	movs	r1, #1
    50b0:	f103 021c 	add.w	r2, r3, #28
    50b4:	4618      	mov	r0, r3
    50b6:	f7fb fb97 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    50ba:	4b66      	ldr	r3, [pc, #408]	; (5254 <_GLOBAL__sub_I__Z8printTabv+0x508>)
    50bc:	f103 021c 	add.w	r2, r3, #28
    50c0:	4618      	mov	r0, r3
    50c2:	4b63      	ldr	r3, [pc, #396]	; (5250 <_GLOBAL__sub_I__Z8printTabv+0x504>)
    50c4:	f44f 3780 	mov.w	r7, #65536	; 0x10000
    50c8:	2101      	movs	r1, #1
    50ca:	601c      	str	r4, [r3, #0]
    50cc:	619f      	str	r7, [r3, #24]
    50ce:	f7fb fb8b 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    50d2:	4b61      	ldr	r3, [pc, #388]	; (5258 <_GLOBAL__sub_I__Z8printTabv+0x50c>)
    50d4:	f103 021c 	add.w	r2, r3, #28
    50d8:	4618      	mov	r0, r3
    50da:	4b5e      	ldr	r3, [pc, #376]	; (5254 <_GLOBAL__sub_I__Z8printTabv+0x508>)
    50dc:	2101      	movs	r1, #1
    50de:	601c      	str	r4, [r3, #0]
    50e0:	619f      	str	r7, [r3, #24]
    50e2:	f7fb fb81 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    50e6:	4b5d      	ldr	r3, [pc, #372]	; (525c <_GLOBAL__sub_I__Z8printTabv+0x510>)
    50e8:	f103 021c 	add.w	r2, r3, #28
    50ec:	4618      	mov	r0, r3
    50ee:	4b5a      	ldr	r3, [pc, #360]	; (5258 <_GLOBAL__sub_I__Z8printTabv+0x50c>)
    50f0:	2101      	movs	r1, #1
    50f2:	601c      	str	r4, [r3, #0]
    50f4:	619f      	str	r7, [r3, #24]
    50f6:	f7fb fb77 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
#include "AudioStream.h"

class AudioFilterBiquad : public AudioStream
{
public:
	AudioFilterBiquad(void) : AudioStream(1, inputQueueArray) {
    50fa:	4b59      	ldr	r3, [pc, #356]	; (5260 <_GLOBAL__sub_I__Z8printTabv+0x514>)
    50fc:	f103 0298 	add.w	r2, r3, #152	; 0x98
    5100:	4618      	mov	r0, r3
    5102:	4b56      	ldr	r3, [pc, #344]	; (525c <_GLOBAL__sub_I__Z8printTabv+0x510>)
    5104:	2101      	movs	r1, #1
    5106:	619f      	str	r7, [r3, #24]
    5108:	601c      	str	r4, [r3, #0]
    510a:	f7fb fb6d 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    510e:	4b54      	ldr	r3, [pc, #336]	; (5260 <_GLOBAL__sub_I__Z8printTabv+0x514>)
    5110:	f103 0194 	add.w	r1, r3, #148	; 0x94
    5114:	f843 6b14 	str.w	r6, [r3], #20
		// by default, the filter will not pass anything
		for (int i=0; i<32; i++) definition[i] = 0;
    5118:	2200      	movs	r2, #0
    511a:	f843 2f04 	str.w	r2, [r3, #4]!
    511e:	428b      	cmp	r3, r1
    5120:	d1fb      	bne.n	511a <_GLOBAL__sub_I__Z8printTabv+0x3ce>
#include "AudioStream.h"

class AudioFilterBiquad : public AudioStream
{
public:
	AudioFilterBiquad(void) : AudioStream(1, inputQueueArray) {
    5122:	4b50      	ldr	r3, [pc, #320]	; (5264 <_GLOBAL__sub_I__Z8printTabv+0x518>)
    5124:	2101      	movs	r1, #1
    5126:	f103 0298 	add.w	r2, r3, #152	; 0x98
    512a:	4618      	mov	r0, r3
    512c:	f7fb fb5c 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    5130:	4b4c      	ldr	r3, [pc, #304]	; (5264 <_GLOBAL__sub_I__Z8printTabv+0x518>)
    5132:	f103 0194 	add.w	r1, r3, #148	; 0x94
    5136:	f843 6b14 	str.w	r6, [r3], #20
		// by default, the filter will not pass anything
		for (int i=0; i<32; i++) definition[i] = 0;
    513a:	2200      	movs	r2, #0
    513c:	f843 2f04 	str.w	r2, [r3, #4]!
    5140:	4299      	cmp	r1, r3
    5142:	d1fb      	bne.n	513c <_GLOBAL__sub_I__Z8printTabv+0x3f0>
#include "AudioStream.h"

class AudioFilterBiquad : public AudioStream
{
public:
	AudioFilterBiquad(void) : AudioStream(1, inputQueueArray) {
    5144:	4b48      	ldr	r3, [pc, #288]	; (5268 <_GLOBAL__sub_I__Z8printTabv+0x51c>)
    5146:	2101      	movs	r1, #1
    5148:	f103 0298 	add.w	r2, r3, #152	; 0x98
    514c:	4618      	mov	r0, r3
    514e:	f7fb fb4b 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    5152:	4b45      	ldr	r3, [pc, #276]	; (5268 <_GLOBAL__sub_I__Z8printTabv+0x51c>)
    5154:	f103 0194 	add.w	r1, r3, #148	; 0x94
    5158:	f843 6b14 	str.w	r6, [r3], #20
		// by default, the filter will not pass anything
		for (int i=0; i<32; i++) definition[i] = 0;
    515c:	2200      	movs	r2, #0
    515e:	f843 2f04 	str.w	r2, [r3, #4]!
    5162:	4299      	cmp	r1, r3
    5164:	d1fb      	bne.n	515e <_GLOBAL__sub_I__Z8printTabv+0x412>
#include "AudioStream.h"

class AudioFilterBiquad : public AudioStream
{
public:
	AudioFilterBiquad(void) : AudioStream(1, inputQueueArray) {
    5166:	4b41      	ldr	r3, [pc, #260]	; (526c <_GLOBAL__sub_I__Z8printTabv+0x520>)
    5168:	2101      	movs	r1, #1
    516a:	f103 0298 	add.w	r2, r3, #152	; 0x98
    516e:	4618      	mov	r0, r3
    5170:	f7fb fb3a 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    5174:	4b3d      	ldr	r3, [pc, #244]	; (526c <_GLOBAL__sub_I__Z8printTabv+0x520>)
    5176:	f103 0194 	add.w	r1, r3, #148	; 0x94
    517a:	f843 6b14 	str.w	r6, [r3], #20
		// by default, the filter will not pass anything
		for (int i=0; i<32; i++) definition[i] = 0;
    517e:	2200      	movs	r2, #0
    5180:	f843 2f04 	str.w	r2, [r3, #4]!
    5184:	428b      	cmp	r3, r1
    5186:	f04f 0700 	mov.w	r7, #0
    518a:	d1f9      	bne.n	5180 <_GLOBAL__sub_I__Z8printTabv+0x434>
    518c:	4b38      	ldr	r3, [pc, #224]	; (5270 <_GLOBAL__sub_I__Z8printTabv+0x524>)

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
    518e:	f8df a0f4 	ldr.w	sl, [pc, #244]	; 5284 <_GLOBAL__sub_I__Z8printTabv+0x538>
    5192:	f103 021c 	add.w	r2, r3, #28
    5196:	4618      	mov	r0, r3
    5198:	2101      	movs	r1, #1
    519a:	f7fb fb25 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    519e:	4b35      	ldr	r3, [pc, #212]	; (5274 <_GLOBAL__sub_I__Z8printTabv+0x528>)
    51a0:	f103 021c 	add.w	r2, r3, #28
    51a4:	4618      	mov	r0, r3
    51a6:	4b32      	ldr	r3, [pc, #200]	; (5270 <_GLOBAL__sub_I__Z8printTabv+0x524>)
    51a8:	f44f 3680 	mov.w	r6, #65536	; 0x10000
    51ac:	2101      	movs	r1, #1
    51ae:	601c      	str	r4, [r3, #0]
    51b0:	619e      	str	r6, [r3, #24]
    51b2:	f7fb fb19 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    51b6:	4b30      	ldr	r3, [pc, #192]	; (5278 <_GLOBAL__sub_I__Z8printTabv+0x52c>)
    51b8:	f103 021c 	add.w	r2, r3, #28
    51bc:	4618      	mov	r0, r3
    51be:	4b2d      	ldr	r3, [pc, #180]	; (5274 <_GLOBAL__sub_I__Z8printTabv+0x528>)
    51c0:	2101      	movs	r1, #1
    51c2:	601c      	str	r4, [r3, #0]
    51c4:	619e      	str	r6, [r3, #24]
    51c6:	f7fb fb0f 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    51ca:	4b2c      	ldr	r3, [pc, #176]	; (527c <_GLOBAL__sub_I__Z8printTabv+0x530>)
    51cc:	f103 021c 	add.w	r2, r3, #28
    51d0:	4618      	mov	r0, r3
    51d2:	4b29      	ldr	r3, [pc, #164]	; (5278 <_GLOBAL__sub_I__Z8printTabv+0x52c>)
    51d4:	2101      	movs	r1, #1
    51d6:	601c      	str	r4, [r3, #0]
    51d8:	619e      	str	r6, [r3, #24]
    51da:	f7fb fb05 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    51de:	4827      	ldr	r0, [pc, #156]	; (527c <_GLOBAL__sub_I__Z8printTabv+0x530>)
			active = false;
    51e0:	f88a 7008 	strb.w	r7, [sl, #8]

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
    51e4:	2102      	movs	r1, #2
    51e6:	6004      	str	r4, [r0, #0]
    51e8:	f10a 0218 	add.w	r2, sl, #24
    51ec:	6186      	str	r6, [r0, #24]
    51ee:	4824      	ldr	r0, [pc, #144]	; (5280 <_GLOBAL__sub_I__Z8printTabv+0x534>)
    51f0:	f88a 1009 	strb.w	r1, [sl, #9]
			active = false;
			destination_list = NULL;
    51f4:	463b      	mov	r3, r7

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
    51f6:	f8ca 0000 	str.w	r0, [sl]
			active = false;
			destination_list = NULL;
    51fa:	f8ca 700c 	str.w	r7, [sl, #12]

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
    51fe:	f8ca 2010 	str.w	r2, [sl, #16]
			active = false;
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
    5202:	4639      	mov	r1, r7
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
    5204:	4654      	mov	r4, sl
    5206:	e000      	b.n	520a <_GLOBAL__sub_I__Z8printTabv+0x4be>
    5208:	6922      	ldr	r2, [r4, #16]
				inputQueue[i] = NULL;
    520a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
    520e:	f89a 2009 	ldrb.w	r2, [sl, #9]
    5212:	481c      	ldr	r0, [pc, #112]	; (5284 <_GLOBAL__sub_I__Z8printTabv+0x538>)
    5214:	3301      	adds	r3, #1
    5216:	429a      	cmp	r2, r3
    5218:	dcf6      	bgt.n	5208 <_GLOBAL__sub_I__Z8printTabv+0x4bc>
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
    521a:	4b1b      	ldr	r3, [pc, #108]	; (5288 <_GLOBAL__sub_I__Z8printTabv+0x53c>)
    521c:	681a      	ldr	r2, [r3, #0]
    521e:	bbc2      	cbnz	r2, 5292 <_GLOBAL__sub_I__Z8printTabv+0x546>
    5220:	e3b3      	b.n	598a <_GLOBAL__sub_I__Z8printTabv+0xc3e>
    5222:	bf00      	nop
    5224:	0001225c 	.word	0x0001225c
    5228:	1ffff6d4 	.word	0x1ffff6d4
    522c:	1ffff8f8 	.word	0x1ffff8f8
    5230:	00012268 	.word	0x00012268
    5234:	20003f78 	.word	0x20003f78
    5238:	1ffff918 	.word	0x1ffff918
    523c:	1ffff5e8 	.word	0x1ffff5e8
    5240:	00012250 	.word	0x00012250
    5244:	1ffff7c0 	.word	0x1ffff7c0
    5248:	1ffff85c 	.word	0x1ffff85c
    524c:	1fffc7a4 	.word	0x1fffc7a4
    5250:	1fffc780 	.word	0x1fffc780
    5254:	1ffffa10 	.word	0x1ffffa10
    5258:	1ffff958 	.word	0x1ffff958
    525c:	1ffff938 	.word	0x1ffff938
    5260:	1fffc854 	.word	0x1fffc854
    5264:	1ffff2fc 	.word	0x1ffff2fc
    5268:	1ffff398 	.word	0x1ffff398
    526c:	1fffd1b8 	.word	0x1fffd1b8
    5270:	1ffff77c 	.word	0x1ffff77c
    5274:	1ffff75c 	.word	0x1ffff75c
    5278:	1ffff998 	.word	0x1ffff998
    527c:	1ffff978 	.word	0x1ffff978
    5280:	000105d0 	.word	0x000105d0
    5284:	1ffff7a0 	.word	0x1ffff7a0
    5288:	20004598 	.word	0x20004598
    528c:	1ffff9f0 	.word	0x1ffff9f0
				first_update = this;
			} else {
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
    5290:	461a      	mov	r2, r3
    5292:	6953      	ldr	r3, [r2, #20]
    5294:	2b00      	cmp	r3, #0
    5296:	d1fb      	bne.n	5290 <_GLOBAL__sub_I__Z8printTabv+0x544>
				p->next_update = this;
    5298:	f8c2 a014 	str.w	sl, [r2, #20]
			}
			next_update = NULL;
    529c:	2700      	movs	r7, #0
};

class AudioOutputUSB : public AudioStream
{
public:
	AudioOutputUSB(void) : AudioStream(2, inputQueueArray) { begin(); }
    529e:	4b46      	ldr	r3, [pc, #280]	; (53b8 <_GLOBAL__sub_I__Z8printTabv+0x66c>)
    52a0:	4846      	ldr	r0, [pc, #280]	; (53bc <_GLOBAL__sub_I__Z8printTabv+0x670>)
    52a2:	f8ca 7014 	str.w	r7, [sl, #20]
			cpu_cycles = 0;
    52a6:	f8aa 7004 	strh.w	r7, [sl, #4]
			cpu_cycles_max = 0;
    52aa:	f8aa 7006 	strh.w	r7, [sl, #6]
			numConnections = 0;
    52ae:	f88a 700a 	strb.w	r7, [sl, #10]
    52b2:	f8ca 3000 	str.w	r3, [sl]
    52b6:	f005 f963 	bl	a580 <AudioOutputUSB::begin()>
	audio_block_t *inputQueueArray[1];
	int64_t accum;
	uint32_t count;

public:
	AudioAnalyzeRMS(void) : AudioStream(1, inputQueueArray) {
    52ba:	4b41      	ldr	r3, [pc, #260]	; (53c0 <_GLOBAL__sub_I__Z8printTabv+0x674>)
    52bc:	4c41      	ldr	r4, [pc, #260]	; (53c4 <_GLOBAL__sub_I__Z8printTabv+0x678>)
#include "AudioStream.h"

class AudioAnalyzePeak : public AudioStream
{
public:
	AudioAnalyzePeak(void) : AudioStream(1, inputQueueArray) {
    52be:	4e42      	ldr	r6, [pc, #264]	; (53c8 <_GLOBAL__sub_I__Z8printTabv+0x67c>)
    52c0:	f103 0218 	add.w	r2, r3, #24
    52c4:	4618      	mov	r0, r3
    52c6:	2101      	movs	r1, #1
    52c8:	f7fb fa8e 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    52cc:	4b3f      	ldr	r3, [pc, #252]	; (53cc <_GLOBAL__sub_I__Z8printTabv+0x680>)
    52ce:	f103 0218 	add.w	r2, r3, #24
    52d2:	4618      	mov	r0, r3
		accum = 0;
		count = 0;
    52d4:	4b3a      	ldr	r3, [pc, #232]	; (53c0 <_GLOBAL__sub_I__Z8printTabv+0x674>)
	int64_t accum;
	uint32_t count;

public:
	AudioAnalyzeRMS(void) : AudioStream(1, inputQueueArray) {
		accum = 0;
    52d6:	f04f 0800 	mov.w	r8, #0
    52da:	f04f 0900 	mov.w	r9, #0
	audio_block_t *inputQueueArray[1];
	int64_t accum;
	uint32_t count;

public:
	AudioAnalyzeRMS(void) : AudioStream(1, inputQueueArray) {
    52de:	2101      	movs	r1, #1
		accum = 0;
    52e0:	e9c3 8908 	strd	r8, r9, [r3, #32]
	audio_block_t *inputQueueArray[1];
	int64_t accum;
	uint32_t count;

public:
	AudioAnalyzeRMS(void) : AudioStream(1, inputQueueArray) {
    52e4:	601c      	str	r4, [r3, #0]
		accum = 0;
		count = 0;
    52e6:	629f      	str	r7, [r3, #40]	; 0x28
	audio_block_t *inputQueueArray[1];
	int64_t accum;
	uint32_t count;

public:
	AudioAnalyzeRMS(void) : AudioStream(1, inputQueueArray) {
    52e8:	f7fb fa7e 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    52ec:	4b38      	ldr	r3, [pc, #224]	; (53d0 <_GLOBAL__sub_I__Z8printTabv+0x684>)
    52ee:	f103 0218 	add.w	r2, r3, #24
    52f2:	4618      	mov	r0, r3
    52f4:	4b35      	ldr	r3, [pc, #212]	; (53cc <_GLOBAL__sub_I__Z8printTabv+0x680>)
    52f6:	2101      	movs	r1, #1
		accum = 0;
    52f8:	e9c3 8908 	strd	r8, r9, [r3, #32]
	audio_block_t *inputQueueArray[1];
	int64_t accum;
	uint32_t count;

public:
	AudioAnalyzeRMS(void) : AudioStream(1, inputQueueArray) {
    52fc:	601c      	str	r4, [r3, #0]
		accum = 0;
		count = 0;
    52fe:	629f      	str	r7, [r3, #40]	; 0x28
	audio_block_t *inputQueueArray[1];
	int64_t accum;
	uint32_t count;

public:
	AudioAnalyzeRMS(void) : AudioStream(1, inputQueueArray) {
    5300:	f7fb fa72 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    5304:	4b33      	ldr	r3, [pc, #204]	; (53d4 <_GLOBAL__sub_I__Z8printTabv+0x688>)
    5306:	f103 0218 	add.w	r2, r3, #24
    530a:	4618      	mov	r0, r3
    530c:	4b30      	ldr	r3, [pc, #192]	; (53d0 <_GLOBAL__sub_I__Z8printTabv+0x684>)
    530e:	2101      	movs	r1, #1
		accum = 0;
    5310:	e9c3 8908 	strd	r8, r9, [r3, #32]
	audio_block_t *inputQueueArray[1];
	int64_t accum;
	uint32_t count;

public:
	AudioAnalyzeRMS(void) : AudioStream(1, inputQueueArray) {
    5314:	601c      	str	r4, [r3, #0]
		accum = 0;
		count = 0;
    5316:	629f      	str	r7, [r3, #40]	; 0x28
	audio_block_t *inputQueueArray[1];
	int64_t accum;
	uint32_t count;

public:
	AudioAnalyzeRMS(void) : AudioStream(1, inputQueueArray) {
    5318:	f7fb fa66 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    531c:	4b2e      	ldr	r3, [pc, #184]	; (53d8 <_GLOBAL__sub_I__Z8printTabv+0x68c>)
    531e:	f103 0218 	add.w	r2, r3, #24
    5322:	4618      	mov	r0, r3
    5324:	4b2b      	ldr	r3, [pc, #172]	; (53d4 <_GLOBAL__sub_I__Z8printTabv+0x688>)
    5326:	2101      	movs	r1, #1
		accum = 0;
    5328:	e9c3 8908 	strd	r8, r9, [r3, #32]
	audio_block_t *inputQueueArray[1];
	int64_t accum;
	uint32_t count;

public:
	AudioAnalyzeRMS(void) : AudioStream(1, inputQueueArray) {
    532c:	601c      	str	r4, [r3, #0]
		accum = 0;
		count = 0;
    532e:	629f      	str	r7, [r3, #40]	; 0x28
    5330:	f7fb fa5a 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    5334:	4b29      	ldr	r3, [pc, #164]	; (53dc <_GLOBAL__sub_I__Z8printTabv+0x690>)

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
    5336:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 53e8 <_GLOBAL__sub_I__Z8printTabv+0x69c>
    533a:	f103 0218 	add.w	r2, r3, #24
    533e:	4618      	mov	r0, r3
    5340:	4b25      	ldr	r3, [pc, #148]	; (53d8 <_GLOBAL__sub_I__Z8printTabv+0x68c>)
		min_sample = 32767;
    5342:	f647 74ff 	movw	r4, #32767	; 0x7fff
		max_sample = -32768;
    5346:	f44f 4800 	mov.w	r8, #32768	; 0x8000
#include "AudioStream.h"

class AudioAnalyzePeak : public AudioStream
{
public:
	AudioAnalyzePeak(void) : AudioStream(1, inputQueueArray) {
    534a:	2101      	movs	r1, #1
		min_sample = 32767;
    534c:	83dc      	strh	r4, [r3, #30]
#include "AudioStream.h"

class AudioAnalyzePeak : public AudioStream
{
public:
	AudioAnalyzePeak(void) : AudioStream(1, inputQueueArray) {
    534e:	601e      	str	r6, [r3, #0]
		min_sample = 32767;
		max_sample = -32768;
    5350:	f8a3 8020 	strh.w	r8, [r3, #32]
#include "AudioStream.h"

class AudioAnalyzePeak : public AudioStream
{
public:
	AudioAnalyzePeak(void) : AudioStream(1, inputQueueArray) {
    5354:	f7fb fa48 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    5358:	4b21      	ldr	r3, [pc, #132]	; (53e0 <_GLOBAL__sub_I__Z8printTabv+0x694>)
    535a:	f103 0218 	add.w	r2, r3, #24
    535e:	4618      	mov	r0, r3
    5360:	4b1e      	ldr	r3, [pc, #120]	; (53dc <_GLOBAL__sub_I__Z8printTabv+0x690>)
    5362:	2101      	movs	r1, #1
		min_sample = 32767;
    5364:	83dc      	strh	r4, [r3, #30]
#include "AudioStream.h"

class AudioAnalyzePeak : public AudioStream
{
public:
	AudioAnalyzePeak(void) : AudioStream(1, inputQueueArray) {
    5366:	601e      	str	r6, [r3, #0]
		min_sample = 32767;
		max_sample = -32768;
    5368:	f8a3 8020 	strh.w	r8, [r3, #32]
#include "AudioStream.h"

class AudioAnalyzePeak : public AudioStream
{
public:
	AudioAnalyzePeak(void) : AudioStream(1, inputQueueArray) {
    536c:	f7fb fa3c 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
		min_sample = 32767;
    5370:	491b      	ldr	r1, [pc, #108]	; (53e0 <_GLOBAL__sub_I__Z8printTabv+0x694>)
			active = false;
    5372:	f889 7008 	strb.w	r7, [r9, #8]
    5376:	83cc      	strh	r4, [r1, #30]

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
    5378:	2001      	movs	r0, #1
    537a:	4c1a      	ldr	r4, [pc, #104]	; (53e4 <_GLOBAL__sub_I__Z8printTabv+0x698>)
#include "AudioStream.h"

class AudioAnalyzePeak : public AudioStream
{
public:
	AudioAnalyzePeak(void) : AudioStream(1, inputQueueArray) {
    537c:	600e      	str	r6, [r1, #0]
    537e:	f209 7224 	addw	r2, r9, #1828	; 0x724
		min_sample = 32767;
		max_sample = -32768;
    5382:	f8a1 8020 	strh.w	r8, [r1, #32]
    5386:	f8c9 4000 	str.w	r4, [r9]
			active = false;
			destination_list = NULL;
    538a:	463b      	mov	r3, r7
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
    538c:	4639      	mov	r1, r7
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
			destination_list = NULL;
    538e:	f8c9 700c 	str.w	r7, [r9, #12]

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
    5392:	f889 0009 	strb.w	r0, [r9, #9]
    5396:	f8c9 2010 	str.w	r2, [r9, #16]
			active = false;
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
    539a:	464c      	mov	r4, r9
    539c:	e000      	b.n	53a0 <_GLOBAL__sub_I__Z8printTabv+0x654>
    539e:	6922      	ldr	r2, [r4, #16]
				inputQueue[i] = NULL;
    53a0:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
    53a4:	f899 2009 	ldrb.w	r2, [r9, #9]
    53a8:	480f      	ldr	r0, [pc, #60]	; (53e8 <_GLOBAL__sub_I__Z8printTabv+0x69c>)
    53aa:	3301      	adds	r3, #1
    53ac:	429a      	cmp	r2, r3
    53ae:	dcf6      	bgt.n	539e <_GLOBAL__sub_I__Z8printTabv+0x652>
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
    53b0:	4b0e      	ldr	r3, [pc, #56]	; (53ec <_GLOBAL__sub_I__Z8printTabv+0x6a0>)
    53b2:	681a      	ldr	r2, [r3, #0]
    53b4:	b9ea      	cbnz	r2, 53f2 <_GLOBAL__sub_I__Z8printTabv+0x6a6>
    53b6:	e2ea      	b.n	598e <_GLOBAL__sub_I__Z8printTabv+0xc42>
    53b8:	000124e0 	.word	0x000124e0
    53bc:	1ffff7a0 	.word	0x1ffff7a0
    53c0:	1fffc9a8 	.word	0x1fffc9a8
    53c4:	00012044 	.word	0x00012044
    53c8:	00012038 	.word	0x00012038
    53cc:	1fffc9d8 	.word	0x1fffc9d8
    53d0:	20003ea8 	.word	0x20003ea8
    53d4:	20003ed8 	.word	0x20003ed8
    53d8:	1fffc538 	.word	0x1fffc538
    53dc:	1fffc55c 	.word	0x1fffc55c
    53e0:	20003f08 	.word	0x20003f08
    53e4:	000105d0 	.word	0x000105d0
    53e8:	1fffca6c 	.word	0x1fffca6c
    53ec:	20004598 	.word	0x20004598
				first_update = this;
			} else {
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
    53f0:	461a      	mov	r2, r3
    53f2:	6953      	ldr	r3, [r2, #20]
    53f4:	2b00      	cmp	r3, #0
    53f6:	d1fb      	bne.n	53f0 <_GLOBAL__sub_I__Z8printTabv+0x6a4>
				p->next_update = this;
    53f8:	f8c2 9014 	str.w	r9, [r2, #20]
			}
			next_update = NULL;
    53fc:	2400      	movs	r4, #0

class AudioAnalyzeFFT256 : public AudioStream
{
public:
	AudioAnalyzeFFT256() : AudioStream(1, inputQueueArray),
	  window(AudioWindowHanning256), count(0), outputflag(false) {
    53fe:	4bbb      	ldr	r3, [pc, #748]	; (56ec <_GLOBAL__sub_I__Z8printTabv+0x9a0>)
    5400:	49bb      	ldr	r1, [pc, #748]	; (56f0 <_GLOBAL__sub_I__Z8printTabv+0x9a4>)
    5402:	f8c9 3000 	str.w	r3, [r9]
		arm_cfft_radix4_init_q15(&fft_inst, 256, 0, 1);
    5406:	4622      	mov	r2, r4

class AudioAnalyzeFFT256 : public AudioStream
{
public:
	AudioAnalyzeFFT256() : AudioStream(1, inputQueueArray),
	  window(AudioWindowHanning256), count(0), outputflag(false) {
    5408:	f8c9 1118 	str.w	r1, [r9, #280]	; 0x118
    540c:	f8c9 4014 	str.w	r4, [r9, #20]
			cpu_cycles = 0;
    5410:	f8a9 4004 	strh.w	r4, [r9, #4]
			cpu_cycles_max = 0;
    5414:	f8a9 4006 	strh.w	r4, [r9, #6]
			numConnections = 0;
    5418:	f889 400a 	strb.w	r4, [r9, #10]
		arm_cfft_radix4_init_q15(&fft_inst, 256, 0, 1);
    541c:	2301      	movs	r3, #1
    541e:	f44f 7180 	mov.w	r1, #256	; 0x100
    5422:	48b4      	ldr	r0, [pc, #720]	; (56f4 <_GLOBAL__sub_I__Z8printTabv+0x9a8>)

class AudioAnalyzeFFT256 : public AudioStream
{
public:
	AudioAnalyzeFFT256() : AudioStream(1, inputQueueArray),
	  window(AudioWindowHanning256), count(0), outputflag(false) {
    5424:	f889 4721 	strb.w	r4, [r9, #1825]	; 0x721
    5428:	f889 4722 	strb.w	r4, [r9, #1826]	; 0x722
		arm_cfft_radix4_init_q15(&fft_inst, 256, 0, 1);
    542c:	f007 f808 	bl	c440 <arm_cfft_radix4_init_q15>
#include "AudioStream.h"

class AudioAnalyzePeak : public AudioStream
{
public:
	AudioAnalyzePeak(void) : AudioStream(1, inputQueueArray) {
    5430:	4bb1      	ldr	r3, [pc, #708]	; (56f8 <_GLOBAL__sub_I__Z8printTabv+0x9ac>)
#if AUDIO_BLOCK_SAMPLES == 128
		prevblock = NULL;
    5432:	f8c9 411c 	str.w	r4, [r9, #284]	; 0x11c
    5436:	f103 0218 	add.w	r2, r3, #24
    543a:	4618      	mov	r0, r3
    543c:	2101      	movs	r1, #1
		naverage = 8;
    543e:	2308      	movs	r3, #8
    5440:	f889 3720 	strb.w	r3, [r9, #1824]	; 0x720
    5444:	f7fb f9d0 	bl	7e8 <AudioStream::AudioStream(unsigned char, audio_block_struct**)>
    5448:	4bab      	ldr	r3, [pc, #684]	; (56f8 <_GLOBAL__sub_I__Z8printTabv+0x9ac>)
		  connect(); }
	AudioConnection(AudioStream &source, unsigned char sourceOutput,
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
    544a:	f8df 833c 	ldr.w	r8, [pc, #828]	; 5788 <_GLOBAL__sub_I__Z8printTabv+0xa3c>
		min_sample = 32767;
    544e:	49aa      	ldr	r1, [pc, #680]	; (56f8 <_GLOBAL__sub_I__Z8printTabv+0x9ac>)
#include "AudioStream.h"

class AudioAnalyzePeak : public AudioStream
{
public:
	AudioAnalyzePeak(void) : AudioStream(1, inputQueueArray) {
    5450:	601e      	str	r6, [r3, #0]
		min_sample = 32767;
		max_sample = -32768;
    5452:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    5456:	4fa9      	ldr	r7, [pc, #676]	; (56fc <_GLOBAL__sub_I__Z8printTabv+0x9b0>)
    5458:	840b      	strh	r3, [r1, #32]

class AudioAnalyzePeak : public AudioStream
{
public:
	AudioAnalyzePeak(void) : AudioStream(1, inputQueueArray) {
		min_sample = 32767;
    545a:	f647 72ff 	movw	r2, #32767	; 0x7fff
    545e:	4ba8      	ldr	r3, [pc, #672]	; (5700 <_GLOBAL__sub_I__Z8printTabv+0x9b4>)
    5460:	f8c8 3004 	str.w	r3, [r8, #4]
		{ isConnected = false;
		  connect(); }
    5464:	4640      	mov	r0, r8
    5466:	83ca      	strh	r2, [r1, #30]
		  connect(); }
	AudioConnection(AudioStream &source, unsigned char sourceOutput,
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
    5468:	f888 4008 	strb.w	r4, [r8, #8]
    546c:	f8c8 5000 	str.w	r5, [r8]
    5470:	f888 4009 	strb.w	r4, [r8, #9]
    5474:	f8c8 400c 	str.w	r4, [r8, #12]
		{ isConnected = false;
    5478:	f888 4010 	strb.w	r4, [r8, #16]
		  connect(); }
    547c:	f003 fc88 	bl	8d90 <AudioConnection::connect()>
AudioAnalyzePeak         song_peak2;     //xy=1631,1112
AudioAnalyzePeak         click_peak1;    //xy=1633,907
AudioAnalyzeFFT256       input_fft;       //xy=1632.5000457763672,1145.000036239624
// AudioAnalyzeFFT1024      song_fft2;       //xy=1632.5000457763672,1177.5000343322754
AudioAnalyzePeak         click_peak2;    //xy=1634,940
AudioConnection          patchCord1(i2s1, 0, click_input_amp1, 0);
    5480:	4aa0      	ldr	r2, [pc, #640]	; (5704 <_GLOBAL__sub_I__Z8printTabv+0x9b8>)
    5482:	49a1      	ldr	r1, [pc, #644]	; (5708 <_GLOBAL__sub_I__Z8printTabv+0x9bc>)
		  connect(); }
	AudioConnection(AudioStream &source, unsigned char sourceOutput,
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
    5484:	4ea1      	ldr	r6, [pc, #644]	; (570c <_GLOBAL__sub_I__Z8printTabv+0x9c0>)
    5486:	4640      	mov	r0, r8
    5488:	f008 fb2e 	bl	dae8 <__aeabi_atexit>
    548c:	4ba0      	ldr	r3, [pc, #640]	; (5710 <_GLOBAL__sub_I__Z8printTabv+0x9c4>)
    548e:	607b      	str	r3, [r7, #4]
		{ isConnected = false;
		  connect(); }
    5490:	4638      	mov	r0, r7
		  connect(); }
	AudioConnection(AudioStream &source, unsigned char sourceOutput,
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
    5492:	723c      	strb	r4, [r7, #8]
    5494:	603d      	str	r5, [r7, #0]
    5496:	727c      	strb	r4, [r7, #9]
    5498:	60fc      	str	r4, [r7, #12]
		{ isConnected = false;
    549a:	743c      	strb	r4, [r7, #16]
		  connect(); }
    549c:	f003 fc78 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord2(i2s1, 0, click_input_amp2, 0);
    54a0:	4a98      	ldr	r2, [pc, #608]	; (5704 <_GLOBAL__sub_I__Z8printTabv+0x9b8>)
    54a2:	4999      	ldr	r1, [pc, #612]	; (5708 <_GLOBAL__sub_I__Z8printTabv+0x9bc>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    54a4:	f8df 82e4 	ldr.w	r8, [pc, #740]	; 578c <_GLOBAL__sub_I__Z8printTabv+0xa40>
    54a8:	4638      	mov	r0, r7
    54aa:	f008 fb1d 	bl	dae8 <__aeabi_atexit>
		  connect(); }
	AudioConnection(AudioStream &source, unsigned char sourceOutput,
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
    54ae:	4b99      	ldr	r3, [pc, #612]	; (5714 <_GLOBAL__sub_I__Z8printTabv+0x9c8>)
    54b0:	4f99      	ldr	r7, [pc, #612]	; (5718 <_GLOBAL__sub_I__Z8printTabv+0x9cc>)
    54b2:	6073      	str	r3, [r6, #4]
		{ isConnected = false;
		  connect(); }
    54b4:	4630      	mov	r0, r6
		  connect(); }
	AudioConnection(AudioStream &source, unsigned char sourceOutput,
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
    54b6:	f04f 0301 	mov.w	r3, #1
    54ba:	7233      	strb	r3, [r6, #8]
    54bc:	7274      	strb	r4, [r6, #9]
    54be:	6035      	str	r5, [r6, #0]
    54c0:	60f4      	str	r4, [r6, #12]
		{ isConnected = false;
    54c2:	7434      	strb	r4, [r6, #16]
		  connect(); }
    54c4:	f003 fc64 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord3(i2s1, 1, song_input_amp1, 0);
    54c8:	4a8e      	ldr	r2, [pc, #568]	; (5704 <_GLOBAL__sub_I__Z8printTabv+0x9b8>)
    54ca:	498f      	ldr	r1, [pc, #572]	; (5708 <_GLOBAL__sub_I__Z8printTabv+0x9bc>)
    54cc:	4630      	mov	r0, r6
    54ce:	f008 fb0b 	bl	dae8 <__aeabi_atexit>
		  connect(); }
	AudioConnection(AudioStream &source, unsigned char sourceOutput,
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
    54d2:	f04f 0301 	mov.w	r3, #1
		{ isConnected = false;
		  connect(); }
    54d6:	4638      	mov	r0, r7
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    54d8:	4e90      	ldr	r6, [pc, #576]	; (571c <_GLOBAL__sub_I__Z8printTabv+0x9d0>)
		  connect(); }
	AudioConnection(AudioStream &source, unsigned char sourceOutput,
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
    54da:	723b      	strb	r3, [r7, #8]
    54dc:	e887 0820 	stmia.w	r7, {r5, fp}
    54e0:	727c      	strb	r4, [r7, #9]
    54e2:	60fc      	str	r4, [r7, #12]
		{ isConnected = false;
    54e4:	743c      	strb	r4, [r7, #16]
		  connect(); }
    54e6:	f003 fc53 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord4(i2s1, 1, song_input_amp2, 0);
    54ea:	4a86      	ldr	r2, [pc, #536]	; (5704 <_GLOBAL__sub_I__Z8printTabv+0x9b8>)
    54ec:	4986      	ldr	r1, [pc, #536]	; (5708 <_GLOBAL__sub_I__Z8printTabv+0x9bc>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    54ee:	4d8c      	ldr	r5, [pc, #560]	; (5720 <_GLOBAL__sub_I__Z8printTabv+0x9d4>)
    54f0:	4638      	mov	r0, r7
    54f2:	f008 faf9 	bl	dae8 <__aeabi_atexit>
    54f6:	4b82      	ldr	r3, [pc, #520]	; (5700 <_GLOBAL__sub_I__Z8printTabv+0x9b4>)
    54f8:	6033      	str	r3, [r6, #0]
		{ isConnected = false;
		  connect(); }
    54fa:	4630      	mov	r0, r6
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    54fc:	4b89      	ldr	r3, [pc, #548]	; (5724 <_GLOBAL__sub_I__Z8printTabv+0x9d8>)
    54fe:	6073      	str	r3, [r6, #4]
    5500:	7234      	strb	r4, [r6, #8]
    5502:	7274      	strb	r4, [r6, #9]
    5504:	60f4      	str	r4, [r6, #12]
		{ isConnected = false;
    5506:	7434      	strb	r4, [r6, #16]
		  connect(); }
    5508:	f003 fc42 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord5(click_input_amp1, click_biquad1);
    550c:	4a7d      	ldr	r2, [pc, #500]	; (5704 <_GLOBAL__sub_I__Z8printTabv+0x9b8>)
    550e:	497e      	ldr	r1, [pc, #504]	; (5708 <_GLOBAL__sub_I__Z8printTabv+0x9bc>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    5510:	4f85      	ldr	r7, [pc, #532]	; (5728 <_GLOBAL__sub_I__Z8printTabv+0x9dc>)
    5512:	4630      	mov	r0, r6
    5514:	f008 fae8 	bl	dae8 <__aeabi_atexit>
    5518:	4b7e      	ldr	r3, [pc, #504]	; (5714 <_GLOBAL__sub_I__Z8printTabv+0x9c8>)
    551a:	4e84      	ldr	r6, [pc, #528]	; (572c <_GLOBAL__sub_I__Z8printTabv+0x9e0>)
    551c:	602b      	str	r3, [r5, #0]
		{ isConnected = false;
		  connect(); }
    551e:	4628      	mov	r0, r5
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    5520:	4b83      	ldr	r3, [pc, #524]	; (5730 <_GLOBAL__sub_I__Z8printTabv+0x9e4>)
    5522:	606b      	str	r3, [r5, #4]
    5524:	722c      	strb	r4, [r5, #8]
    5526:	726c      	strb	r4, [r5, #9]
    5528:	60ec      	str	r4, [r5, #12]
		{ isConnected = false;
    552a:	742c      	strb	r4, [r5, #16]
		  connect(); }
    552c:	f003 fc30 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord6(song_input_amp1, song_biquad1);
    5530:	4a74      	ldr	r2, [pc, #464]	; (5704 <_GLOBAL__sub_I__Z8printTabv+0x9b8>)
    5532:	4975      	ldr	r1, [pc, #468]	; (5708 <_GLOBAL__sub_I__Z8printTabv+0x9bc>)
    5534:	4628      	mov	r0, r5
    5536:	f008 fad7 	bl	dae8 <__aeabi_atexit>
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    553a:	4b7e      	ldr	r3, [pc, #504]	; (5734 <_GLOBAL__sub_I__Z8printTabv+0x9e8>)
    553c:	4d7e      	ldr	r5, [pc, #504]	; (5738 <_GLOBAL__sub_I__Z8printTabv+0x9ec>)
    553e:	6073      	str	r3, [r6, #4]
		{ isConnected = false;
		  connect(); }
    5540:	4630      	mov	r0, r6
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    5542:	7234      	strb	r4, [r6, #8]
    5544:	f8c6 b000 	str.w	fp, [r6]
    5548:	7274      	strb	r4, [r6, #9]
    554a:	60f4      	str	r4, [r6, #12]
		{ isConnected = false;
    554c:	7434      	strb	r4, [r6, #16]
		  connect(); }
    554e:	f003 fc1f 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord7(song_input_amp2, song_biquad2);
    5552:	4a6c      	ldr	r2, [pc, #432]	; (5704 <_GLOBAL__sub_I__Z8printTabv+0x9b8>)
    5554:	496c      	ldr	r1, [pc, #432]	; (5708 <_GLOBAL__sub_I__Z8printTabv+0x9bc>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    5556:	f8df b238 	ldr.w	fp, [pc, #568]	; 5790 <_GLOBAL__sub_I__Z8printTabv+0xa44>
    555a:	4630      	mov	r0, r6
    555c:	f008 fac4 	bl	dae8 <__aeabi_atexit>
    5560:	4b6b      	ldr	r3, [pc, #428]	; (5710 <_GLOBAL__sub_I__Z8printTabv+0x9c4>)
    5562:	602b      	str	r3, [r5, #0]
		{ isConnected = false;
		  connect(); }
    5564:	4628      	mov	r0, r5
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    5566:	4b75      	ldr	r3, [pc, #468]	; (573c <_GLOBAL__sub_I__Z8printTabv+0x9f0>)
    5568:	722c      	strb	r4, [r5, #8]
    556a:	606b      	str	r3, [r5, #4]
    556c:	726c      	strb	r4, [r5, #9]
    556e:	60ec      	str	r4, [r5, #12]
		{ isConnected = false;
    5570:	742c      	strb	r4, [r5, #16]
		  connect(); }
    5572:	f003 fc0d 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord8(click_input_amp2, click_biquad2);
    5576:	4a63      	ldr	r2, [pc, #396]	; (5704 <_GLOBAL__sub_I__Z8printTabv+0x9b8>)
    5578:	4963      	ldr	r1, [pc, #396]	; (5708 <_GLOBAL__sub_I__Z8printTabv+0x9bc>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    557a:	4b71      	ldr	r3, [pc, #452]	; (5740 <_GLOBAL__sub_I__Z8printTabv+0x9f4>)
    557c:	9307      	str	r3, [sp, #28]
    557e:	4628      	mov	r0, r5
    5580:	f008 fab2 	bl	dae8 <__aeabi_atexit>
    5584:	4b6d      	ldr	r3, [pc, #436]	; (573c <_GLOBAL__sub_I__Z8printTabv+0x9f0>)
    5586:	f8c8 3000 	str.w	r3, [r8]
		{ isConnected = false;
		  connect(); }
    558a:	4640      	mov	r0, r8
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    558c:	4b6d      	ldr	r3, [pc, #436]	; (5744 <_GLOBAL__sub_I__Z8printTabv+0x9f8>)
    558e:	f8c8 3004 	str.w	r3, [r8, #4]
    5592:	f888 4008 	strb.w	r4, [r8, #8]
    5596:	f888 4009 	strb.w	r4, [r8, #9]
    559a:	f8c8 400c 	str.w	r4, [r8, #12]
		{ isConnected = false;
    559e:	f888 4010 	strb.w	r4, [r8, #16]
		  connect(); }
    55a2:	f003 fbf5 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord9(click_biquad2, click_mid_amp2);
    55a6:	4a57      	ldr	r2, [pc, #348]	; (5704 <_GLOBAL__sub_I__Z8printTabv+0x9b8>)
    55a8:	4957      	ldr	r1, [pc, #348]	; (5708 <_GLOBAL__sub_I__Z8printTabv+0x9bc>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    55aa:	4e67      	ldr	r6, [pc, #412]	; (5748 <_GLOBAL__sub_I__Z8printTabv+0x9fc>)
    55ac:	4d67      	ldr	r5, [pc, #412]	; (574c <_GLOBAL__sub_I__Z8printTabv+0xa00>)
    55ae:	4640      	mov	r0, r8
    55b0:	f008 fa9a 	bl	dae8 <__aeabi_atexit>
    55b4:	4b5f      	ldr	r3, [pc, #380]	; (5734 <_GLOBAL__sub_I__Z8printTabv+0x9e8>)
    55b6:	603b      	str	r3, [r7, #0]
		{ isConnected = false;
		  connect(); }
    55b8:	4638      	mov	r0, r7
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    55ba:	4b65      	ldr	r3, [pc, #404]	; (5750 <_GLOBAL__sub_I__Z8printTabv+0xa04>)
    55bc:	607b      	str	r3, [r7, #4]
    55be:	723c      	strb	r4, [r7, #8]
    55c0:	727c      	strb	r4, [r7, #9]
    55c2:	60fc      	str	r4, [r7, #12]
		{ isConnected = false;
    55c4:	743c      	strb	r4, [r7, #16]
		  connect(); }
    55c6:	f003 fbe3 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord10(song_biquad2, song_mid_amp2);
    55ca:	4a4e      	ldr	r2, [pc, #312]	; (5704 <_GLOBAL__sub_I__Z8printTabv+0x9b8>)
    55cc:	494e      	ldr	r1, [pc, #312]	; (5708 <_GLOBAL__sub_I__Z8printTabv+0x9bc>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    55ce:	f8df 81c4 	ldr.w	r8, [pc, #452]	; 5794 <_GLOBAL__sub_I__Z8printTabv+0xa48>
    55d2:	4638      	mov	r0, r7
    55d4:	f008 fa88 	bl	dae8 <__aeabi_atexit>
    55d8:	4b52      	ldr	r3, [pc, #328]	; (5724 <_GLOBAL__sub_I__Z8printTabv+0x9d8>)
    55da:	6033      	str	r3, [r6, #0]
		{ isConnected = false;
		  connect(); }
    55dc:	4630      	mov	r0, r6
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    55de:	4b5d      	ldr	r3, [pc, #372]	; (5754 <_GLOBAL__sub_I__Z8printTabv+0xa08>)
    55e0:	6073      	str	r3, [r6, #4]
    55e2:	7234      	strb	r4, [r6, #8]
    55e4:	7274      	strb	r4, [r6, #9]
    55e6:	60f4      	str	r4, [r6, #12]
		{ isConnected = false;
    55e8:	7434      	strb	r4, [r6, #16]
		  connect(); }
    55ea:	f003 fbd1 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord11(click_biquad1, click_mid_amp1);
    55ee:	4a45      	ldr	r2, [pc, #276]	; (5704 <_GLOBAL__sub_I__Z8printTabv+0x9b8>)
    55f0:	4945      	ldr	r1, [pc, #276]	; (5708 <_GLOBAL__sub_I__Z8printTabv+0x9bc>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    55f2:	4f59      	ldr	r7, [pc, #356]	; (5758 <_GLOBAL__sub_I__Z8printTabv+0xa0c>)
    55f4:	4630      	mov	r0, r6
    55f6:	f008 fa77 	bl	dae8 <__aeabi_atexit>
    55fa:	4b4d      	ldr	r3, [pc, #308]	; (5730 <_GLOBAL__sub_I__Z8printTabv+0x9e4>)
    55fc:	602b      	str	r3, [r5, #0]
		{ isConnected = false;
		  connect(); }
    55fe:	4628      	mov	r0, r5
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    5600:	4b56      	ldr	r3, [pc, #344]	; (575c <_GLOBAL__sub_I__Z8printTabv+0xa10>)
    5602:	606b      	str	r3, [r5, #4]
    5604:	722c      	strb	r4, [r5, #8]
    5606:	726c      	strb	r4, [r5, #9]
    5608:	60ec      	str	r4, [r5, #12]
		{ isConnected = false;
    560a:	742c      	strb	r4, [r5, #16]
		  connect(); }
    560c:	f003 fbc0 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord12(song_biquad1, song_mid_amp1);
    5610:	493d      	ldr	r1, [pc, #244]	; (5708 <_GLOBAL__sub_I__Z8printTabv+0x9bc>)
    5612:	4a3c      	ldr	r2, [pc, #240]	; (5704 <_GLOBAL__sub_I__Z8printTabv+0x9b8>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    5614:	4e52      	ldr	r6, [pc, #328]	; (5760 <_GLOBAL__sub_I__Z8printTabv+0xa14>)
    5616:	4628      	mov	r0, r5
    5618:	f008 fa66 	bl	dae8 <__aeabi_atexit>
		{ isConnected = false;
		  connect(); }
    561c:	9b07      	ldr	r3, [sp, #28]
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    561e:	4a49      	ldr	r2, [pc, #292]	; (5744 <_GLOBAL__sub_I__Z8printTabv+0x9f8>)
    5620:	601a      	str	r2, [r3, #0]
		{ isConnected = false;
		  connect(); }
    5622:	4618      	mov	r0, r3
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    5624:	4a4f      	ldr	r2, [pc, #316]	; (5764 <_GLOBAL__sub_I__Z8printTabv+0xa18>)
    5626:	721c      	strb	r4, [r3, #8]
    5628:	605a      	str	r2, [r3, #4]
    562a:	725c      	strb	r4, [r3, #9]
    562c:	60dc      	str	r4, [r3, #12]
		{ isConnected = false;
    562e:	741c      	strb	r4, [r3, #16]
		  connect(); }
    5630:	f003 fbae 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord13(click_mid_amp2, click_biquad21);
    5634:	9b07      	ldr	r3, [sp, #28]
    5636:	4a33      	ldr	r2, [pc, #204]	; (5704 <_GLOBAL__sub_I__Z8printTabv+0x9b8>)
    5638:	4933      	ldr	r1, [pc, #204]	; (5708 <_GLOBAL__sub_I__Z8printTabv+0x9bc>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    563a:	4d4b      	ldr	r5, [pc, #300]	; (5768 <_GLOBAL__sub_I__Z8printTabv+0xa1c>)
    563c:	4618      	mov	r0, r3
    563e:	4b4b      	ldr	r3, [pc, #300]	; (576c <_GLOBAL__sub_I__Z8printTabv+0xa20>)
    5640:	9307      	str	r3, [sp, #28]
    5642:	f008 fa51 	bl	dae8 <__aeabi_atexit>
    5646:	4b43      	ldr	r3, [pc, #268]	; (5754 <_GLOBAL__sub_I__Z8printTabv+0xa08>)
    5648:	f8cb 3000 	str.w	r3, [fp]
		{ isConnected = false;
		  connect(); }
    564c:	4658      	mov	r0, fp
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    564e:	4b48      	ldr	r3, [pc, #288]	; (5770 <_GLOBAL__sub_I__Z8printTabv+0xa24>)
    5650:	f8cb 3004 	str.w	r3, [fp, #4]
    5654:	f88b 4008 	strb.w	r4, [fp, #8]
    5658:	f88b 4009 	strb.w	r4, [fp, #9]
    565c:	f8cb 400c 	str.w	r4, [fp, #12]
		{ isConnected = false;
    5660:	f88b 4010 	strb.w	r4, [fp, #16]
		  connect(); }
    5664:	f003 fb94 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord14(click_mid_amp1, click_biquad11);
    5668:	4927      	ldr	r1, [pc, #156]	; (5708 <_GLOBAL__sub_I__Z8printTabv+0x9bc>)
    566a:	4a26      	ldr	r2, [pc, #152]	; (5704 <_GLOBAL__sub_I__Z8printTabv+0x9b8>)
    566c:	4658      	mov	r0, fp
    566e:	f008 fa3b 	bl	dae8 <__aeabi_atexit>
    5672:	4840      	ldr	r0, [pc, #256]	; (5774 <_GLOBAL__sub_I__Z8printTabv+0xa28>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    5674:	4a36      	ldr	r2, [pc, #216]	; (5750 <_GLOBAL__sub_I__Z8printTabv+0xa04>)
    5676:	6002      	str	r2, [r0, #0]
    5678:	4a3f      	ldr	r2, [pc, #252]	; (5778 <_GLOBAL__sub_I__Z8printTabv+0xa2c>)
    567a:	7204      	strb	r4, [r0, #8]
    567c:	6042      	str	r2, [r0, #4]
    567e:	7244      	strb	r4, [r0, #9]
    5680:	60c4      	str	r4, [r0, #12]
		{ isConnected = false;
    5682:	7404      	strb	r4, [r0, #16]
		  connect(); }
    5684:	f003 fb84 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord15(song_mid_amp2, song_biquad21);
    5688:	491f      	ldr	r1, [pc, #124]	; (5708 <_GLOBAL__sub_I__Z8printTabv+0x9bc>)
    568a:	4a1e      	ldr	r2, [pc, #120]	; (5704 <_GLOBAL__sub_I__Z8printTabv+0x9b8>)
    568c:	4839      	ldr	r0, [pc, #228]	; (5774 <_GLOBAL__sub_I__Z8printTabv+0xa28>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    568e:	f8df b108 	ldr.w	fp, [pc, #264]	; 5798 <_GLOBAL__sub_I__Z8printTabv+0xa4c>
    5692:	f008 fa29 	bl	dae8 <__aeabi_atexit>
		{ isConnected = false;
		  connect(); }
    5696:	4839      	ldr	r0, [pc, #228]	; (577c <_GLOBAL__sub_I__Z8printTabv+0xa30>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    5698:	4a30      	ldr	r2, [pc, #192]	; (575c <_GLOBAL__sub_I__Z8printTabv+0xa10>)
    569a:	6002      	str	r2, [r0, #0]
    569c:	4a38      	ldr	r2, [pc, #224]	; (5780 <_GLOBAL__sub_I__Z8printTabv+0xa34>)
    569e:	7204      	strb	r4, [r0, #8]
    56a0:	6042      	str	r2, [r0, #4]
    56a2:	7244      	strb	r4, [r0, #9]
    56a4:	60c4      	str	r4, [r0, #12]
		{ isConnected = false;
    56a6:	7404      	strb	r4, [r0, #16]
		  connect(); }
    56a8:	f003 fb72 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord16(song_mid_amp1, song_biquad11);
    56ac:	4a15      	ldr	r2, [pc, #84]	; (5704 <_GLOBAL__sub_I__Z8printTabv+0x9b8>)
    56ae:	4916      	ldr	r1, [pc, #88]	; (5708 <_GLOBAL__sub_I__Z8printTabv+0x9bc>)
    56b0:	4832      	ldr	r0, [pc, #200]	; (577c <_GLOBAL__sub_I__Z8printTabv+0xa30>)
    56b2:	f008 fa19 	bl	dae8 <__aeabi_atexit>
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    56b6:	4b32      	ldr	r3, [pc, #200]	; (5780 <_GLOBAL__sub_I__Z8printTabv+0xa34>)
    56b8:	f8c8 3000 	str.w	r3, [r8]
		{ isConnected = false;
		  connect(); }
    56bc:	4640      	mov	r0, r8
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    56be:	4b31      	ldr	r3, [pc, #196]	; (5784 <_GLOBAL__sub_I__Z8printTabv+0xa38>)
    56c0:	f8c8 3004 	str.w	r3, [r8, #4]
    56c4:	f888 4008 	strb.w	r4, [r8, #8]
    56c8:	f888 4009 	strb.w	r4, [r8, #9]
    56cc:	f8c8 400c 	str.w	r4, [r8, #12]
		{ isConnected = false;
    56d0:	f888 4010 	strb.w	r4, [r8, #16]
		  connect(); }
    56d4:	f003 fb5c 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord17(song_biquad11, song_post_amp1);
    56d8:	4a0a      	ldr	r2, [pc, #40]	; (5704 <_GLOBAL__sub_I__Z8printTabv+0x9b8>)
    56da:	490b      	ldr	r1, [pc, #44]	; (5708 <_GLOBAL__sub_I__Z8printTabv+0x9bc>)
    56dc:	4640      	mov	r0, r8
    56de:	f008 fa03 	bl	dae8 <__aeabi_atexit>
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    56e2:	4b20      	ldr	r3, [pc, #128]	; (5764 <_GLOBAL__sub_I__Z8printTabv+0xa18>)
    56e4:	603b      	str	r3, [r7, #0]
		{ isConnected = false;
		  connect(); }
    56e6:	4638      	mov	r0, r7
    56e8:	e058      	b.n	579c <_GLOBAL__sub_I__Z8printTabv+0xa50>
    56ea:	bf00      	nop
    56ec:	0001202c 	.word	0x0001202c
    56f0:	00012048 	.word	0x00012048
    56f4:	1fffd194 	.word	0x1fffd194
    56f8:	20003f2c 	.word	0x20003f2c
    56fc:	1fffc8f4 	.word	0x1fffc8f4
    5700:	1ffff8f8 	.word	0x1ffff8f8
    5704:	1fffb874 	.word	0x1fffb874
    5708:	00000549 	.word	0x00000549
    570c:	1fffc908 	.word	0x1fffc908
    5710:	1ffff918 	.word	0x1ffff918
    5714:	20003f78 	.word	0x20003f78
    5718:	1fffc91c 	.word	0x1fffc91c
    571c:	1fffc930 	.word	0x1fffc930
    5720:	1fffc944 	.word	0x1fffc944
    5724:	1ffff85c 	.word	0x1ffff85c
    5728:	1fffc96c 	.word	0x1fffc96c
    572c:	1fffc958 	.word	0x1fffc958
    5730:	1fffc7a4 	.word	0x1fffc7a4
    5734:	1ffff7c0 	.word	0x1ffff7c0
    5738:	1fffd254 	.word	0x1fffd254
    573c:	1ffff5e8 	.word	0x1ffff5e8
    5740:	1ffff9cc 	.word	0x1ffff9cc
    5744:	1fffc780 	.word	0x1fffc780
    5748:	1ffff9b8 	.word	0x1ffff9b8
    574c:	1fffc994 	.word	0x1fffc994
    5750:	1ffff958 	.word	0x1ffff958
    5754:	1ffffa10 	.word	0x1ffffa10
    5758:	1fffca44 	.word	0x1fffca44
    575c:	1ffff938 	.word	0x1ffff938
    5760:	1fffca58 	.word	0x1fffca58
    5764:	1ffff2fc 	.word	0x1ffff2fc
    5768:	1ffff684 	.word	0x1ffff684
    576c:	1ffff6ac 	.word	0x1ffff6ac
    5770:	1fffd1b8 	.word	0x1fffd1b8
    5774:	1fffca08 	.word	0x1fffca08
    5778:	1ffff398 	.word	0x1ffff398
    577c:	1fffca1c 	.word	0x1fffca1c
    5780:	1fffc854 	.word	0x1fffc854
    5784:	1ffff978 	.word	0x1ffff978
    5788:	1fffd1a4 	.word	0x1fffd1a4
    578c:	1fffc980 	.word	0x1fffc980
    5790:	1fffc840 	.word	0x1fffc840
    5794:	1fffca30 	.word	0x1fffca30
    5798:	20004090 	.word	0x20004090
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    579c:	4b7d      	ldr	r3, [pc, #500]	; (5994 <_GLOBAL__sub_I__Z8printTabv+0xc48>)
    579e:	607b      	str	r3, [r7, #4]
    57a0:	723c      	strb	r4, [r7, #8]
    57a2:	727c      	strb	r4, [r7, #9]
    57a4:	60fc      	str	r4, [r7, #12]
		{ isConnected = false;
    57a6:	743c      	strb	r4, [r7, #16]
		  connect(); }
    57a8:	f003 faf2 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord18(click_biquad21, click_post_amp2);
    57ac:	4a7a      	ldr	r2, [pc, #488]	; (5998 <_GLOBAL__sub_I__Z8printTabv+0xc4c>)
    57ae:	497b      	ldr	r1, [pc, #492]	; (599c <_GLOBAL__sub_I__Z8printTabv+0xc50>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    57b0:	f8df 8250 	ldr.w	r8, [pc, #592]	; 5a04 <_GLOBAL__sub_I__Z8printTabv+0xcb8>
    57b4:	4638      	mov	r0, r7
    57b6:	f008 f997 	bl	dae8 <__aeabi_atexit>
    57ba:	4b79      	ldr	r3, [pc, #484]	; (59a0 <_GLOBAL__sub_I__Z8printTabv+0xc54>)
    57bc:	6033      	str	r3, [r6, #0]
		{ isConnected = false;
		  connect(); }
    57be:	4630      	mov	r0, r6
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    57c0:	4b78      	ldr	r3, [pc, #480]	; (59a4 <_GLOBAL__sub_I__Z8printTabv+0xc58>)
    57c2:	6073      	str	r3, [r6, #4]
    57c4:	7234      	strb	r4, [r6, #8]
    57c6:	7274      	strb	r4, [r6, #9]
    57c8:	60f4      	str	r4, [r6, #12]
		{ isConnected = false;
    57ca:	7434      	strb	r4, [r6, #16]
		  connect(); }
    57cc:	f003 fae0 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord19(song_biquad21, song_post_amp2);
    57d0:	4a71      	ldr	r2, [pc, #452]	; (5998 <_GLOBAL__sub_I__Z8printTabv+0xc4c>)
    57d2:	4972      	ldr	r1, [pc, #456]	; (599c <_GLOBAL__sub_I__Z8printTabv+0xc50>)
    57d4:	4630      	mov	r0, r6
    57d6:	f008 f987 	bl	dae8 <__aeabi_atexit>
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    57da:	4b73      	ldr	r3, [pc, #460]	; (59a8 <_GLOBAL__sub_I__Z8printTabv+0xc5c>)
    57dc:	602b      	str	r3, [r5, #0]
		{ isConnected = false;
		  connect(); }
    57de:	4628      	mov	r0, r5
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    57e0:	4b72      	ldr	r3, [pc, #456]	; (59ac <_GLOBAL__sub_I__Z8printTabv+0xc60>)
    57e2:	606b      	str	r3, [r5, #4]
    57e4:	722c      	strb	r4, [r5, #8]
    57e6:	726c      	strb	r4, [r5, #9]
    57e8:	60ec      	str	r4, [r5, #12]
		{ isConnected = false;
    57ea:	742c      	strb	r4, [r5, #16]
		  connect(); }
    57ec:	f003 fad0 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord20(click_biquad11, click_post_amp1);
    57f0:	496a      	ldr	r1, [pc, #424]	; (599c <_GLOBAL__sub_I__Z8printTabv+0xc50>)
    57f2:	4a69      	ldr	r2, [pc, #420]	; (5998 <_GLOBAL__sub_I__Z8printTabv+0xc4c>)
    57f4:	4628      	mov	r0, r5
    57f6:	f008 f977 	bl	dae8 <__aeabi_atexit>
    57fa:	486d      	ldr	r0, [pc, #436]	; (59b0 <_GLOBAL__sub_I__Z8printTabv+0xc64>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    57fc:	4a65      	ldr	r2, [pc, #404]	; (5994 <_GLOBAL__sub_I__Z8printTabv+0xc48>)
    57fe:	6002      	str	r2, [r0, #0]
    5800:	4a6c      	ldr	r2, [pc, #432]	; (59b4 <_GLOBAL__sub_I__Z8printTabv+0xc68>)
    5802:	7204      	strb	r4, [r0, #8]
    5804:	6042      	str	r2, [r0, #4]
    5806:	7244      	strb	r4, [r0, #9]
    5808:	60c4      	str	r4, [r0, #12]
		{ isConnected = false;
    580a:	7404      	strb	r4, [r0, #16]
		  connect(); }
    580c:	f003 fac0 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord21(click_post_amp2, click_rms2);
    5810:	4962      	ldr	r1, [pc, #392]	; (599c <_GLOBAL__sub_I__Z8printTabv+0xc50>)
    5812:	4a61      	ldr	r2, [pc, #388]	; (5998 <_GLOBAL__sub_I__Z8printTabv+0xc4c>)
    5814:	4866      	ldr	r0, [pc, #408]	; (59b0 <_GLOBAL__sub_I__Z8printTabv+0xc64>)
    5816:	f008 f967 	bl	dae8 <__aeabi_atexit>
    581a:	9b07      	ldr	r3, [sp, #28]
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    581c:	4a66      	ldr	r2, [pc, #408]	; (59b8 <_GLOBAL__sub_I__Z8printTabv+0xc6c>)
    581e:	605a      	str	r2, [r3, #4]
		{ isConnected = false;
		  connect(); }
    5820:	4618      	mov	r0, r3
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    5822:	4a5c      	ldr	r2, [pc, #368]	; (5994 <_GLOBAL__sub_I__Z8printTabv+0xc48>)
    5824:	601a      	str	r2, [r3, #0]
    5826:	721c      	strb	r4, [r3, #8]
    5828:	725c      	strb	r4, [r3, #9]
    582a:	60dc      	str	r4, [r3, #12]
		{ isConnected = false;
    582c:	741c      	strb	r4, [r3, #16]
		  connect(); }
    582e:	f003 faaf 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord22(click_post_amp2, click_peak2);
    5832:	9b07      	ldr	r3, [sp, #28]
    5834:	4959      	ldr	r1, [pc, #356]	; (599c <_GLOBAL__sub_I__Z8printTabv+0xc50>)
    5836:	4a58      	ldr	r2, [pc, #352]	; (5998 <_GLOBAL__sub_I__Z8printTabv+0xc4c>)
    5838:	4618      	mov	r0, r3
    583a:	f008 f955 	bl	dae8 <__aeabi_atexit>
    583e:	485f      	ldr	r0, [pc, #380]	; (59bc <_GLOBAL__sub_I__Z8printTabv+0xc70>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    5840:	4a5a      	ldr	r2, [pc, #360]	; (59ac <_GLOBAL__sub_I__Z8printTabv+0xc60>)
    5842:	6002      	str	r2, [r0, #0]
    5844:	4a5e      	ldr	r2, [pc, #376]	; (59c0 <_GLOBAL__sub_I__Z8printTabv+0xc74>)
    5846:	7204      	strb	r4, [r0, #8]
    5848:	6042      	str	r2, [r0, #4]
    584a:	7244      	strb	r4, [r0, #9]
    584c:	60c4      	str	r4, [r0, #12]
		{ isConnected = false;
    584e:	7404      	strb	r4, [r0, #16]
		  connect(); }
    5850:	f003 fa9e 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord23(click_post_amp1, click_rms1);
    5854:	4a50      	ldr	r2, [pc, #320]	; (5998 <_GLOBAL__sub_I__Z8printTabv+0xc4c>)
    5856:	4951      	ldr	r1, [pc, #324]	; (599c <_GLOBAL__sub_I__Z8printTabv+0xc50>)
    5858:	4858      	ldr	r0, [pc, #352]	; (59bc <_GLOBAL__sub_I__Z8printTabv+0xc70>)
    585a:	f008 f945 	bl	dae8 <__aeabi_atexit>
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    585e:	4b53      	ldr	r3, [pc, #332]	; (59ac <_GLOBAL__sub_I__Z8printTabv+0xc60>)
    5860:	f8cb 3000 	str.w	r3, [fp]
		{ isConnected = false;
		  connect(); }
    5864:	4658      	mov	r0, fp
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    5866:	4b57      	ldr	r3, [pc, #348]	; (59c4 <_GLOBAL__sub_I__Z8printTabv+0xc78>)
    5868:	f8cb 3004 	str.w	r3, [fp, #4]
    586c:	f88b 4008 	strb.w	r4, [fp, #8]
    5870:	f88b 4009 	strb.w	r4, [fp, #9]
    5874:	f8cb 400c 	str.w	r4, [fp, #12]
		{ isConnected = false;
    5878:	f88b 4010 	strb.w	r4, [fp, #16]
		  connect(); }
    587c:	f003 fa88 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord24(click_post_amp1, click_peak1);
    5880:	4946      	ldr	r1, [pc, #280]	; (599c <_GLOBAL__sub_I__Z8printTabv+0xc50>)
    5882:	4a45      	ldr	r2, [pc, #276]	; (5998 <_GLOBAL__sub_I__Z8printTabv+0xc4c>)
    5884:	4658      	mov	r0, fp
    5886:	f008 f92f 	bl	dae8 <__aeabi_atexit>
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
		{ isConnected = false;
		  connect(); }
    588a:	484f      	ldr	r0, [pc, #316]	; (59c8 <_GLOBAL__sub_I__Z8printTabv+0xc7c>)
		  connect(); }
	AudioConnection(AudioStream &source, unsigned char sourceOutput,
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
    588c:	4a47      	ldr	r2, [pc, #284]	; (59ac <_GLOBAL__sub_I__Z8printTabv+0xc60>)
    588e:	7204      	strb	r4, [r0, #8]
    5890:	e880 0404 	stmia.w	r0, {r2, sl}
    5894:	7244      	strb	r4, [r0, #9]
    5896:	60c4      	str	r4, [r0, #12]
		{ isConnected = false;
    5898:	7404      	strb	r4, [r0, #16]
		  connect(); }
    589a:	f003 fa79 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord25(click_post_amp1, 0, usb1, 0);
    589e:	493f      	ldr	r1, [pc, #252]	; (599c <_GLOBAL__sub_I__Z8printTabv+0xc50>)
    58a0:	4a3d      	ldr	r2, [pc, #244]	; (5998 <_GLOBAL__sub_I__Z8printTabv+0xc4c>)
    58a2:	4849      	ldr	r0, [pc, #292]	; (59c8 <_GLOBAL__sub_I__Z8printTabv+0xc7c>)
    58a4:	f008 f920 	bl	dae8 <__aeabi_atexit>
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
		{ isConnected = false;
		  connect(); }
    58a8:	4848      	ldr	r0, [pc, #288]	; (59cc <_GLOBAL__sub_I__Z8printTabv+0xc80>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    58aa:	4a3e      	ldr	r2, [pc, #248]	; (59a4 <_GLOBAL__sub_I__Z8printTabv+0xc58>)
    58ac:	6002      	str	r2, [r0, #0]
    58ae:	4a48      	ldr	r2, [pc, #288]	; (59d0 <_GLOBAL__sub_I__Z8printTabv+0xc84>)
    58b0:	7204      	strb	r4, [r0, #8]
    58b2:	6042      	str	r2, [r0, #4]
    58b4:	7244      	strb	r4, [r0, #9]
    58b6:	60c4      	str	r4, [r0, #12]
		{ isConnected = false;
    58b8:	7404      	strb	r4, [r0, #16]
		  connect(); }
    58ba:	f003 fa69 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord26(song_post_amp2, song_rms2);
    58be:	4937      	ldr	r1, [pc, #220]	; (599c <_GLOBAL__sub_I__Z8printTabv+0xc50>)
    58c0:	4a35      	ldr	r2, [pc, #212]	; (5998 <_GLOBAL__sub_I__Z8printTabv+0xc4c>)
    58c2:	4842      	ldr	r0, [pc, #264]	; (59cc <_GLOBAL__sub_I__Z8printTabv+0xc80>)
    58c4:	f008 f910 	bl	dae8 <__aeabi_atexit>
    58c8:	4842      	ldr	r0, [pc, #264]	; (59d4 <_GLOBAL__sub_I__Z8printTabv+0xc88>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    58ca:	4a36      	ldr	r2, [pc, #216]	; (59a4 <_GLOBAL__sub_I__Z8printTabv+0xc58>)
    58cc:	6002      	str	r2, [r0, #0]
    58ce:	4a42      	ldr	r2, [pc, #264]	; (59d8 <_GLOBAL__sub_I__Z8printTabv+0xc8c>)
    58d0:	7204      	strb	r4, [r0, #8]
    58d2:	6042      	str	r2, [r0, #4]
    58d4:	7244      	strb	r4, [r0, #9]
    58d6:	60c4      	str	r4, [r0, #12]
		{ isConnected = false;
    58d8:	7404      	strb	r4, [r0, #16]
		  connect(); }
    58da:	f003 fa59 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord27(song_post_amp2, song_peak2);
    58de:	492f      	ldr	r1, [pc, #188]	; (599c <_GLOBAL__sub_I__Z8printTabv+0xc50>)
    58e0:	4a2d      	ldr	r2, [pc, #180]	; (5998 <_GLOBAL__sub_I__Z8printTabv+0xc4c>)
    58e2:	483c      	ldr	r0, [pc, #240]	; (59d4 <_GLOBAL__sub_I__Z8printTabv+0xc88>)
    58e4:	f008 f900 	bl	dae8 <__aeabi_atexit>
    58e8:	483c      	ldr	r0, [pc, #240]	; (59dc <_GLOBAL__sub_I__Z8printTabv+0xc90>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    58ea:	4a3d      	ldr	r2, [pc, #244]	; (59e0 <_GLOBAL__sub_I__Z8printTabv+0xc94>)
    58ec:	6002      	str	r2, [r0, #0]
    58ee:	4a3d      	ldr	r2, [pc, #244]	; (59e4 <_GLOBAL__sub_I__Z8printTabv+0xc98>)
    58f0:	7204      	strb	r4, [r0, #8]
    58f2:	6042      	str	r2, [r0, #4]
    58f4:	7244      	strb	r4, [r0, #9]
    58f6:	60c4      	str	r4, [r0, #12]
		{ isConnected = false;
    58f8:	7404      	strb	r4, [r0, #16]
		  connect(); }
    58fa:	f003 fa49 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord29(song_post_amp1, song_rms1);
    58fe:	4927      	ldr	r1, [pc, #156]	; (599c <_GLOBAL__sub_I__Z8printTabv+0xc50>)
    5900:	4a25      	ldr	r2, [pc, #148]	; (5998 <_GLOBAL__sub_I__Z8printTabv+0xc4c>)
    5902:	4836      	ldr	r0, [pc, #216]	; (59dc <_GLOBAL__sub_I__Z8printTabv+0xc90>)
    5904:	f008 f8f0 	bl	dae8 <__aeabi_atexit>
    5908:	4837      	ldr	r0, [pc, #220]	; (59e8 <_GLOBAL__sub_I__Z8printTabv+0xc9c>)
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    590a:	4a35      	ldr	r2, [pc, #212]	; (59e0 <_GLOBAL__sub_I__Z8printTabv+0xc94>)
    590c:	6002      	str	r2, [r0, #0]
    590e:	4a37      	ldr	r2, [pc, #220]	; (59ec <_GLOBAL__sub_I__Z8printTabv+0xca0>)
    5910:	7204      	strb	r4, [r0, #8]
    5912:	6042      	str	r2, [r0, #4]
    5914:	7244      	strb	r4, [r0, #9]
    5916:	60c4      	str	r4, [r0, #12]
		{ isConnected = false;
    5918:	7404      	strb	r4, [r0, #16]
		  connect(); }
    591a:	f003 fa39 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord30(song_post_amp1, song_peak1);
    591e:	491f      	ldr	r1, [pc, #124]	; (599c <_GLOBAL__sub_I__Z8printTabv+0xc50>)
    5920:	4a1d      	ldr	r2, [pc, #116]	; (5998 <_GLOBAL__sub_I__Z8printTabv+0xc4c>)
    5922:	4831      	ldr	r0, [pc, #196]	; (59e8 <_GLOBAL__sub_I__Z8printTabv+0xc9c>)
    5924:	f008 f8e0 	bl	dae8 <__aeabi_atexit>
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
		{ isConnected = false;
		  connect(); }
    5928:	4831      	ldr	r0, [pc, #196]	; (59f0 <_GLOBAL__sub_I__Z8printTabv+0xca4>)
		  connect(); }
	AudioConnection(AudioStream &source, unsigned char sourceOutput,
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
    592a:	f04f 0201 	mov.w	r2, #1
    592e:	7242      	strb	r2, [r0, #9]
    5930:	4a2b      	ldr	r2, [pc, #172]	; (59e0 <_GLOBAL__sub_I__Z8printTabv+0xc94>)
    5932:	7204      	strb	r4, [r0, #8]
    5934:	e880 0404 	stmia.w	r0, {r2, sl}
    5938:	60c4      	str	r4, [r0, #12]
		{ isConnected = false;
    593a:	7404      	strb	r4, [r0, #16]
		  connect(); }
    593c:	f003 fa28 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord31(song_post_amp1, 0, usb1, 1);
    5940:	4a15      	ldr	r2, [pc, #84]	; (5998 <_GLOBAL__sub_I__Z8printTabv+0xc4c>)
    5942:	4916      	ldr	r1, [pc, #88]	; (599c <_GLOBAL__sub_I__Z8printTabv+0xc50>)
    5944:	482a      	ldr	r0, [pc, #168]	; (59f0 <_GLOBAL__sub_I__Z8printTabv+0xca4>)
    5946:	f008 f8cf 	bl	dae8 <__aeabi_atexit>
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    594a:	4b2a      	ldr	r3, [pc, #168]	; (59f4 <_GLOBAL__sub_I__Z8printTabv+0xca8>)
    594c:	f888 4008 	strb.w	r4, [r8, #8]
		{ isConnected = false;
		  connect(); }
    5950:	4640      	mov	r0, r8
class AudioConnection
{
public:
	AudioConnection(AudioStream &source, AudioStream &destination) :
		src(source), dst(destination), src_index(0), dest_index(0),
		next_dest(NULL)
    5952:	e888 0208 	stmia.w	r8, {r3, r9}
    5956:	f888 4009 	strb.w	r4, [r8, #9]
    595a:	f8c8 400c 	str.w	r4, [r8, #12]
		{ isConnected = false;
    595e:	f888 4010 	strb.w	r4, [r8, #16]
		  connect(); }
    5962:	f003 fa15 	bl	8d90 <AudioConnection::connect()>
AudioConnection          patchCord32(click_input_amp1, input_fft);
    5966:	4640      	mov	r0, r8
    5968:	4a0b      	ldr	r2, [pc, #44]	; (5998 <_GLOBAL__sub_I__Z8printTabv+0xc4c>)
    596a:	490c      	ldr	r1, [pc, #48]	; (599c <_GLOBAL__sub_I__Z8printTabv+0xc50>)
    596c:	f008 f8bc 	bl	dae8 <__aeabi_atexit>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5970:	4b21      	ldr	r3, [pc, #132]	; (59f8 <_GLOBAL__sub_I__Z8printTabv+0xcac>)
    5972:	681b      	ldr	r3, [r3, #0]
    5974:	930a      	str	r3, [sp, #40]	; 0x28
	return ret;
    5976:	9a0a      	ldr	r2, [sp, #40]	; 0x28
class elapsedMillis
{
private:
	unsigned long ms;
public:
	elapsedMillis(void) { ms = millis(); }
    5978:	4b20      	ldr	r3, [pc, #128]	; (59fc <_GLOBAL__sub_I__Z8printTabv+0xcb0>)
    597a:	601a      	str	r2, [r3, #0]
    597c:	b00f      	add	sp, #60	; 0x3c
    597e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
				first_update = this;
    5982:	4b1f      	ldr	r3, [pc, #124]	; (5a00 <_GLOBAL__sub_I__Z8printTabv+0xcb4>)
    5984:	601d      	str	r5, [r3, #0]
    5986:	f7ff bb16 	b.w	4fb6 <_GLOBAL__sub_I__Z8printTabv+0x26a>
    598a:	6018      	str	r0, [r3, #0]
    598c:	e486      	b.n	529c <_GLOBAL__sub_I__Z8printTabv+0x550>
    598e:	6018      	str	r0, [r3, #0]
    5990:	e534      	b.n	53fc <_GLOBAL__sub_I__Z8printTabv+0x6b0>
    5992:	bf00      	nop
    5994:	1ffff77c 	.word	0x1ffff77c
    5998:	1fffb874 	.word	0x1fffb874
    599c:	00000549 	.word	0x00000549
    59a0:	1ffff398 	.word	0x1ffff398
    59a4:	1ffff998 	.word	0x1ffff998
    59a8:	1fffd1b8 	.word	0x1fffd1b8
    59ac:	1ffff75c 	.word	0x1ffff75c
    59b0:	1ffff698 	.word	0x1ffff698
    59b4:	20003ed8 	.word	0x20003ed8
    59b8:	20003f2c 	.word	0x20003f2c
    59bc:	1ffff6c0 	.word	0x1ffff6c0
    59c0:	20003ea8 	.word	0x20003ea8
    59c4:	20003f08 	.word	0x20003f08
    59c8:	1ffff6ec 	.word	0x1ffff6ec
    59cc:	1ffff700 	.word	0x1ffff700
    59d0:	1fffc9d8 	.word	0x1fffc9d8
    59d4:	1ffff714 	.word	0x1ffff714
    59d8:	1fffc55c 	.word	0x1fffc55c
    59dc:	1ffff728 	.word	0x1ffff728
    59e0:	1ffff978 	.word	0x1ffff978
    59e4:	1fffc9a8 	.word	0x1fffc9a8
    59e8:	20003e90 	.word	0x20003e90
    59ec:	1fffc538 	.word	0x1fffc538
    59f0:	20003f50 	.word	0x20003f50
    59f4:	1ffff8f8 	.word	0x1ffff8f8
    59f8:	200045ec 	.word	0x200045ec
    59fc:	1ffff79c 	.word	0x1ffff79c
    5a00:	20004598 	.word	0x20004598
    5a04:	20003f64 	.word	0x20003f64

00005a08 <tcaselect(unsigned char) [clone .part.25]>:
  lux_total = 0;
  lux_readings = 0;
  dprintln(PRINT_LUX_DEBUG, "reset lux_total and lux_readings");
}

void tcaselect(uint8_t i) {
    5a08:	b538      	push	{r3, r4, r5, lr}
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    5a0a:	4c0a      	ldr	r4, [pc, #40]	; (5a34 <tcaselect(unsigned char) [clone .part.25]+0x2c>)
		transmitting = 1;
    5a0c:	2501      	movs	r5, #1
	}
	size_t write(unsigned int n) {
		return write((uint8_t)n);
	}
	size_t write(int n) {
		return write((uint8_t)n);
    5a0e:	fa05 f100 	lsl.w	r1, r5, r0
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    5a12:	23e0      	movs	r3, #224	; 0xe0
	}
	size_t write(unsigned int n) {
		return write((uint8_t)n);
	}
	size_t write(int n) {
		return write((uint8_t)n);
    5a14:	b2c9      	uxtb	r1, r1
    5a16:	4620      	mov	r0, r4
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
		transmitting = 1;
    5a18:	f884 505e 	strb.w	r5, [r4, #94]	; 0x5e
		txBufferLength = 1;
    5a1c:	f884 505d 	strb.w	r5, [r4, #93]	; 0x5d
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    5a20:	f884 303b 	strb.w	r3, [r4, #59]	; 0x3b
	}
	size_t write(unsigned int n) {
		return write((uint8_t)n);
	}
	size_t write(int n) {
		return write((uint8_t)n);
    5a24:	f002 f9f6 	bl	7e14 <TwoWire::write(unsigned char)>
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    5a28:	4629      	mov	r1, r5
    5a2a:	4620      	mov	r0, r4
  if (i > 7) return;
  Wire.beginTransmission(TCAADDR);
  Wire.write(1 << i);
  Wire.endTransmission();
}
    5a2c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    5a30:	f002 bb94 	b.w	815c <TwoWire::endTransmission(unsigned char)>
    5a34:	1fffb924 	.word	0x1fffb924

00005a38 <LuxManager::startSensor(unsigned char, unsigned char)>:

void LuxManager::startSensor(byte g, byte r) {
    5a38:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    5a3c:	4604      	mov	r4, r0
    5a3e:	b085      	sub	sp, #20
    5a40:	4688      	mov	r8, r1
    5a42:	4835      	ldr	r0, [pc, #212]	; (5b18 <LuxManager::startSensor(unsigned char, unsigned char)+0xe0>)
    5a44:	2121      	movs	r1, #33	; 0x21
    5a46:	4617      	mov	r7, r2
    5a48:	f005 fdda 	bl	b600 <usb_serial_write>
  Serial.print("attempting to start lux sensor...");
  Wire.begin();
    5a4c:	4833      	ldr	r0, [pc, #204]	; (5b1c <LuxManager::startSensor(unsigned char, unsigned char)+0xe4>)
    5a4e:	f002 f9f5 	bl	7e3c <TwoWire::begin()>
  if (tca_addr > -1) {
    5a52:	6ea0      	ldr	r0, [r4, #104]	; 0x68
    5a54:	2800      	cmp	r0, #0
    5a56:	db02      	blt.n	5a5e <LuxManager::startSensor(unsigned char, unsigned char)+0x26>
    tcaselect(tca_addr);
    5a58:	b2c0      	uxtb	r0, r0
  lux_readings = 0;
  dprintln(PRINT_LUX_DEBUG, "reset lux_total and lux_readings");
}

void tcaselect(uint8_t i) {
  if (i > 7) return;
    5a5a:	2807      	cmp	r0, #7
    5a5c:	d958      	bls.n	5b10 <LuxManager::startSensor(unsigned char, unsigned char)+0xd8>
  Serial.print("attempting to start lux sensor...");
  Wire.begin();
  if (tca_addr > -1) {
    tcaselect(tca_addr);
  }
  if (!sensor.begin()) {
    5a5e:	f104 0528 	add.w	r5, r4, #40	; 0x28
    5a62:	4628      	mov	r0, r5
    5a64:	492d      	ldr	r1, [pc, #180]	; (5b1c <LuxManager::startSensor(unsigned char, unsigned char)+0xe4>)
    5a66:	f002 f841 	bl	7aec <Adafruit_VEML7700::begin(TwoWire*)>
    5a6a:	4606      	mov	r6, r0
    5a6c:	2800      	cmp	r0, #0
    5a6e:	d134      	bne.n	5ada <LuxManager::startSensor(unsigned char, unsigned char)+0xa2>
    5a70:	2110      	movs	r1, #16
    5a72:	482b      	ldr	r0, [pc, #172]	; (5b20 <LuxManager::startSensor(unsigned char, unsigned char)+0xe8>)
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5a74:	4d2b      	ldr	r5, [pc, #172]	; (5b24 <LuxManager::startSensor(unsigned char, unsigned char)+0xec>)
    5a76:	f005 fdc3 	bl	b600 <usb_serial_write>
    Serial.print("ERROR ---- VEML "); Serial.print(id); Serial.println(" not found");
    5a7a:	f104 0170 	add.w	r1, r4, #112	; 0x70
    5a7e:	482a      	ldr	r0, [pc, #168]	; (5b28 <LuxManager::startSensor(unsigned char, unsigned char)+0xf0>)
    5a80:	f003 fbd2 	bl	9228 <Print::print(String const&)>
    5a84:	210a      	movs	r1, #10
    5a86:	4829      	ldr	r0, [pc, #164]	; (5b2c <LuxManager::startSensor(unsigned char, unsigned char)+0xf4>)
    5a88:	f005 fdba 	bl	b600 <usb_serial_write>
    5a8c:	4826      	ldr	r0, [pc, #152]	; (5b28 <LuxManager::startSensor(unsigned char, unsigned char)+0xf0>)
    5a8e:	f003 fbf1 	bl	9274 <Print::println()>
    neo->colorWipe(255, 100, 0);
    5a92:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
  HsbToRgb(h, s, b);
  colorWipe(rgb[0], rgb[1], rgb[2]);
}

void NeoGroup::colorWipe(uint8_t red, uint8_t green, uint8_t blue) {
  colorWipe(red, green, blue, brightness_scaler);
    5a94:	e9d0 8930 	ldrd	r8, r9, [r0, #192]	; 0xc0
    5a98:	4633      	mov	r3, r6
    5a9a:	e9cd 8900 	strd	r8, r9, [sp]
    5a9e:	2264      	movs	r2, #100	; 0x64
    5aa0:	21ff      	movs	r1, #255	; 0xff
    5aa2:	f7fb febd 	bl	1820 <NeoGroup::colorWipe(unsigned char, unsigned char, unsigned char, double)>
    5aa6:	682b      	ldr	r3, [r5, #0]
    5aa8:	9303      	str	r3, [sp, #12]
	return ret;
    5aaa:	9c03      	ldr	r4, [sp, #12]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5aac:	682b      	ldr	r3, [r5, #0]
    5aae:	9302      	str	r3, [sp, #8]
    unsigned long then = millis();
    while (millis() < then + 5000) {
    5ab0:	f504 549c 	add.w	r4, r4, #4992	; 0x1380
	return ret;
    5ab4:	9b02      	ldr	r3, [sp, #8]
    5ab6:	3408      	adds	r4, #8
    5ab8:	429c      	cmp	r4, r3
    5aba:	d90b      	bls.n	5ad4 <LuxManager::startSensor(unsigned char, unsigned char)+0x9c>
    5abc:	2101      	movs	r1, #1
    5abe:	481c      	ldr	r0, [pc, #112]	; (5b30 <LuxManager::startSensor(unsigned char, unsigned char)+0xf8>)
    5ac0:	f005 fd9e 	bl	b600 <usb_serial_write>
      Serial.print(".");
      delay(100);
    5ac4:	2064      	movs	r0, #100	; 0x64
    5ac6:	f004 fb23 	bl	a110 <delay>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5aca:	682b      	ldr	r3, [r5, #0]
    5acc:	9302      	str	r3, [sp, #8]
	return ret;
    5ace:	9b02      	ldr	r3, [sp, #8]
  }
  if (!sensor.begin()) {
    Serial.print("ERROR ---- VEML "); Serial.print(id); Serial.println(" not found");
    neo->colorWipe(255, 100, 0);
    unsigned long then = millis();
    while (millis() < then + 5000) {
    5ad0:	429c      	cmp	r4, r3
    5ad2:	d8f3      	bhi.n	5abc <LuxManager::startSensor(unsigned char, unsigned char)+0x84>
  else {
    Serial.print("VEML "); Serial.print(id); Serial.println(" found");
    sensor.setGain(g);
    sensor.setIntegrationTime(r);// 800ms was default
  }
}
    5ad4:	b005      	add	sp, #20
    5ad6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    5ada:	2105      	movs	r1, #5
    5adc:	4815      	ldr	r0, [pc, #84]	; (5b34 <LuxManager::startSensor(unsigned char, unsigned char)+0xfc>)
    5ade:	f005 fd8f 	bl	b600 <usb_serial_write>
      Serial.print(".");
      delay(100);
    }
  }
  else {
    Serial.print("VEML "); Serial.print(id); Serial.println(" found");
    5ae2:	f104 0170 	add.w	r1, r4, #112	; 0x70
    5ae6:	4810      	ldr	r0, [pc, #64]	; (5b28 <LuxManager::startSensor(unsigned char, unsigned char)+0xf0>)
    5ae8:	f003 fb9e 	bl	9228 <Print::print(String const&)>
    5aec:	2106      	movs	r1, #6
    5aee:	4812      	ldr	r0, [pc, #72]	; (5b38 <LuxManager::startSensor(unsigned char, unsigned char)+0x100>)
    5af0:	f005 fd86 	bl	b600 <usb_serial_write>
    5af4:	480c      	ldr	r0, [pc, #48]	; (5b28 <LuxManager::startSensor(unsigned char, unsigned char)+0xf0>)
    5af6:	f003 fbbd 	bl	9274 <Print::println()>
    sensor.setGain(g);
    5afa:	4641      	mov	r1, r8
    5afc:	4628      	mov	r0, r5
    5afe:	f002 f943 	bl	7d88 <Adafruit_VEML7700::setGain(unsigned char)>
    sensor.setIntegrationTime(r);// 800ms was default
    5b02:	4639      	mov	r1, r7
    5b04:	4628      	mov	r0, r5
    5b06:	f002 f93b 	bl	7d80 <Adafruit_VEML7700::setIntegrationTime(unsigned char)>
  }
}
    5b0a:	b005      	add	sp, #20
    5b0c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    5b10:	f7ff ff7a 	bl	5a08 <tcaselect(unsigned char) [clone .part.25]>
    5b14:	e7a3      	b.n	5a5e <LuxManager::startSensor(unsigned char, unsigned char)+0x26>
    5b16:	bf00      	nop
    5b18:	00011e90 	.word	0x00011e90
    5b1c:	1fffb924 	.word	0x1fffb924
    5b20:	00011eb4 	.word	0x00011eb4
    5b24:	200045ec 	.word	0x200045ec
    5b28:	1fffbaf4 	.word	0x1fffbaf4
    5b2c:	00011ec8 	.word	0x00011ec8
    5b30:	00011eb0 	.word	0x00011eb0
    5b34:	00011ed4 	.word	0x00011ed4
    5b38:	00011ecc 	.word	0x00011ecc
    5b3c:	ffffffff 	.word	0xffffffff

00005b40 <LuxManager::readLux(Adafruit_VEML7700*)>:

void LuxManager::readLux() {
    readLux(&sensor);
}

void LuxManager::readLux(Adafruit_VEML7700 *s) {
    5b40:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5b44:	4d68      	ldr	r5, [pc, #416]	; (5ce8 <LuxManager::readLux(Adafruit_VEML7700*)+0x1a8>)
    5b46:	b086      	sub	sp, #24
    5b48:	682b      	ldr	r3, [r5, #0]
    5b4a:	9301      	str	r3, [sp, #4]
    5b4c:	4604      	mov	r4, r0
    5b4e:	460f      	mov	r7, r1
  dprint(PRINT_LUX_DEBUG, last_reading); dprint(PRINT_LUX_DEBUG, " readLux("); dprint(PRINT_LUX_DEBUG, id); dprint(PRINT_LUX_DEBUG, ")\t");
    5b50:	a802      	add	r0, sp, #8
    5b52:	4966      	ldr	r1, [pc, #408]	; (5cec <LuxManager::readLux(Adafruit_VEML7700*)+0x1ac>)
	return ret;
    5b54:	9b01      	ldr	r3, [sp, #4]
    5b56:	f104 0670 	add.w	r6, r4, #112	; 0x70
    5b5a:	f003 fcfd 	bl	9558 <String::String(char const*)>
    5b5e:	a802      	add	r0, sp, #8
    5b60:	f003 fcba 	bl	94d8 <String::~String()>
    5b64:	4631      	mov	r1, r6
    5b66:	a802      	add	r0, sp, #8
    5b68:	f003 fd0a 	bl	9580 <String::String(String const&)>
    5b6c:	a802      	add	r0, sp, #8
    5b6e:	f003 fcb3 	bl	94d8 <String::~String()>
    5b72:	495f      	ldr	r1, [pc, #380]	; (5cf0 <LuxManager::readLux(Adafruit_VEML7700*)+0x1b0>)
    5b74:	a802      	add	r0, sp, #8
    5b76:	f003 fcef 	bl	9558 <String::String(char const*)>
    5b7a:	a802      	add	r0, sp, #8
    5b7c:	f003 fcac 	bl	94d8 <String::~String()>
  if (tca_addr > -1) {
    5b80:	6ea0      	ldr	r0, [r4, #104]	; 0x68
    5b82:	2800      	cmp	r0, #0
    5b84:	db03      	blt.n	5b8e <LuxManager::readLux(Adafruit_VEML7700*)+0x4e>
    tcaselect(tca_addr);
    5b86:	b2c0      	uxtb	r0, r0
  lux_readings = 0;
  dprintln(PRINT_LUX_DEBUG, "reset lux_total and lux_readings");
}

void tcaselect(uint8_t i) {
  if (i > 7) return;
    5b88:	2807      	cmp	r0, #7
    5b8a:	f240 80a3 	bls.w	5cd4 <LuxManager::readLux(Adafruit_VEML7700*)+0x194>
void LuxManager::readLux(Adafruit_VEML7700 *s) {
  dprint(PRINT_LUX_DEBUG, last_reading); dprint(PRINT_LUX_DEBUG, " readLux("); dprint(PRINT_LUX_DEBUG, id); dprint(PRINT_LUX_DEBUG, ")\t");
  if (tca_addr > -1) {
    tcaselect(tca_addr);
  }
  double temp  = s->readLux();
    5b8e:	4638      	mov	r0, r7
    5b90:	f002 f8e4 	bl	7d5c <Adafruit_VEML7700::readLux()>
    5b94:	f006 ff38 	bl	ca08 <__aeabi_f2d>
  if (temp > 10000) {
    5b98:	a351      	add	r3, pc, #324	; (adr r3, 5ce0 <LuxManager::readLux(Adafruit_VEML7700*)+0x1a0>)
    5b9a:	e9d3 2300 	ldrd	r2, r3, [r3]
void LuxManager::readLux(Adafruit_VEML7700 *s) {
  dprint(PRINT_LUX_DEBUG, last_reading); dprint(PRINT_LUX_DEBUG, " readLux("); dprint(PRINT_LUX_DEBUG, id); dprint(PRINT_LUX_DEBUG, ")\t");
  if (tca_addr > -1) {
    tcaselect(tca_addr);
  }
  double temp  = s->readLux();
    5b9e:	4680      	mov	r8, r0
    5ba0:	4689      	mov	r9, r1
  if (temp > 10000) {
    5ba2:	f007 fa15 	bl	cfd0 <__aeabi_dcmpgt>
    5ba6:	b110      	cbz	r0, 5bae <LuxManager::readLux(Adafruit_VEML7700*)+0x6e>
      dprintln(PRINT_LUX_READINGS, brightness_scaler);
  };

  updateMinMax();
  last_reading = 0;
}
    5ba8:	b006      	add	sp, #24
    5baa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    lux = (lux + temp) * 0.5;
    checkForLuxOverValue();
    lux_total += lux;
    lux_readings++;
  } else {
    lux = temp;
    5bae:	e9c4 8904 	strd	r8, r9, [r4, #16]
    checkForLuxOverValue();
    5bb2:	4620      	mov	r0, r4
    5bb4:	f7fc f95c 	bl	1e70 <LuxManager::checkForLuxOverValue()>
    lux_total += lux;
    5bb8:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
    5bbc:	e9d4 0138 	ldrd	r0, r1, [r4, #224]	; 0xe0
    5bc0:	f006 fdc4 	bl	c74c <__adddf3>
    lux_readings++;
    5bc4:	2200      	movs	r2, #0
    5bc6:	4b4b      	ldr	r3, [pc, #300]	; (5cf4 <LuxManager::readLux(Adafruit_VEML7700*)+0x1b4>)
    lux_total += lux;
    lux_readings++;
  } else {
    lux = temp;
    checkForLuxOverValue();
    lux_total += lux;
    5bc8:	e9c4 0138 	strd	r0, r1, [r4, #224]	; 0xe0
    lux_readings++;
    5bcc:	e9d4 013a 	ldrd	r0, r1, [r4, #232]	; 0xe8
    5bd0:	f006 fdbc 	bl	c74c <__adddf3>
    5bd4:	e9c4 013a 	strd	r0, r1, [r4, #232]	; 0xe8
  }
  dprint(PRINT_LUX_READINGS, id); dprint(PRINT_LUX_READINGS,":");
    5bd8:	4631      	mov	r1, r6
    5bda:	a802      	add	r0, sp, #8
    5bdc:	f003 fcd0 	bl	9580 <String::String(String const&)>
    5be0:	a802      	add	r0, sp, #8
    5be2:	f003 fc79 	bl	94d8 <String::~String()>
    5be6:	4944      	ldr	r1, [pc, #272]	; (5cf8 <LuxManager::readLux(Adafruit_VEML7700*)+0x1b8>)
    5be8:	a802      	add	r0, sp, #8
    5bea:	f003 fcb5 	bl	9558 <String::String(char const*)>
    5bee:	a802      	add	r0, sp, #8
    5bf0:	f003 fc72 	bl	94d8 <String::~String()>
  dprint(PRINT_LUX_READINGS, lux); dprintln(PRINT_LUX_READINGS,"");
    5bf4:	4941      	ldr	r1, [pc, #260]	; (5cfc <LuxManager::readLux(Adafruit_VEML7700*)+0x1bc>)
    5bf6:	a802      	add	r0, sp, #8
    5bf8:	f003 fcae 	bl	9558 <String::String(char const*)>
    5bfc:	a802      	add	r0, sp, #8
    5bfe:	f003 fc6b 	bl	94d8 <String::~String()>
  // dprint(PRINT_LUX_READINGS, "lux_readings "); dprint(PRINT_LUX_READINGS, id);
  // dprint(PRINT_LUX_READINGS, " increased to : "); dprintln(PRINT_LUX_READINGS, lux_readings);
  // update the brightness scales TODO , this logic does not work if the number of lux sensors is less than the number of groups
  // todo have the brightness scaler mapping
  brightness_scaler = calculateBrightnessScaler();
    5c02:	4620      	mov	r0, r4
    5c04:	f7fc f98e 	bl	1f24 <LuxManager::calculateBrightnessScaler()>
  num_brightness_scaler_vals++;
    5c08:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
  dprint(PRINT_LUX_READINGS, lux); dprintln(PRINT_LUX_READINGS,"");
  // dprint(PRINT_LUX_READINGS, "lux_readings "); dprint(PRINT_LUX_READINGS, id);
  // dprint(PRINT_LUX_READINGS, " increased to : "); dprintln(PRINT_LUX_READINGS, lux_readings);
  // update the brightness scales TODO , this logic does not work if the number of lux sensors is less than the number of groups
  // todo have the brightness scaler mapping
  brightness_scaler = calculateBrightnessScaler();
    5c0c:	4606      	mov	r6, r0
    5c0e:	460f      	mov	r7, r1
  num_brightness_scaler_vals++;
    5c10:	f103 0a01 	add.w	sl, r3, #1
  dprint(PRINT_LUX_READINGS, lux); dprintln(PRINT_LUX_READINGS,"");
  // dprint(PRINT_LUX_READINGS, "lux_readings "); dprint(PRINT_LUX_READINGS, id);
  // dprint(PRINT_LUX_READINGS, " increased to : "); dprintln(PRINT_LUX_READINGS, lux_readings);
  // update the brightness scales TODO , this logic does not work if the number of lux sensors is less than the number of groups
  // todo have the brightness scaler mapping
  brightness_scaler = calculateBrightnessScaler();
    5c14:	e9c4 6706 	strd	r6, r7, [r4, #24]
  num_brightness_scaler_vals++;
  brightness_scaler_total += brightness_scaler;
    5c18:	e9d4 233c 	ldrd	r2, r3, [r4, #240]	; 0xf0
  // dprint(PRINT_LUX_READINGS, "lux_readings "); dprint(PRINT_LUX_READINGS, id);
  // dprint(PRINT_LUX_READINGS, " increased to : "); dprintln(PRINT_LUX_READINGS, lux_readings);
  // update the brightness scales TODO , this logic does not work if the number of lux sensors is less than the number of groups
  // todo have the brightness scaler mapping
  brightness_scaler = calculateBrightnessScaler();
  num_brightness_scaler_vals++;
    5c1c:	f8c4 a0f8 	str.w	sl, [r4, #248]	; 0xf8
  brightness_scaler_total += brightness_scaler;
    5c20:	f006 fd94 	bl	c74c <__adddf3>
    5c24:	4680      	mov	r8, r0
    5c26:	4689      	mov	r9, r1
    5c28:	e9c4 893c 	strd	r8, r9, [r4, #240]	; 0xf0
  brightness_scaler_avg = brightness_scaler_total / num_brightness_scaler_vals;
    5c2c:	4650      	mov	r0, sl
    5c2e:	f006 fec9 	bl	c9c4 <__aeabi_ui2d>
    5c32:	4602      	mov	r2, r0
    5c34:	460b      	mov	r3, r1
    5c36:	4640      	mov	r0, r8
    5c38:	4649      	mov	r1, r9
    5c3a:	f007 f863 	bl	cd04 <__aeabi_ddiv>
  neo->setBrightnessScaler(brightness_scaler);
    5c3e:	f8d4 806c 	ldr.w	r8, [r4, #108]	; 0x6c
  // update the brightness scales TODO , this logic does not work if the number of lux sensors is less than the number of groups
  // todo have the brightness scaler mapping
  brightness_scaler = calculateBrightnessScaler();
  num_brightness_scaler_vals++;
  brightness_scaler_total += brightness_scaler;
  brightness_scaler_avg = brightness_scaler_total / num_brightness_scaler_vals;
    5c42:	e9c4 0108 	strd	r0, r1, [r4, #32]
    dprintln(PRINT_CLICK_DEBUG, "updated last_flash_upate to 0");
  }
}

void NeoGroup::updateAvgBrightnessScaler() {
  brightness_scaler_total += brightness_scaler;
    5c46:	4632      	mov	r2, r6
    5c48:	463b      	mov	r3, r7
    5c4a:	e9d8 0132 	ldrd	r0, r1, [r8, #200]	; 0xc8
    ////////////////////////////// SHDN Timer ///////////////////////////////
    uint32_t getShdnLen();
    bool isInShutdown();
    void updateAvgBrightnessScaler();
    void resetAvgBrightnessScaler();
    void setBrightnessScaler(double scaler) {brightness_scaler = scaler;updateAvgBrightnessScaler();};
    5c4e:	e9c8 6730 	strd	r6, r7, [r8, #192]	; 0xc0
    dprintln(PRINT_CLICK_DEBUG, "updated last_flash_upate to 0");
  }
}

void NeoGroup::updateAvgBrightnessScaler() {
  brightness_scaler_total += brightness_scaler;
    5c52:	f006 fd7b 	bl	c74c <__adddf3>
  brightness_scaler_changes++;
    5c56:	2200      	movs	r2, #0
    5c58:	4b26      	ldr	r3, [pc, #152]	; (5cf4 <LuxManager::readLux(Adafruit_VEML7700*)+0x1b4>)
    dprintln(PRINT_CLICK_DEBUG, "updated last_flash_upate to 0");
  }
}

void NeoGroup::updateAvgBrightnessScaler() {
  brightness_scaler_total += brightness_scaler;
    5c5a:	e9c8 0132 	strd	r0, r1, [r8, #200]	; 0xc8
  brightness_scaler_changes++;
    5c5e:	e9d8 0134 	ldrd	r0, r1, [r8, #208]	; 0xd0
    5c62:	f006 fd73 	bl	c74c <__adddf3>
    5c66:	e9c8 0134 	strd	r0, r1, [r8, #208]	; 0xd0
  neo->setBrightnessScaler(brightness_scaler);
  
  if (PRINT_BRIGHTNESS_SCALER_DEBUG == 0) {
      dprint(PRINT_LUX_READINGS, "\tbs: "); 
    5c6a:	4925      	ldr	r1, [pc, #148]	; (5d00 <LuxManager::readLux(Adafruit_VEML7700*)+0x1c0>)
    5c6c:	a802      	add	r0, sp, #8
    5c6e:	f003 fc73 	bl	9558 <String::String(char const*)>
    5c72:	a802      	add	r0, sp, #8
    5c74:	f003 fc30 	bl	94d8 <String::~String()>
    num_brightness_scaler_vals = 0;
    brightness_scaler_total = 0;
}

void LuxManager::updateMinMax() {
  if (lux < min_reading && lux > 0.0) {
    5c78:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
    5c7c:	e9d4 2300 	ldrd	r2, r3, [r4]
    5c80:	4630      	mov	r0, r6
    5c82:	4639      	mov	r1, r7
    5c84:	f007 f986 	bl	cf94 <__aeabi_dcmplt>
    5c88:	b180      	cbz	r0, 5cac <LuxManager::readLux(Adafruit_VEML7700*)+0x16c>
    5c8a:	2200      	movs	r2, #0
    5c8c:	2300      	movs	r3, #0
    5c8e:	4630      	mov	r0, r6
    5c90:	4639      	mov	r1, r7
    5c92:	f007 f99d 	bl	cfd0 <__aeabi_dcmpgt>
    5c96:	b148      	cbz	r0, 5cac <LuxManager::readLux(Adafruit_VEML7700*)+0x16c>
    min_reading = lux;
    5c98:	e9c4 6700 	strd	r6, r7, [r4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5c9c:	682b      	ldr	r3, [r5, #0]
    5c9e:	9302      	str	r3, [sp, #8]
	return ret;
    5ca0:	9b02      	ldr	r3, [sp, #8]
	elapsedMillis(unsigned long val) { ms = millis() - val; }
	elapsedMillis(const elapsedMillis &orig) { ms = orig.ms; }
	operator unsigned long () const { return millis() - ms; }
	elapsedMillis & operator = (const elapsedMillis &rhs) { ms = rhs.ms; return *this; }
	elapsedMillis & operator = (unsigned long val) { ms = millis() - val; return *this; }
    5ca2:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
      dprintln(PRINT_LUX_READINGS, brightness_scaler);
  };

  updateMinMax();
  last_reading = 0;
}
    5ca6:	b006      	add	sp, #24
    5ca8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
}

void LuxManager::updateMinMax() {
  if (lux < min_reading && lux > 0.0) {
    min_reading = lux;
  } else if (lux > max_reading && lux < 10000) {
    5cac:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
    5cb0:	4630      	mov	r0, r6
    5cb2:	4639      	mov	r1, r7
    5cb4:	f007 f98c 	bl	cfd0 <__aeabi_dcmpgt>
    5cb8:	2800      	cmp	r0, #0
    5cba:	d0ef      	beq.n	5c9c <LuxManager::readLux(Adafruit_VEML7700*)+0x15c>
    5cbc:	a308      	add	r3, pc, #32	; (adr r3, 5ce0 <LuxManager::readLux(Adafruit_VEML7700*)+0x1a0>)
    5cbe:	e9d3 2300 	ldrd	r2, r3, [r3]
    5cc2:	4630      	mov	r0, r6
    5cc4:	4639      	mov	r1, r7
    5cc6:	f007 f965 	bl	cf94 <__aeabi_dcmplt>
    5cca:	2800      	cmp	r0, #0
    5ccc:	d0e6      	beq.n	5c9c <LuxManager::readLux(Adafruit_VEML7700*)+0x15c>
    max_reading = lux;
    5cce:	e9c4 6702 	strd	r6, r7, [r4, #8]
    5cd2:	e7e3      	b.n	5c9c <LuxManager::readLux(Adafruit_VEML7700*)+0x15c>
    5cd4:	f7ff fe98 	bl	5a08 <tcaselect(unsigned char) [clone .part.25]>
    5cd8:	e759      	b.n	5b8e <LuxManager::readLux(Adafruit_VEML7700*)+0x4e>
    5cda:	bf00      	nop
    5cdc:	f3af 8000 	nop.w
    5ce0:	00000000 	.word	0x00000000
    5ce4:	40c38800 	.word	0x40c38800
    5ce8:	200045ec 	.word	0x200045ec
    5cec:	00011230 	.word	0x00011230
    5cf0:	0001123c 	.word	0x0001123c
    5cf4:	3ff00000 	.word	0x3ff00000
    5cf8:	00010a7c 	.word	0x00010a7c
    5cfc:	00010b88 	.word	0x00010b88
    5d00:	00011240 	.word	0x00011240

00005d04 <LuxManager::calibrate(long, bool)>:
void LuxManager::resetMinMax() {
  min_reading = 10000;
  max_reading = 0;
}
// todo move me to the correct place
void LuxManager::calibrate(long len, bool first_time = true) {
    5d04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5d08:	460c      	mov	r4, r1
    5d0a:	b083      	sub	sp, #12
    5d0c:	2125      	movs	r1, #37	; 0x25
    5d0e:	4605      	mov	r5, r0
    5d10:	4839      	ldr	r0, [pc, #228]	; (5df8 <LuxManager::calibrate(long, bool)+0xf4>)
    5d12:	4691      	mov	r9, r2
    5d14:	f005 fc74 	bl	b600 <usb_serial_write>
    5d18:	4838      	ldr	r0, [pc, #224]	; (5dfc <LuxManager::calibrate(long, bool)+0xf8>)
    5d1a:	f003 faab 	bl	9274 <Print::println()>
    5d1e:	2118      	movs	r1, #24
    5d20:	4837      	ldr	r0, [pc, #220]	; (5e00 <LuxManager::calibrate(long, bool)+0xfc>)
    5d22:	f005 fc6d 	bl	b600 <usb_serial_write>
    5d26:	4835      	ldr	r0, [pc, #212]	; (5dfc <LuxManager::calibrate(long, bool)+0xf8>)
    5d28:	f003 faa4 	bl	9274 <Print::println()>
    5d2c:	4a35      	ldr	r2, [pc, #212]	; (5e04 <LuxManager::calibrate(long, bool)+0x100>)
    5d2e:	17e3      	asrs	r3, r4, #31
    5d30:	fb82 2404 	smull	r2, r4, r2, r4
    5d34:	ebc3 08a4 	rsb	r8, r3, r4, asr #2
    5d38:	f105 0a28 	add.w	sl, r5, #40	; 0x28
    5d3c:	240a      	movs	r4, #10
  // todo change this function so it takes the average of these readings
  printMinorDivide();
  Serial.println("Starting Lux Calibration");
  double lux_tot = 0.0;
    5d3e:	2600      	movs	r6, #0
    5d40:	2700      	movs	r7, #0
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
    5d42:	f04f 0b02 	mov.w	fp, #2
    5d46:	e007      	b.n	5d58 <LuxManager::calibrate(long, bool)+0x54>
    forceLuxReading(); // todo change this to not be hard coded
    if (first_time) {
      Serial.print(lux);
      Serial.print("  ");
    }
    lux_tot += lux;
    5d48:	4630      	mov	r0, r6
    5d4a:	4639      	mov	r1, r7
    5d4c:	f006 fcfe 	bl	c74c <__adddf3>
void LuxManager::calibrate(long len, bool first_time = true) {
  // todo change this function so it takes the average of these readings
  printMinorDivide();
  Serial.println("Starting Lux Calibration");
  double lux_tot = 0.0;
  for (int i = 0; i < 10; i++) {
    5d50:	3c01      	subs	r4, #1
    forceLuxReading(); // todo change this to not be hard coded
    if (first_time) {
      Serial.print(lux);
      Serial.print("  ");
    }
    lux_tot += lux;
    5d52:	4606      	mov	r6, r0
    5d54:	460f      	mov	r7, r1
void LuxManager::calibrate(long len, bool first_time = true) {
  // todo change this function so it takes the average of these readings
  printMinorDivide();
  Serial.println("Starting Lux Calibration");
  double lux_tot = 0.0;
  for (int i = 0; i < 10; i++) {
    5d56:	d01e      	beq.n	5d96 <LuxManager::calibrate(long, bool)+0x92>
    delay(len / 10);
    5d58:	4640      	mov	r0, r8
    5d5a:	f004 f9d9 	bl	a110 <delay>
  updateMinMax();
  last_reading = 0;
}

void LuxManager::readLux() {
    readLux(&sensor);
    5d5e:	4651      	mov	r1, sl
    5d60:	4628      	mov	r0, r5
    5d62:	f7ff feed 	bl	5b40 <LuxManager::readLux(Adafruit_VEML7700*)>
  Serial.println("------------------------\n");
}

double LuxManager::forceLuxReading() {
  readLux();
  return lux;
    5d66:	e9d5 2304 	ldrd	r2, r3, [r5, #16]
  Serial.println("Starting Lux Calibration");
  double lux_tot = 0.0;
  for (int i = 0; i < 10; i++) {
    delay(len / 10);
    forceLuxReading(); // todo change this to not be hard coded
    if (first_time) {
    5d6a:	f1b9 0f00 	cmp.w	r9, #0
    5d6e:	d0eb      	beq.n	5d48 <LuxManager::calibrate(long, bool)+0x44>
    5d70:	f8cd b000 	str.w	fp, [sp]
    5d74:	4821      	ldr	r0, [pc, #132]	; (5dfc <LuxManager::calibrate(long, bool)+0xf8>)
    5d76:	f003 fad7 	bl	9328 <Print::printFloat(double, unsigned char)>
    5d7a:	2102      	movs	r1, #2
    5d7c:	4822      	ldr	r0, [pc, #136]	; (5e08 <LuxManager::calibrate(long, bool)+0x104>)
    5d7e:	f005 fc3f 	bl	b600 <usb_serial_write>
      Serial.print(lux);
      Serial.print("  ");
    }
    lux_tot += lux;
    5d82:	4630      	mov	r0, r6
    5d84:	4639      	mov	r1, r7
    5d86:	e9d5 2304 	ldrd	r2, r3, [r5, #16]
    5d8a:	f006 fcdf 	bl	c74c <__adddf3>
void LuxManager::calibrate(long len, bool first_time = true) {
  // todo change this function so it takes the average of these readings
  printMinorDivide();
  Serial.println("Starting Lux Calibration");
  double lux_tot = 0.0;
  for (int i = 0; i < 10; i++) {
    5d8e:	3c01      	subs	r4, #1
    forceLuxReading(); // todo change this to not be hard coded
    if (first_time) {
      Serial.print(lux);
      Serial.print("  ");
    }
    lux_tot += lux;
    5d90:	4606      	mov	r6, r0
    5d92:	460f      	mov	r7, r1
void LuxManager::calibrate(long len, bool first_time = true) {
  // todo change this function so it takes the average of these readings
  printMinorDivide();
  Serial.println("Starting Lux Calibration");
  double lux_tot = 0.0;
  for (int i = 0; i < 10; i++) {
    5d94:	d1e0      	bne.n	5d58 <LuxManager::calibrate(long, bool)+0x54>
    5d96:	2118      	movs	r1, #24
    5d98:	481c      	ldr	r0, [pc, #112]	; (5e0c <LuxManager::calibrate(long, bool)+0x108>)
    5d9a:	f005 fc31 	bl	b600 <usb_serial_write>
    }
    lux_tot += lux;
    // when we have the first 10 readings
  }
  Serial.print("\nAverage lux readings : ");
  lux = lux_tot / 10.0;
    5d9e:	2200      	movs	r2, #0
    5da0:	4b1b      	ldr	r3, [pc, #108]	; (5e10 <LuxManager::calibrate(long, bool)+0x10c>)
    5da2:	4630      	mov	r0, r6
    5da4:	4639      	mov	r1, r7
    5da6:	f006 ffad 	bl	cd04 <__aeabi_ddiv>
    5daa:	4602      	mov	r2, r0
    5dac:	460b      	mov	r3, r1
    5dae:	2102      	movs	r1, #2
    5db0:	e9c5 2304 	strd	r2, r3, [r5, #16]
    5db4:	4811      	ldr	r0, [pc, #68]	; (5dfc <LuxManager::calibrate(long, bool)+0xf8>)
    5db6:	9100      	str	r1, [sp, #0]
    5db8:	f003 fab6 	bl	9328 <Print::printFloat(double, unsigned char)>
  Serial.print(lux);
  Serial.println();
    5dbc:	480f      	ldr	r0, [pc, #60]	; (5dfc <LuxManager::calibrate(long, bool)+0xf8>)
    5dbe:	f003 fa59 	bl	9274 <Print::println()>
  if (first_time) {
    5dc2:	f1b9 0f00 	cmp.w	r9, #0
    5dc6:	d005      	beq.n	5dd4 <LuxManager::calibrate(long, bool)+0xd0>
    lux_total = 0;
    5dc8:	2200      	movs	r2, #0
    5dca:	2300      	movs	r3, #0
    5dcc:	e9c5 2338 	strd	r2, r3, [r5, #224]	; 0xe0
    lux_readings = 0;
    5dd0:	e9c5 233a 	strd	r2, r3, [r5, #232]	; 0xe8
    5dd4:	2119      	movs	r1, #25
    5dd6:	480f      	ldr	r0, [pc, #60]	; (5e14 <LuxManager::calibrate(long, bool)+0x110>)
    5dd8:	f005 fc12 	bl	b600 <usb_serial_write>
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    5ddc:	4807      	ldr	r0, [pc, #28]	; (5dfc <LuxManager::calibrate(long, bool)+0xf8>)
    5dde:	f003 fa49 	bl	9274 <Print::println()>
    5de2:	2119      	movs	r1, #25
    5de4:	480c      	ldr	r0, [pc, #48]	; (5e18 <LuxManager::calibrate(long, bool)+0x114>)
    5de6:	f005 fc0b 	bl	b600 <usb_serial_write>
    5dea:	4804      	ldr	r0, [pc, #16]	; (5dfc <LuxManager::calibrate(long, bool)+0xf8>)
  }
  Serial.println("\nLux calibration finished");
  Serial.println("------------------------\n");
}
    5dec:	b003      	add	sp, #12
    5dee:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5df2:	f003 ba3f 	b.w	9274 <Print::println()>
    5df6:	bf00      	nop
    5df8:	00010734 	.word	0x00010734
    5dfc:	1fffbaf4 	.word	0x1fffbaf4
    5e00:	00011edc 	.word	0x00011edc
    5e04:	66666667 	.word	0x66666667
    5e08:	00011ef8 	.word	0x00011ef8
    5e0c:	00011efc 	.word	0x00011efc
    5e10:	40240000 	.word	0x40240000
    5e14:	00011f18 	.word	0x00011f18
    5e18:	00011f34 	.word	0x00011f34

00005e1c <setup>:
  } else {
    Serial.println("ERROR - this PCB does not contain jumpers, or jumper pins are not populated");
  }
}

void setup() {
    5e1c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  delay(2000); // to avoid booting to the bootloader
    5e20:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
  } else {
    Serial.println("ERROR - this PCB does not contain jumpers, or jumper pins are not populated");
  }
}

void setup() {
    5e24:	b085      	sub	sp, #20
  delay(2000); // to avoid booting to the bootloader
    5e26:	f004 f973 	bl	a110 <delay>
    5e2a:	4e53      	ldr	r6, [pc, #332]	; (5f78 <setup+0x15c>)
    5e2c:	4853      	ldr	r0, [pc, #332]	; (5f7c <setup+0x160>)
    5e2e:	210c      	movs	r1, #12
    5e30:	f005 fbe6 	bl	b600 <usb_serial_write>
    5e34:	4852      	ldr	r0, [pc, #328]	; (5f80 <setup+0x164>)
    5e36:	f003 fa1d 	bl	9274 <Print::println()>
  Serial.begin(SERIAL_BAUD_RATE);
  Serial.println("Serial begun");
  leds.begin();
  for (int i = 0; i < 10; i++) {
    5e3a:	2400      	movs	r4, #0

void setup() {
  delay(2000); // to avoid booting to the bootloader
  Serial.begin(SERIAL_BAUD_RATE);
  Serial.println("Serial begun");
  leds.begin();
    5e3c:	4630      	mov	r0, r6
    5e3e:	f001 fced 	bl	781c <WS2812Serial::begin()>
    5e42:	4637      	mov	r7, r6
	}
	void setPixel(uint32_t num, uint8_t red, uint8_t green, uint8_t blue) {
		if (num >= numled) return;
		num *= 3;
		drawBuffer[num+0] = blue;
    5e44:	46a1      	mov	r9, r4
    5e46:	2501      	movs	r5, #1
		drawBuffer[num+1] = green;
    5e48:	f04f 080c 	mov.w	r8, #12
    5e4c:	e006      	b.n	5e5c <setup+0x40>
  for (int i = 0; i < 10; i++) {
    5e4e:	3401      	adds	r4, #1
    leds.setPixel(i, 12, 12, 0);
    leds.show();
    5e50:	f001 fd7a 	bl	7948 <WS2812Serial::show()>
void setup() {
  delay(2000); // to avoid booting to the bootloader
  Serial.begin(SERIAL_BAUD_RATE);
  Serial.println("Serial begun");
  leds.begin();
  for (int i = 0; i < 10; i++) {
    5e54:	2c0a      	cmp	r4, #10
    5e56:	f105 0503 	add.w	r5, r5, #3
    5e5a:	d015      	beq.n	5e88 <setup+0x6c>
		drawBuffer[num+0] = color & 255;
		drawBuffer[num+1] = (color >> 8) & 255;
		drawBuffer[num+2] = (color >> 16) & 255;
	}
	void setPixel(uint32_t num, uint8_t red, uint8_t green, uint8_t blue) {
		if (num >= numled) return;
    5e5c:	8833      	ldrh	r3, [r6, #0]
    leds.setPixel(i, 12, 12, 0);
    leds.show();
    5e5e:	4846      	ldr	r0, [pc, #280]	; (5f78 <setup+0x15c>)
    5e60:	429c      	cmp	r4, r3
    5e62:	d2f4      	bcs.n	5e4e <setup+0x32>
		num *= 3;
		drawBuffer[num+0] = blue;
    5e64:	68bb      	ldr	r3, [r7, #8]
    5e66:	eb04 0244 	add.w	r2, r4, r4, lsl #1
void setup() {
  delay(2000); // to avoid booting to the bootloader
  Serial.begin(SERIAL_BAUD_RATE);
  Serial.println("Serial begun");
  leds.begin();
  for (int i = 0; i < 10; i++) {
    5e6a:	3401      	adds	r4, #1
    5e6c:	f803 9002 	strb.w	r9, [r3, r2]
		drawBuffer[num+1] = green;
    5e70:	68bb      	ldr	r3, [r7, #8]
    5e72:	f803 8005 	strb.w	r8, [r3, r5]
		drawBuffer[num+2] = red;
    5e76:	68bb      	ldr	r3, [r7, #8]
    5e78:	442b      	add	r3, r5
    5e7a:	3503      	adds	r5, #3
    5e7c:	f883 8001 	strb.w	r8, [r3, #1]
    leds.setPixel(i, 12, 12, 0);
    leds.show();
    5e80:	f001 fd62 	bl	7948 <WS2812Serial::show()>
void setup() {
  delay(2000); // to avoid booting to the bootloader
  Serial.begin(SERIAL_BAUD_RATE);
  Serial.println("Serial begun");
  leds.begin();
  for (int i = 0; i < 10; i++) {
    5e84:	2c0a      	cmp	r4, #10
    5e86:	d1e9      	bne.n	5e5c <setup+0x40>
    5e88:	2119      	movs	r1, #25
    5e8a:	483e      	ldr	r0, [pc, #248]	; (5f84 <setup+0x168>)
    5e8c:	f8df 80e8 	ldr.w	r8, [pc, #232]	; 5f78 <setup+0x15c>
    5e90:	f005 fbb6 	bl	b600 <usb_serial_write>
    5e94:	483a      	ldr	r0, [pc, #232]	; (5f80 <setup+0x164>)
    5e96:	f003 f9ed 	bl	9274 <Print::println()>
    leds.setPixel(i, 12, 12, 0);
    leds.show();
  }
  Serial.println("LEDS have been initalised");
  delay(3000); Serial.println("Setup Loop has started");
    5e9a:	f640 30b8 	movw	r0, #3000	; 0xbb8
    5e9e:	f004 f937 	bl	a110 <delay>
    5ea2:	2116      	movs	r1, #22
    5ea4:	4838      	ldr	r0, [pc, #224]	; (5f88 <setup+0x16c>)
    5ea6:	f005 fbab 	bl	b600 <usb_serial_write>
    5eaa:	4835      	ldr	r0, [pc, #212]	; (5f80 <setup+0x164>)
    5eac:	f003 f9e2 	bl	9274 <Print::println()>
  if (JUMPERS_POPULATED) {// TODO this should also check the READ_JUMPERS bool, jumpers populated should be determined by hardware revision
    readJumpers();
    5eb0:	f7fe fe8c 	bl	4bcc <readJumpers()>
  } else {
    printMajorDivide("Jumpers are not populated, not printing values");
  }
  setupDLManager();
    5eb4:	f7fe f8b2 	bl	401c <setupDLManager()>
  setupAudio();
    5eb8:	f7fd fc96 	bl	37e8 <setupAudio()>
    return 0;
  }
}

void NeoGroup::setFlashColors(uint8_t red, uint8_t green, uint8_t blue) {
  flash_red = red;
    5ebc:	4b33      	ldr	r3, [pc, #204]	; (5f8c <setup+0x170>)
    5ebe:	2096      	movs	r0, #150	; 0x96
  flash_green = green;
    5ec0:	2164      	movs	r1, #100	; 0x64
  flash_blue = blue;
    5ec2:	22ff      	movs	r2, #255	; 0xff
    5ec4:	2400      	movs	r4, #0
    return 0;
  }
}

void NeoGroup::setFlashColors(uint8_t red, uint8_t green, uint8_t blue) {
  flash_red = red;
    5ec6:	f883 004c 	strb.w	r0, [r3, #76]	; 0x4c
    5eca:	f883 0124 	strb.w	r0, [r3, #292]	; 0x124
  flash_green = green;
    5ece:	f883 104d 	strb.w	r1, [r3, #77]	; 0x4d
    5ed2:	f883 1125 	strb.w	r1, [r3, #293]	; 0x125
  flash_blue = blue;
    5ed6:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
    5eda:	f883 2126 	strb.w	r2, [r3, #294]	; 0x126
		drawBuffer[num+2] = (color >> 16) & 255;
	}
	void setPixel(uint32_t num, uint8_t red, uint8_t green, uint8_t blue) {
		if (num >= numled) return;
		num *= 3;
		drawBuffer[num+0] = blue;
    5ede:	4627      	mov	r7, r4
    5ee0:	2501      	movs	r5, #1
    5ee2:	e006      	b.n	5ef2 <setup+0xd6>

  for (int i = 0; i < NUM_NEO_GROUPS; i++) {
    neos[i].setFlashColors(FLASH_RED, FLASH_GREEN, FLASH_BLUE);
  }
  for (int i = 0; i < NUM_LED; i++) {
    5ee4:	3401      	adds	r4, #1
    leds.setPixel(i, 0, 0, 0);
    leds.show();
    5ee6:	f001 fd2f 	bl	7948 <WS2812Serial::show()>
  setupAudio();

  for (int i = 0; i < NUM_NEO_GROUPS; i++) {
    neos[i].setFlashColors(FLASH_RED, FLASH_GREEN, FLASH_BLUE);
  }
  for (int i = 0; i < NUM_LED; i++) {
    5eea:	2c0a      	cmp	r4, #10
    5eec:	f105 0503 	add.w	r5, r5, #3
    5ef0:	d015      	beq.n	5f1e <setup+0x102>
		drawBuffer[num+0] = color & 255;
		drawBuffer[num+1] = (color >> 8) & 255;
		drawBuffer[num+2] = (color >> 16) & 255;
	}
	void setPixel(uint32_t num, uint8_t red, uint8_t green, uint8_t blue) {
		if (num >= numled) return;
    5ef2:	8833      	ldrh	r3, [r6, #0]
    leds.setPixel(i, 0, 0, 0);
    leds.show();
    5ef4:	4820      	ldr	r0, [pc, #128]	; (5f78 <setup+0x15c>)
    5ef6:	42a3      	cmp	r3, r4
    5ef8:	d9f4      	bls.n	5ee4 <setup+0xc8>
		num *= 3;
		drawBuffer[num+0] = blue;
    5efa:	f8d8 2008 	ldr.w	r2, [r8, #8]
    5efe:	eb04 0344 	add.w	r3, r4, r4, lsl #1
  setupAudio();

  for (int i = 0; i < NUM_NEO_GROUPS; i++) {
    neos[i].setFlashColors(FLASH_RED, FLASH_GREEN, FLASH_BLUE);
  }
  for (int i = 0; i < NUM_LED; i++) {
    5f02:	3401      	adds	r4, #1
    5f04:	54d7      	strb	r7, [r2, r3]
		drawBuffer[num+1] = green;
    5f06:	f8d8 3008 	ldr.w	r3, [r8, #8]
    5f0a:	555f      	strb	r7, [r3, r5]
		drawBuffer[num+2] = red;
    5f0c:	f8d8 3008 	ldr.w	r3, [r8, #8]
    5f10:	442b      	add	r3, r5
    5f12:	3503      	adds	r5, #3
    5f14:	705f      	strb	r7, [r3, #1]
    leds.setPixel(i, 0, 0, 0);
    leds.show();
    5f16:	f001 fd17 	bl	7948 <WS2812Serial::show()>
  setupAudio();

  for (int i = 0; i < NUM_NEO_GROUPS; i++) {
    neos[i].setFlashColors(FLASH_RED, FLASH_GREEN, FLASH_BLUE);
  }
  for (int i = 0; i < NUM_LED; i++) {
    5f1a:	2c0a      	cmp	r4, #10
    5f1c:	d1e9      	bne.n	5ef2 <setup+0xd6>
    5f1e:	2124      	movs	r1, #36	; 0x24
    5f20:	481b      	ldr	r0, [pc, #108]	; (5f90 <setup+0x174>)
    5f22:	f005 fb6d 	bl	b600 <usb_serial_write>
    5f26:	4816      	ldr	r0, [pc, #88]	; (5f80 <setup+0x164>)
    5f28:	f003 f9a4 	bl	9274 <Print::println()>
    leds.show();
  }
  if (LUX_SENSORS_ACTIVE) {
    Serial.println("turning off LEDs for Lux Calibration");
    // todo make this proper
    lux_managers[0].startSensor(VEML7700_GAIN_1, VEML7700_IT_25MS); // todo add this to config_adv? todo
    5f2c:	220c      	movs	r2, #12
    5f2e:	2100      	movs	r1, #0
    5f30:	4818      	ldr	r0, [pc, #96]	; (5f94 <setup+0x178>)
    5f32:	f7ff fd81 	bl	5a38 <LuxManager::startSensor(unsigned char, unsigned char)>
    lux_managers[1].startSensor(VEML7700_GAIN_1, VEML7700_IT_25MS);
    5f36:	220c      	movs	r2, #12
    5f38:	2100      	movs	r1, #0
    5f3a:	4817      	ldr	r0, [pc, #92]	; (5f98 <setup+0x17c>)
    5f3c:	f7ff fd7c 	bl	5a38 <LuxManager::startSensor(unsigned char, unsigned char)>
    delay(200);
    5f40:	20c8      	movs	r0, #200	; 0xc8
    5f42:	f004 f8e5 	bl	a110 <delay>
    lux_managers[0].calibrate(LUX_CALIBRATION_TIME);
    5f46:	2201      	movs	r2, #1
    5f48:	f640 31b8 	movw	r1, #3000	; 0xbb8
    5f4c:	4811      	ldr	r0, [pc, #68]	; (5f94 <setup+0x178>)
    5f4e:	f7ff fed9 	bl	5d04 <LuxManager::calibrate(long, bool)>
    lux_managers[1].calibrate(LUX_CALIBRATION_TIME);
    5f52:	2201      	movs	r2, #1
    5f54:	f640 31b8 	movw	r1, #3000	; 0xbb8
    5f58:	480f      	ldr	r0, [pc, #60]	; (5f98 <setup+0x17c>)
    5f5a:	f7ff fed3 	bl	5d04 <LuxManager::calibrate(long, bool)>
  for (int i = 0; i < 10; i++) {
    leds.setPixel(i, 64, 64, 64);
    leds.show();
  }
#endif
  printMajorDivide("Setup Loop Finished");
    5f5e:	490f      	ldr	r1, [pc, #60]	; (5f9c <setup+0x180>)
    5f60:	4668      	mov	r0, sp
    5f62:	f003 faf9 	bl	9558 <String::String(char const*)>
    5f66:	4668      	mov	r0, sp
    5f68:	f7fa fc66 	bl	838 <printMajorDivide(String)>
    5f6c:	4668      	mov	r0, sp
    5f6e:	f003 fab3 	bl	94d8 <String::~String()>
}
    5f72:	b005      	add	sp, #20
    5f74:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    5f78:	1fffb8d4 	.word	0x1fffb8d4
    5f7c:	00011f50 	.word	0x00011f50
    5f80:	1fffbaf4 	.word	0x1fffbaf4
    5f84:	00011f60 	.word	0x00011f60
    5f88:	00011f7c 	.word	0x00011f7c
    5f8c:	1ffff438 	.word	0x1ffff438
    5f90:	00011f94 	.word	0x00011f94
    5f94:	1fffc580 	.word	0x1fffc580
    5f98:	1fffc680 	.word	0x1fffc680
    5f9c:	00011fbc 	.word	0x00011fbc

00005fa0 <LuxManager::update()>:
double LuxManager::forceLuxReading() {
  readLux();
  return lux;
}

bool LuxManager::update() {
    5fa0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    5fa4:	4604      	mov	r4, r0
  if ((neo->getLedsOn() == false && neo->getOnOffLen() >= LUX_SHDN_LEN) || (neo->getShdnLen() > LUX_SHDN_LEN)) {
    5fa6:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5fa8:	4d4f      	ldr	r5, [pc, #316]	; (60e8 <LuxManager::update()+0x148>)
    5faa:	f890 10a8 	ldrb.w	r1, [r0, #168]	; 0xa8
double LuxManager::forceLuxReading() {
  readLux();
  return lux;
}

bool LuxManager::update() {
    5fae:	b08e      	sub	sp, #56	; 0x38
  if ((neo->getLedsOn() == false && neo->getOnOffLen() >= LUX_SHDN_LEN) || (neo->getShdnLen() > LUX_SHDN_LEN)) {
    5fb0:	b9d9      	cbnz	r1, 5fea <LuxManager::update()+0x4a>
    5fb2:	682b      	ldr	r3, [r5, #0]
    5fb4:	9301      	str	r3, [sp, #4]
    5fb6:	f8d0 20b0 	ldr.w	r2, [r0, #176]	; 0xb0
	return ret;
    5fba:	9b01      	ldr	r3, [sp, #4]
    5fbc:	1a9b      	subs	r3, r3, r2
    5fbe:	2b27      	cmp	r3, #39	; 0x27
    5fc0:	d913      	bls.n	5fea <LuxManager::update()+0x4a>
    5fc2:	f890 604b 	ldrb.w	r6, [r0, #75]	; 0x4b
      // if currently in extreme lux shutdown then poll 20x faster
    if (neo->getLuxShdn() && last_reading > min_reading_time * 0.05) {
    5fc6:	2e00      	cmp	r6, #0
    5fc8:	d131      	bne.n	602e <LuxManager::update()+0x8e>
    5fca:	f8d4 80d0 	ldr.w	r8, [r4, #208]	; 0xd0
    5fce:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5fd2:	682a      	ldr	r2, [r5, #0]
    5fd4:	9207      	str	r2, [sp, #28]
	return ret;
    5fd6:	9a07      	ldr	r2, [sp, #28]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5fd8:	4d43      	ldr	r5, [pc, #268]	; (60e8 <LuxManager::update()+0x148>)
        if (neo->getShdnLen() > LUX_SHDN_LEN) {
          neo->powerOn();
        }
        return true;
    }
    else if (last_reading > min_reading_time) {
    5fda:	1ad3      	subs	r3, r2, r3
    5fdc:	4598      	cmp	r8, r3
    5fde:	d362      	bcc.n	60a6 <LuxManager::update()+0x106>
    }
  } else if (last_reading > max_reading_time && neo->getLedsOn() == true) {
    // shdn len has to be longer to ensure the lux sensors get a good reading
    neo->shutdown(LUX_SHDN_LEN*1.25);
  }
  return false;
    5fe0:	2600      	movs	r6, #0
}
    5fe2:	4630      	mov	r0, r6
    5fe4:	b00e      	add	sp, #56	; 0x38
    5fe6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5fea:	682b      	ldr	r3, [r5, #0]
    5fec:	9303      	str	r3, [sp, #12]
	return ret;
    5fee:	9b03      	ldr	r3, [sp, #12]
	unsigned long ms;
public:
	elapsedMillis(void) { ms = millis(); }
	elapsedMillis(unsigned long val) { ms = millis() - val; }
	elapsedMillis(const elapsedMillis &orig) { ms = orig.ms; }
	operator unsigned long () const { return millis() - ms; }
    5ff0:	f8d0 60a0 	ldr.w	r6, [r0, #160]	; 0xa0
  dprintln(PRINT_LUX_DEBUG, "POWER ON MESSAGE RECEIVED");
  shdn_timer += shdn_len;
}

uint32_t NeoGroup::getShdnLen() {
  if (shdn_timer <= shdn_len) {
    5ff4:	f8d0 20a4 	ldr.w	r2, [r0, #164]	; 0xa4
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5ff8:	4f3b      	ldr	r7, [pc, #236]	; (60e8 <LuxManager::update()+0x148>)
    5ffa:	1b9b      	subs	r3, r3, r6
    5ffc:	4293      	cmp	r3, r2
    5ffe:	d806      	bhi.n	600e <LuxManager::update()+0x6e>
    6000:	683b      	ldr	r3, [r7, #0]
    6002:	9302      	str	r3, [sp, #8]
	return ret;
    6004:	9b02      	ldr	r3, [sp, #8]
  readLux();
  return lux;
}

bool LuxManager::update() {
  if ((neo->getLedsOn() == false && neo->getOnOffLen() >= LUX_SHDN_LEN) || (neo->getShdnLen() > LUX_SHDN_LEN)) {
    6006:	1b9e      	subs	r6, r3, r6
    6008:	1b92      	subs	r2, r2, r6
    600a:	2a28      	cmp	r2, #40	; 0x28
    600c:	d8d9      	bhi.n	5fc2 <LuxManager::update()+0x22>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    600e:	682b      	ldr	r3, [r5, #0]
    6010:	930a      	str	r3, [sp, #40]	; 0x28
	return ret;
    6012:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        if (neo->getShdnLen() > LUX_SHDN_LEN) {
          neo->powerOn();
        }
        return true;
    }
  } else if (last_reading > max_reading_time && neo->getLedsOn() == true) {
    6014:	f8d4 50d8 	ldr.w	r5, [r4, #216]	; 0xd8
    6018:	f8d4 20d4 	ldr.w	r2, [r4, #212]	; 0xd4
    601c:	1b5b      	subs	r3, r3, r5
    601e:	429a      	cmp	r2, r3
    6020:	d2de      	bcs.n	5fe0 <LuxManager::update()+0x40>
    6022:	2900      	cmp	r1, #0
    6024:	d0dc      	beq.n	5fe0 <LuxManager::update()+0x40>
    // shdn len has to be longer to ensure the lux sensors get a good reading
    neo->shutdown(LUX_SHDN_LEN*1.25);
    6026:	2132      	movs	r1, #50	; 0x32
    6028:	f7fb fe9e 	bl	1d68 <NeoGroup::shutdown(unsigned long)>
    602c:	e7d8      	b.n	5fe0 <LuxManager::update()+0x40>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    602e:	682b      	ldr	r3, [r5, #0]
    6030:	9304      	str	r3, [sp, #16]
	return ret;
    6032:	9804      	ldr	r0, [sp, #16]
    6034:	f8d4 70d8 	ldr.w	r7, [r4, #216]	; 0xd8
}

bool LuxManager::update() {
  if ((neo->getLedsOn() == false && neo->getOnOffLen() >= LUX_SHDN_LEN) || (neo->getShdnLen() > LUX_SHDN_LEN)) {
      // if currently in extreme lux shutdown then poll 20x faster
    if (neo->getLuxShdn() && last_reading > min_reading_time * 0.05) {
    6038:	f8d4 80d0 	ldr.w	r8, [r4, #208]	; 0xd0
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    603c:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 60e8 <LuxManager::update()+0x148>
    6040:	1bc0      	subs	r0, r0, r7
    6042:	f007 f933 	bl	d2ac <__aeabi_ui2f>
    6046:	4682      	mov	sl, r0
    6048:	4640      	mov	r0, r8
    604a:	f007 f92f 	bl	d2ac <__aeabi_ui2f>
    604e:	4927      	ldr	r1, [pc, #156]	; (60ec <LuxManager::update()+0x14c>)
    6050:	f007 f984 	bl	d35c <__aeabi_fmul>
    6054:	4601      	mov	r1, r0
    6056:	4650      	mov	r0, sl
    6058:	f007 fb3c 	bl	d6d4 <__aeabi_fcmpgt>
    605c:	2800      	cmp	r0, #0
    605e:	d040      	beq.n	60e2 <LuxManager::update()+0x142>
        dprint(PRINT_LUX_DEBUG, "QUICK UPDATE due to extreme lux reading");
    6060:	4923      	ldr	r1, [pc, #140]	; (60f0 <LuxManager::update()+0x150>)
    6062:	a80a      	add	r0, sp, #40	; 0x28
    6064:	f003 fa78 	bl	9558 <String::String(char const*)>
    6068:	a80a      	add	r0, sp, #40	; 0x28
    606a:	f003 fa35 	bl	94d8 <String::~String()>
  updateMinMax();
  last_reading = 0;
}

void LuxManager::readLux() {
    readLux(&sensor);
    606e:	f104 0128 	add.w	r1, r4, #40	; 0x28
    6072:	4620      	mov	r0, r4
    6074:	f7ff fd64 	bl	5b40 <LuxManager::readLux(Adafruit_VEML7700*)>
  if ((neo->getLedsOn() == false && neo->getOnOffLen() >= LUX_SHDN_LEN) || (neo->getShdnLen() > LUX_SHDN_LEN)) {
      // if currently in extreme lux shutdown then poll 20x faster
    if (neo->getLuxShdn() && last_reading > min_reading_time * 0.05) {
        dprint(PRINT_LUX_DEBUG, "QUICK UPDATE due to extreme lux reading");
        readLux();
        if (neo->getShdnLen() > LUX_SHDN_LEN) {
    6078:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    607a:	f8d9 3000 	ldr.w	r3, [r9]
    607e:	9306      	str	r3, [sp, #24]
	return ret;
    6080:	9b06      	ldr	r3, [sp, #24]
    6082:	f8d0 10a0 	ldr.w	r1, [r0, #160]	; 0xa0
    6086:	f8d0 20a4 	ldr.w	r2, [r0, #164]	; 0xa4
    608a:	1a5b      	subs	r3, r3, r1
    608c:	4293      	cmp	r3, r2
    608e:	d823      	bhi.n	60d8 <LuxManager::update()+0x138>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    6090:	f8d9 3000 	ldr.w	r3, [r9]
    6094:	9305      	str	r3, [sp, #20]
	return ret;
    6096:	9b05      	ldr	r3, [sp, #20]
    6098:	1a59      	subs	r1, r3, r1
    609a:	1a52      	subs	r2, r2, r1
    609c:	2a28      	cmp	r2, #40	; 0x28
    609e:	d91b      	bls.n	60d8 <LuxManager::update()+0x138>
          neo->powerOn();
    60a0:	f7fb fade 	bl	1660 <NeoGroup::powerOn()>
    60a4:	e79d      	b.n	5fe2 <LuxManager::update()+0x42>
  updateMinMax();
  last_reading = 0;
}

void LuxManager::readLux() {
    readLux(&sensor);
    60a6:	f104 0128 	add.w	r1, r4, #40	; 0x28
    60aa:	4620      	mov	r0, r4
    60ac:	f7ff fd48 	bl	5b40 <LuxManager::readLux(Adafruit_VEML7700*)>
        }
        return true;
    }
    else if (last_reading > min_reading_time) {
        readLux();
        if (neo->getShdnLen() > LUX_SHDN_LEN) {
    60b0:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    60b2:	682b      	ldr	r3, [r5, #0]
    60b4:	9309      	str	r3, [sp, #36]	; 0x24
	return ret;
    60b6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    60b8:	f8d0 10a0 	ldr.w	r1, [r0, #160]	; 0xa0
    60bc:	f8d0 20a4 	ldr.w	r2, [r0, #164]	; 0xa4
    60c0:	1a5b      	subs	r3, r3, r1
    60c2:	4293      	cmp	r3, r2
    60c4:	d808      	bhi.n	60d8 <LuxManager::update()+0x138>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    60c6:	682b      	ldr	r3, [r5, #0]
    60c8:	9308      	str	r3, [sp, #32]
	return ret;
    60ca:	9b08      	ldr	r3, [sp, #32]
    60cc:	1a59      	subs	r1, r3, r1
    60ce:	1a52      	subs	r2, r2, r1
    60d0:	2a28      	cmp	r2, #40	; 0x28
    60d2:	d901      	bls.n	60d8 <LuxManager::update()+0x138>
          neo->powerOn();
    60d4:	f7fb fac4 	bl	1660 <NeoGroup::powerOn()>
        }
        return true;
    60d8:	2601      	movs	r6, #1
  } else if (last_reading > max_reading_time && neo->getLedsOn() == true) {
    // shdn len has to be longer to ensure the lux sensors get a good reading
    neo->shutdown(LUX_SHDN_LEN*1.25);
  }
  return false;
}
    60da:	4630      	mov	r0, r6
    60dc:	b00e      	add	sp, #56	; 0x38
    60de:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    60e2:	463b      	mov	r3, r7
    60e4:	e775      	b.n	5fd2 <LuxManager::update()+0x32>
    60e6:	bf00      	nop
    60e8:	200045ec 	.word	0x200045ec
    60ec:	3d4ccccd 	.word	0x3d4ccccd
    60f0:	00011fd0 	.word	0x00011fd0

000060f4 <updateLuxManagers()>:
    fc[i].update();
  }
#endif
}

void updateLuxManagers() {
    60f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  // update the feature collectors
  if (LUX_SENSORS_ACTIVE) {
    uint8_t updated = 0;
    for (int i = 0; i < NUM_LUX_MANAGERS; i++) {
      if (lux_managers[i].update()) {
    60f8:	4d2a      	ldr	r5, [pc, #168]	; (61a4 <updateLuxManagers()+0xb0>)
    fc[i].update();
  }
#endif
}

void updateLuxManagers() {
    60fa:	b085      	sub	sp, #20
  // update the feature collectors
  if (LUX_SENSORS_ACTIVE) {
    uint8_t updated = 0;
    for (int i = 0; i < NUM_LUX_MANAGERS; i++) {
      if (lux_managers[i].update()) {
    60fc:	4628      	mov	r0, r5
    60fe:	f7ff ff4f 	bl	5fa0 <LuxManager::update()>
    6102:	2800      	cmp	r0, #0
    6104:	d044      	beq.n	6190 <updateLuxManagers()+0x9c>
    6106:	f505 7080 	add.w	r0, r5, #256	; 0x100
    610a:	f7ff ff49 	bl	5fa0 <LuxManager::update()>
    610e:	f8df a094 	ldr.w	sl, [pc, #148]	; 61a4 <updateLuxManagers()+0xb0>
    fc[i].update();
  }
#endif
}

void updateLuxManagers() {
    6112:	2600      	movs	r6, #0
    6114:	2700      	movs	r7, #0
    6116:	f50a 7b00 	add.w	fp, sl, #512	; 0x200
    611a:	e9da 8904 	ldrd	r8, r9, [sl, #16]
#if COMBINE_LUX_READINGS > 0
    if (updated) {
      // calculate what the combined lux is
      double combined_lux = 0;
      for (int i = 0; i < NUM_LUX_MANAGERS; i++) {
        if (combined_lux < lux_managers[i].getLux()) {
    611e:	4632      	mov	r2, r6
    6120:	463b      	mov	r3, r7
    6122:	4640      	mov	r0, r8
    6124:	4649      	mov	r1, r9
    6126:	f006 ff53 	bl	cfd0 <__aeabi_dcmpgt>
    612a:	b108      	cbz	r0, 6130 <updateLuxManagers()+0x3c>
          combined_lux = lux_managers[i].getLux();
    612c:	4646      	mov	r6, r8
    612e:	464f      	mov	r7, r9
        }
        dprint(PRINT_LUX_DEBUG, " combined_lux value is : ");
    6130:	491d      	ldr	r1, [pc, #116]	; (61a8 <updateLuxManagers()+0xb4>)
    6132:	4668      	mov	r0, sp
    6134:	f003 fa10 	bl	9558 <String::String(char const*)>
    6138:	4668      	mov	r0, sp
    613a:	f003 f9cd 	bl	94d8 <String::~String()>
    613e:	2400      	movs	r4, #0
        dprint(PRINT_LUX_DEBUG, combined_lux);
        // set the new combined lux value to both managers
        for (int i = 0; i < NUM_LUX_MANAGERS; i++) {
          lux_managers[i].setLuxValue(combined_lux);
    6140:	4632      	mov	r2, r6
    6142:	463b      	mov	r3, r7
    6144:	1928      	adds	r0, r5, r4
    6146:	f7fb ffd7 	bl	20f8 <LuxManager::setLuxValue(double)>
          dprint(PRINT_LUX_DEBUG, "\t");
    614a:	4918      	ldr	r1, [pc, #96]	; (61ac <updateLuxManagers()+0xb8>)
    614c:	4668      	mov	r0, sp
    614e:	f003 fa03 	bl	9558 <String::String(char const*)>
    6152:	4668      	mov	r0, sp
    6154:	f003 f9c0 	bl	94d8 <String::~String()>
    double max_reading = 0.0;

    double getAvgLux();
    void   resetAvgLux();

    String getName() {return id;};
    6158:	f104 0170 	add.w	r1, r4, #112	; 0x70
    615c:	4429      	add	r1, r5
    615e:	4668      	mov	r0, sp
    6160:	f003 fa0e 	bl	9580 <String::String(String const&)>
          dprint(PRINT_LUX_DEBUG, lux_managers[i].getName());
    6164:	4668      	mov	r0, sp
    6166:	f003 f9b7 	bl	94d8 <String::~String()>
          dprint(PRINT_LUX_DEBUG, " lux reading : ");
    616a:	4911      	ldr	r1, [pc, #68]	; (61b0 <updateLuxManagers()+0xbc>)
    616c:	4668      	mov	r0, sp
    616e:	f003 f9f3 	bl	9558 <String::String(char const*)>
    6172:	f504 7480 	add.w	r4, r4, #256	; 0x100
    6176:	4668      	mov	r0, sp
    6178:	f003 f9ae 	bl	94d8 <String::~String()>
          combined_lux = lux_managers[i].getLux();
        }
        dprint(PRINT_LUX_DEBUG, " combined_lux value is : ");
        dprint(PRINT_LUX_DEBUG, combined_lux);
        // set the new combined lux value to both managers
        for (int i = 0; i < NUM_LUX_MANAGERS; i++) {
    617c:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
    6180:	d1de      	bne.n	6140 <updateLuxManagers()+0x4c>
    6182:	f50a 7a80 	add.w	sl, sl, #256	; 0x100
    }
#if COMBINE_LUX_READINGS > 0
    if (updated) {
      // calculate what the combined lux is
      double combined_lux = 0;
      for (int i = 0; i < NUM_LUX_MANAGERS; i++) {
    6186:	45da      	cmp	sl, fp
    6188:	d1c7      	bne.n	611a <updateLuxManagers()+0x26>
        }
      }
#endif
    }
  }
}
    618a:	b005      	add	sp, #20
    618c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
void updateLuxManagers() {
  // update the feature collectors
  if (LUX_SENSORS_ACTIVE) {
    uint8_t updated = 0;
    for (int i = 0; i < NUM_LUX_MANAGERS; i++) {
      if (lux_managers[i].update()) {
    6190:	f505 7080 	add.w	r0, r5, #256	; 0x100
    6194:	f7ff ff04 	bl	5fa0 <LuxManager::update()>
    6198:	2800      	cmp	r0, #0
    619a:	d1b8      	bne.n	610e <updateLuxManagers()+0x1a>
        }
      }
#endif
    }
  }
}
    619c:	b005      	add	sp, #20
    619e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    61a2:	bf00      	nop
    61a4:	1fffc580 	.word	0x1fffc580
    61a8:	00011ff8 	.word	0x00011ff8
    61ac:	00010cc0 	.word	0x00010cc0
    61b0:	00012014 	.word	0x00012014

000061b4 <loop>:
  loop_length = 0;
  }
  #endif//print loop length
*/

void loop() {
    61b4:	b508      	push	{r3, lr}
  updateLuxManagers();
    61b6:	f7ff ff9d 	bl	60f4 <updateLuxManagers()>
#if NUM_FEATURE_COLLECTORS == 1
  fc.update();
#endif
#if NUM_FEATURE_COLLECTORS > 1
  for (int i = 0; i < NUM_FEATURE_COLLECTORS; i++) {
    fc[i].update();
    61ba:	480e      	ldr	r0, [pc, #56]	; (61f4 <loop+0x40>)
    61bc:	f7fc fde2 	bl	2d84 <FeatureCollector::update()>
    61c0:	480d      	ldr	r0, [pc, #52]	; (61f8 <loop+0x44>)
    61c2:	f7fc fddf 	bl	2d84 <FeatureCollector::update()>
    61c6:	480d      	ldr	r0, [pc, #52]	; (61fc <loop+0x48>)
    61c8:	f7fc fddc 	bl	2d84 <FeatureCollector::update()>
    61cc:	480c      	ldr	r0, [pc, #48]	; (6200 <loop+0x4c>)
    61ce:	f7fc fdd9 	bl	2d84 <FeatureCollector::update()>
  return;
#endif
}

void updateMode() {
  updateClick();
    61d2:	f7fe faf3 	bl	47bc <updateClick()>
  updateSong();
    61d6:	f7fe f99f 	bl	4518 <updateSong()>

void loop() {
  updateLuxManagers();
  updateFeatureCollectors();
  updateMode();
  updateAutogain();
    61da:	f7fe fc03 	bl	49e4 <updateAutogain()>
  updateDatalog();
    61de:	f7fe fc2f 	bl	4a40 <updateDatalog()>
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    61e2:	f005 f9e3 	bl	b5ac <usb_serial_available>
#endif
  printMajorDivide("Setup Loop Finished");
}

void listenForSerialCommands() {
  if (Serial.available() > 0) {
    61e6:	2800      	cmp	r0, #0
    61e8:	dd03      	ble.n	61f2 <loop+0x3e>
  updateMode();
  updateAutogain();
  updateDatalog();
  listenForSerialCommands();
  //updateLoopLength();
}
    61ea:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    61ee:	f7fa b9c3 	b.w	578 <listenForSerialCommands() [clone .part.50]>
    61f2:	bd08      	pop	{r3, pc}
    61f4:	1ffffa30 	.word	0x1ffffa30
    61f8:	20000b48 	.word	0x20000b48
    61fc:	20001c60 	.word	0x20001c60
    6200:	20002d78 	.word	0x20002d78

00006204 <AudioAnalyzeFFT256::update()>:
		buf += 2;
	}
}

void AudioAnalyzeFFT256::update(void)
{
    6204:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	audio_block_t *block;

	block = receiveReadOnly();
    6206:	2100      	movs	r1, #0
		buf += 2;
	}
}

void AudioAnalyzeFFT256::update(void)
{
    6208:	4605      	mov	r5, r0
	audio_block_t *block;

	block = receiveReadOnly();
    620a:	f002 fd93 	bl	8d34 <AudioStream::receiveReadOnly(unsigned int)>
	if (!block) return;
    620e:	2800      	cmp	r0, #0
    6210:	d055      	beq.n	62be <AudioAnalyzeFFT256::update()+0xba>
#if AUDIO_BLOCK_SAMPLES == 128
	if (!prevblock) {
    6212:	f8d5 711c 	ldr.w	r7, [r5, #284]	; 0x11c
    6216:	4606      	mov	r6, r0
    6218:	2f00      	cmp	r7, #0
    621a:	d04e      	beq.n	62ba <AudioAnalyzeFFT256::update()+0xb6>
    621c:	f505 748e 	add.w	r4, r5, #284	; 0x11c
		prevblock = block;
		return;
	}
	copy_to_fft_buffer(buffer, prevblock->data);
    6220:	1d3b      	adds	r3, r7, #4
    6222:	4622      	mov	r2, r4
    6224:	f505 7190 	add.w	r1, r5, #288	; 0x120
    6228:	f507 7782 	add.w	r7, r7, #260	; 0x104
{
	const uint16_t *src = (const uint16_t *)source;
	uint32_t *dst = (uint32_t *)destination;

	for (int i=0; i < AUDIO_BLOCK_SAMPLES; i++) {
		*dst++ = *src++;  // real sample plus a zero for imaginary
    622c:	f833 0b02 	ldrh.w	r0, [r3], #2
    6230:	f842 0f04 	str.w	r0, [r2, #4]!
static void copy_to_fft_buffer(void *destination, const void *source)
{
	const uint16_t *src = (const uint16_t *)source;
	uint32_t *dst = (uint32_t *)destination;

	for (int i=0; i < AUDIO_BLOCK_SAMPLES; i++) {
    6234:	429f      	cmp	r7, r3
    6236:	d1f9      	bne.n	622c <AudioAnalyzeFFT256::update()+0x28>
	if (!prevblock) {
		prevblock = block;
		return;
	}
	copy_to_fft_buffer(buffer, prevblock->data);
	copy_to_fft_buffer(buffer+256, block->data);
    6238:	1d33      	adds	r3, r6, #4
    623a:	f505 7247 	add.w	r2, r5, #796	; 0x31c
    623e:	f506 7782 	add.w	r7, r6, #260	; 0x104
{
	const uint16_t *src = (const uint16_t *)source;
	uint32_t *dst = (uint32_t *)destination;

	for (int i=0; i < AUDIO_BLOCK_SAMPLES; i++) {
		*dst++ = *src++;  // real sample plus a zero for imaginary
    6242:	f833 0b02 	ldrh.w	r0, [r3], #2
    6246:	f842 0f04 	str.w	r0, [r2, #4]!
static void copy_to_fft_buffer(void *destination, const void *source)
{
	const uint16_t *src = (const uint16_t *)source;
	uint32_t *dst = (uint32_t *)destination;

	for (int i=0; i < AUDIO_BLOCK_SAMPLES; i++) {
    624a:	42bb      	cmp	r3, r7
    624c:	d1f9      	bne.n	6242 <AudioAnalyzeFFT256::update()+0x3e>
	}
	copy_to_fft_buffer(buffer, prevblock->data);
	copy_to_fft_buffer(buffer+256, block->data);
	//window = AudioWindowBlackmanNuttall256;
	//window = NULL;
	if (window) apply_window_to_fft_buffer(buffer, window);
    624e:	f8d5 0118 	ldr.w	r0, [r5, #280]	; 0x118
    6252:	b180      	cbz	r0, 6276 <AudioAnalyzeFFT256::update()+0x72>
    6254:	f505 7292 	add.w	r2, r5, #292	; 0x124
    6258:	f500 7e00 	add.w	lr, r0, #512	; 0x200
{
	int16_t *buf = (int16_t *)buffer;
	const int16_t *win = (int16_t *)window;;

	for (int i=0; i < 256; i++) {
		int32_t val = *buf * *win++;
    625c:	f932 3c04 	ldrsh.w	r3, [r2, #-4]
    6260:	f930 7b02 	ldrsh.w	r7, [r0], #2
		//*buf = signed_saturate_rshift(val, 16, 15);
		*buf = val >> 15;
    6264:	fb03 f307 	mul.w	r3, r3, r7
    6268:	13db      	asrs	r3, r3, #15
static void apply_window_to_fft_buffer(void *buffer, const void *window)
{
	int16_t *buf = (int16_t *)buffer;
	const int16_t *win = (int16_t *)window;;

	for (int i=0; i < 256; i++) {
    626a:	4586      	cmp	lr, r0
		int32_t val = *buf * *win++;
		//*buf = signed_saturate_rshift(val, 16, 15);
		*buf = val >> 15;
    626c:	f822 3c04 	strh.w	r3, [r2, #-4]
    6270:	f102 0204 	add.w	r2, r2, #4
static void apply_window_to_fft_buffer(void *buffer, const void *window)
{
	int16_t *buf = (int16_t *)buffer;
	const int16_t *win = (int16_t *)window;;

	for (int i=0; i < 256; i++) {
    6274:	d1f2      	bne.n	625c <AudioAnalyzeFFT256::update()+0x58>
	copy_to_fft_buffer(buffer, prevblock->data);
	copy_to_fft_buffer(buffer+256, block->data);
	//window = AudioWindowBlackmanNuttall256;
	//window = NULL;
	if (window) apply_window_to_fft_buffer(buffer, window);
	arm_cfft_radix4_q15(&fft_inst, buffer);
    6276:	f505 60e5 	add.w	r0, r5, #1832	; 0x728
    627a:	f006 f8c3 	bl	c404 <arm_cfft_radix4_q15>
	// G. Heinzel's paper says we're supposed to average the magnitude
	// squared, then do the square root at the end.
	if (count == 0) {
    627e:	f895 7721 	ldrb.w	r7, [r5, #1825]	; 0x721
    6282:	b9ef      	cbnz	r7, 62c0 <AudioAnalyzeFFT256::update()+0xbc>
    6284:	f205 5c1c 	addw	ip, r5, #1308	; 0x51c
    6288:	f895 2720 	ldrb.w	r2, [r5, #1824]	; 0x720
    628c:	46e6      	mov	lr, ip
    628e:	f205 711c 	addw	r1, r5, #1820	; 0x71c
		for (int i=0; i < 128; i++) {
			uint32_t tmp = *((uint32_t *)buffer + i);
    6292:	f854 3f04 	ldr.w	r3, [r4, #4]!
// computes ((a[15:0] * b[15:0]) + (a[31:16] * b[31:16]))
static inline int32_t multiply_16tx16t_add_16bx16b(uint32_t a, uint32_t b) __attribute__((always_inline, unused));
static inline int32_t multiply_16tx16t_add_16bx16b(uint32_t a, uint32_t b)
{
	int32_t out;
	asm volatile("smuad %0, %1, %2" : "=r" (out) : "r" (a), "r" (b));
    6296:	fb23 f303 	smuad	r3, r3, r3
			uint32_t magsq = multiply_16tx16t_add_16bx16b(tmp, tmp);
			sum[i] = magsq / naverage;
    629a:	fbb3 f3f2 	udiv	r3, r3, r2
    629e:	f84e 3f04 	str.w	r3, [lr, #4]!
	if (window) apply_window_to_fft_buffer(buffer, window);
	arm_cfft_radix4_q15(&fft_inst, buffer);
	// G. Heinzel's paper says we're supposed to average the magnitude
	// squared, then do the square root at the end.
	if (count == 0) {
		for (int i=0; i < 128; i++) {
    62a2:	4571      	cmp	r1, lr
    62a4:	d1f5      	bne.n	6292 <AudioAnalyzeFFT256::update()+0x8e>
			uint32_t tmp = *((uint32_t *)buffer + i);
			uint32_t magsq = multiply_16tx16t_add_16bx16b(tmp, tmp);
			sum[i] += magsq / naverage;
		}
	}
	if (++count == naverage) {
    62a6:	1c7b      	adds	r3, r7, #1
    62a8:	b2db      	uxtb	r3, r3
    62aa:	4293      	cmp	r3, r2
    62ac:	d020      	beq.n	62f0 <AudioAnalyzeFFT256::update()+0xec>
    62ae:	f885 3721 	strb.w	r3, [r5, #1825]	; 0x721
		for (int i=0; i < 128; i++) {
			output[i] = sqrt_uint32_approx(sum[i]);
		}
		outputflag = true;
	}
	release(prevblock);
    62b2:	f8d5 011c 	ldr.w	r0, [r5, #284]	; 0x11c
    62b6:	f002 fcf9 	bl	8cac <AudioStream::release(audio_block_struct*)>
	prevblock = block;
    62ba:	f8c5 611c 	str.w	r6, [r5, #284]	; 0x11c
    62be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    62c0:	f205 5c1c 	addw	ip, r5, #1308	; 0x51c
    62c4:	f895 2720 	ldrb.w	r2, [r5, #1824]	; 0x720
    62c8:	46e6      	mov	lr, ip
    62ca:	f205 711c 	addw	r1, r5, #1820	; 0x71c
			uint32_t magsq = multiply_16tx16t_add_16bx16b(tmp, tmp);
			sum[i] = magsq / naverage;
		}
	} else {
		for (int i=0; i < 128; i++) {
			uint32_t tmp = *((uint32_t *)buffer + i);
    62ce:	f854 3f04 	ldr.w	r3, [r4, #4]!
    62d2:	fb23 f303 	smuad	r3, r3, r3
			uint32_t magsq = multiply_16tx16t_add_16bx16b(tmp, tmp);
			sum[i] += magsq / naverage;
    62d6:	f85e 0f04 	ldr.w	r0, [lr, #4]!
    62da:	fbb3 f3f2 	udiv	r3, r3, r2
			uint32_t tmp = *((uint32_t *)buffer + i);
			uint32_t magsq = multiply_16tx16t_add_16bx16b(tmp, tmp);
			sum[i] = magsq / naverage;
		}
	} else {
		for (int i=0; i < 128; i++) {
    62de:	4571      	cmp	r1, lr
			uint32_t tmp = *((uint32_t *)buffer + i);
			uint32_t magsq = multiply_16tx16t_add_16bx16b(tmp, tmp);
			sum[i] += magsq / naverage;
    62e0:	4403      	add	r3, r0
    62e2:	f8ce 3000 	str.w	r3, [lr]
			uint32_t tmp = *((uint32_t *)buffer + i);
			uint32_t magsq = multiply_16tx16t_add_16bx16b(tmp, tmp);
			sum[i] = magsq / naverage;
		}
	} else {
		for (int i=0; i < 128; i++) {
    62e6:	d1f2      	bne.n	62ce <AudioAnalyzeFFT256::update()+0xca>
			uint32_t tmp = *((uint32_t *)buffer + i);
			uint32_t magsq = multiply_16tx16t_add_16bx16b(tmp, tmp);
			sum[i] += magsq / naverage;
		}
	}
	if (++count == naverage) {
    62e8:	1c7b      	adds	r3, r7, #1
    62ea:	b2db      	uxtb	r3, r3
    62ec:	4293      	cmp	r3, r2
    62ee:	d1de      	bne.n	62ae <AudioAnalyzeFFT256::update()+0xaa>
		count = 0;
    62f0:	2300      	movs	r3, #0
    62f2:	f8df e03c 	ldr.w	lr, [pc, #60]	; 6330 <AudioAnalyzeFFT256::update()+0x12c>
    62f6:	f885 3721 	strb.w	r3, [r5, #1825]	; 0x721
    62fa:	4660      	mov	r0, ip
    62fc:	f105 0716 	add.w	r7, r5, #22
		for (int i=0; i < 128; i++) {
			output[i] = sqrt_uint32_approx(sum[i]);
    6300:	f850 4f04 	ldr.w	r4, [r0, #4]!
}

inline uint32_t sqrt_uint32_approx(uint32_t in) __attribute__((always_inline,unused));
inline uint32_t sqrt_uint32_approx(uint32_t in)
{
	uint32_t n = sqrt_integer_guess_table[__builtin_clz(in)];
    6304:	fab4 f384 	clz	r3, r4
			sum[i] += magsq / naverage;
		}
	}
	if (++count == naverage) {
		count = 0;
		for (int i=0; i < 128; i++) {
    6308:	4281      	cmp	r1, r0
    630a:	f83e 2013 	ldrh.w	r2, [lr, r3, lsl #1]
	n = ((in / n) + n) / 2;
    630e:	fbb4 f3f2 	udiv	r3, r4, r2
    6312:	441a      	add	r2, r3
    6314:	ea4f 0352 	mov.w	r3, r2, lsr #1
	n = ((in / n) + n) / 2;
    6318:	fbb4 f4f3 	udiv	r4, r4, r3
    631c:	4423      	add	r3, r4
			output[i] = sqrt_uint32_approx(sum[i]);
    631e:	ea4f 0353 	mov.w	r3, r3, lsr #1
    6322:	f827 3f02 	strh.w	r3, [r7, #2]!
			sum[i] += magsq / naverage;
		}
	}
	if (++count == naverage) {
		count = 0;
		for (int i=0; i < 128; i++) {
    6326:	d1eb      	bne.n	6300 <AudioAnalyzeFFT256::update()+0xfc>
			output[i] = sqrt_uint32_approx(sum[i]);
		}
		outputflag = true;
    6328:	2301      	movs	r3, #1
    632a:	f885 3722 	strb.w	r3, [r5, #1826]	; 0x722
    632e:	e7c0      	b.n	62b2 <AudioAnalyzeFFT256::update()+0xae>
    6330:	0001226c 	.word	0x0001226c

00006334 <AudioAnalyzeNoteFrequency::available()>:
/**
 *  available
 *
 *  @return true if data is ready else false
 */
bool AudioAnalyzeNoteFrequency::available( void ) {
    6334:	4601      	mov	r1, r0
    __disable_irq( );
    6336:	b672      	cpsid	i
    bool flag = new_output;
    6338:	f641 028f 	movw	r2, #6287	; 0x188f
    633c:	5c83      	ldrb	r3, [r0, r2]
    if ( flag ) new_output = false;
    633e:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    6342:	b10b      	cbz	r3, 6348 <AudioAnalyzeNoteFrequency::available()+0x14>
    6344:	2300      	movs	r3, #0
    6346:	548b      	strb	r3, [r1, r2]
    __enable_irq( );
    6348:	b662      	cpsie	i
    return flag;
}
    634a:	4770      	bx	lr

0000634c <AudioAnalyzeNoteFrequency::read()>:
/**
 *  read processes the data samples for the Yin algorithm.
 *
 *  @return frequency in hertz
 */
float AudioAnalyzeNoteFrequency::read( void ) {
    634c:	b508      	push	{r3, lr}
    __disable_irq( );
    634e:	b672      	cpsid	i
    float d = data;
    6350:	f641 0388 	movw	r3, #6280	; 0x1888
    6354:	58c1      	ldr	r1, [r0, r3]
    __enable_irq( );
    6356:	b662      	cpsie	i
    return AUDIO_SAMPLE_RATE_EXACT / d;
    6358:	4801      	ldr	r0, [pc, #4]	; (6360 <AudioAnalyzeNoteFrequency::read()+0x14>)
    635a:	f007 f8b3 	bl	d4c4 <__aeabi_fdiv>
}
    635e:	bd08      	pop	{r3, pc}
    6360:	472c55a6 	.word	0x472c55a6

00006364 <AudioAnalyzeNoteFrequency::probability()>:
 *  Periodicity of the sampled signal from Yin algorithm from read function.
 *
 *  @return periodicity
 */
float AudioAnalyzeNoteFrequency::probability( void ) {
    __disable_irq( );
    6364:	b672      	cpsid	i
    float p = periodicity;
    6366:	f641 037c 	movw	r3, #6268	; 0x187c
    636a:	58c0      	ldr	r0, [r0, r3]
    __enable_irq( );
    636c:	b662      	cpsie	i
    return p;
}
    636e:	4770      	bx	lr

00006370 <AudioAnalyzePeak::update()>:

#include <Arduino.h>
#include "analyze_peak.h"

void AudioAnalyzePeak::update(void)
{
    6370:	b570      	push	{r4, r5, r6, lr}
	audio_block_t *block;
	const int16_t *p, *end;
	int32_t min, max;

	block = receiveReadOnly();
    6372:	2100      	movs	r1, #0

#include <Arduino.h>
#include "analyze_peak.h"

void AudioAnalyzePeak::update(void)
{
    6374:	4606      	mov	r6, r0
	audio_block_t *block;
	const int16_t *p, *end;
	int32_t min, max;

	block = receiveReadOnly();
    6376:	f002 fcdd 	bl	8d34 <AudioStream::receiveReadOnly(unsigned int)>
	if (!block) {
    637a:	b1c0      	cbz	r0, 63ae <AudioAnalyzePeak::update()+0x3e>
		return;
	}
	p = block->data;
	end = p + AUDIO_BLOCK_SAMPLES;
	min = min_sample;
    637c:	f9b6 401e 	ldrsh.w	r4, [r6, #30]
	max = max_sample;
    6380:	f9b6 1020 	ldrsh.w	r1, [r6, #32]

	block = receiveReadOnly();
	if (!block) {
		return;
	}
	p = block->data;
    6384:	1d03      	adds	r3, r0, #4
	end = p + AUDIO_BLOCK_SAMPLES;
    6386:	f500 7582 	add.w	r5, r0, #260	; 0x104
	max = max_sample;
	do {
		int16_t d=*p++;
		// TODO: can we speed this up with SSUB16 and SEL
		// http://www.m4-unleashed.com/parallel-comparison/
		if (d<min) min=d;
    638a:	f933 2b02 	ldrsh.w	r2, [r3], #2
    638e:	4294      	cmp	r4, r2
    6390:	bfa8      	it	ge
    6392:	4614      	movge	r4, r2
    6394:	4291      	cmp	r1, r2
    6396:	bfb8      	it	lt
    6398:	4611      	movlt	r1, r2
		if (d>max) max=d;
	} while (p < end);
    639a:	429d      	cmp	r5, r3
    639c:	d8f5      	bhi.n	638a <AudioAnalyzePeak::update()+0x1a>
	min_sample = min;
	max_sample = max;
	new_output = true;
    639e:	2301      	movs	r3, #1
		// TODO: can we speed this up with SSUB16 and SEL
		// http://www.m4-unleashed.com/parallel-comparison/
		if (d<min) min=d;
		if (d>max) max=d;
	} while (p < end);
	min_sample = min;
    63a0:	83f4      	strh	r4, [r6, #30]
	max_sample = max;
    63a2:	8431      	strh	r1, [r6, #32]
	new_output = true;
    63a4:	7733      	strb	r3, [r6, #28]
	release(block);
}
    63a6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		if (d>max) max=d;
	} while (p < end);
	min_sample = min;
	max_sample = max;
	new_output = true;
	release(block);
    63aa:	f002 bc7f 	b.w	8cac <AudioStream::release(audio_block_struct*)>
    63ae:	bd70      	pop	{r4, r5, r6, pc}

000063b0 <AudioAnalyzeRMS::update()>:
#include <Arduino.h>
#include "analyze_rms.h"
#include "utility/dspinst.h"

void AudioAnalyzeRMS::update(void)
{
    63b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	audio_block_t *block = receiveReadOnly();
    63b4:	2100      	movs	r1, #0
#include <Arduino.h>
#include "analyze_rms.h"
#include "utility/dspinst.h"

void AudioAnalyzeRMS::update(void)
{
    63b6:	4680      	mov	r8, r0
	audio_block_t *block = receiveReadOnly();
    63b8:	f002 fcbc 	bl	8d34 <AudioStream::receiveReadOnly(unsigned int)>
	if (!block) {
    63bc:	b1f8      	cbz	r0, 63fe <AudioAnalyzeRMS::update()+0x4e>
		return;
	}
#if defined(__ARM_ARCH_7EM__)
	uint32_t *p = (uint32_t *)(block->data);
	uint32_t *end = p + AUDIO_BLOCK_SAMPLES/2;
	int64_t sum = accum;
    63be:	e9d8 2308 	ldrd	r2, r3, [r8, #32]
	if (!block) {
		count++;
		return;
	}
#if defined(__ARM_ARCH_7EM__)
	uint32_t *p = (uint32_t *)(block->data);
    63c2:	1d01      	adds	r1, r0, #4
	uint32_t *end = p + AUDIO_BLOCK_SAMPLES/2;
    63c4:	f500 7e82 	add.w	lr, r0, #260	; 0x104
	int64_t sum = accum;
	do {
		uint32_t n1 = *p++;
    63c8:	680f      	ldr	r7, [r1, #0]
		uint32_t n2 = *p++;
    63ca:	684e      	ldr	r6, [r1, #4]
		uint32_t n3 = *p++;
    63cc:	688d      	ldr	r5, [r1, #8]
    63ce:	3110      	adds	r1, #16
		uint32_t n4 = *p++;
    63d0:	f851 4c04 	ldr.w	r4, [r1, #-4]
}

// // computes sum += ((a[15:0] * b[15:0]) + (a[31:16] * b[31:16]))
static inline int64_t multiply_accumulate_16tx16t_add_16bx16b(int64_t sum, uint32_t a, uint32_t b)
{
	asm volatile("smlald %Q0, %R0, %1, %2" : "+r" (sum) : "r" (a), "r" (b));
    63d4:	fbc7 23c7 	smlald	r2, r3, r7, r7
    63d8:	fbc6 23c6 	smlald	r2, r3, r6, r6
    63dc:	fbc5 23c5 	smlald	r2, r3, r5, r5
    63e0:	fbc4 23c4 	smlald	r2, r3, r4, r4
		sum = multiply_accumulate_16tx16t_add_16bx16b(sum, n1, n1);
		sum = multiply_accumulate_16tx16t_add_16bx16b(sum, n2, n2);
		sum = multiply_accumulate_16tx16t_add_16bx16b(sum, n3, n3);
		sum = multiply_accumulate_16tx16t_add_16bx16b(sum, n4, n4);
	} while (p < end);
    63e4:	458e      	cmp	lr, r1
    63e6:	d8ef      	bhi.n	63c8 <AudioAnalyzeRMS::update()+0x18>
	accum = sum;
	count++;
    63e8:	f8d8 1028 	ldr.w	r1, [r8, #40]	; 0x28
    63ec:	3101      	adds	r1, #1
		sum = multiply_accumulate_16tx16t_add_16bx16b(sum, n1, n1);
		sum = multiply_accumulate_16tx16t_add_16bx16b(sum, n2, n2);
		sum = multiply_accumulate_16tx16t_add_16bx16b(sum, n3, n3);
		sum = multiply_accumulate_16tx16t_add_16bx16b(sum, n4, n4);
	} while (p < end);
	accum = sum;
    63ee:	e9c8 2308 	strd	r2, r3, [r8, #32]
	count++;
    63f2:	f8c8 1028 	str.w	r1, [r8, #40]	; 0x28
	} while (p < end);
	accum = sum;
	count++;
#endif
	release(block);
}
    63f6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		sum += n * n;
	} while (p < end);
	accum = sum;
	count++;
#endif
	release(block);
    63fa:	f002 bc57 	b.w	8cac <AudioStream::release(audio_block_struct*)>

void AudioAnalyzeRMS::update(void)
{
	audio_block_t *block = receiveReadOnly();
	if (!block) {
		count++;
    63fe:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
    6402:	3301      	adds	r3, #1
    6404:	f8c8 3028 	str.w	r3, [r8, #40]	; 0x28
		return;
    6408:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000640c <AudioAnalyzeRMS::read()>:
#endif
	release(block);
}

float AudioAnalyzeRMS::read(void)
{
    640c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__disable_irq();
    640e:	b672      	cpsid	i
	int64_t sum = accum;
	accum = 0;
    6410:	2600      	movs	r6, #0
    6412:	2700      	movs	r7, #0
	uint32_t num = count;
	count = 0;
    6414:	2300      	movs	r3, #0
}

float AudioAnalyzeRMS::read(void)
{
	__disable_irq();
	int64_t sum = accum;
    6416:	e9d0 4508 	ldrd	r4, r5, [r0, #32]
	accum = 0;
	uint32_t num = count;
    641a:	6a82      	ldr	r2, [r0, #40]	; 0x28
	count = 0;
    641c:	6283      	str	r3, [r0, #40]	; 0x28

float AudioAnalyzeRMS::read(void)
{
	__disable_irq();
	int64_t sum = accum;
	accum = 0;
    641e:	e9c0 6708 	strd	r6, r7, [r0, #32]
	uint32_t num = count;
	count = 0;
	__enable_irq();
    6422:	b662      	cpsie	i
	float meansq = sum / (num * AUDIO_BLOCK_SAMPLES);
	// TODO: shift down to 32 bits and use sqrt_uint32
	//       but is that really any more efficient?
	return sqrtf(meansq) / 32767.0;
    6424:	01d2      	lsls	r2, r2, #7
    6426:	4620      	mov	r0, r4
    6428:	4629      	mov	r1, r5
    642a:	f007 f999 	bl	d760 <__aeabi_ldivmod>
    642e:	f006 ff57 	bl	d2e0 <__aeabi_l2f>
    6432:	f006 f8e1 	bl	c5f8 <sqrtf>
    6436:	4902      	ldr	r1, [pc, #8]	; (6440 <AudioAnalyzeRMS::read()+0x34>)
    6438:	f007 f844 	bl	d4c4 <__aeabi_fdiv>
}
    643c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    643e:	bf00      	nop
    6440:	46fffe00 	.word	0x46fffe00

00006444 <AudioAnalyzeToneDetect::read()>:
	__enable_irq();
	//Serial.printf("Tone: coef=%d, ncycles=%d, length=%d\n", coefficient, ncycles, length);
}

float AudioAnalyzeToneDetect::read(void)
{
    6444:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	int32_t coef, q1, q2, power;
	uint16_t len;

	__disable_irq();
    6448:	b672      	cpsid	i
	coef = coefficient;
    644a:	6987      	ldr	r7, [r0, #24]
	q1 = out1;
    644c:	6a42      	ldr	r2, [r0, #36]	; 0x24
	q2 = out2;
    644e:	6a85      	ldr	r5, [r0, #40]	; 0x28
	len = length;
    6450:	8d84      	ldrh	r4, [r0, #44]	; 0x2c
	__enable_irq();
    6452:	b662      	cpsie	i
	power64 = (int64_t)q2 * (int64_t)q2;
	power64 += (int64_t)q1 * (int64_t)q1;
	power64 -= (((int64_t)q1 * (int64_t)q2) >> 30) * (int64_t)coef;
	power = power64 >> 28;
#endif
	return sqrtf((float)power) / (float)len;
    6454:	fb85 0102 	smull	r0, r1, r5, r2
    6458:	0f83      	lsrs	r3, r0, #30
    645a:	ea43 0381 	orr.w	r3, r3, r1, lsl #2
    645e:	ea4f 79e7 	mov.w	r9, r7, asr #31
    6462:	fb03 f609 	mul.w	r6, r3, r9
    6466:	1789      	asrs	r1, r1, #30
    6468:	fb07 6601 	mla	r6, r7, r1, r6
    646c:	fba3 0107 	umull	r0, r1, r3, r7
		multiply_32x32_rshift30(q1, q2), coef);
	power <<= 4;
#else
	int64_t power64;
	power64 = (int64_t)q2 * (int64_t)q2;
	power64 += (int64_t)q1 * (int64_t)q1;
    6470:	fb82 2302 	smull	r2, r3, r2, r2
    6474:	fbc5 2305 	smlal	r2, r3, r5, r5
	power64 -= (((int64_t)q1 * (int64_t)q2) >> 30) * (int64_t)coef;
	power = power64 >> 28;
#endif
	return sqrtf((float)power) / (float)len;
    6478:	4431      	add	r1, r6
    647a:	1a12      	subs	r2, r2, r0
    647c:	eb63 0301 	sbc.w	r3, r3, r1
    6480:	0f10      	lsrs	r0, r2, #28
    6482:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
    6486:	f006 ff15 	bl	d2b4 <__aeabi_i2f>
    648a:	f006 f8b5 	bl	c5f8 <sqrtf>
    648e:	4605      	mov	r5, r0
    6490:	4620      	mov	r0, r4
    6492:	f006 ff0b 	bl	d2ac <__aeabi_ui2f>
    6496:	4601      	mov	r1, r0
    6498:	4628      	mov	r0, r5
    649a:	f007 f813 	bl	d4c4 <__aeabi_fdiv>
}
    649e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    64a2:	bf00      	nop

000064a4 <AudioFilterBiquad::update()>:
#include "utility/dspinst.h"

#if defined(__ARM_ARCH_7EM__)

void AudioFilterBiquad::update(void)
{
    64a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    64a8:	b083      	sub	sp, #12
	audio_block_t *block;
	int32_t b0, b1, b2, a1, a2, sum;
	uint32_t in2, out2, bprev, aprev, flag;
	uint32_t *data, *end;
	int32_t *state;
	block = receiveWritable();
    64aa:	2100      	movs	r1, #0
#include "utility/dspinst.h"

#if defined(__ARM_ARCH_7EM__)

void AudioFilterBiquad::update(void)
{
    64ac:	4604      	mov	r4, r0
    64ae:	9000      	str	r0, [sp, #0]
	audio_block_t *block;
	int32_t b0, b1, b2, a1, a2, sum;
	uint32_t in2, out2, bprev, aprev, flag;
	uint32_t *data, *end;
	int32_t *state;
	block = receiveWritable();
    64b0:	f002 fc4c 	bl	8d4c <AudioStream::receiveWritable(unsigned int)>
	if (!block) return;
    64b4:	9001      	str	r0, [sp, #4]
    64b6:	2800      	cmp	r0, #0
    64b8:	d05e      	beq.n	6578 <AudioFilterBiquad::update()+0xd4>
	end = (uint32_t *)(block->data) + AUDIO_BLOCK_SAMPLES/2;
    64ba:	f500 7982 	add.w	r9, r0, #260	; 0x104
    64be:	f100 0a04 	add.w	sl, r0, #4
    64c2:	f104 0838 	add.w	r8, r4, #56	; 0x38
	state = (int32_t *)definition;
	do {
		b0 = *state++;
		b1 = *state++;
		b2 = *state++;
    64c6:	f1a8 0b20 	sub.w	fp, r8, #32
		a1 = *state++;
		a2 = *state++;
		bprev = *state++;
		aprev = *state++;
		sum = *state & 0x3FFF;
    64ca:	f858 2c04 	ldr.w	r2, [r8, #-4]
		b0 = *state++;
		b1 = *state++;
		b2 = *state++;
		a1 = *state++;
		a2 = *state++;
		bprev = *state++;
    64ce:	f858 4c0c 	ldr.w	r4, [r8, #-12]
	do {
		b0 = *state++;
		b1 = *state++;
		b2 = *state++;
		a1 = *state++;
		a2 = *state++;
    64d2:	f858 6c10 	ldr.w	r6, [r8, #-16]
	state = (int32_t *)definition;
	do {
		b0 = *state++;
		b1 = *state++;
		b2 = *state++;
		a1 = *state++;
    64d6:	f858 7c14 	ldr.w	r7, [r8, #-20]
		a2 = *state++;
		bprev = *state++;
		aprev = *state++;
    64da:	f858 1c08 	ldr.w	r1, [r8, #-8]
	end = (uint32_t *)(block->data) + AUDIO_BLOCK_SAMPLES/2;
	state = (int32_t *)definition;
	do {
		b0 = *state++;
		b1 = *state++;
		b2 = *state++;
    64de:	e89b 5800 	ldmia.w	fp, {fp, ip, lr}
		a1 = *state++;
		a2 = *state++;
		bprev = *state++;
		aprev = *state++;
		sum = *state & 0x3FFF;
    64e2:	f3c2 030d 	ubfx	r3, r2, #0, #14
		data = end - AUDIO_BLOCK_SAMPLES/2;
    64e6:	4655      	mov	r5, sl
    64e8:	461a      	mov	r2, r3
    64ea:	4623      	mov	r3, r4
    64ec:	4654      	mov	r4, sl
    64ee:	46c2      	mov	sl, r8
    64f0:	46b0      	mov	r8, r6
		do {
			in2 = *data;
    64f2:	6828      	ldr	r0, [r5, #0]
// computes (sum + ((a[31:0] * b[15:0]) >> 16))
static inline int32_t signed_multiply_accumulate_32x16b(int32_t sum, int32_t a, uint32_t b) __attribute__((always_inline, unused));
static inline int32_t signed_multiply_accumulate_32x16b(int32_t sum, int32_t a, uint32_t b)
{
	int32_t out;
	asm volatile("smlawb %0, %2, %3, %1" : "=r" (out) : "r" (sum), "r" (a), "r" (b));
    64f4:	fb3b 2200 	smlawb	r2, fp, r0, r2
// computes (sum + ((a[31:0] * b[31:16]) >> 16))
static inline int32_t signed_multiply_accumulate_32x16t(int32_t sum, int32_t a, uint32_t b) __attribute__((always_inline, unused));
static inline int32_t signed_multiply_accumulate_32x16t(int32_t sum, int32_t a, uint32_t b)
{
	int32_t out;
	asm volatile("smlawt %0, %2, %3, %1" : "=r" (out) : "r" (sum), "r" (a), "r" (b));
    64f8:	fb3c 2213 	smlawt	r2, ip, r3, r2
// computes (sum + ((a[31:0] * b[15:0]) >> 16))
static inline int32_t signed_multiply_accumulate_32x16b(int32_t sum, int32_t a, uint32_t b) __attribute__((always_inline, unused));
static inline int32_t signed_multiply_accumulate_32x16b(int32_t sum, int32_t a, uint32_t b)
{
	int32_t out;
	asm volatile("smlawb %0, %2, %3, %1" : "=r" (out) : "r" (sum), "r" (a), "r" (b));
    64fc:	fb3e 2203 	smlawb	r2, lr, r3, r2
// computes (sum + ((a[31:0] * b[31:16]) >> 16))
static inline int32_t signed_multiply_accumulate_32x16t(int32_t sum, int32_t a, uint32_t b) __attribute__((always_inline, unused));
static inline int32_t signed_multiply_accumulate_32x16t(int32_t sum, int32_t a, uint32_t b)
{
	int32_t out;
	asm volatile("smlawt %0, %2, %3, %1" : "=r" (out) : "r" (sum), "r" (a), "r" (b));
    6500:	fb37 2211 	smlawt	r2, r7, r1, r2
// computes (sum + ((a[31:0] * b[15:0]) >> 16))
static inline int32_t signed_multiply_accumulate_32x16b(int32_t sum, int32_t a, uint32_t b) __attribute__((always_inline, unused));
static inline int32_t signed_multiply_accumulate_32x16b(int32_t sum, int32_t a, uint32_t b)
{
	int32_t out;
	asm volatile("smlawb %0, %2, %3, %1" : "=r" (out) : "r" (sum), "r" (a), "r" (b));
    6504:	fb38 2201 	smlawb	r2, r8, r1, r2
static inline int32_t signed_saturate_rshift(int32_t val, int bits, int rshift) __attribute__((always_inline, unused));
static inline int32_t signed_saturate_rshift(int32_t val, int bits, int rshift)
{
#if defined (__ARM_ARCH_7EM__)
	int32_t out;
	asm volatile("ssat %0, %1, %2, asr %3" : "=r" (out) : "I" (bits), "r" (val), "I" (rshift));
    6508:	f322 368f 	ssat	r6, #16, r2, asr #14
			sum = signed_multiply_accumulate_32x16t(sum, b1, bprev);
			sum = signed_multiply_accumulate_32x16b(sum, b2, bprev);
			sum = signed_multiply_accumulate_32x16t(sum, a1, aprev);
			sum = signed_multiply_accumulate_32x16b(sum, a2, aprev);
			out2 = signed_saturate_rshift(sum, 16, 14);
			sum &= 0x3FFF;
    650c:	f3c2 020d 	ubfx	r2, r2, #0, #14
// computes (sum + ((a[31:0] * b[31:16]) >> 16))
static inline int32_t signed_multiply_accumulate_32x16t(int32_t sum, int32_t a, uint32_t b) __attribute__((always_inline, unused));
static inline int32_t signed_multiply_accumulate_32x16t(int32_t sum, int32_t a, uint32_t b)
{
	int32_t out;
	asm volatile("smlawt %0, %2, %3, %1" : "=r" (out) : "r" (sum), "r" (a), "r" (b));
    6510:	fb3b 2210 	smlawt	r2, fp, r0, r2
// computes (sum + ((a[31:0] * b[15:0]) >> 16))
static inline int32_t signed_multiply_accumulate_32x16b(int32_t sum, int32_t a, uint32_t b) __attribute__((always_inline, unused));
static inline int32_t signed_multiply_accumulate_32x16b(int32_t sum, int32_t a, uint32_t b)
{
	int32_t out;
	asm volatile("smlawb %0, %2, %3, %1" : "=r" (out) : "r" (sum), "r" (a), "r" (b));
    6514:	fb3c 2200 	smlawb	r2, ip, r0, r2
// computes (sum + ((a[31:0] * b[31:16]) >> 16))
static inline int32_t signed_multiply_accumulate_32x16t(int32_t sum, int32_t a, uint32_t b) __attribute__((always_inline, unused));
static inline int32_t signed_multiply_accumulate_32x16t(int32_t sum, int32_t a, uint32_t b)
{
	int32_t out;
	asm volatile("smlawt %0, %2, %3, %1" : "=r" (out) : "r" (sum), "r" (a), "r" (b));
    6518:	fb3e 2313 	smlawt	r3, lr, r3, r2
// computes (sum + ((a[31:0] * b[15:0]) >> 16))
static inline int32_t signed_multiply_accumulate_32x16b(int32_t sum, int32_t a, uint32_t b) __attribute__((always_inline, unused));
static inline int32_t signed_multiply_accumulate_32x16b(int32_t sum, int32_t a, uint32_t b)
{
	int32_t out;
	asm volatile("smlawb %0, %2, %3, %1" : "=r" (out) : "r" (sum), "r" (a), "r" (b));
    651c:	fb37 3306 	smlawb	r3, r7, r6, r3
// computes (sum + ((a[31:0] * b[31:16]) >> 16))
static inline int32_t signed_multiply_accumulate_32x16t(int32_t sum, int32_t a, uint32_t b) __attribute__((always_inline, unused));
static inline int32_t signed_multiply_accumulate_32x16t(int32_t sum, int32_t a, uint32_t b)
{
	int32_t out;
	asm volatile("smlawt %0, %2, %3, %1" : "=r" (out) : "r" (sum), "r" (a), "r" (b));
    6520:	fb38 3311 	smlawt	r3, r8, r1, r3
static inline int32_t signed_saturate_rshift(int32_t val, int bits, int rshift) __attribute__((always_inline, unused));
static inline int32_t signed_saturate_rshift(int32_t val, int bits, int rshift)
{
#if defined (__ARM_ARCH_7EM__)
	int32_t out;
	asm volatile("ssat %0, %1, %2, asr %3" : "=r" (out) : "I" (bits), "r" (val), "I" (rshift));
    6524:	f323 318f 	ssat	r1, #16, r3, asr #14
static inline uint32_t pack_16b_16b(int32_t a, int32_t b) __attribute__((always_inline, unused));
static inline uint32_t pack_16b_16b(int32_t a, int32_t b)
{
#if defined (__ARM_ARCH_7EM__)
	int32_t out;
	asm volatile("pkhbt %0, %1, %2, lsl #16" : "=r" (out) : "r" (b), "r" (a));
    6528:	eac6 4101 	pkhbt	r1, r6, r1, lsl #16
			// http://www.earlevel.com/main/2003/02/28/biquads/
			//  TODO: is logical AND really correct, or maybe it
			//        should really be signed_saturate_rshift() ???
			sum &= 0x3FFF;
			bprev = in2;
			*data++ = aprev;
    652c:	f845 1b04 	str.w	r1, [r5], #4
		} while (data < end);
    6530:	45a9      	cmp	r9, r5
			// retaining part of the sum is meant to implement the
			// "first order noise shaping" described in this article:
			// http://www.earlevel.com/main/2003/02/28/biquads/
			//  TODO: is logical AND really correct, or maybe it
			//        should really be signed_saturate_rshift() ???
			sum &= 0x3FFF;
    6532:	f3c3 020d 	ubfx	r2, r3, #0, #14
		bprev = *state++;
		aprev = *state++;
		sum = *state & 0x3FFF;
		data = end - AUDIO_BLOCK_SAMPLES/2;
		do {
			in2 = *data;
    6536:	4603      	mov	r3, r0
			//  TODO: is logical AND really correct, or maybe it
			//        should really be signed_saturate_rshift() ???
			sum &= 0x3FFF;
			bprev = in2;
			*data++ = aprev;
		} while (data < end);
    6538:	d8db      	bhi.n	64f2 <AudioFilterBiquad::update()+0x4e>
    653a:	46d0      	mov	r8, sl
    653c:	46a2      	mov	sl, r4
    653e:	4604      	mov	r4, r0
		flag = *state & 0x80000000;
    6540:	f858 0c04 	ldr.w	r0, [r8, #-4]
		*state++ = sum | flag;
		*(state-2) = aprev;
    6544:	f848 1c08 	str.w	r1, [r8, #-8]
    6548:	4613      	mov	r3, r2
			//        should really be signed_saturate_rshift() ???
			sum &= 0x3FFF;
			bprev = in2;
			*data++ = aprev;
		} while (data < end);
		flag = *state & 0x80000000;
    654a:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
		*state++ = sum | flag;
    654e:	4303      	orrs	r3, r0
		*(state-2) = aprev;
		*(state-3) = bprev;
    6550:	f848 4c0c 	str.w	r4, [r8, #-12]
			sum &= 0x3FFF;
			bprev = in2;
			*data++ = aprev;
		} while (data < end);
		flag = *state & 0x80000000;
		*state++ = sum | flag;
    6554:	f848 3c04 	str.w	r3, [r8, #-4]
    6558:	f108 0820 	add.w	r8, r8, #32
	int32_t *state;
	block = receiveWritable();
	if (!block) return;
	end = (uint32_t *)(block->data) + AUDIO_BLOCK_SAMPLES/2;
	state = (int32_t *)definition;
	do {
    655c:	2800      	cmp	r0, #0
    655e:	d1b2      	bne.n	64c6 <AudioFilterBiquad::update()+0x22>
		flag = *state & 0x80000000;
		*state++ = sum | flag;
		*(state-2) = aprev;
		*(state-3) = bprev;
	} while (flag);
	transmit(block);
    6560:	4602      	mov	r2, r0
    6562:	e89d 0011 	ldmia.w	sp, {r0, r4}
    6566:	4621      	mov	r1, r4
    6568:	f002 fbca 	bl	8d00 <AudioStream::transmit(audio_block_struct*, unsigned char)>
	release(block);
    656c:	4620      	mov	r0, r4
}
    656e:	b003      	add	sp, #12
    6570:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		*state++ = sum | flag;
		*(state-2) = aprev;
		*(state-3) = bprev;
	} while (flag);
	transmit(block);
	release(block);
    6574:	f002 bb9a 	b.w	8cac <AudioStream::release(audio_block_struct*)>
}
    6578:	b003      	add	sp, #12
    657a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    657e:	bf00      	nop

00006580 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)>:

void AudioFilterBiquad::setCoefficients(uint32_t stage, const int *coefficients)
{
	if (stage >= 4) return;
    6580:	2903      	cmp	r1, #3
    6582:	d817      	bhi.n	65b4 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)+0x34>
	transmit(block);
	release(block);
}

void AudioFilterBiquad::setCoefficients(uint32_t stage, const int *coefficients)
{
    6584:	b470      	push	{r4, r5, r6}
	if (stage >= 4) return;
	int32_t *dest = definition + (stage << 3);
    6586:	3018      	adds	r0, #24
    6588:	014c      	lsls	r4, r1, #5
    658a:	1903      	adds	r3, r0, r4
	__disable_irq();
    658c:	b672      	cpsid	i
	if (stage > 0) *(dest - 1) |= 0x80000000;
    658e:	b991      	cbnz	r1, 65b6 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)+0x36>
	*dest++ = *coefficients++;
    6590:	6811      	ldr	r1, [r2, #0]
    6592:	5101      	str	r1, [r0, r4]
	*dest++ = *coefficients++;
	*dest++ = *coefficients++;
	*dest++ = *coefficients++ * -1;
    6594:	68d0      	ldr	r0, [r2, #12]
	*dest++ = *coefficients++ * -1;
    6596:	6911      	ldr	r1, [r2, #16]
	//*dest++ = 0;
	//*dest++ = 0;  // clearing filter state causes loud pop
	dest += 2;
	*dest   &= 0x80000000;
    6598:	69dc      	ldr	r4, [r3, #28]
	if (stage >= 4) return;
	int32_t *dest = definition + (stage << 3);
	__disable_irq();
	if (stage > 0) *(dest - 1) |= 0x80000000;
	*dest++ = *coefficients++;
	*dest++ = *coefficients++;
    659a:	6856      	ldr	r6, [r2, #4]
	*dest++ = *coefficients++;
    659c:	6895      	ldr	r5, [r2, #8]
    659e:	609d      	str	r5, [r3, #8]
	*dest++ = *coefficients++ * -1;
	*dest++ = *coefficients++ * -1;
	//*dest++ = 0;
	//*dest++ = 0;  // clearing filter state causes loud pop
	dest += 2;
	*dest   &= 0x80000000;
    65a0:	f004 4400 	and.w	r4, r4, #2147483648	; 0x80000000
	__disable_irq();
	if (stage > 0) *(dest - 1) |= 0x80000000;
	*dest++ = *coefficients++;
	*dest++ = *coefficients++;
	*dest++ = *coefficients++;
	*dest++ = *coefficients++ * -1;
    65a4:	4240      	negs	r0, r0
	*dest++ = *coefficients++ * -1;
    65a6:	424a      	negs	r2, r1
	if (stage >= 4) return;
	int32_t *dest = definition + (stage << 3);
	__disable_irq();
	if (stage > 0) *(dest - 1) |= 0x80000000;
	*dest++ = *coefficients++;
	*dest++ = *coefficients++;
    65a8:	605e      	str	r6, [r3, #4]
	*dest++ = *coefficients++ * -1;
	*dest++ = *coefficients++ * -1;
	//*dest++ = 0;
	//*dest++ = 0;  // clearing filter state causes loud pop
	dest += 2;
	*dest   &= 0x80000000;
    65aa:	61dc      	str	r4, [r3, #28]
	__disable_irq();
	if (stage > 0) *(dest - 1) |= 0x80000000;
	*dest++ = *coefficients++;
	*dest++ = *coefficients++;
	*dest++ = *coefficients++;
	*dest++ = *coefficients++ * -1;
    65ac:	60d8      	str	r0, [r3, #12]
	*dest++ = *coefficients++ * -1;
    65ae:	611a      	str	r2, [r3, #16]
	//*dest++ = 0;
	//*dest++ = 0;  // clearing filter state causes loud pop
	dest += 2;
	*dest   &= 0x80000000;
	__enable_irq();
    65b0:	b662      	cpsie	i
}
    65b2:	bc70      	pop	{r4, r5, r6}
    65b4:	4770      	bx	lr
void AudioFilterBiquad::setCoefficients(uint32_t stage, const int *coefficients)
{
	if (stage >= 4) return;
	int32_t *dest = definition + (stage << 3);
	__disable_irq();
	if (stage > 0) *(dest - 1) |= 0x80000000;
    65b6:	f853 1c04 	ldr.w	r1, [r3, #-4]
    65ba:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
    65be:	f843 1c04 	str.w	r1, [r3, #-4]
    65c2:	e7e5      	b.n	6590 <AudioFilterBiquad::setCoefficients(unsigned long, int const*)+0x10>

000065c4 <DMAChannel::~DMAChannel()>:
	}
	DMAChannel & operator = (const DMASetting &rhs) {
		copy_tcd(TCD, rhs.TCD);
		return *this;
	}
	~DMAChannel() {
    65c4:	b510      	push	{r4, lr}
    65c6:	4604      	mov	r4, r0
		release();
    65c8:	f002 fd12 	bl	8ff0 <DMAChannel::release()>
	}
    65cc:	4620      	mov	r0, r4
    65ce:	bd10      	pop	{r4, pc}

000065d0 <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE>:
uint16_t AudioInputAnalog::block_offset = 0;
int32_t AudioInputAnalog::hpf_y1 = 0;
int32_t AudioInputAnalog::hpf_x1 = 0;

bool AudioInputAnalog::update_responsibility = false;
DMAChannel AudioInputAnalog::dma(false);
    65d0:	4a02      	ldr	r2, [pc, #8]	; (65dc <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE+0xc>)
    65d2:	4903      	ldr	r1, [pc, #12]	; (65e0 <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE+0x10>)
    65d4:	4803      	ldr	r0, [pc, #12]	; (65e4 <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE+0x14>)
    65d6:	f007 ba87 	b.w	dae8 <__aeabi_atexit>
    65da:	bf00      	nop
    65dc:	1fffb874 	.word	0x1fffb874
    65e0:	000065c5 	.word	0x000065c5
    65e4:	200040a4 	.word	0x200040a4

000065e8 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE>:
        while (1) {
                if ((ADC1_SC1A & ADC_SC1_COCO)) {
                        return ADC1_RA;
                }
        }
}
    65e8:	b538      	push	{r3, r4, r5, lr}
uint16_t AudioInputAnalogStereo::offset_left = 0;
uint16_t AudioInputAnalogStereo::offset_right = 0;
int32_t AudioInputAnalogStereo::hpf_y1[2] = { 0, 0 };
int32_t AudioInputAnalogStereo::hpf_x1[2] = { 0, 0 };
bool AudioInputAnalogStereo::update_responsibility = false;
DMAChannel AudioInputAnalogStereo::dma0(false);
    65ea:	4d07      	ldr	r5, [pc, #28]	; (6608 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x20>)
    65ec:	4c07      	ldr	r4, [pc, #28]	; (660c <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x24>)
    65ee:	4808      	ldr	r0, [pc, #32]	; (6610 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x28>)
    65f0:	462a      	mov	r2, r5
    65f2:	4621      	mov	r1, r4
    65f4:	f007 fa78 	bl	dae8 <__aeabi_atexit>
DMAChannel AudioInputAnalogStereo::dma1(false);
    65f8:	462a      	mov	r2, r5
    65fa:	4621      	mov	r1, r4
    65fc:	4805      	ldr	r0, [pc, #20]	; (6614 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x2c>)
        while (1) {
                if ((ADC1_SC1A & ADC_SC1_COCO)) {
                        return ADC1_RA;
                }
        }
}
    65fe:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
uint16_t AudioInputAnalogStereo::offset_right = 0;
int32_t AudioInputAnalogStereo::hpf_y1[2] = { 0, 0 };
int32_t AudioInputAnalogStereo::hpf_x1[2] = { 0, 0 };
bool AudioInputAnalogStereo::update_responsibility = false;
DMAChannel AudioInputAnalogStereo::dma0(false);
DMAChannel AudioInputAnalogStereo::dma1(false);
    6602:	f007 ba71 	b.w	dae8 <__aeabi_atexit>
    6606:	bf00      	nop
    6608:	1fffb874 	.word	0x1fffb874
    660c:	000065c5 	.word	0x000065c5
    6610:	200040ac 	.word	0x200040ac
    6614:	200040b4 	.word	0x200040b4

00006618 <AudioInputI2S::isr()>:
	const int16_t *src, *end;
	int16_t *dest_left, *dest_right;
	audio_block_t *left, *right;

#if defined(KINETISK) || defined(__IMXRT1062__)
	daddr = (uint32_t)(dma.TCD->DADDR);
    6618:	4a1b      	ldr	r2, [pc, #108]	; (6688 <AudioInputI2S::isr()+0x70>)
#endif
	dma.clearInterrupt();
	//Serial.println("isr");

	if (daddr < (uint32_t)i2s_rx_buffer + sizeof(i2s_rx_buffer) / 2) {
    661a:	4b1c      	ldr	r3, [pc, #112]	; (668c <AudioInputI2S::isr()+0x74>)
	const int16_t *src, *end;
	int16_t *dest_left, *dest_right;
	audio_block_t *left, *right;

#if defined(KINETISK) || defined(__IMXRT1062__)
	daddr = (uint32_t)(dma.TCD->DADDR);
    661c:	6811      	ldr	r1, [r2, #0]
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
    661e:	481c      	ldr	r0, [pc, #112]	; (6690 <AudioInputI2S::isr()+0x78>)
    6620:	6909      	ldr	r1, [r1, #16]
	dma.enable();
	dma.attachInterrupt(isr);
}

void AudioInputI2S::isr(void)
{
    6622:	b470      	push	{r4, r5, r6}
	daddr = (uint32_t)(dma.TCD->DADDR);
#endif
	dma.clearInterrupt();
	//Serial.println("isr");

	if (daddr < (uint32_t)i2s_rx_buffer + sizeof(i2s_rx_buffer) / 2) {
    6624:	4299      	cmp	r1, r3
    6626:	7912      	ldrb	r2, [r2, #4]
    6628:	7002      	strb	r2, [r0, #0]
    662a:	d209      	bcs.n	6640 <AudioInputI2S::isr()+0x28>
		// DMA is receiving to the first half of the buffer
		// need to remove data from the second half
		src = (int16_t *)&i2s_rx_buffer[AUDIO_BLOCK_SAMPLES/2];
		end = (int16_t *)&i2s_rx_buffer[AUDIO_BLOCK_SAMPLES];
		if (AudioInputI2S::update_responsibility) AudioStream::update_all();
    662c:	4a19      	ldr	r2, [pc, #100]	; (6694 <AudioInputI2S::isr()+0x7c>)
    662e:	7812      	ldrb	r2, [r2, #0]
    6630:	b332      	cbz	r2, 6680 <AudioInputI2S::isr()+0x68>
	void transmit(audio_block_t *block, unsigned char index = 0);
	audio_block_t * receiveReadOnly(unsigned int index = 0);
	audio_block_t * receiveWritable(unsigned int index = 0);
	static bool update_setup(void);
	static void update_stop(void);
	static void update_all(void) { NVIC_SET_PENDING(IRQ_SOFTWARE); }
    6632:	4a19      	ldr	r2, [pc, #100]	; (6698 <AudioInputI2S::isr()+0x80>)
    6634:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    6638:	6011      	str	r1, [r2, #0]

	if (daddr < (uint32_t)i2s_rx_buffer + sizeof(i2s_rx_buffer) / 2) {
		// DMA is receiving to the first half of the buffer
		// need to remove data from the second half
		src = (int16_t *)&i2s_rx_buffer[AUDIO_BLOCK_SAMPLES/2];
		end = (int16_t *)&i2s_rx_buffer[AUDIO_BLOCK_SAMPLES];
    663a:	f503 7480 	add.w	r4, r3, #256	; 0x100
    663e:	e002      	b.n	6646 <AudioInputI2S::isr()+0x2e>
		if (AudioInputI2S::update_responsibility) AudioStream::update_all();
	} else {
		// DMA is receiving to the second half of the buffer
		// need to remove data from the first half
		src = (int16_t *)&i2s_rx_buffer[0];
		end = (int16_t *)&i2s_rx_buffer[AUDIO_BLOCK_SAMPLES/2];
    6640:	461c      	mov	r4, r3
		end = (int16_t *)&i2s_rx_buffer[AUDIO_BLOCK_SAMPLES];
		if (AudioInputI2S::update_responsibility) AudioStream::update_all();
	} else {
		// DMA is receiving to the second half of the buffer
		// need to remove data from the first half
		src = (int16_t *)&i2s_rx_buffer[0];
    6642:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
		end = (int16_t *)&i2s_rx_buffer[AUDIO_BLOCK_SAMPLES/2];
	}
	left = AudioInputI2S::block_left;
    6646:	4a15      	ldr	r2, [pc, #84]	; (669c <AudioInputI2S::isr()+0x84>)
	right = AudioInputI2S::block_right;
    6648:	4915      	ldr	r1, [pc, #84]	; (66a0 <AudioInputI2S::isr()+0x88>)
		// DMA is receiving to the second half of the buffer
		// need to remove data from the first half
		src = (int16_t *)&i2s_rx_buffer[0];
		end = (int16_t *)&i2s_rx_buffer[AUDIO_BLOCK_SAMPLES/2];
	}
	left = AudioInputI2S::block_left;
    664a:	6812      	ldr	r2, [r2, #0]
	right = AudioInputI2S::block_right;
    664c:	680d      	ldr	r5, [r1, #0]
	if (left != NULL && right != NULL) {
    664e:	b1aa      	cbz	r2, 667c <AudioInputI2S::isr()+0x64>
    6650:	b1a5      	cbz	r5, 667c <AudioInputI2S::isr()+0x64>
		offset = AudioInputI2S::block_offset;
    6652:	4e14      	ldr	r6, [pc, #80]	; (66a4 <AudioInputI2S::isr()+0x8c>)
    6654:	8830      	ldrh	r0, [r6, #0]
		if (offset <= AUDIO_BLOCK_SAMPLES/2) {
    6656:	2840      	cmp	r0, #64	; 0x40
    6658:	d810      	bhi.n	667c <AudioInputI2S::isr()+0x64>
			dest_left = &(left->data[offset]);
    665a:	0041      	lsls	r1, r0, #1
    665c:	440a      	add	r2, r1
			dest_right = &(right->data[offset]);
			AudioInputI2S::block_offset = offset + AUDIO_BLOCK_SAMPLES/2;
    665e:	3040      	adds	r0, #64	; 0x40
	right = AudioInputI2S::block_right;
	if (left != NULL && right != NULL) {
		offset = AudioInputI2S::block_offset;
		if (offset <= AUDIO_BLOCK_SAMPLES/2) {
			dest_left = &(left->data[offset]);
			dest_right = &(right->data[offset]);
    6660:	4429      	add	r1, r5
    6662:	3202      	adds	r2, #2
    6664:	3102      	adds	r1, #2
			AudioInputI2S::block_offset = offset + AUDIO_BLOCK_SAMPLES/2;
    6666:	8030      	strh	r0, [r6, #0]
			do {
				//Serial.println(*src);
				//n = *src++;
				//*dest_left++ = (int16_t)n;
				//*dest_right++ = (int16_t)(n >> 16);
				*dest_left++ = *src++;
    6668:	f933 0b04 	ldrsh.w	r0, [r3], #4
    666c:	f822 0f02 	strh.w	r0, [r2, #2]!
				*dest_right++ = *src++;
			} while (src < end);
    6670:	429c      	cmp	r4, r3
				//Serial.println(*src);
				//n = *src++;
				//*dest_left++ = (int16_t)n;
				//*dest_right++ = (int16_t)(n >> 16);
				*dest_left++ = *src++;
				*dest_right++ = *src++;
    6672:	f933 0c02 	ldrsh.w	r0, [r3, #-2]
    6676:	f821 0f02 	strh.w	r0, [r1, #2]!
			} while (src < end);
    667a:	d8f5      	bhi.n	6668 <AudioInputI2S::isr()+0x50>
		}
	}
}
    667c:	bc70      	pop	{r4, r5, r6}
    667e:	4770      	bx	lr

	if (daddr < (uint32_t)i2s_rx_buffer + sizeof(i2s_rx_buffer) / 2) {
		// DMA is receiving to the first half of the buffer
		// need to remove data from the second half
		src = (int16_t *)&i2s_rx_buffer[AUDIO_BLOCK_SAMPLES/2];
		end = (int16_t *)&i2s_rx_buffer[AUDIO_BLOCK_SAMPLES];
    6680:	f503 7480 	add.w	r4, r3, #256	; 0x100
    6684:	e7df      	b.n	6646 <AudioInputI2S::isr()+0x2e>
    6686:	bf00      	nop
    6688:	200042c8 	.word	0x200042c8
    668c:	200041c0 	.word	0x200041c0
    6690:	4000801f 	.word	0x4000801f
    6694:	200042c0 	.word	0x200042c0
    6698:	e000e208 	.word	0xe000e208
    669c:	200042d0 	.word	0x200042d0
    66a0:	200042c4 	.word	0x200042c4
    66a4:	200040bc 	.word	0x200040bc

000066a8 <AudioInputI2S::update()>:
}



void AudioInputI2S::update(void)
{
    66a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    66aa:	4606      	mov	r6, r0
	audio_block_t *new_left=NULL, *new_right=NULL, *out_left=NULL, *out_right=NULL;

	// allocate 2 new blocks, but if one fails, allocate neither
	new_left = allocate();
    66ac:	f002 faaa 	bl	8c04 <AudioStream::allocate()>
	if (new_left != NULL) {
    66b0:	4604      	mov	r4, r0
    66b2:	b1e8      	cbz	r0, 66f0 <AudioInputI2S::update()+0x48>
		new_right = allocate();
    66b4:	f002 faa6 	bl	8c04 <AudioStream::allocate()>
		if (new_right == NULL) {
    66b8:	4605      	mov	r5, r0
    66ba:	2800      	cmp	r0, #0
    66bc:	d03a      	beq.n	6734 <AudioInputI2S::update()+0x8c>
			release(new_left);
			new_left = NULL;
		}
	}
	__disable_irq();
    66be:	b672      	cpsid	i
	if (block_offset >= AUDIO_BLOCK_SAMPLES) {
    66c0:	4b1f      	ldr	r3, [pc, #124]	; (6740 <AudioInputI2S::update()+0x98>)
    66c2:	881a      	ldrh	r2, [r3, #0]
    66c4:	2a7f      	cmp	r2, #127	; 0x7f
    66c6:	d819      	bhi.n	66fc <AudioInputI2S::update()+0x54>
		transmit(out_left, 0);
		release(out_left);
		transmit(out_right, 1);
		release(out_right);
		//Serial.print(".");
	} else if (new_left != NULL) {
    66c8:	2c00      	cmp	r4, #0
    66ca:	d031      	beq.n	6730 <AudioInputI2S::update()+0x88>
		// the DMA didn't fill blocks, but we allocated blocks
		if (block_left == NULL) {
    66cc:	491d      	ldr	r1, [pc, #116]	; (6744 <AudioInputI2S::update()+0x9c>)
    66ce:	680a      	ldr	r2, [r1, #0]
    66d0:	b142      	cbz	r2, 66e4 <AudioInputI2S::update()+0x3c>
			block_right = new_right;
			block_offset = 0;
			__enable_irq();
		} else {
			// the DMA already has blocks, doesn't need these
			__enable_irq();
    66d2:	b662      	cpsie	i
			release(new_left);
    66d4:	4620      	mov	r0, r4
    66d6:	f002 fae9 	bl	8cac <AudioStream::release(audio_block_struct*)>
			release(new_right);
    66da:	4628      	mov	r0, r5
		// The DMA didn't fill blocks, and we could not allocate
		// memory... the system is likely starving for memory!
		// Sadly, there's nothing we can do.
		__enable_irq();
	}
}
    66dc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			__enable_irq();
		} else {
			// the DMA already has blocks, doesn't need these
			__enable_irq();
			release(new_left);
			release(new_right);
    66e0:	f002 bae4 	b.w	8cac <AudioStream::release(audio_block_struct*)>
		// the DMA didn't fill blocks, but we allocated blocks
		if (block_left == NULL) {
			// the DMA doesn't have any blocks to fill, so
			// give it the ones we just allocated
			block_left = new_left;
			block_right = new_right;
    66e4:	4818      	ldr	r0, [pc, #96]	; (6748 <AudioInputI2S::update()+0xa0>)
	} else if (new_left != NULL) {
		// the DMA didn't fill blocks, but we allocated blocks
		if (block_left == NULL) {
			// the DMA doesn't have any blocks to fill, so
			// give it the ones we just allocated
			block_left = new_left;
    66e6:	600c      	str	r4, [r1, #0]
			block_right = new_right;
			block_offset = 0;
    66e8:	801a      	strh	r2, [r3, #0]
		// the DMA didn't fill blocks, but we allocated blocks
		if (block_left == NULL) {
			// the DMA doesn't have any blocks to fill, so
			// give it the ones we just allocated
			block_left = new_left;
			block_right = new_right;
    66ea:	6005      	str	r5, [r0, #0]
			block_offset = 0;
			__enable_irq();
    66ec:	b662      	cpsie	i
    66ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}



void AudioInputI2S::update(void)
{
	audio_block_t *new_left=NULL, *new_right=NULL, *out_left=NULL, *out_right=NULL;
    66f0:	4605      	mov	r5, r0
		if (new_right == NULL) {
			release(new_left);
			new_left = NULL;
		}
	}
	__disable_irq();
    66f2:	b672      	cpsid	i
	if (block_offset >= AUDIO_BLOCK_SAMPLES) {
    66f4:	4b12      	ldr	r3, [pc, #72]	; (6740 <AudioInputI2S::update()+0x98>)
    66f6:	881a      	ldrh	r2, [r3, #0]
    66f8:	2a7f      	cmp	r2, #127	; 0x7f
    66fa:	d9e5      	bls.n	66c8 <AudioInputI2S::update()+0x20>
		// the DMA filled 2 blocks, so grab them and get the
		// 2 new blocks to the DMA, as quickly as possible
		out_left = block_left;
    66fc:	4a11      	ldr	r2, [pc, #68]	; (6744 <AudioInputI2S::update()+0x9c>)
		block_left = new_left;
		out_right = block_right;
    66fe:	4912      	ldr	r1, [pc, #72]	; (6748 <AudioInputI2S::update()+0xa0>)
	}
	__disable_irq();
	if (block_offset >= AUDIO_BLOCK_SAMPLES) {
		// the DMA filled 2 blocks, so grab them and get the
		// 2 new blocks to the DMA, as quickly as possible
		out_left = block_left;
    6700:	6817      	ldr	r7, [r2, #0]
		block_left = new_left;
    6702:	6014      	str	r4, [r2, #0]
		out_right = block_right;
		block_right = new_right;
		block_offset = 0;
    6704:	2200      	movs	r2, #0
	if (block_offset >= AUDIO_BLOCK_SAMPLES) {
		// the DMA filled 2 blocks, so grab them and get the
		// 2 new blocks to the DMA, as quickly as possible
		out_left = block_left;
		block_left = new_left;
		out_right = block_right;
    6706:	680c      	ldr	r4, [r1, #0]
		block_right = new_right;
		block_offset = 0;
    6708:	801a      	strh	r2, [r3, #0]
		// the DMA filled 2 blocks, so grab them and get the
		// 2 new blocks to the DMA, as quickly as possible
		out_left = block_left;
		block_left = new_left;
		out_right = block_right;
		block_right = new_right;
    670a:	600d      	str	r5, [r1, #0]
		block_offset = 0;
		__enable_irq();
    670c:	b662      	cpsie	i
		// then transmit the DMA's former blocks
		transmit(out_left, 0);
    670e:	4639      	mov	r1, r7
    6710:	4630      	mov	r0, r6
    6712:	f002 faf5 	bl	8d00 <AudioStream::transmit(audio_block_struct*, unsigned char)>
		release(out_left);
    6716:	4638      	mov	r0, r7
    6718:	f002 fac8 	bl	8cac <AudioStream::release(audio_block_struct*)>
		transmit(out_right, 1);
    671c:	4630      	mov	r0, r6
    671e:	4621      	mov	r1, r4
    6720:	2201      	movs	r2, #1
    6722:	f002 faed 	bl	8d00 <AudioStream::transmit(audio_block_struct*, unsigned char)>
		release(out_right);
    6726:	4620      	mov	r0, r4
		// The DMA didn't fill blocks, and we could not allocate
		// memory... the system is likely starving for memory!
		// Sadly, there's nothing we can do.
		__enable_irq();
	}
}
    6728:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		__enable_irq();
		// then transmit the DMA's former blocks
		transmit(out_left, 0);
		release(out_left);
		transmit(out_right, 1);
		release(out_right);
    672c:	f002 babe 	b.w	8cac <AudioStream::release(audio_block_struct*)>
		}
	} else {
		// The DMA didn't fill blocks, and we could not allocate
		// memory... the system is likely starving for memory!
		// Sadly, there's nothing we can do.
		__enable_irq();
    6730:	b662      	cpsie	i
    6732:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	// allocate 2 new blocks, but if one fails, allocate neither
	new_left = allocate();
	if (new_left != NULL) {
		new_right = allocate();
		if (new_right == NULL) {
			release(new_left);
    6734:	4620      	mov	r0, r4
    6736:	f002 fab9 	bl	8cac <AudioStream::release(audio_block_struct*)>
			new_left = NULL;
    673a:	462c      	mov	r4, r5
    673c:	e7bf      	b.n	66be <AudioInputI2S::update()+0x16>
    673e:	bf00      	nop
    6740:	200040bc 	.word	0x200040bc
    6744:	200042d0 	.word	0x200042d0
    6748:	200042c4 	.word	0x200042c4

0000674c <AudioInputI2S::begin()>:
bool AudioInputI2S::update_responsibility = false;
DMAChannel AudioInputI2S::dma(false);


void AudioInputI2S::begin(void)
{
    674c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	dma.begin(true); // Allocate the DMA channel first
    674e:	4c28      	ldr	r4, [pc, #160]	; (67f0 <AudioInputI2S::begin()+0xa4>)
	dma.TCD->SADDR = (void *)((uint32_t)&I2S0_RDR0 + 2);
	dma.TCD->SOFF = 0;
	dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
	dma.TCD->NBYTES_MLNO = 2;
	dma.TCD->SLAST = 0;
	dma.TCD->DADDR = i2s_rx_buffer;
    6750:	4e28      	ldr	r6, [pc, #160]	; (67f4 <AudioInputI2S::begin()+0xa8>)
	dma.TCD->DOFF = 2;
	dma.TCD->CITER_ELINKNO = sizeof(i2s_rx_buffer) / 2;
	dma.TCD->DLASTSGA = -sizeof(i2s_rx_buffer);
    6752:	4f29      	ldr	r7, [pc, #164]	; (67f8 <AudioInputI2S::begin()+0xac>)
	dma.TCD->BITER_ELINKNO = sizeof(i2s_rx_buffer) / 2;
	dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
	dma.triggerAtHardwareEvent(DMAMUX_SOURCE_I2S0_RX);

	I2S0_RCSR |= I2S_RCSR_RE | I2S_RCSR_BCE | I2S_RCSR_FRDE | I2S_RCSR_FR;
    6754:	4d29      	ldr	r5, [pc, #164]	; (67fc <AudioInputI2S::begin()+0xb0>)
DMAChannel AudioInputI2S::dma(false);


void AudioInputI2S::begin(void)
{
	dma.begin(true); // Allocate the DMA channel first
    6756:	4620      	mov	r0, r4
    6758:	2101      	movs	r1, #1
    675a:	f002 fbe5 	bl	8f28 <DMAChannel::begin(bool)>

	//block_left_1st = NULL;
	//block_right_1st = NULL;

	// TODO: should we set & clear the I2S_RCSR_SR bit here?
	AudioOutputI2S::config_i2s();
    675e:	f000 f8e3 	bl	6928 <AudioOutputI2S::config_i2s()>

#if defined(KINETISK)
	CORE_PIN13_CONFIG = PORT_PCR_MUX(4); // pin 13, PTC5, I2S0_RXD0
    6762:	4b27      	ldr	r3, [pc, #156]	; (6800 <AudioInputI2S::begin()+0xb4>)
	dma.TCD->SADDR = (void *)((uint32_t)&I2S0_RDR0 + 2);
    6764:	4a27      	ldr	r2, [pc, #156]	; (6804 <AudioInputI2S::begin()+0xb8>)
	dma.TCD->BITER_ELINKNO = sizeof(i2s_rx_buffer) / 2;
	dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
	dma.triggerAtHardwareEvent(DMAMUX_SOURCE_I2S0_RX);

	I2S0_RCSR |= I2S_RCSR_RE | I2S_RCSR_BCE | I2S_RCSR_FRDE | I2S_RCSR_FR;
	I2S0_TCSR |= I2S_TCSR_TE | I2S_TCSR_BCE; // TX clock enable, because sync'd to TX
    6766:	4828      	ldr	r0, [pc, #160]	; (6808 <AudioInputI2S::begin()+0xbc>)

	// TODO: should we set & clear the I2S_RCSR_SR bit here?
	AudioOutputI2S::config_i2s();

#if defined(KINETISK)
	CORE_PIN13_CONFIG = PORT_PCR_MUX(4); // pin 13, PTC5, I2S0_RXD0
    6768:	f44f 6180 	mov.w	r1, #1024	; 0x400
    676c:	6019      	str	r1, [r3, #0]
	dma.TCD->SADDR = (void *)((uint32_t)&I2S0_RDR0 + 2);
    676e:	6823      	ldr	r3, [r4, #0]
	dma.TCD->SOFF = 0;
    6770:	2100      	movs	r1, #0
	// TODO: should we set & clear the I2S_RCSR_SR bit here?
	AudioOutputI2S::config_i2s();

#if defined(KINETISK)
	CORE_PIN13_CONFIG = PORT_PCR_MUX(4); // pin 13, PTC5, I2S0_RXD0
	dma.TCD->SADDR = (void *)((uint32_t)&I2S0_RDR0 + 2);
    6772:	601a      	str	r2, [r3, #0]
	dma.TCD->SOFF = 0;
    6774:	8099      	strh	r1, [r3, #4]
	// 32 bits.  If a channel is configured for 200 transfers

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
    6776:	7922      	ldrb	r2, [r4, #4]
	dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
	dma.TCD->NBYTES_MLNO = 2;
	dma.TCD->SLAST = 0;
	dma.TCD->DADDR = i2s_rx_buffer;
    6778:	611e      	str	r6, [r3, #16]
    677a:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000

#if defined(KINETISK)
	CORE_PIN13_CONFIG = PORT_PCR_MUX(4); // pin 13, PTC5, I2S0_RXD0
	dma.TCD->SADDR = (void *)((uint32_t)&I2S0_RDR0 + 2);
	dma.TCD->SOFF = 0;
	dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
    677e:	f240 1601 	movw	r6, #257	; 0x101
    6782:	80de      	strh	r6, [r3, #6]
	dma.TCD->NBYTES_MLNO = 2;
	dma.TCD->SLAST = 0;
	dma.TCD->DADDR = i2s_rx_buffer;
	dma.TCD->DOFF = 2;
	dma.TCD->CITER_ELINKNO = sizeof(i2s_rx_buffer) / 2;
	dma.TCD->DLASTSGA = -sizeof(i2s_rx_buffer);
    6784:	619f      	str	r7, [r3, #24]
    6786:	f502 3204 	add.w	r2, r2, #135168	; 0x21000
	dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
	dma.TCD->NBYTES_MLNO = 2;
	dma.TCD->SLAST = 0;
	dma.TCD->DADDR = i2s_rx_buffer;
	dma.TCD->DOFF = 2;
	dma.TCD->CITER_ELINKNO = sizeof(i2s_rx_buffer) / 2;
    678a:	f44f 7680 	mov.w	r6, #256	; 0x100
	dma.TCD->DLASTSGA = -sizeof(i2s_rx_buffer);
	dma.TCD->BITER_ELINKNO = sizeof(i2s_rx_buffer) / 2;
	dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
    678e:	2706      	movs	r7, #6
	dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
	dma.TCD->NBYTES_MLNO = 2;
	dma.TCD->SLAST = 0;
	dma.TCD->DADDR = i2s_rx_buffer;
	dma.TCD->DOFF = 2;
	dma.TCD->CITER_ELINKNO = sizeof(i2s_rx_buffer) / 2;
    6790:	82de      	strh	r6, [r3, #22]
	dma.TCD->DLASTSGA = -sizeof(i2s_rx_buffer);
	dma.TCD->BITER_ELINKNO = sizeof(i2s_rx_buffer) / 2;
    6792:	83de      	strh	r6, [r3, #30]
	dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
    6794:	839f      	strh	r7, [r3, #28]
#if defined(KINETISK)
	CORE_PIN13_CONFIG = PORT_PCR_MUX(4); // pin 13, PTC5, I2S0_RXD0
	dma.TCD->SADDR = (void *)((uint32_t)&I2S0_RDR0 + 2);
	dma.TCD->SOFF = 0;
	dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
	dma.TCD->NBYTES_MLNO = 2;
    6796:	2602      	movs	r6, #2
		*mux = 0;
		*mux = (source & 63) | DMAMUX_ENABLE;
    6798:	278e      	movs	r7, #142	; 0x8e
	dma.TCD->SLAST = 0;
    679a:	60d9      	str	r1, [r3, #12]
#if defined(KINETISK)
	CORE_PIN13_CONFIG = PORT_PCR_MUX(4); // pin 13, PTC5, I2S0_RXD0
	dma.TCD->SADDR = (void *)((uint32_t)&I2S0_RDR0 + 2);
	dma.TCD->SOFF = 0;
	dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
	dma.TCD->NBYTES_MLNO = 2;
    679c:	609e      	str	r6, [r3, #8]
	dma.TCD->SLAST = 0;
	dma.TCD->DADDR = i2s_rx_buffer;
	dma.TCD->DOFF = 2;
    679e:	829e      	strh	r6, [r3, #20]

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
		*mux = 0;
    67a0:	7011      	strb	r1, [r2, #0]
		*mux = (source & 63) | DMAMUX_ENABLE;
    67a2:	7017      	strb	r7, [r2, #0]
	dma.TCD->DLASTSGA = -sizeof(i2s_rx_buffer);
	dma.TCD->BITER_ELINKNO = sizeof(i2s_rx_buffer) / 2;
	dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
	dma.triggerAtHardwareEvent(DMAMUX_SOURCE_I2S0_RX);

	I2S0_RCSR |= I2S_RCSR_RE | I2S_RCSR_BCE | I2S_RCSR_FRDE | I2S_RCSR_FR;
    67a4:	682b      	ldr	r3, [r5, #0]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    67a6:	4e19      	ldr	r6, [pc, #100]	; (680c <AudioInputI2S::begin()+0xc0>)
    67a8:	f043 4312 	orr.w	r3, r3, #2449473536	; 0x92000000
    67ac:	f043 0301 	orr.w	r3, r3, #1
    67b0:	602b      	str	r3, [r5, #0]
	I2S0_TCSR |= I2S_TCSR_TE | I2S_TCSR_BCE; // TX clock enable, because sync'd to TX
    67b2:	6803      	ldr	r3, [r0, #0]

	// An interrupt routine can be run when the DMA channel completes
	// the entire transfer, and also optionally when half of the
	// transfer is completed.
	void attachInterrupt(void (*isr)(void)) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
    67b4:	4d16      	ldr	r5, [pc, #88]	; (6810 <AudioInputI2S::begin()+0xc4>)
    67b6:	f043 4310 	orr.w	r3, r3, #2415919104	; 0x90000000
    67ba:	6003      	str	r3, [r0, #0]
	dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
	dma.triggerAtHardwareEvent(DMAMUX_SOURCE_SAI1_RX);

	I2S1_RCSR = I2S_RCSR_RE | I2S_RCSR_BCE | I2S_RCSR_FRDE | I2S_RCSR_FR;
#endif
	update_responsibility = update_setup();
    67bc:	f002 fb5a 	bl	8e74 <AudioStream::update_setup()>
    67c0:	7922      	ldrb	r2, [r4, #4]
    67c2:	4b14      	ldr	r3, [pc, #80]	; (6814 <AudioInputI2S::begin()+0xc8>)
    67c4:	4c14      	ldr	r4, [pc, #80]	; (6818 <AudioInputI2S::begin()+0xcc>)
    67c6:	7018      	strb	r0, [r3, #0]
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
    67c8:	1153      	asrs	r3, r2, #5
    67ca:	009b      	lsls	r3, r3, #2
    67cc:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    67d0:	4617      	mov	r7, r2

	// An interrupt routine can be run when the DMA channel completes
	// the entire transfer, and also optionally when half of the
	// transfer is completed.
	void attachInterrupt(void (*isr)(void)) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
    67d2:	f102 0010 	add.w	r0, r2, #16
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
    67d6:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    67da:	f002 021f 	and.w	r2, r2, #31
    67de:	2101      	movs	r1, #1
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    67e0:	7037      	strb	r7, [r6, #0]
	// An interrupt routine can be run when the DMA channel completes
	// the entire transfer, and also optionally when half of the
	// transfer is completed.
	void attachInterrupt(void (*isr)(void)) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
    67e2:	fa01 f202 	lsl.w	r2, r1, r2

	// An interrupt routine can be run when the DMA channel completes
	// the entire transfer, and also optionally when half of the
	// transfer is completed.
	void attachInterrupt(void (*isr)(void)) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
    67e6:	f845 4020 	str.w	r4, [r5, r0, lsl #2]
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
    67ea:	601a      	str	r2, [r3, #0]
    67ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    67ee:	bf00      	nop
    67f0:	200042c8 	.word	0x200042c8
    67f4:	200040c0 	.word	0x200040c0
    67f8:	fffffe00 	.word	0xfffffe00
    67fc:	4002f080 	.word	0x4002f080
    6800:	4004b014 	.word	0x4004b014
    6804:	4002f0a2 	.word	0x4002f0a2
    6808:	4002f000 	.word	0x4002f000
    680c:	4000801b 	.word	0x4000801b
    6810:	1fffac00 	.word	0x1fffac00
    6814:	200042c0 	.word	0x200042c0
    6818:	00006619 	.word	0x00006619

0000681c <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE>:
static uint32_t i2s_rx_buffer[AUDIO_BLOCK_SAMPLES];
audio_block_t * AudioInputI2S::block_left = NULL;
audio_block_t * AudioInputI2S::block_right = NULL;
uint16_t AudioInputI2S::block_offset = 0;
bool AudioInputI2S::update_responsibility = false;
DMAChannel AudioInputI2S::dma(false);
    681c:	4a02      	ldr	r2, [pc, #8]	; (6828 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0xc>)
    681e:	4903      	ldr	r1, [pc, #12]	; (682c <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0x10>)
    6820:	4803      	ldr	r0, [pc, #12]	; (6830 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0x14>)
    6822:	f007 b961 	b.w	dae8 <__aeabi_atexit>
    6826:	bf00      	nop
    6828:	1fffb874 	.word	0x1fffb874
    682c:	000065c5 	.word	0x000065c5
    6830:	200042c8 	.word	0x200042c8

00006834 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E>:
audio_block_t * AudioInputI2SQuad::block_ch2 = NULL;
audio_block_t * AudioInputI2SQuad::block_ch3 = NULL;
audio_block_t * AudioInputI2SQuad::block_ch4 = NULL;
uint16_t AudioInputI2SQuad::block_offset = 0;
bool AudioInputI2SQuad::update_responsibility = false;
DMAChannel AudioInputI2SQuad::dma(false);
    6834:	4a02      	ldr	r2, [pc, #8]	; (6840 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0xc>)
    6836:	4903      	ldr	r1, [pc, #12]	; (6844 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0x10>)
    6838:	4803      	ldr	r0, [pc, #12]	; (6848 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0x14>)
    683a:	f007 b955 	b.w	dae8 <__aeabi_atexit>
    683e:	bf00      	nop
    6840:	1fffb874 	.word	0x1fffb874
    6844:	000065c5 	.word	0x000065c5
    6848:	200042d4 	.word	0x200042d4

0000684c <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE>:

DMAMEM static uint32_t pdm_buffer[AUDIO_BLOCK_SAMPLES*4];
static uint32_t leftover[14];
audio_block_t * AudioInputPDM::block_left = NULL;
bool AudioInputPDM::update_responsibility = false;
DMAChannel AudioInputPDM::dma(false);
    684c:	4a02      	ldr	r2, [pc, #8]	; (6858 <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE+0xc>)
    684e:	4903      	ldr	r1, [pc, #12]	; (685c <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE+0x10>)
    6850:	4803      	ldr	r0, [pc, #12]	; (6860 <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE+0x14>)
    6852:	f007 b949 	b.w	dae8 <__aeabi_atexit>
    6856:	bf00      	nop
    6858:	1fffb874 	.word	0x1fffb874
    685c:	000065c5 	.word	0x000065c5
    6860:	200042dc 	.word	0x200042dc

00006864 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE>:
audio_block_t * AudioInputTDM::block_incoming[16] = {
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
};
bool AudioInputTDM::update_responsibility = false;
DMAChannel AudioInputTDM::dma(false);
    6864:	4a02      	ldr	r2, [pc, #8]	; (6870 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0xc>)
    6866:	4903      	ldr	r1, [pc, #12]	; (6874 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0x10>)
    6868:	4803      	ldr	r0, [pc, #12]	; (6878 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0x14>)
    686a:	f007 b93d 	b.w	dae8 <__aeabi_atexit>
    686e:	bf00      	nop
    6870:	1fffb874 	.word	0x1fffb874
    6874:	000065c5 	.word	0x000065c5
    6878:	200042e4 	.word	0x200042e4

0000687c <AudioAmplifier::update()>:
		release(out);
	}
}

void AudioAmplifier::update(void)
{
    687c:	b570      	push	{r4, r5, r6, lr}
	audio_block_t *block;
	int32_t mult = multiplier;
    687e:	6984      	ldr	r4, [r0, #24]

	if (mult == 0) {
    6880:	b32c      	cbz	r4, 68ce <AudioAmplifier::update()+0x52>
		// zero gain, discard any input and transmit nothing
		block = receiveReadOnly(0);
		if (block) release(block);
	} else if (mult == MULTI_UNITYGAIN) {
    6882:	f5b4 3f80 	cmp.w	r4, #65536	; 0x10000
    6886:	4606      	mov	r6, r0
		// unity gain, pass input to output without any change
		block = receiveReadOnly(0);
    6888:	f04f 0100 	mov.w	r1, #0

	if (mult == 0) {
		// zero gain, discard any input and transmit nothing
		block = receiveReadOnly(0);
		if (block) release(block);
	} else if (mult == MULTI_UNITYGAIN) {
    688c:	d025      	beq.n	68da <AudioAmplifier::update()+0x5e>
			transmit(block);
			release(block);
		}
	} else {
		// apply gain to signal
		block = receiveWritable(0);
    688e:	f002 fa5d 	bl	8d4c <AudioStream::receiveWritable(unsigned int)>
		if (block) {
    6892:	4605      	mov	r5, r0
    6894:	b300      	cbz	r0, 68d8 <AudioAmplifier::update()+0x5c>
			applyGain(block->data, mult);
    6896:	1d01      	adds	r1, r0, #4
#define MULTI_UNITYGAIN 65536

static void applyGain(int16_t *data, int32_t mult)
{
	uint32_t *p = (uint32_t *)data;
	const uint32_t *end = (uint32_t *)(data + AUDIO_BLOCK_SAMPLES);
    6898:	f500 7082 	add.w	r0, r0, #260	; 0x104

	do {
		uint32_t tmp32 = *p; // read 2 samples from *data
    689c:	680b      	ldr	r3, [r1, #0]
static inline int32_t signed_multiply_32x16b(int32_t a, uint32_t b) __attribute__((always_inline, unused));
static inline int32_t signed_multiply_32x16b(int32_t a, uint32_t b)
{
#if defined (__ARM_ARCH_7EM__)
	int32_t out;
	asm volatile("smulwb %0, %1, %2" : "=r" (out) : "r" (a), "r" (b));
    689e:	fb34 f203 	smulwb	r2, r4, r3
static inline int32_t signed_multiply_32x16t(int32_t a, uint32_t b) __attribute__((always_inline, unused));
static inline int32_t signed_multiply_32x16t(int32_t a, uint32_t b)
{
#if defined (__ARM_ARCH_7EM__)
	int32_t out;
	asm volatile("smulwt %0, %1, %2" : "=r" (out) : "r" (a), "r" (b));
    68a2:	fb34 f313 	smulwt	r3, r4, r3
static inline int32_t signed_saturate_rshift(int32_t val, int bits, int rshift) __attribute__((always_inline, unused));
static inline int32_t signed_saturate_rshift(int32_t val, int bits, int rshift)
{
#if defined (__ARM_ARCH_7EM__)
	int32_t out;
	asm volatile("ssat %0, %1, %2, asr %3" : "=r" (out) : "I" (bits), "r" (val), "I" (rshift));
    68a6:	f302 020f 	ssat	r2, #16, r2
    68aa:	f303 030f 	ssat	r3, #16, r3
static inline uint32_t pack_16b_16b(int32_t a, int32_t b) __attribute__((always_inline, unused));
static inline uint32_t pack_16b_16b(int32_t a, int32_t b)
{
#if defined (__ARM_ARCH_7EM__)
	int32_t out;
	asm volatile("pkhbt %0, %1, %2, lsl #16" : "=r" (out) : "r" (b), "r" (a));
    68ae:	eac2 4303 	pkhbt	r3, r2, r3, lsl #16
		int32_t val1 = signed_multiply_32x16b(mult, tmp32);
		int32_t val2 = signed_multiply_32x16t(mult, tmp32);
		val1 = signed_saturate_rshift(val1, 16, 0);
		val2 = signed_saturate_rshift(val2, 16, 0);
		*p++ = pack_16b_16b(val2, val1);
    68b2:	f841 3b04 	str.w	r3, [r1], #4
	} while (p < end);
    68b6:	4288      	cmp	r0, r1
    68b8:	d8f0      	bhi.n	689c <AudioAmplifier::update()+0x20>
	} else {
		// apply gain to signal
		block = receiveWritable(0);
		if (block) {
			applyGain(block->data, mult);
			transmit(block);
    68ba:	4630      	mov	r0, r6
    68bc:	2200      	movs	r2, #0
    68be:	4629      	mov	r1, r5
    68c0:	f002 fa1e 	bl	8d00 <AudioStream::transmit(audio_block_struct*, unsigned char)>
			release(block);
    68c4:	4628      	mov	r0, r5
		}
	}
}
    68c6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		// apply gain to signal
		block = receiveWritable(0);
		if (block) {
			applyGain(block->data, mult);
			transmit(block);
			release(block);
    68ca:	f002 b9ef 	b.w	8cac <AudioStream::release(audio_block_struct*)>
	audio_block_t *block;
	int32_t mult = multiplier;

	if (mult == 0) {
		// zero gain, discard any input and transmit nothing
		block = receiveReadOnly(0);
    68ce:	4621      	mov	r1, r4
    68d0:	f002 fa30 	bl	8d34 <AudioStream::receiveReadOnly(unsigned int)>
		if (block) release(block);
    68d4:	2800      	cmp	r0, #0
    68d6:	d1f6      	bne.n	68c6 <AudioAmplifier::update()+0x4a>
    68d8:	bd70      	pop	{r4, r5, r6, pc}
	} else if (mult == MULTI_UNITYGAIN) {
		// unity gain, pass input to output without any change
		block = receiveReadOnly(0);
    68da:	f002 fa2b 	bl	8d34 <AudioStream::receiveReadOnly(unsigned int)>
		if (block) {
    68de:	4604      	mov	r4, r0
    68e0:	2800      	cmp	r0, #0
    68e2:	d0f9      	beq.n	68d8 <AudioAmplifier::update()+0x5c>
			transmit(block);
    68e4:	4630      	mov	r0, r6
    68e6:	4621      	mov	r1, r4
    68e8:	2200      	movs	r2, #0
    68ea:	f002 fa09 	bl	8d00 <AudioStream::transmit(audio_block_struct*, unsigned char)>
			release(block);
    68ee:	4620      	mov	r0, r4
			applyGain(block->data, mult);
			transmit(block);
			release(block);
		}
	}
}
    68f0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	} else if (mult == MULTI_UNITYGAIN) {
		// unity gain, pass input to output without any change
		block = receiveReadOnly(0);
		if (block) {
			transmit(block);
			release(block);
    68f4:	f002 b9da 	b.w	8cac <AudioStream::release(audio_block_struct*)>

000068f8 <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE>:
bool AudioOutputADAT::update_responsibility = false;
//uint32_t  AudioOutputADAT::vucp = VUCP_VALID;

DMAMEM static uint32_t ADAT_tx_buffer[AUDIO_BLOCK_SAMPLES * 8]; //4 KB, AUDIO_BLOCK_SAMPLES is usually 128

DMAChannel AudioOutputADAT::dma(false);
    68f8:	4a02      	ldr	r2, [pc, #8]	; (6904 <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE+0xc>)
    68fa:	4903      	ldr	r1, [pc, #12]	; (6908 <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE+0x10>)
    68fc:	4803      	ldr	r0, [pc, #12]	; (690c <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE+0x14>)
    68fe:	f007 b8f3 	b.w	dae8 <__aeabi_atexit>
    6902:	bf00      	nop
    6904:	1fffb874 	.word	0x1fffb874
    6908:	000065c5 	.word	0x000065c5
    690c:	200042ec 	.word	0x200042ec

00006910 <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE>:

DMAMEM static uint16_t dac_buffer[AUDIO_BLOCK_SAMPLES*2];
audio_block_t * AudioOutputAnalog::block_left_1st = NULL;
audio_block_t * AudioOutputAnalog::block_left_2nd = NULL;
bool AudioOutputAnalog::update_responsibility = false;
DMAChannel AudioOutputAnalog::dma(false);
    6910:	4a02      	ldr	r2, [pc, #8]	; (691c <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE+0xc>)
    6912:	4903      	ldr	r1, [pc, #12]	; (6920 <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE+0x10>)
    6914:	4803      	ldr	r0, [pc, #12]	; (6924 <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE+0x14>)
    6916:	f007 b8e7 	b.w	dae8 <__aeabi_atexit>
    691a:	bf00      	nop
    691c:	1fffb874 	.word	0x1fffb874
    6920:	000065c5 	.word	0x000065c5
    6924:	200042f4 	.word	0x200042f4

00006928 <AudioOutputI2S::config_i2s()>:


void AudioOutputI2S::config_i2s(void)
{
#if defined(KINETISK) || defined(KINETISL)
	SIM_SCGC6 |= SIM_SCGC6_I2S;
    6928:	4b28      	ldr	r3, [pc, #160]	; (69cc <AudioOutputI2S::config_i2s()+0xa4>)
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    692a:	4929      	ldr	r1, [pc, #164]	; (69d0 <AudioOutputI2S::config_i2s()+0xa8>)


void AudioOutputI2S::config_i2s(void)
{
#if defined(KINETISK) || defined(KINETISL)
	SIM_SCGC6 |= SIM_SCGC6_I2S;
    692c:	681a      	ldr	r2, [r3, #0]
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;

	// if either transmitter or receiver is enabled, do nothing
	if (I2S0_TCSR & I2S_TCSR_TE) return;
    692e:	4829      	ldr	r0, [pc, #164]	; (69d4 <AudioOutputI2S::config_i2s()+0xac>)


void AudioOutputI2S::config_i2s(void)
{
#if defined(KINETISK) || defined(KINETISL)
	SIM_SCGC6 |= SIM_SCGC6_I2S;
    6930:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    6934:	601a      	str	r2, [r3, #0]
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    6936:	680a      	ldr	r2, [r1, #0]
    6938:	f042 0202 	orr.w	r2, r2, #2
    693c:	600a      	str	r2, [r1, #0]
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    693e:	681a      	ldr	r2, [r3, #0]
    6940:	f042 0202 	orr.w	r2, r2, #2
    6944:	601a      	str	r2, [r3, #0]

	// if either transmitter or receiver is enabled, do nothing
	if (I2S0_TCSR & I2S_TCSR_TE) return;
    6946:	6803      	ldr	r3, [r0, #0]
    6948:	2b00      	cmp	r3, #0
    694a:	db3e      	blt.n	69ca <AudioOutputI2S::config_i2s()+0xa2>
	if (I2S0_RCSR & I2S_RCSR_RE) return;
    694c:	4b22      	ldr	r3, [pc, #136]	; (69d8 <AudioOutputI2S::config_i2s()+0xb0>)
    694e:	681b      	ldr	r3, [r3, #0]
    6950:	2b00      	cmp	r3, #0
    6952:	db3a      	blt.n	69ca <AudioOutputI2S::config_i2s()+0xa2>

	// enable MCLK output
	I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
    6954:	4a21      	ldr	r2, [pc, #132]	; (69dc <AudioOutputI2S::config_i2s()+0xb4>)
    6956:	f04f 4386 	mov.w	r3, #1124073472	; 0x43000000
    695a:	6013      	str	r3, [r2, #0]
	while (I2S0_MCR & I2S_MCR_DUF) ;
    695c:	6813      	ldr	r3, [r2, #0]
    695e:	2b00      	cmp	r3, #0
    6960:	dbfc      	blt.n	695c <AudioOutputI2S::config_i2s()+0x34>
#endif
#endif


void AudioOutputI2S::config_i2s(void)
{
    6962:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (I2S0_RCSR & I2S_RCSR_RE) return;

	// enable MCLK output
	I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
	while (I2S0_MCR & I2S_MCR_DUF) ;
	I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
    6964:	4c1e      	ldr	r4, [pc, #120]	; (69e0 <AudioOutputI2S::config_i2s()+0xb8>)

	// configure transmitter
	I2S0_TMR = 0;
    6966:	481f      	ldr	r0, [pc, #124]	; (69e4 <AudioOutputI2S::config_i2s()+0xbc>)
	I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
    6968:	f8df e0a8 	ldr.w	lr, [pc, #168]	; 6a14 <AudioOutputI2S::config_i2s()+0xec>
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV(1);
    696c:	491e      	ldr	r1, [pc, #120]	; (69e8 <AudioOutputI2S::config_i2s()+0xc0>)
	I2S0_TCR3 = I2S_TCR3_TCE;
    696e:	4b1f      	ldr	r3, [pc, #124]	; (69ec <AudioOutputI2S::config_i2s()+0xc4>)
	I2S0_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(31) | I2S_TCR4_MF
		| I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD;
    6970:	4a1f      	ldr	r2, [pc, #124]	; (69f0 <AudioOutputI2S::config_i2s()+0xc8>)
	I2S0_TCR5 = I2S_TCR5_WNW(31) | I2S_TCR5_W0W(31) | I2S_TCR5_FBT(31);
    6972:	4f20      	ldr	r7, [pc, #128]	; (69f4 <AudioOutputI2S::config_i2s()+0xcc>)

	// configure receiver (sync'd to transmitter clocks)
	I2S0_RMR = 0;
    6974:	4e20      	ldr	r6, [pc, #128]	; (69f8 <AudioOutputI2S::config_i2s()+0xd0>)
	I2S0_RCR1 = I2S_RCR1_RFW(1);
    6976:	4d21      	ldr	r5, [pc, #132]	; (69fc <AudioOutputI2S::config_i2s()+0xd4>)
	if (I2S0_RCSR & I2S_RCSR_RE) return;

	// enable MCLK output
	I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
	while (I2S0_MCR & I2S_MCR_DUF) ;
	I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
    6978:	f247 0c54 	movw	ip, #28756	; 0x7054
    697c:	f8c4 c000 	str.w	ip, [r4]

	// configure transmitter
	I2S0_TMR = 0;
    6980:	2400      	movs	r4, #0
    6982:	6004      	str	r4, [r0, #0]
	I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
    6984:	2001      	movs	r0, #1
    6986:	f8ce 0000 	str.w	r0, [lr]
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV(1);
    698a:	f8df e08c 	ldr.w	lr, [pc, #140]	; 6a18 <AudioOutputI2S::config_i2s()+0xf0>
    698e:	f8c1 e000 	str.w	lr, [r1]
	I2S0_TCR3 = I2S_TCR3_TCE;
    6992:	f44f 3180 	mov.w	r1, #65536	; 0x10000
    6996:	6019      	str	r1, [r3, #0]
	I2S0_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(31) | I2S_TCR4_MF
		| I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD;
    6998:	4b19      	ldr	r3, [pc, #100]	; (6a00 <AudioOutputI2S::config_i2s()+0xd8>)
    699a:	6013      	str	r3, [r2, #0]

	// configure receiver (sync'd to transmitter clocks)
	I2S0_RMR = 0;
	I2S0_RCR1 = I2S_RCR1_RFW(1);
	I2S0_RCR2 = I2S_RCR2_SYNC(1) | I2S_TCR2_BCP | I2S_RCR2_MSEL(1)
		| I2S_RCR2_BCD | I2S_RCR2_DIV(1);
    699c:	f8df e07c 	ldr.w	lr, [pc, #124]	; 6a1c <AudioOutputI2S::config_i2s()+0xf4>
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV(1);
	I2S0_TCR3 = I2S_TCR3_TCE;
	I2S0_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(31) | I2S_TCR4_MF
		| I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD;
	I2S0_TCR5 = I2S_TCR5_WNW(31) | I2S_TCR5_W0W(31) | I2S_TCR5_FBT(31);
    69a0:	4a18      	ldr	r2, [pc, #96]	; (6a04 <AudioOutputI2S::config_i2s()+0xdc>)
    69a2:	603a      	str	r2, [r7, #0]

	// configure receiver (sync'd to transmitter clocks)
	I2S0_RMR = 0;
    69a4:	6034      	str	r4, [r6, #0]
	I2S0_RCR1 = I2S_RCR1_RFW(1);
    69a6:	6028      	str	r0, [r5, #0]
	I2S0_RCR2 = I2S_RCR2_SYNC(1) | I2S_TCR2_BCP | I2S_RCR2_MSEL(1)
		| I2S_RCR2_BCD | I2S_RCR2_DIV(1);
    69a8:	f100 408e 	add.w	r0, r0, #1191182336	; 0x47000000
    69ac:	f8ce 0000 	str.w	r0, [lr]
	I2S0_RCR4 = I2S_RCR4_FRSZ(1) | I2S_RCR4_SYWD(31) | I2S_RCR4_MF
		| I2S_RCR4_FSE | I2S_RCR4_FSP | I2S_RCR4_FSD;
	I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);

	// configure pin mux for 3 clock signals
	CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
    69b0:	4c15      	ldr	r4, [pc, #84]	; (6a08 <AudioOutputI2S::config_i2s()+0xe0>)
	// configure receiver (sync'd to transmitter clocks)
	I2S0_RMR = 0;
	I2S0_RCR1 = I2S_RCR1_RFW(1);
	I2S0_RCR2 = I2S_RCR2_SYNC(1) | I2S_TCR2_BCP | I2S_RCR2_MSEL(1)
		| I2S_RCR2_BCD | I2S_RCR2_DIV(1);
	I2S0_RCR3 = I2S_RCR3_RCE;
    69b2:	67b9      	str	r1, [r7, #120]	; 0x78
		| I2S_RCR4_FSE | I2S_RCR4_FSP | I2S_RCR4_FSD;
	I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);

	// configure pin mux for 3 clock signals
	CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
	CORE_PIN9_CONFIG  = PORT_PCR_MUX(6); // pin  9, PTC3, I2S0_TX_BCLK
    69b4:	4815      	ldr	r0, [pc, #84]	; (6a0c <AudioOutputI2S::config_i2s()+0xe4>)
	CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
    69b6:	4916      	ldr	r1, [pc, #88]	; (6a10 <AudioOutputI2S::config_i2s()+0xe8>)
	I2S0_RCR1 = I2S_RCR1_RFW(1);
	I2S0_RCR2 = I2S_RCR2_SYNC(1) | I2S_TCR2_BCP | I2S_RCR2_MSEL(1)
		| I2S_RCR2_BCD | I2S_RCR2_DIV(1);
	I2S0_RCR3 = I2S_RCR3_RCE;
	I2S0_RCR4 = I2S_RCR4_FRSZ(1) | I2S_RCR4_SYWD(31) | I2S_RCR4_MF
		| I2S_RCR4_FSE | I2S_RCR4_FSP | I2S_RCR4_FSD;
    69b8:	f846 3c50 	str.w	r3, [r6, #-80]
	I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);

	// configure pin mux for 3 clock signals
	CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
    69bc:	f44f 63c0 	mov.w	r3, #1536	; 0x600
	I2S0_RCR2 = I2S_RCR2_SYNC(1) | I2S_TCR2_BCP | I2S_RCR2_MSEL(1)
		| I2S_RCR2_BCD | I2S_RCR2_DIV(1);
	I2S0_RCR3 = I2S_RCR3_RCE;
	I2S0_RCR4 = I2S_RCR4_FRSZ(1) | I2S_RCR4_SYWD(31) | I2S_RCR4_MF
		| I2S_RCR4_FSE | I2S_RCR4_FSP | I2S_RCR4_FSD;
	I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);
    69c0:	612a      	str	r2, [r5, #16]

	// configure pin mux for 3 clock signals
	CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
    69c2:	6023      	str	r3, [r4, #0]
	CORE_PIN9_CONFIG  = PORT_PCR_MUX(6); // pin  9, PTC3, I2S0_TX_BCLK
    69c4:	6003      	str	r3, [r0, #0]
	CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
    69c6:	600b      	str	r3, [r1, #0]
    69c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    69ca:	4770      	bx	lr
    69cc:	4004803c 	.word	0x4004803c
    69d0:	40048040 	.word	0x40048040
    69d4:	4002f000 	.word	0x4002f000
    69d8:	4002f080 	.word	0x4002f080
    69dc:	4002f100 	.word	0x4002f100
    69e0:	4002f104 	.word	0x4002f104
    69e4:	4002f060 	.word	0x4002f060
    69e8:	4002f008 	.word	0x4002f008
    69ec:	4002f00c 	.word	0x4002f00c
    69f0:	4002f010 	.word	0x4002f010
    69f4:	4002f014 	.word	0x4002f014
    69f8:	4002f0e0 	.word	0x4002f0e0
    69fc:	4002f084 	.word	0x4002f084
    6a00:	00011f1b 	.word	0x00011f1b
    6a04:	1f1f1f00 	.word	0x1f1f1f00
    6a08:	4004b008 	.word	0x4004b008
    6a0c:	4004b00c 	.word	0x4004b00c
    6a10:	4004b018 	.word	0x4004b018
    6a14:	4002f004 	.word	0x4002f004
    6a18:	07000001 	.word	0x07000001
    6a1c:	4002f088 	.word	0x4002f088

00006a20 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE>:
audio_block_t * AudioOutputI2S::block_left_2nd = NULL;
audio_block_t * AudioOutputI2S::block_right_2nd = NULL;
uint16_t  AudioOutputI2S::block_left_offset = 0;
uint16_t  AudioOutputI2S::block_right_offset = 0;
bool AudioOutputI2S::update_responsibility = false;
DMAChannel AudioOutputI2S::dma(false);
    6a20:	4a02      	ldr	r2, [pc, #8]	; (6a2c <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0xc>)
    6a22:	4903      	ldr	r1, [pc, #12]	; (6a30 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0x10>)
    6a24:	4803      	ldr	r0, [pc, #12]	; (6a34 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0x14>)
    6a26:	f007 b85f 	b.w	dae8 <__aeabi_atexit>
    6a2a:	bf00      	nop
    6a2c:	1fffb874 	.word	0x1fffb874
    6a30:	000065c5 	.word	0x000065c5
    6a34:	200042fc 	.word	0x200042fc

00006a38 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE>:
uint16_t  AudioOutputI2SQuad::ch3_offset = 0;
uint16_t  AudioOutputI2SQuad::ch4_offset = 0;
//audio_block_t * AudioOutputI2SQuad::inputQueueArray[4];
bool AudioOutputI2SQuad::update_responsibility = false;
DMAMEM static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*2];
DMAChannel AudioOutputI2SQuad::dma(false);
    6a38:	4a02      	ldr	r2, [pc, #8]	; (6a44 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0xc>)
    6a3a:	4903      	ldr	r1, [pc, #12]	; (6a48 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0x10>)
    6a3c:	4803      	ldr	r0, [pc, #12]	; (6a4c <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0x14>)
    6a3e:	f007 b853 	b.w	dae8 <__aeabi_atexit>
    6a42:	bf00      	nop
    6a44:	1fffb874 	.word	0x1fffb874
    6a48:	000065c5 	.word	0x000065c5
    6a4c:	20004304 	.word	0x20004304

00006a50 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE>:
#if defined(AUDIO_PT8211_OVERSAMPLING)
	static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*4];
#else
	static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES];
#endif
DMAChannel AudioOutputPT8211::dma(false);
    6a50:	4a02      	ldr	r2, [pc, #8]	; (6a5c <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0xc>)
    6a52:	4903      	ldr	r1, [pc, #12]	; (6a60 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0x10>)
    6a54:	4803      	ldr	r0, [pc, #12]	; (6a64 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0x14>)
    6a56:	f007 b847 	b.w	dae8 <__aeabi_atexit>
    6a5a:	bf00      	nop
    6a5c:	1fffb874 	.word	0x1fffb874
    6a60:	000065c5 	.word	0x000065c5
    6a64:	2000430c 	.word	0x2000430c

00006a68 <_GLOBAL__sub_I__ZN14AudioOutputPWM9block_1stE>:
uint32_t  AudioOutputPWM::block_offset = 0;
bool AudioOutputPWM::update_responsibility = false;
uint8_t AudioOutputPWM::interrupt_count = 0;

DMAMEM uint32_t pwm_dma_buffer[AUDIO_BLOCK_SAMPLES*2];
DMAChannel AudioOutputPWM::dma(false);
    6a68:	4a02      	ldr	r2, [pc, #8]	; (6a74 <_GLOBAL__sub_I__ZN14AudioOutputPWM9block_1stE+0xc>)
    6a6a:	4903      	ldr	r1, [pc, #12]	; (6a78 <_GLOBAL__sub_I__ZN14AudioOutputPWM9block_1stE+0x10>)
    6a6c:	4803      	ldr	r0, [pc, #12]	; (6a7c <_GLOBAL__sub_I__ZN14AudioOutputPWM9block_1stE+0x14>)
    6a6e:	f007 b83b 	b.w	dae8 <__aeabi_atexit>
    6a72:	bf00      	nop
    6a74:	1fffb874 	.word	0x1fffb874
    6a78:	000065c5 	.word	0x000065c5
    6a7c:	20004314 	.word	0x20004314

00006a80 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE>:
audio_block_t * AudioOutputSPDIF::block_left_2nd = NULL;
audio_block_t * AudioOutputSPDIF::block_right_2nd = NULL;
uint16_t  AudioOutputSPDIF::block_left_offset = 0;
uint16_t  AudioOutputSPDIF::block_right_offset = 0;
bool AudioOutputSPDIF::update_responsibility = false;
DMAChannel AudioOutputSPDIF::dma(false);
    6a80:	4a02      	ldr	r2, [pc, #8]	; (6a8c <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0xc>)
    6a82:	4903      	ldr	r1, [pc, #12]	; (6a90 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0x10>)
    6a84:	4803      	ldr	r0, [pc, #12]	; (6a94 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0x14>)
    6a86:	f007 b82f 	b.w	dae8 <__aeabi_atexit>
    6a8a:	bf00      	nop
    6a8c:	1fffb874 	.word	0x1fffb874
    6a90:	000065c5 	.word	0x000065c5
    6a94:	2000431c 	.word	0x2000431c

00006a98 <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE>:
audio_block_t * AudioOutputTDM::block_input[16] = {
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
};
bool AudioOutputTDM::update_responsibility = false;
DMAChannel AudioOutputTDM::dma(false);
    6a98:	4a02      	ldr	r2, [pc, #8]	; (6aa4 <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0xc>)
    6a9a:	4903      	ldr	r1, [pc, #12]	; (6aa8 <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0x10>)
    6a9c:	4803      	ldr	r0, [pc, #12]	; (6aac <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0x14>)
    6a9e:	f007 b823 	b.w	dae8 <__aeabi_atexit>
    6aa2:	bf00      	nop
    6aa4:	1fffb874 	.word	0x1fffb874
    6aa8:	000065c5 	.word	0x000065c5
    6aac:	20004324 	.word	0x20004324

00006ab0 <EventResponder::triggerEvent(int, void*)>:
	}

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
    6ab0:	b410      	push	{r4}
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    6ab2:	7f04      	ldrb	r4, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
    6ab4:	6041      	str	r1, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
    6ab6:	2c02      	cmp	r4, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
    6ab8:	60c2      	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    6aba:	d002      	beq.n	6ac2 <EventResponder::triggerEvent(int, void*)+0x12>
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
		}
	}
    6abc:	bc10      	pop	{r4}
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
    6abe:	f002 bab1 	b.w	9024 <EventResponder::triggerEventNotImmediate()>
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    6ac2:	6883      	ldr	r3, [r0, #8]
		} else {
			triggerEventNotImmediate();
		}
	}
    6ac4:	bc10      	pop	{r4}
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    6ac6:	4718      	bx	r3

00006ac8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]>:
			}
		}
	}
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
    6ac8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6acc:	6804      	ldr	r4, [r0, #0]
{

	if (count == 0) return;
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    6ace:	68e5      	ldr	r5, [r4, #12]
    6ad0:	f015 7f80 	tst.w	r5, #16777216	; 0x1000000
		const uint8_t *p_write = (const uint8_t *)buf;
		uint8_t *p_read = (uint8_t *)retbuf;
		size_t count_read = count;

		// Lets clear the reader queue
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);
    6ad4:	4d79      	ldr	r5, [pc, #484]	; (6cbc <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1f4>)
    6ad6:	6025      	str	r5, [r4, #0]

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    6ad8:	d152      	bne.n	6b80 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xb8>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    6ada:	07df      	lsls	r7, r3, #31
    6adc:	f140 80b3 	bpl.w	6c46 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x17e>
		    if (p_write) {
    6ae0:	2900      	cmp	r1, #0
    6ae2:	f000 80e3 	beq.w	6cac <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1e4>
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    6ae6:	780d      	ldrb	r5, [r1, #0]
		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
		    if (p_write) {
				if (count > 1)
    6ae8:	2b01      	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    6aea:	bf18      	it	ne
    6aec:	f045 4500 	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    6af0:	6365      	str	r5, [r4, #52]	; 0x34
    6af2:	3101      	adds	r1, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    6af4:	f890 8024 	ldrb.w	r8, [r0, #36]	; 0x24
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
    6af8:	f103 3cff 	add.w	ip, r3, #4294967295	; 0xffffffff
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    6afc:	ea48 2808 	orr.w	r8, r8, r8, lsl #8

		while (count > 0) {
    6b00:	f1bc 0f00 	cmp.w	ip, #0
    6b04:	f000 80a8 	beq.w	6c58 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
			// Push out the next byte; 
		    if (p_write) {
    6b08:	b121      	cbz	r1, 6b14 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x4c>
		    	w = (*p_write++) << 8;
				w |= *p_write++;
    6b0a:	784d      	ldrb	r5, [r1, #1]
	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;

		while (count > 0) {
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
    6b0c:	f811 8b02 	ldrb.w	r8, [r1], #2
				w |= *p_write++;
    6b10:	ea45 2808 	orr.w	r8, r5, r8, lsl #8
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    6b14:	6845      	ldr	r5, [r0, #4]
    6b16:	7a2e      	ldrb	r6, [r5, #8]
			if (count == 2)
    6b18:	f1bc 0f02 	cmp.w	ip, #2
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    6b1c:	f106 36ff 	add.w	r6, r6, #4294967295	; 0xffffffff
    6b20:	ea4f 3606 	mov.w	r6, r6, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    6b24:	bf0c      	ite	eq
    6b26:	f048 5580 	orreq.w	r5, r8, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    6b2a:	f048 4510 	orrne.w	r5, r8, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    6b2e:	b2b6      	uxth	r6, r6
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    6b30:	6365      	str	r5, [r4, #52]	; 0x34
			count -= 2; // how many bytes to output.
    6b32:	f1ac 0c02 	sub.w	ip, ip, #2
    6b36:	e008      	b.n	6b4a <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x82>
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
						if (p_read) {
    6b38:	b10a      	cbz	r2, 6b3e <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x76>
							*p_read++ = w;  // Read any pending RX bytes in
    6b3a:	7014      	strb	r4, [r2, #0]
    6b3c:	3201      	adds	r2, #1
						} 
						count_read--;
    6b3e:	3b01      	subs	r3, #1
							*p_read++ = (w & 0xff);
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    6b40:	f405 4570 	and.w	r5, r5, #61440	; 0xf000
    6b44:	42b5      	cmp	r5, r6
    6b46:	d916      	bls.n	6b76 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xae>
    6b48:	6804      	ldr	r4, [r0, #0]
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    6b4a:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
				if (sr & 0xF0)  {
    6b4c:	f015 0ff0 	tst.w	r5, #240	; 0xf0
    6b50:	d0f6      	beq.n	6b40 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x78>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    6b52:	6ba4      	ldr	r4, [r4, #56]	; 0x38
					if (count_read & 1) {
    6b54:	f013 0f01 	tst.w	r3, #1
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
							*p_read++ = w >> 8;
    6b58:	4617      	mov	r7, r2
    6b5a:	ea4f 2e24 	mov.w	lr, r4, asr #8
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    6b5e:	d1eb      	bne.n	6b38 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x70>
						if (p_read) {
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
    6b60:	b11a      	cbz	r2, 6b6a <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xa2>
							*p_read++ = w >> 8;
    6b62:	f807 eb02 	strb.w	lr, [r7], #2
							*p_read++ = (w & 0xff);
    6b66:	7054      	strb	r4, [r2, #1]
    6b68:	463a      	mov	r2, r7
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    6b6a:	f405 4570 	and.w	r5, r5, #61440	; 0xf000
    6b6e:	42b5      	cmp	r5, r6
					} else {
						if (p_read) {
							*p_read++ = w >> 8;
							*p_read++ = (w & 0xff);
						}
						count_read -= 2;
    6b70:	f1a3 0302 	sub.w	r3, r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    6b74:	d8e8      	bhi.n	6b48 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x80>
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;

		while (count > 0) {
    6b76:	f1bc 0f00 	cmp.w	ip, #0
    6b7a:	d06d      	beq.n	6c58 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
    6b7c:	6804      	ldr	r4, [r0, #0]
    6b7e:	e7c3      	b.n	6b08 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x40>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    6b80:	07dd      	lsls	r5, r3, #31
    6b82:	d54c      	bpl.n	6c1e <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x156>
		    if (p_write) {
    6b84:	2900      	cmp	r1, #0
    6b86:	f000 8089 	beq.w	6c9c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1d4>
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    6b8a:	780d      	ldrb	r5, [r1, #0]
		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
		    if (p_write) {
				if (count > 1)
    6b8c:	2b01      	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    6b8e:	bf18      	it	ne
    6b90:	f045 4500 	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    6b94:	6365      	str	r5, [r4, #52]	; 0x34
    6b96:	3101      	adds	r1, #1
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
    6b98:	f103 3eff 	add.w	lr, r3, #4294967295	; 0xffffffff
		}

	    uint16_t w = _transferWriteFill;
    6b9c:	f890 c024 	ldrb.w	ip, [r0, #36]	; 0x24

		while (count > 0) {
    6ba0:	f1be 0f00 	cmp.w	lr, #0
    6ba4:	d041      	beq.n	6c2a <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
			// Push out the next byte; 
		    if (p_write) {
    6ba6:	b129      	cbz	r1, 6bb4 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xec>
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
    6ba8:	f891 c001 	ldrb.w	ip, [r1, #1]
    6bac:	780d      	ldrb	r5, [r1, #0]
    6bae:	3102      	adds	r1, #2
    6bb0:	ea45 2c0c 	orr.w	ip, r5, ip, lsl #8
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    6bb4:	6845      	ldr	r5, [r0, #4]
    6bb6:	7a2e      	ldrb	r6, [r5, #8]
			if (count == 2)
    6bb8:	f1be 0f02 	cmp.w	lr, #2
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    6bbc:	f106 36ff 	add.w	r6, r6, #4294967295	; 0xffffffff
    6bc0:	ea4f 3606 	mov.w	r6, r6, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    6bc4:	bf0c      	ite	eq
    6bc6:	f04c 5580 	orreq.w	r5, ip, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    6bca:	f04c 4510 	orrne.w	r5, ip, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    6bce:	b2b6      	uxth	r6, r6
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    6bd0:	6365      	str	r5, [r4, #52]	; 0x34
			count -= 2; // how many bytes to output.
    6bd2:	f1ae 0e02 	sub.w	lr, lr, #2
    6bd6:	e008      	b.n	6bea <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x122>
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
						if (p_read) {
    6bd8:	b10a      	cbz	r2, 6bde <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x116>
							*p_read++ = w;  // Read any pending RX bytes in
    6bda:	7014      	strb	r4, [r2, #0]
    6bdc:	3201      	adds	r2, #1
						} 
						count_read--;
    6bde:	3b01      	subs	r3, #1
							*p_read++ = w >> 8;
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    6be0:	f405 4570 	and.w	r5, r5, #61440	; 0xf000
    6be4:	42b5      	cmp	r5, r6
    6be6:	d915      	bls.n	6c14 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x14c>
    6be8:	6804      	ldr	r4, [r0, #0]
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    6bea:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
				if (sr & 0xF0)  {
    6bec:	f015 0ff0 	tst.w	r5, #240	; 0xf0
    6bf0:	d0f6      	beq.n	6be0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x118>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    6bf2:	f013 0f01 	tst.w	r3, #1
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
							*p_read++ = (w & 0xff);
    6bf6:	4617      	mov	r7, r2
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    6bf8:	6ba4      	ldr	r4, [r4, #56]	; 0x38
					if (count_read & 1) {
    6bfa:	d1ed      	bne.n	6bd8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x110>
						if (p_read) {
							*p_read++ = w;  // Read any pending RX bytes in
						} 
						count_read--;
					} else {
						if (p_read) {
    6bfc:	b122      	cbz	r2, 6c08 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x140>
							*p_read++ = (w & 0xff);
    6bfe:	f807 4b02 	strb.w	r4, [r7], #2
							*p_read++ = w >> 8;
    6c02:	1224      	asrs	r4, r4, #8
    6c04:	7054      	strb	r4, [r2, #1]
    6c06:	463a      	mov	r2, r7
						}
						count_read -= 2;
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    6c08:	f405 4570 	and.w	r5, r5, #61440	; 0xf000
    6c0c:	42b5      	cmp	r5, r6
					} else {
						if (p_read) {
							*p_read++ = (w & 0xff);
							*p_read++ = w >> 8;
						}
						count_read -= 2;
    6c0e:	f1a3 0302 	sub.w	r3, r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    6c12:	d8e9      	bhi.n	6be8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x120>
			count--;
		}

	    uint16_t w = _transferWriteFill;

		while (count > 0) {
    6c14:	f1be 0f00 	cmp.w	lr, #0
    6c18:	d007      	beq.n	6c2a <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
    6c1a:	6804      	ldr	r4, [r0, #0]
    6c1c:	e7c3      	b.n	6ba6 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xde>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    6c1e:	469e      	mov	lr, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w = _transferWriteFill;
    6c20:	f890 c024 	ldrb.w	ip, [r0, #36]	; 0x24

		while (count > 0) {
    6c24:	f1be 0f00 	cmp.w	lr, #0
    6c28:	d1bd      	bne.n	6ba6 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xde>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    6c2a:	b31b      	cbz	r3, 6c74 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1ac>
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    6c2c:	6804      	ldr	r4, [r0, #0]
			sr = port().SR;
    6c2e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
			if (sr & 0xF0)  {
    6c30:	f011 0ff0 	tst.w	r1, #240	; 0xf0
    6c34:	d0fb      	beq.n	6c2e <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x166>
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    6c36:	6ba1      	ldr	r1, [r4, #56]	; 0x38
				if (count_read & 1) {
    6c38:	07dc      	lsls	r4, r3, #31
    6c3a:	d51d      	bpl.n	6c78 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1b0>
					if (p_read)
    6c3c:	b10a      	cbz	r2, 6c42 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x17a>
						*p_read++ = w;  // Read any pending RX bytes in
    6c3e:	7011      	strb	r1, [r2, #0]
    6c40:	3201      	adds	r2, #1
					count_read--;
    6c42:	3b01      	subs	r3, #1
    6c44:	e7f1      	b.n	6c2a <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    6c46:	f890 8024 	ldrb.w	r8, [r0, #36]	; 0x24
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    6c4a:	469c      	mov	ip, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    6c4c:	ea48 2808 	orr.w	r8, r8, r8, lsl #8

		while (count > 0) {
    6c50:	f1bc 0f00 	cmp.w	ip, #0
    6c54:	f47f af58 	bne.w	6b08 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x40>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    6c58:	b163      	cbz	r3, 6c74 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1ac>
    6c5a:	6804      	ldr	r4, [r0, #0]
			sr = port().SR;
    6c5c:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
			if (sr & 0xF0)  {
    6c5e:	f011 0ff0 	tst.w	r1, #240	; 0xf0
    6c62:	d0fb      	beq.n	6c5c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x194>
				uint16_t w = port().POPR;  // Read any pending RX bytes in
				if (count_read & 1) {
    6c64:	07de      	lsls	r6, r3, #31

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    6c66:	6ba1      	ldr	r1, [r4, #56]	; 0x38
				if (count_read & 1) {
    6c68:	d50f      	bpl.n	6c8a <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1c2>
					if (p_read)
    6c6a:	b10a      	cbz	r2, 6c70 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1a8>
						*p_read++ = w;  // Read any pending RX bytes in
    6c6c:	7011      	strb	r1, [r2, #0]
    6c6e:	3201      	adds	r2, #1
					count_read--;
    6c70:	3b01      	subs	r3, #1
    6c72:	e7f1      	b.n	6c58 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
    6c74:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if (count_read & 1) {
					if (p_read)
						*p_read++ = w;  // Read any pending RX bytes in
					count_read--;
				} else {
					if (p_read) {
    6c78:	b12a      	cbz	r2, 6c86 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1be>
						*p_read++ = (w & 0xff);
    6c7a:	4614      	mov	r4, r2
						*p_read++ = w >> 8;
    6c7c:	120d      	asrs	r5, r1, #8
					if (p_read)
						*p_read++ = w;  // Read any pending RX bytes in
					count_read--;
				} else {
					if (p_read) {
						*p_read++ = (w & 0xff);
    6c7e:	f804 1b02 	strb.w	r1, [r4], #2
						*p_read++ = w >> 8;
    6c82:	7055      	strb	r5, [r2, #1]
    6c84:	4622      	mov	r2, r4
					}
					count_read -= 2;
    6c86:	3b02      	subs	r3, #2
    6c88:	e7cf      	b.n	6c2a <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x162>
				if (count_read & 1) {
					if (p_read)
						*p_read++ = w;  // Read any pending RX bytes in
					count_read--;
				} else {
					if (p_read) {
    6c8a:	b12a      	cbz	r2, 6c98 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x1d0>
						*p_read++ = w >> 8;
    6c8c:	4614      	mov	r4, r2
    6c8e:	120d      	asrs	r5, r1, #8
    6c90:	f804 5b02 	strb.w	r5, [r4], #2
						*p_read++ = (w & 0xff);
    6c94:	7051      	strb	r1, [r2, #1]
    6c96:	4622      	mov	r2, r4
					}
					count_read -= 2;
    6c98:	3b02      	subs	r3, #2
    6c9a:	e7dd      	b.n	6c58 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x190>
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    6c9c:	f890 5024 	ldrb.w	r5, [r0, #36]	; 0x24
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
    6ca0:	2b01      	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    6ca2:	bf18      	it	ne
    6ca4:	f045 4500 	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    6ca8:	6365      	str	r5, [r4, #52]	; 0x34
    6caa:	e775      	b.n	6b98 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0xd0>
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    6cac:	f890 5024 	ldrb.w	r5, [r0, #36]	; 0x24
				if (count > 1)
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
			} else {
				if (count > 1)
    6cb0:	2b01      	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    6cb2:	bf18      	it	ne
    6cb4:	f045 4500 	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    6cb8:	6365      	str	r5, [r4, #52]	; 0x34
    6cba:	e71b      	b.n	6af4 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]+0x2c>
    6cbc:	801f0400 	.word	0x801f0400

00006cc0 <_spi_dma_rxISR0()>:
#endif


#if defined(__MK20DX128__) || defined(__MK20DX256__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    6cc0:	b4f0      	push	{r4, r5, r6, r7}

//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
    6cc2:	4b46      	ldr	r3, [pc, #280]	; (6ddc <_spi_dma_rxISR0()+0x11c>)
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
    6cc4:	4a46      	ldr	r2, [pc, #280]	; (6de0 <_spi_dma_rxISR0()+0x120>)
    6cc6:	6b18      	ldr	r0, [r3, #48]	; 0x30
    6cc8:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    6cca:	7901      	ldrb	r1, [r0, #4]
    6ccc:	7011      	strb	r1, [r2, #0]
	bool complete(void) {
		if (TCD->CSR & DMA_TCD_CSR_DONE) return true;
		return false;
	}
	void clearComplete(void) {
		DMA_CDNE = channel;
    6cce:	4945      	ldr	r1, [pc, #276]	; (6de4 <_spi_dma_rxISR0()+0x124>)
    6cd0:	7922      	ldrb	r2, [r4, #4]
    6cd2:	700a      	strb	r2, [r1, #0]
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
    6cd4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    6cd6:	7900      	ldrb	r0, [r0, #4]
    6cd8:	7008      	strb	r0, [r1, #0]
    6cda:	2a00      	cmp	r2, #0
    6cdc:	d046      	beq.n	6d6c <_spi_dma_rxISR0()+0xac>
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
    6cde:	6859      	ldr	r1, [r3, #4]
    6ce0:	68c9      	ldr	r1, [r1, #12]
    6ce2:	428a      	cmp	r2, r1
    6ce4:	d83e      	bhi.n	6d64 <_spi_dma_rxISR0()+0xa4>
    6ce6:	6821      	ldr	r1, [r4, #0]

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    6ce8:	8bcc      	ldrh	r4, [r1, #30]
    6cea:	0424      	lsls	r4, r4, #16
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
			_dma_count_remaining -= hardware().max_dma_count;
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
    6cec:	f102 30ff 	add.w	r0, r2, #4294967295	; 0xffffffff

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    6cf0:	d465      	bmi.n	6dbe <_spi_dma_rxISR0()+0xfe>
		tcd->BITER = len & 0x7fff;
    6cf2:	f3c0 000e 	ubfx	r0, r0, #0, #15
    6cf6:	83c8      	strh	r0, [r1, #30]
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    6cf8:	8bc8      	ldrh	r0, [r1, #30]
    6cfa:	b280      	uxth	r0, r0
    6cfc:	82c8      	strh	r0, [r1, #22]
    6cfe:	6b19      	ldr	r1, [r3, #48]	; 0x30
    6d00:	6809      	ldr	r1, [r1, #0]

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    6d02:	8bc8      	ldrh	r0, [r1, #30]
    6d04:	0400      	lsls	r0, r0, #16
    6d06:	d452      	bmi.n	6dae <_spi_dma_rxISR0()+0xee>
		tcd->BITER = len & 0x7fff;
    6d08:	f3c2 000e 	ubfx	r0, r2, #0, #15
    6d0c:	83c8      	strh	r0, [r1, #30]
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    6d0e:	8bc8      	ldrh	r0, [r1, #30]
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    6d10:	2400      	movs	r4, #0
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    6d12:	b280      	uxth	r0, r0
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    6d14:	f112 32ff 	adds.w	r2, r2, #4294967295	; 0xffffffff
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
    6d18:	82c8      	strh	r0, [r1, #22]
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    6d1a:	bf18      	it	ne
    6d1c:	2201      	movne	r2, #1
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    6d1e:	629c      	str	r4, [r3, #40]	; 0x28
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
    6d20:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
    6d22:	482e      	ldr	r0, [pc, #184]	; (6ddc <_spi_dma_rxISR0()+0x11c>)
    6d24:	6809      	ldr	r1, [r1, #0]
    6d26:	680d      	ldr	r5, [r1, #0]
    6d28:	f100 0424 	add.w	r4, r0, #36	; 0x24
    6d2c:	42a5      	cmp	r5, r4
    6d2e:	d036      	beq.n	6d9e <_spi_dma_rxISR0()+0xde>
    6d30:	6800      	ldr	r0, [r0, #0]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    6d32:	68c4      	ldr	r4, [r0, #12]
    6d34:	f014 4f80 	tst.w	r4, #1073741824	; 0x40000000
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    6d38:	680c      	ldr	r4, [r1, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    6d3a:	680d      	ldr	r5, [r1, #0]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    6d3c:	bf15      	itete	ne
    6d3e:	8824      	ldrhne	r4, [r4, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
    6d40:	7824      	ldrbeq	r4, [r4, #0]
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    6d42:	3502      	addne	r5, #2
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    6d44:	3501      	addeq	r5, #1
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    6d46:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    6d4a:	600d      	str	r5, [r1, #0]
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    6d4c:	6344      	str	r4, [r0, #52]	; 0x34
    6d4e:	6b19      	ldr	r1, [r3, #48]	; 0x30
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    6d50:	4b25      	ldr	r3, [pc, #148]	; (6de8 <_spi_dma_rxISR0()+0x128>)
    6d52:	7909      	ldrb	r1, [r1, #4]
    6d54:	7019      	strb	r1, [r3, #0]
			}
		}
		_dmaRX->enable();
    6d56:	4921      	ldr	r1, [pc, #132]	; (6ddc <_spi_dma_rxISR0()+0x11c>)
		if (should_reenable_tx)
    6d58:	b112      	cbz	r2, 6d60 <_spi_dma_rxISR0()+0xa0>
    6d5a:	6aca      	ldr	r2, [r1, #44]	; 0x2c
    6d5c:	7912      	ldrb	r2, [r2, #4]
    6d5e:	701a      	strb	r2, [r3, #0]
#endif


#if defined(__MK20DX128__) || defined(__MK20DX256__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    6d60:	bcf0      	pop	{r4, r5, r6, r7}
    6d62:	4770      	bx	lr
	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
			_dma_count_remaining -= hardware().max_dma_count;
    6d64:	1a52      	subs	r2, r2, r1
    6d66:	629a      	str	r2, [r3, #40]	; 0x28
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    6d68:	2201      	movs	r2, #1
    6d6a:	e7d9      	b.n	6d20 <_spi_dma_rxISR0()+0x60>
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    6d6c:	6b58      	ldr	r0, [r3, #52]	; 0x34
    6d6e:	6819      	ldr	r1, [r3, #0]
    6d70:	6805      	ldr	r5, [r0, #0]
			_dmaTX->enable();
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    6d72:	4c1e      	ldr	r4, [pc, #120]	; (6dec <_spi_dma_rxISR0()+0x12c>)
		_dmaRX->enable();
		if (should_reenable_tx)
			_dmaTX->enable();
	} else {

		port().RSER = 0;
    6d74:	630a      	str	r2, [r1, #48]	; 0x30
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    6d76:	62cc      	str	r4, [r1, #44]	; 0x2c
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    6d78:	68cc      	ldr	r4, [r1, #12]

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    6d7a:	682d      	ldr	r5, [r5, #0]
    6d7c:	4e1c      	ldr	r6, [pc, #112]	; (6df0 <_spi_dma_rxISR0()+0x130>)
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    6d7e:	f024 4480 	bic.w	r4, r4, #1073741824	; 0x40000000

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    6d82:	2703      	movs	r7, #3
    6d84:	42b5      	cmp	r5, r6
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    6d86:	60cc      	str	r4, [r1, #12]

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    6d88:	f883 7025 	strb.w	r7, [r3, #37]	; 0x25
    6d8c:	d11f      	bne.n	6dce <_spi_dma_rxISR0()+0x10e>
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    6d8e:	7f03      	ldrb	r3, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
    6d90:	6042      	str	r2, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
    6d92:	2b02      	cmp	r3, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
    6d94:	60c2      	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    6d96:	d01e      	beq.n	6dd6 <_spi_dma_rxISR0()+0x116>
#endif


#if defined(__MK20DX128__) || defined(__MK20DX256__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    6d98:	bcf0      	pop	{r4, r5, r6, r7}
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
    6d9a:	f002 b943 	b.w	9024 <EventResponder::triggerEventNotImmediate()>
    6d9e:	6801      	ldr	r1, [r0, #0]
			_dma_count_remaining = 0;
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    6da0:	f890 0024 	ldrb.w	r0, [r0, #36]	; 0x24

			_dma_count_remaining = 0;
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    6da4:	68cc      	ldr	r4, [r1, #12]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    6da6:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
    6daa:	6348      	str	r0, [r1, #52]	; 0x34
    6dac:	e7cf      	b.n	6d4e <_spi_dma_rxISR0()+0x8e>
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    6dae:	8bcc      	ldrh	r4, [r1, #30]
    6db0:	f3c2 0008 	ubfx	r0, r2, #0, #9
    6db4:	f404 447e 	and.w	r4, r4, #65024	; 0xfe00
    6db8:	4320      	orrs	r0, r4
    6dba:	83c8      	strh	r0, [r1, #30]
    6dbc:	e7a7      	b.n	6d0e <_spi_dma_rxISR0()+0x4e>
    6dbe:	8bcc      	ldrh	r4, [r1, #30]
    6dc0:	f3c0 0008 	ubfx	r0, r0, #0, #9
    6dc4:	f404 447e 	and.w	r4, r4, #65024	; 0xfe00
    6dc8:	4320      	orrs	r0, r4
    6dca:	83c8      	strh	r0, [r1, #30]
    6dcc:	e794      	b.n	6cf8 <_spi_dma_rxISR0()+0x38>
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    6dce:	462b      	mov	r3, r5
    6dd0:	4611      	mov	r1, r2
#endif


#if defined(__MK20DX128__) || defined(__MK20DX256__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    6dd2:	bcf0      	pop	{r4, r5, r6, r7}
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    6dd4:	4718      	bx	r3
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    6dd6:	6883      	ldr	r3, [r0, #8]
#endif


#if defined(__MK20DX128__) || defined(__MK20DX256__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    6dd8:	bcf0      	pop	{r4, r5, r6, r7}
    6dda:	4718      	bx	r3
    6ddc:	1fffb8e8 	.word	0x1fffb8e8
    6de0:	4000801f 	.word	0x4000801f
    6de4:	4000801c 	.word	0x4000801c
    6de8:	4000801b 	.word	0x4000801b
    6dec:	ff0f0000 	.word	0xff0f0000
    6df0:	00006ab1 	.word	0x00006ab1

00006df4 <SPIClass::transfer(void const*, void*, unsigned int)>:
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
    6df4:	b10b      	cbz	r3, 6dfa <SPIClass::transfer(void const*, void*, unsigned int)+0x6>
    6df6:	f7ff be67 	b.w	6ac8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.10]>
    6dfa:	4770      	bx	lr

00006dfc <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
    6dfc:	2000      	movs	r0, #0
    6dfe:	4770      	bx	lr

00006e00 <Print::flush()>:
	virtual void flush()				{ }
    6e00:	4770      	bx	lr
    6e02:	bf00      	nop

00006e04 <_GLOBAL__sub_I__Z20getNextPathComponentPKcPjPc>:
 * \brief Raw access to SD and SDHC flash memory cards.
 */
class Sd2Card {
 public:
  /** Construct an instance of Sd2Card. */
  Sd2Card(void) : type_(0) {}
    6e04:	4b06      	ldr	r3, [pc, #24]	; (6e20 <_GLOBAL__sub_I__Z20getNextPathComponentPKcPjPc+0x1c>)
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
    6e06:	4a07      	ldr	r2, [pc, #28]	; (6e24 <_GLOBAL__sub_I__Z20getNextPathComponentPKcPjPc+0x20>)
    6e08:	62da      	str	r2, [r3, #44]	; 0x2c
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
    6e0a:	2102      	movs	r1, #2
    6e0c:	2200      	movs	r2, #0
    6e0e:	6059      	str	r1, [r3, #4]
    6e10:	709a      	strb	r2, [r3, #2]
    6e12:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    6e16:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
    6e1a:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
    6e1e:	4770      	bx	lr
    6e20:	2000432c 	.word	0x2000432c
    6e24:	00012330 	.word	0x00012330

00006e28 <Sd2Card::chipSelectHigh()>:
}
//------------------------------------------------------------------------------
#ifdef SPI_HAS_TRANSACTION
static uint8_t chip_select_asserted = 0;
#endif
void Sd2Card::chipSelectHigh(void) {
    6e28:	b510      	push	{r4, lr}
  digitalWrite(chipSelectPin_, HIGH);
    6e2a:	2101      	movs	r1, #1
    6e2c:	7800      	ldrb	r0, [r0, #0]
    6e2e:	f003 f933 	bl	a098 <digitalWrite>
#ifdef SPI_HAS_TRANSACTION
  if (chip_select_asserted) {
    6e32:	4a0e      	ldr	r2, [pc, #56]	; (6e6c <Sd2Card::chipSelectHigh()+0x44>)
    6e34:	7813      	ldrb	r3, [r2, #0]
    6e36:	b193      	cbz	r3, 6e5e <Sd2Card::chipSelectHigh()+0x36>
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    6e38:	490d      	ldr	r1, [pc, #52]	; (6e70 <Sd2Card::chipSelectHigh()+0x48>)
    6e3a:	7acb      	ldrb	r3, [r1, #11]
    chip_select_asserted = 0;
    6e3c:	2400      	movs	r4, #0
    6e3e:	4618      	mov	r0, r3
    6e40:	7014      	strb	r4, [r2, #0]
    6e42:	b163      	cbz	r3, 6e5e <Sd2Card::chipSelectHigh()+0x36>
			if (interruptMasksUsed & 0x01) {
    6e44:	07dc      	lsls	r4, r3, #31
    6e46:	d503      	bpl.n	6e50 <Sd2Card::chipSelectHigh()+0x28>
				NVIC_ISER0 = interruptSave[0];
    6e48:	4a0a      	ldr	r2, [pc, #40]	; (6e74 <Sd2Card::chipSelectHigh()+0x4c>)
    6e4a:	6988      	ldr	r0, [r1, #24]
    6e4c:	6010      	str	r0, [r2, #0]
    6e4e:	4618      	mov	r0, r3
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    6e50:	079a      	lsls	r2, r3, #30
    6e52:	d405      	bmi.n	6e60 <Sd2Card::chipSelectHigh()+0x38>
				NVIC_ISER1 = interruptSave[1];
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    6e54:	0743      	lsls	r3, r0, #29
    6e56:	d502      	bpl.n	6e5e <Sd2Card::chipSelectHigh()+0x36>
				NVIC_ISER2 = interruptSave[2];
    6e58:	4b07      	ldr	r3, [pc, #28]	; (6e78 <Sd2Card::chipSelectHigh()+0x50>)
    6e5a:	6a0a      	ldr	r2, [r1, #32]
    6e5c:	601a      	str	r2, [r3, #0]
    6e5e:	bd10      	pop	{r4, pc}
			if (interruptMasksUsed & 0x01) {
				NVIC_ISER0 = interruptSave[0];
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
				NVIC_ISER1 = interruptSave[1];
    6e60:	4b06      	ldr	r3, [pc, #24]	; (6e7c <Sd2Card::chipSelectHigh()+0x54>)
    6e62:	69ca      	ldr	r2, [r1, #28]
    6e64:	7ac8      	ldrb	r0, [r1, #11]
    6e66:	601a      	str	r2, [r3, #0]
    6e68:	e7f4      	b.n	6e54 <Sd2Card::chipSelectHigh()+0x2c>
    6e6a:	bf00      	nop
    6e6c:	20004384 	.word	0x20004384
    6e70:	1fffb8e8 	.word	0x1fffb8e8
    6e74:	e000e100 	.word	0xe000e100
    6e78:	e000e108 	.word	0xe000e108
    6e7c:	e000e104 	.word	0xe000e104

00006e80 <Sd2Card::chipSelectLow()>:
#endif
}
//------------------------------------------------------------------------------
void Sd2Card::chipSelectLow(void) {
#ifdef SPI_HAS_TRANSACTION
  if (!chip_select_asserted) {
    6e80:	4b1e      	ldr	r3, [pc, #120]	; (6efc <Sd2Card::chipSelectLow()+0x7c>)
    6e82:	781a      	ldrb	r2, [r3, #0]
    6e84:	b11a      	cbz	r2, 6e8e <Sd2Card::chipSelectLow()+0xe>
    chip_select_asserted = 1;
    SPI.beginTransaction(settings);
  }
#endif
  digitalWrite(chipSelectPin_, LOW);
    6e86:	7800      	ldrb	r0, [r0, #0]
    6e88:	2100      	movs	r1, #0
    6e8a:	f003 b905 	b.w	a098 <digitalWrite>
    SPI.endTransaction();
  }
#endif
}
//------------------------------------------------------------------------------
void Sd2Card::chipSelectLow(void) {
    6e8e:	b470      	push	{r4, r5, r6}

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    6e90:	4a1b      	ldr	r2, [pc, #108]	; (6f00 <Sd2Card::chipSelectLow()+0x80>)
    6e92:	491c      	ldr	r1, [pc, #112]	; (6f04 <Sd2Card::chipSelectLow()+0x84>)
    6e94:	7ad4      	ldrb	r4, [r2, #11]
    6e96:	6809      	ldr	r1, [r1, #0]
#ifdef SPI_HAS_TRANSACTION
  if (!chip_select_asserted) {
    chip_select_asserted = 1;
    6e98:	2501      	movs	r5, #1
    6e9a:	701d      	strb	r5, [r3, #0]
    6e9c:	b1ec      	cbz	r4, 6eda <Sd2Card::chipSelectLow()+0x5a>
			__disable_irq();
    6e9e:	b672      	cpsid	i
			if (interruptMasksUsed & 0x01) {
    6ea0:	7ad3      	ldrb	r3, [r2, #11]
    6ea2:	07de      	lsls	r6, r3, #31
    6ea4:	461c      	mov	r4, r3
    6ea6:	d506      	bpl.n	6eb6 <Sd2Card::chipSelectLow()+0x36>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    6ea8:	4d17      	ldr	r5, [pc, #92]	; (6f08 <Sd2Card::chipSelectLow()+0x88>)
    6eaa:	68d4      	ldr	r4, [r2, #12]
    6eac:	682e      	ldr	r6, [r5, #0]
    6eae:	4034      	ands	r4, r6
    6eb0:	6194      	str	r4, [r2, #24]
				NVIC_ICER0 = interruptSave[0];
    6eb2:	602c      	str	r4, [r5, #0]
    6eb4:	461c      	mov	r4, r3
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    6eb6:	079d      	lsls	r5, r3, #30
    6eb8:	d506      	bpl.n	6ec8 <Sd2Card::chipSelectLow()+0x48>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    6eba:	4d14      	ldr	r5, [pc, #80]	; (6f0c <Sd2Card::chipSelectLow()+0x8c>)
    6ebc:	6913      	ldr	r3, [r2, #16]
    6ebe:	682e      	ldr	r6, [r5, #0]
    6ec0:	7ad4      	ldrb	r4, [r2, #11]
    6ec2:	4033      	ands	r3, r6
    6ec4:	61d3      	str	r3, [r2, #28]
				NVIC_ICER1 = interruptSave[1];
    6ec6:	602b      	str	r3, [r5, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    6ec8:	0763      	lsls	r3, r4, #29
    6eca:	d505      	bpl.n	6ed8 <Sd2Card::chipSelectLow()+0x58>
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    6ecc:	4c10      	ldr	r4, [pc, #64]	; (6f10 <Sd2Card::chipSelectLow()+0x90>)
    6ece:	6953      	ldr	r3, [r2, #20]
    6ed0:	6825      	ldr	r5, [r4, #0]
    6ed2:	402b      	ands	r3, r5
    6ed4:	6213      	str	r3, [r2, #32]
				NVIC_ICER2 = interruptSave[2];
    6ed6:	6023      	str	r3, [r4, #0]
			if (interruptMasksUsed & 0x08) {
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
				NVIC_ICER3 = interruptSave[3];
			}
			#endif
			__enable_irq();
    6ed8:	b662      	cpsie	i
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    6eda:	6813      	ldr	r3, [r2, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
    6edc:	68da      	ldr	r2, [r3, #12]
    6ede:	428a      	cmp	r2, r1
    6ee0:	d007      	beq.n	6ef2 <Sd2Card::chipSelectLow()+0x72>
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
    6ee2:	4c0c      	ldr	r4, [pc, #48]	; (6f14 <Sd2Card::chipSelectLow()+0x94>)
    6ee4:	601c      	str	r4, [r3, #0]
			port().CTAR0 = settings.ctar;
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    6ee6:	4a0c      	ldr	r2, [pc, #48]	; (6f18 <Sd2Card::chipSelectLow()+0x98>)
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
			port().CTAR0 = settings.ctar;
    6ee8:	60d9      	str	r1, [r3, #12]
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
    6eea:	f041 4480 	orr.w	r4, r1, #1073741824	; 0x40000000
    6eee:	611c      	str	r4, [r3, #16]
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    6ef0:	601a      	str	r2, [r3, #0]
    SPI.beginTransaction(settings);
  }
#endif
  digitalWrite(chipSelectPin_, LOW);
    6ef2:	7800      	ldrb	r0, [r0, #0]
    6ef4:	2100      	movs	r1, #0
}
    6ef6:	bc70      	pop	{r4, r5, r6}
  if (!chip_select_asserted) {
    chip_select_asserted = 1;
    SPI.beginTransaction(settings);
  }
#endif
  digitalWrite(chipSelectPin_, LOW);
    6ef8:	f003 b8ce 	b.w	a098 <digitalWrite>
    6efc:	20004384 	.word	0x20004384
    6f00:	1fffb8e8 	.word	0x1fffb8e8
    6f04:	20004380 	.word	0x20004380
    6f08:	e000e180 	.word	0xe000e180
    6f0c:	e000e184 	.word	0xe000e184
    6f10:	e000e188 	.word	0xe000e188
    6f14:	003f4001 	.word	0x003f4001
    6f18:	803f0000 	.word	0x803f0000

00006f1c <Sd2Card::waitNotBusy(unsigned int)>:
  return true;
#endif
}
//------------------------------------------------------------------------------
// wait for card to go not busy
uint8_t Sd2Card::waitNotBusy(unsigned int timeoutMillis) {
    6f1c:	b4f0      	push	{r4, r5, r6, r7}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    6f1e:	4812      	ldr	r0, [pc, #72]	; (6f68 <Sd2Card::waitNotBusy(unsigned int)+0x4c>)
  SPI.begin();
}

/** SPI receive a byte */
static  uint8_t spiRec() {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    6f20:	4a12      	ldr	r2, [pc, #72]	; (6f6c <Sd2Card::waitNotBusy(unsigned int)+0x50>)
    6f22:	6803      	ldr	r3, [r0, #0]
  return true;
#endif
}
//------------------------------------------------------------------------------
// wait for card to go not busy
uint8_t Sd2Card::waitNotBusy(unsigned int timeoutMillis) {
    6f24:	b082      	sub	sp, #8
/** SPI receive a byte */
static  uint8_t spiRec() {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
  SPI0_SR = SPI_SR_TCF;
  SPI0_PUSHR = 0xFF;
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    6f26:	4616      	mov	r6, r2
    6f28:	9300      	str	r3, [sp, #0]
	return ret;
    6f2a:	9f00      	ldr	r7, [sp, #0]
}

/** SPI receive a byte */
static  uint8_t spiRec() {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
  SPI0_SR = SPI_SR_TCF;
    6f2c:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
  SPI0_PUSHR = 0xFF;
    6f30:	24ff      	movs	r4, #255	; 0xff
  SPI.begin();
}

/** SPI receive a byte */
static  uint8_t spiRec() {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    6f32:	6813      	ldr	r3, [r2, #0]
    6f34:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    6f38:	6013      	str	r3, [r2, #0]
  SPI0_SR = SPI_SR_TCF;
    6f3a:	62d5      	str	r5, [r2, #44]	; 0x2c
  SPI0_PUSHR = 0xFF;
    6f3c:	6354      	str	r4, [r2, #52]	; 0x34
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    6f3e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    6f40:	2b00      	cmp	r3, #0
    6f42:	dafc      	bge.n	6f3e <Sd2Card::waitNotBusy(unsigned int)+0x22>
  return SPI0_POPR;
    6f44:	6bb3      	ldr	r3, [r6, #56]	; 0x38
// wait for card to go not busy
uint8_t Sd2Card::waitNotBusy(unsigned int timeoutMillis) {
  unsigned int t0 = millis();
  unsigned int d;
  do {
    if (spiRec() == 0XFF) return true;
    6f46:	b2db      	uxtb	r3, r3
    6f48:	2bff      	cmp	r3, #255	; 0xff
    6f4a:	d009      	beq.n	6f60 <Sd2Card::waitNotBusy(unsigned int)+0x44>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    6f4c:	6803      	ldr	r3, [r0, #0]
    6f4e:	9301      	str	r3, [sp, #4]
	return ret;
    6f50:	9b01      	ldr	r3, [sp, #4]
    d = millis() - t0;
  }
  while (d < timeoutMillis);
    6f52:	1bdb      	subs	r3, r3, r7
    6f54:	428b      	cmp	r3, r1
    6f56:	d3ec      	bcc.n	6f32 <Sd2Card::waitNotBusy(unsigned int)+0x16>
  return false;
    6f58:	2000      	movs	r0, #0
}
    6f5a:	b002      	add	sp, #8
    6f5c:	bcf0      	pop	{r4, r5, r6, r7}
    6f5e:	4770      	bx	lr
// wait for card to go not busy
uint8_t Sd2Card::waitNotBusy(unsigned int timeoutMillis) {
  unsigned int t0 = millis();
  unsigned int d;
  do {
    if (spiRec() == 0XFF) return true;
    6f60:	2001      	movs	r0, #1
    d = millis() - t0;
  }
  while (d < timeoutMillis);
  return false;
}
    6f62:	b002      	add	sp, #8
    6f64:	bcf0      	pop	{r4, r5, r6, r7}
    6f66:	4770      	bx	lr
    6f68:	200045ec 	.word	0x200045ec
    6f6c:	4002c000 	.word	0x4002c000

00006f70 <Sd2Card::cardCommand(unsigned char, unsigned long)>:


//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg)
{
    6f70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6f72:	460d      	mov	r5, r1
  // wait up to 300 ms if busy
  waitNotBusy(300);
    6f74:	f44f 7196 	mov.w	r1, #300	; 0x12c


//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg)
{
    6f78:	4616      	mov	r6, r2
    6f7a:	4604      	mov	r4, r0
  // wait up to 300 ms if busy
  waitNotBusy(300);
    6f7c:	f7ff ffce 	bl	6f1c <Sd2Card::waitNotBusy(unsigned int)>
    nf--;
  }
}
/** SPI send a byte */
static void spiSend(uint8_t b) {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    6f80:	4b28      	ldr	r3, [pc, #160]	; (7024 <Sd2Card::cardCommand(unsigned char, unsigned long)+0xb4>)
    6f82:	681a      	ldr	r2, [r3, #0]
  SPI0_SR = SPI_SR_TCF;
    6f84:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    nf--;
  }
}
/** SPI send a byte */
static void spiSend(uint8_t b) {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    6f88:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
  SPI0_SR = SPI_SR_TCF;
  SPI0_PUSHR = b;
    6f8c:	f045 0140 	orr.w	r1, r5, #64	; 0x40
    nf--;
  }
}
/** SPI send a byte */
static void spiSend(uint8_t b) {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    6f90:	601a      	str	r2, [r3, #0]
  SPI0_SR = SPI_SR_TCF;
    6f92:	62d8      	str	r0, [r3, #44]	; 0x2c
  SPI0_PUSHR = b;
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    6f94:	461a      	mov	r2, r3
}
/** SPI send a byte */
static void spiSend(uint8_t b) {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
  SPI0_SR = SPI_SR_TCF;
  SPI0_PUSHR = b;
    6f96:	6359      	str	r1, [r3, #52]	; 0x34
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    6f98:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    6f9a:	2b00      	cmp	r3, #0
    6f9c:	dafc      	bge.n	6f98 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x28>
    nf--;
  }
}
/** SPI send a byte */
static void spiSend(uint8_t b) {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    6f9e:	4921      	ldr	r1, [pc, #132]	; (7024 <Sd2Card::cardCommand(unsigned char, unsigned long)+0xb4>)
  SPI0_SR = SPI_SR_TCF;
  SPI0_PUSHR = b;
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    6fa0:	2018      	movs	r0, #24
  }
}
/** SPI send a byte */
static void spiSend(uint8_t b) {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
  SPI0_SR = SPI_SR_TCF;
    6fa2:	f04f 4700 	mov.w	r7, #2147483648	; 0x80000000
    nf--;
  }
}
/** SPI send a byte */
static void spiSend(uint8_t b) {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    6fa6:	680a      	ldr	r2, [r1, #0]
    6fa8:	fa26 f300 	lsr.w	r3, r6, r0
    6fac:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    6fb0:	b2db      	uxtb	r3, r3
    6fb2:	600a      	str	r2, [r1, #0]
  SPI0_SR = SPI_SR_TCF;
    6fb4:	62cf      	str	r7, [r1, #44]	; 0x2c
  SPI0_PUSHR = b;
    6fb6:	634b      	str	r3, [r1, #52]	; 0x34
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    6fb8:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    6fba:	2b00      	cmp	r3, #0
    6fbc:	dafc      	bge.n	6fb8 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x48>
    6fbe:	3808      	subs	r0, #8

  // send command
  spiSend(cmd | 0x40);

  // send argument
  for (int8_t s = 24; s >= 0; s -= 8) spiSend(arg >> s);
    6fc0:	f110 0f08 	cmn.w	r0, #8
    6fc4:	d1ef      	bne.n	6fa6 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x36>

  // send CRC
  uint8_t crc = 0XFF;
  if (cmd == CMD0) crc = 0X95;  // correct crc for CMD0 with arg 0
    6fc6:	b355      	cbz	r5, 701e <Sd2Card::cardCommand(unsigned char, unsigned long)+0xae>
  if (cmd == CMD8) crc = 0X87;  // correct crc for CMD8 with arg 0X1AA
    6fc8:	2d08      	cmp	r5, #8
    6fca:	bf0c      	ite	eq
    6fcc:	2187      	moveq	r1, #135	; 0x87
    6fce:	21ff      	movne	r1, #255	; 0xff
    nf--;
  }
}
/** SPI send a byte */
static void spiSend(uint8_t b) {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    6fd0:	4b14      	ldr	r3, [pc, #80]	; (7024 <Sd2Card::cardCommand(unsigned char, unsigned long)+0xb4>)
    6fd2:	681a      	ldr	r2, [r3, #0]
  SPI0_SR = SPI_SR_TCF;
    6fd4:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    nf--;
  }
}
/** SPI send a byte */
static void spiSend(uint8_t b) {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    6fd8:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    6fdc:	601a      	str	r2, [r3, #0]
  SPI0_SR = SPI_SR_TCF;
    6fde:	62d8      	str	r0, [r3, #44]	; 0x2c
  SPI0_PUSHR = b;
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    6fe0:	461a      	mov	r2, r3
}
/** SPI send a byte */
static void spiSend(uint8_t b) {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
  SPI0_SR = SPI_SR_TCF;
  SPI0_PUSHR = b;
    6fe2:	6359      	str	r1, [r3, #52]	; 0x34
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    6fe4:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    6fe6:	2b00      	cmp	r3, #0
    6fe8:	dafc      	bge.n	6fe4 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x74>
  SPI.begin();
}

/** SPI receive a byte */
static  uint8_t spiRec() {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    6fea:	4a0e      	ldr	r2, [pc, #56]	; (7024 <Sd2Card::cardCommand(unsigned char, unsigned long)+0xb4>)
/** SPI send a byte */
static void spiSend(uint8_t b) {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
  SPI0_SR = SPI_SR_TCF;
  SPI0_PUSHR = b;
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    6fec:	2700      	movs	r7, #0
/** SPI receive a byte */
static  uint8_t spiRec() {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
  SPI0_SR = SPI_SR_TCF;
  SPI0_PUSHR = 0xFF;
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    6fee:	4616      	mov	r6, r2
}

/** SPI receive a byte */
static  uint8_t spiRec() {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
  SPI0_SR = SPI_SR_TCF;
    6ff0:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
  SPI0_PUSHR = 0xFF;
    6ff4:	21ff      	movs	r1, #255	; 0xff
  SPI.begin();
}

/** SPI receive a byte */
static  uint8_t spiRec() {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    6ff6:	6813      	ldr	r3, [r2, #0]
    6ff8:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    6ffc:	6013      	str	r3, [r2, #0]
  SPI0_SR = SPI_SR_TCF;
    6ffe:	62d5      	str	r5, [r2, #44]	; 0x2c
  SPI0_PUSHR = 0xFF;
    7000:	6351      	str	r1, [r2, #52]	; 0x34
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    7002:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    7004:	2b00      	cmp	r3, #0
    7006:	dafc      	bge.n	7002 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x92>
  return SPI0_POPR;
    7008:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    700a:	b2d8      	uxtb	r0, r3
  if (cmd == CMD0) crc = 0X95;  // correct crc for CMD0 with arg 0
  if (cmd == CMD8) crc = 0X87;  // correct crc for CMD8 with arg 0X1AA
  spiSend(crc);

  // wait for response
  for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++);
    700c:	061b      	lsls	r3, r3, #24
    700e:	7060      	strb	r0, [r4, #1]
    7010:	d400      	bmi.n	7014 <Sd2Card::cardCommand(unsigned char, unsigned long)+0xa4>
  return status_;
}
    7012:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7014:	3701      	adds	r7, #1
  if (cmd == CMD0) crc = 0X95;  // correct crc for CMD0 with arg 0
  if (cmd == CMD8) crc = 0X87;  // correct crc for CMD8 with arg 0X1AA
  spiSend(crc);

  // wait for response
  for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++);
    7016:	f5b7 7f80 	cmp.w	r7, #256	; 0x100
    701a:	d1ec      	bne.n	6ff6 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x86>
  return status_;
}
    701c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    701e:	2195      	movs	r1, #149	; 0x95
    7020:	e7d6      	b.n	6fd0 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x60>
    7022:	bf00      	nop
    7024:	4002c000 	.word	0x4002c000

00007028 <Sd2Card::waitStartBlock()>:
  while (d < timeoutMillis);
  return false;
}
//------------------------------------------------------------------------------
/** Wait for start block token */
uint8_t Sd2Card::waitStartBlock(void) {
    7028:	b4f0      	push	{r4, r5, r6, r7}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    702a:	4915      	ldr	r1, [pc, #84]	; (7080 <Sd2Card::waitStartBlock()+0x58>)
  SPI.begin();
}

/** SPI receive a byte */
static  uint8_t spiRec() {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    702c:	4a15      	ldr	r2, [pc, #84]	; (7084 <Sd2Card::waitStartBlock()+0x5c>)
    702e:	680b      	ldr	r3, [r1, #0]
  while (d < timeoutMillis);
  return false;
}
//------------------------------------------------------------------------------
/** Wait for start block token */
uint8_t Sd2Card::waitStartBlock(void) {
    7030:	b082      	sub	sp, #8
/** SPI receive a byte */
static  uint8_t spiRec() {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
  SPI0_SR = SPI_SR_TCF;
  SPI0_PUSHR = 0xFF;
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    7032:	4616      	mov	r6, r2
    7034:	9300      	str	r3, [sp, #0]
	return ret;
    7036:	9f00      	ldr	r7, [sp, #0]
}

/** SPI receive a byte */
static  uint8_t spiRec() {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
  SPI0_SR = SPI_SR_TCF;
    7038:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
  SPI0_PUSHR = 0xFF;
    703c:	24ff      	movs	r4, #255	; 0xff
  SPI.begin();
}

/** SPI receive a byte */
static  uint8_t spiRec() {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    703e:	6813      	ldr	r3, [r2, #0]
    7040:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    7044:	6013      	str	r3, [r2, #0]
  SPI0_SR = SPI_SR_TCF;
    7046:	62d5      	str	r5, [r2, #44]	; 0x2c
  SPI0_PUSHR = 0xFF;
    7048:	6354      	str	r4, [r2, #52]	; 0x34
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    704a:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    704c:	2b00      	cmp	r3, #0
    704e:	dafc      	bge.n	704a <Sd2Card::waitStartBlock()+0x22>
  return SPI0_POPR;
    7050:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    7052:	b2db      	uxtb	r3, r3
}
//------------------------------------------------------------------------------
/** Wait for start block token */
uint8_t Sd2Card::waitStartBlock(void) {
  unsigned int t0 = millis();
  while ((status_ = spiRec()) == 0XFF) {
    7054:	2bff      	cmp	r3, #255	; 0xff
    7056:	7043      	strb	r3, [r0, #1]
    7058:	d10a      	bne.n	7070 <Sd2Card::waitStartBlock()+0x48>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    705a:	680b      	ldr	r3, [r1, #0]
    705c:	9301      	str	r3, [sp, #4]
	return ret;
    705e:	9b01      	ldr	r3, [sp, #4]
    unsigned int d = millis() - t0;
    if (d > SD_READ_TIMEOUT) {
    7060:	1bdb      	subs	r3, r3, r7
    7062:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
    7066:	d9ea      	bls.n	703e <Sd2Card::waitStartBlock()+0x16>
      return false; // SD_CARD_ERROR_READ_TIMEOUT
    7068:	2000      	movs	r0, #0
  }
  if (status_ != DATA_START_BLOCK) {
    return false; // SD_CARD_ERROR_READ
  }
  return true;
}
    706a:	b002      	add	sp, #8
    706c:	bcf0      	pop	{r4, r5, r6, r7}
    706e:	4770      	bx	lr
uint8_t Sd2Card::waitStartBlock(void) {
  unsigned int t0 = millis();
  while ((status_ = spiRec()) == 0XFF) {
    unsigned int d = millis() - t0;
    if (d > SD_READ_TIMEOUT) {
      return false; // SD_CARD_ERROR_READ_TIMEOUT
    7070:	f1a3 00fe 	sub.w	r0, r3, #254	; 0xfe
    7074:	fab0 f080 	clz	r0, r0
    7078:	0940      	lsrs	r0, r0, #5
  }
  if (status_ != DATA_START_BLOCK) {
    return false; // SD_CARD_ERROR_READ
  }
  return true;
}
    707a:	b002      	add	sp, #8
    707c:	bcf0      	pop	{r4, r5, r6, r7}
    707e:	4770      	bx	lr
    7080:	200045ec 	.word	0x200045ec
    7084:	4002c000 	.word	0x4002c000

00007088 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)>:

 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::SD_readBlock(uint32_t block, uint8_t* dst)
{
    7088:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  // use address if not SDHC card
  if (type_ != SD_CARD_TYPE_SDHC) block <<= 9;
    708a:	7883      	ldrb	r3, [r0, #2]
    708c:	2b03      	cmp	r3, #3

 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::SD_readBlock(uint32_t block, uint8_t* dst)
{
    708e:	460e      	mov	r6, r1
    7090:	4604      	mov	r4, r0
  // use address if not SDHC card
  if (type_ != SD_CARD_TYPE_SDHC) block <<= 9;
    7092:	bf18      	it	ne
    7094:	024e      	lslne	r6, r1, #9

 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::SD_readBlock(uint32_t block, uint8_t* dst)
{
    7096:	4615      	mov	r5, r2
  // use address if not SDHC card
  if (type_ != SD_CARD_TYPE_SDHC) block <<= 9;
  chipSelectLow();
    7098:	f7ff fef2 	bl	6e80 <Sd2Card::chipSelectLow()>
  if (cardCommand(CMD17, block)) {
    709c:	4632      	mov	r2, r6
    709e:	2111      	movs	r1, #17
    70a0:	4620      	mov	r0, r4
    70a2:	f7ff ff65 	bl	6f70 <Sd2Card::cardCommand(unsigned char, unsigned long)>
    70a6:	b918      	cbnz	r0, 70b0 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0x28>
    goto fail; // SD_CARD_ERROR_CMD17
  }
  if (!waitStartBlock()) {
    70a8:	4620      	mov	r0, r4
    70aa:	f7ff ffbd 	bl	7028 <Sd2Card::waitStartBlock()>
    70ae:	b920      	cbnz	r0, 70ba <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0x32>
#endif
  chipSelectHigh();
  return true;

 fail:
  chipSelectHigh();
    70b0:	4620      	mov	r0, r4
    70b2:	f7ff feb9 	bl	6e28 <Sd2Card::chipSelectHigh()>
  return false;
    70b6:	2000      	movs	r0, #0
}
    70b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return SPI0_POPR;
}
/** SPI receive multiple bytes */
static uint8_t spiRec(uint8_t* buf, size_t len) {
  // clear any data in RX FIFO
  SPI0_MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);
    70ba:	4b20      	ldr	r3, [pc, #128]	; (713c <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0xb4>)
    len--;
  }
  // initial number of words to push into TX FIFO
  int nf = len/2 < SPI_INITIAL_FIFO_DEPTH ? len/2 : SPI_INITIAL_FIFO_DEPTH;
  for (int i = 0; i < nf; i++) {
    SPI0_PUSHR = SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1) | 0XFFFF;
    70bc:	4920      	ldr	r1, [pc, #128]	; (7140 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0xb8>)
  return SPI0_POPR;
}
/** SPI receive multiple bytes */
static uint8_t spiRec(uint8_t* buf, size_t len) {
  // clear any data in RX FIFO
  SPI0_MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);
    70be:	4a21      	ldr	r2, [pc, #132]	; (7144 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0xbc>)
    70c0:	601a      	str	r2, [r3, #0]
    SPI0_PUSHR = SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1) | 0XFFFF;
  }
  uint8_t* limit = buf + len - 2*nf;
  while (buf < limit) {
    while (!(SPI0_SR & SPI_SR_RXCTR)) {}
    SPI0_PUSHR = SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1) | 0XFFFF;
    70c2:	468e      	mov	lr, r1
    len--;
  }
  // initial number of words to push into TX FIFO
  int nf = len/2 < SPI_INITIAL_FIFO_DEPTH ? len/2 : SPI_INITIAL_FIFO_DEPTH;
  for (int i = 0; i < nf; i++) {
    SPI0_PUSHR = SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1) | 0XFFFF;
    70c4:	6359      	str	r1, [r3, #52]	; 0x34
  }
  uint8_t* limit = buf + len - 2*nf;
  while (buf < limit) {
    while (!(SPI0_SR & SPI_SR_RXCTR)) {}
    70c6:	461a      	mov	r2, r3
    len--;
  }
  // initial number of words to push into TX FIFO
  int nf = len/2 < SPI_INITIAL_FIFO_DEPTH ? len/2 : SPI_INITIAL_FIFO_DEPTH;
  for (int i = 0; i < nf; i++) {
    SPI0_PUSHR = SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1) | 0XFFFF;
    70c8:	6359      	str	r1, [r3, #52]	; 0x34
  }
  uint8_t* limit = buf + len - 2*nf;
  while (buf < limit) {
    while (!(SPI0_SR & SPI_SR_RXCTR)) {}
    70ca:	461e      	mov	r6, r3
    len--;
  }
  // initial number of words to push into TX FIFO
  int nf = len/2 < SPI_INITIAL_FIFO_DEPTH ? len/2 : SPI_INITIAL_FIFO_DEPTH;
  for (int i = 0; i < nf; i++) {
    SPI0_PUSHR = SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1) | 0XFFFF;
    70cc:	6359      	str	r1, [r3, #52]	; 0x34
  }
  uint8_t* limit = buf + len - 2*nf;
    70ce:	f505 70fd 	add.w	r0, r5, #506	; 0x1fa
    70d2:	1ca9      	adds	r1, r5, #2
    70d4:	f505 77fe 	add.w	r7, r5, #508	; 0x1fc
  while (buf < limit) {
    while (!(SPI0_SR & SPI_SR_RXCTR)) {}
    70d8:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    70da:	f013 0ff0 	tst.w	r3, #240	; 0xf0
    70de:	d0fb      	beq.n	70d8 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0x50>
    SPI0_PUSHR = SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1) | 0XFFFF;
    70e0:	f8c6 e034 	str.w	lr, [r6, #52]	; 0x34
    uint16_t w = SPI0_POPR;
    70e4:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    *buf++ = w >> 8;
    *buf++ = w & 0XFF;
    70e6:	f801 3c01 	strb.w	r3, [r1, #-1]
  uint8_t* limit = buf + len - 2*nf;
  while (buf < limit) {
    while (!(SPI0_SR & SPI_SR_RXCTR)) {}
    SPI0_PUSHR = SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1) | 0XFFFF;
    uint16_t w = SPI0_POPR;
    *buf++ = w >> 8;
    70ea:	121b      	asrs	r3, r3, #8
    70ec:	f801 3c02 	strb.w	r3, [r1, #-2]
    70f0:	3102      	adds	r1, #2
  int nf = len/2 < SPI_INITIAL_FIFO_DEPTH ? len/2 : SPI_INITIAL_FIFO_DEPTH;
  for (int i = 0; i < nf; i++) {
    SPI0_PUSHR = SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1) | 0XFFFF;
  }
  uint8_t* limit = buf + len - 2*nf;
  while (buf < limit) {
    70f2:	428f      	cmp	r7, r1
    70f4:	d1f0      	bne.n	70d8 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0x50>
    uint16_t w = SPI0_POPR;
    *buf++ = w >> 8;
    *buf++ = w & 0XFF;
  }
  // limit for rest of RX data
  limit += 2*nf;
    70f6:	f505 7500 	add.w	r5, r5, #512	; 0x200
  while (buf < limit) {
    70fa:	42a8      	cmp	r0, r5
    70fc:	d20d      	bcs.n	711a <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0x92>
    while (!(SPI0_SR & SPI_SR_RXCTR)) {}
    70fe:	4a0f      	ldr	r2, [pc, #60]	; (713c <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0xb4>)
    7100:	4616      	mov	r6, r2
    7102:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    7104:	f013 0ff0 	tst.w	r3, #240	; 0xf0
    7108:	d0fb      	beq.n	7102 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0x7a>
    uint16_t w = SPI0_POPR;
    710a:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    *buf++ = w >> 8;
    710c:	1219      	asrs	r1, r3, #8
    710e:	f800 1b02 	strb.w	r1, [r0], #2
    *buf++ = w >> 8;
    *buf++ = w & 0XFF;
  }
  // limit for rest of RX data
  limit += 2*nf;
  while (buf < limit) {
    7112:	42a8      	cmp	r0, r5
    while (!(SPI0_SR & SPI_SR_RXCTR)) {}
    uint16_t w = SPI0_POPR;
    *buf++ = w >> 8;
    *buf++ = w & 0XFF;
    7114:	f800 3c01 	strb.w	r3, [r0, #-1]
    *buf++ = w >> 8;
    *buf++ = w & 0XFF;
  }
  // limit for rest of RX data
  limit += 2*nf;
  while (buf < limit) {
    7118:	d3f3      	bcc.n	7102 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0x7a>
  }
  return 0;
}
static void spiRecIgnore(size_t len) {
  // clear any data in RX FIFO
  SPI0_MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);
    711a:	4b08      	ldr	r3, [pc, #32]	; (713c <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0xb4>)
    711c:	4909      	ldr	r1, [pc, #36]	; (7144 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0xbc>)
    len--;
  }
  // initial number of words to push into TX FIFO
  int nf = len/2 < SPI_INITIAL_FIFO_DEPTH ? len/2 : SPI_INITIAL_FIFO_DEPTH;
  for (int i = 0; i < nf; i++) {
    SPI0_PUSHR = SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1) | 0XFFFF;
    711e:	4a08      	ldr	r2, [pc, #32]	; (7140 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0xb8>)
  }
  return 0;
}
static void spiRecIgnore(size_t len) {
  // clear any data in RX FIFO
  SPI0_MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);
    7120:	6019      	str	r1, [r3, #0]
    SPI0_POPR;
    len -= 2;
  }
  // limit for rest of RX data
  while (nf > 0) {
    while (!(SPI0_SR & SPI_SR_RXCTR)) {}
    7122:	4619      	mov	r1, r3
    len--;
  }
  // initial number of words to push into TX FIFO
  int nf = len/2 < SPI_INITIAL_FIFO_DEPTH ? len/2 : SPI_INITIAL_FIFO_DEPTH;
  for (int i = 0; i < nf; i++) {
    SPI0_PUSHR = SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1) | 0XFFFF;
    7124:	635a      	str	r2, [r3, #52]	; 0x34
    SPI0_POPR;
    len -= 2;
  }
  // limit for rest of RX data
  while (nf > 0) {
    while (!(SPI0_SR & SPI_SR_RXCTR)) {}
    7126:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    7128:	4a04      	ldr	r2, [pc, #16]	; (713c <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0xb4>)
    712a:	f013 0ff0 	tst.w	r3, #240	; 0xf0
    712e:	d0fa      	beq.n	7126 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0x9e>
  dst[511] = SPDR;
  // skip CRC bytes
  spiRec();
  spiRec();
#endif
  chipSelectHigh();
    7130:	4620      	mov	r0, r4
    len -= 2;
  }
  // limit for rest of RX data
  while (nf > 0) {
    while (!(SPI0_SR & SPI_SR_RXCTR)) {}
    SPI0_POPR;
    7132:	6b93      	ldr	r3, [r2, #56]	; 0x38
  dst[511] = SPDR;
  // skip CRC bytes
  spiRec();
  spiRec();
#endif
  chipSelectHigh();
    7134:	f7ff fe78 	bl	6e28 <Sd2Card::chipSelectHigh()>
  return true;
    7138:	2001      	movs	r0, #1
    713a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    713c:	4002c000 	.word	0x4002c000
    7140:	9000ffff 	.word	0x9000ffff
    7144:	801f0400 	.word	0x801f0400

00007148 <Sd2Card::writeData(unsigned char, unsigned char const*)>:
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
// send one block of data for write block or write multiple blocks
uint8_t Sd2Card::writeData(uint8_t token, const uint8_t* src) {
    7148:	b4f0      	push	{r4, r5, r6, r7}
public:
	inline SPDRemulation & operator = (int val) __attribute__((always_inline)) {
		//serial_print("SPDR = ");
		//serial_phex(val);
		//serial_print("\n");
		SPI0_MCR |= SPI_MCR_CLR_RXF; // discard any received data
    714a:	4e31      	ldr	r6, [pc, #196]	; (7210 <Sd2Card::writeData(unsigned char, unsigned char const*)+0xc8>)
    714c:	6833      	ldr	r3, [r6, #0]
		SPI0_SR = SPI_SR_TCF;
    714e:	f04f 4700 	mov.w	r7, #2147483648	; 0x80000000
public:
	inline SPDRemulation & operator = (int val) __attribute__((always_inline)) {
		//serial_print("SPDR = ");
		//serial_phex(val);
		//serial_print("\n");
		SPI0_MCR |= SPI_MCR_CLR_RXF; // discard any received data
    7152:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    7156:	6033      	str	r3, [r6, #0]
		SPI0_SR = SPI_SR_TCF;
    7158:	463d      	mov	r5, r7
    715a:	62f7      	str	r7, [r6, #44]	; 0x2c
		// a difference when digitalWrite is used to manually control the CS
		// pin, and perhaps it could matter at high clocks if faster register
		// access is used?  But does it really matter?  Do any SPI chips in
		// practice really perform differently if CS negates early, after the
		// final bit is clocked, but before the end of the whole clock cycle?
		if ((val & (1<<SPIF)) && (SPI0_SR & SPI_SR_TCF)) ret = (1<<SPIF);
    715c:	4634      	mov	r4, r6
		//serial_print("\n");
		SPI0_MCR |= SPI_MCR_CLR_RXF; // discard any received data
		SPI0_SR = SPI_SR_TCF;
		//SPI0_SR = SPI_SR_EOQF;
		//SPI0_PUSHR = (val & 255) | SPI0_PUSHR_EOQ;
		SPI0_PUSHR = (val & 255);
    715e:	6371      	str	r1, [r6, #52]	; 0x34
		// a difference when digitalWrite is used to manually control the CS
		// pin, and perhaps it could matter at high clocks if faster register
		// access is used?  But does it really matter?  Do any SPI chips in
		// practice really perform differently if CS negates early, after the
		// final bit is clocked, but before the end of the whole clock cycle?
		if ((val & (1<<SPIF)) && (SPI0_SR & SPI_SR_TCF)) ret = (1<<SPIF);
    7160:	4633      	mov	r3, r6
    7162:	1c51      	adds	r1, r2, #1
    7164:	f202 2701 	addw	r7, r2, #513	; 0x201
    7168:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    716a:	2a00      	cmp	r2, #0
    716c:	dafc      	bge.n	7168 <Sd2Card::writeData(unsigned char, unsigned char const*)+0x20>
public:
	inline SPDRemulation & operator = (int val) __attribute__((always_inline)) {
		//serial_print("SPDR = ");
		//serial_phex(val);
		//serial_print("\n");
		SPI0_MCR |= SPI_MCR_CLR_RXF; // discard any received data
    716e:	681a      	ldr	r2, [r3, #0]
  SPDR = token;

  // send two byte per iteration
  for (uint16_t i = 0; i < 512; i += 2) {
    while (!(SPSR & (1 << SPIF)));
    SPDR = src[i];
    7170:	f811 6c01 	ldrb.w	r6, [r1, #-1]
    7174:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    7178:	601a      	str	r2, [r3, #0]
		SPI0_SR = SPI_SR_TCF;
    717a:	62dd      	str	r5, [r3, #44]	; 0x2c
		//SPI0_SR = SPI_SR_EOQF;
		//SPI0_PUSHR = (val & 255) | SPI0_PUSHR_EOQ;
		SPI0_PUSHR = (val & 255);
    717c:	635e      	str	r6, [r3, #52]	; 0x34
		// a difference when digitalWrite is used to manually control the CS
		// pin, and perhaps it could matter at high clocks if faster register
		// access is used?  But does it really matter?  Do any SPI chips in
		// practice really perform differently if CS negates early, after the
		// final bit is clocked, but before the end of the whole clock cycle?
		if ((val & (1<<SPIF)) && (SPI0_SR & SPI_SR_TCF)) ret = (1<<SPIF);
    717e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    7180:	2a00      	cmp	r2, #0
    7182:	dafc      	bge.n	717e <Sd2Card::writeData(unsigned char, unsigned char const*)+0x36>
public:
	inline SPDRemulation & operator = (int val) __attribute__((always_inline)) {
		//serial_print("SPDR = ");
		//serial_phex(val);
		//serial_print("\n");
		SPI0_MCR |= SPI_MCR_CLR_RXF; // discard any received data
    7184:	681a      	ldr	r2, [r3, #0]
    while (!(SPSR & (1 << SPIF)));
    SPDR = src[i+1];
    7186:	f811 6b02 	ldrb.w	r6, [r1], #2
    718a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400

  // send data - optimized loop
  SPDR = token;

  // send two byte per iteration
  for (uint16_t i = 0; i < 512; i += 2) {
    718e:	428f      	cmp	r7, r1
    7190:	601a      	str	r2, [r3, #0]
		SPI0_SR = SPI_SR_TCF;
    7192:	62dd      	str	r5, [r3, #44]	; 0x2c
		//SPI0_SR = SPI_SR_EOQF;
		//SPI0_PUSHR = (val & 255) | SPI0_PUSHR_EOQ;
		SPI0_PUSHR = (val & 255);
    7194:	635e      	str	r6, [r3, #52]	; 0x34
    7196:	d1e7      	bne.n	7168 <Sd2Card::writeData(unsigned char, unsigned char const*)+0x20>
		// a difference when digitalWrite is used to manually control the CS
		// pin, and perhaps it could matter at high clocks if faster register
		// access is used?  But does it really matter?  Do any SPI chips in
		// practice really perform differently if CS negates early, after the
		// final bit is clocked, but before the end of the whole clock cycle?
		if ((val & (1<<SPIF)) && (SPI0_SR & SPI_SR_TCF)) ret = (1<<SPIF);
    7198:	491d      	ldr	r1, [pc, #116]	; (7210 <Sd2Card::writeData(unsigned char, unsigned char const*)+0xc8>)
    719a:	6aca      	ldr	r2, [r1, #44]	; 0x2c
    719c:	4b1c      	ldr	r3, [pc, #112]	; (7210 <Sd2Card::writeData(unsigned char, unsigned char const*)+0xc8>)
    719e:	2a00      	cmp	r2, #0
    71a0:	dafb      	bge.n	719a <Sd2Card::writeData(unsigned char, unsigned char const*)+0x52>
    nf--;
  }
}
/** SPI send a byte */
static void spiSend(uint8_t b) {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    71a2:	681a      	ldr	r2, [r3, #0]
  SPI0_SR = SPI_SR_TCF;
    71a4:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
    nf--;
  }
}
/** SPI send a byte */
static void spiSend(uint8_t b) {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    71a8:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
  SPI0_SR = SPI_SR_TCF;
  SPI0_PUSHR = b;
    71ac:	24ff      	movs	r4, #255	; 0xff
    nf--;
  }
}
/** SPI send a byte */
static void spiSend(uint8_t b) {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    71ae:	601a      	str	r2, [r3, #0]
  SPI0_SR = SPI_SR_TCF;
  SPI0_PUSHR = b;
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    71b0:	4619      	mov	r1, r3
  }
}
/** SPI send a byte */
static void spiSend(uint8_t b) {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
  SPI0_SR = SPI_SR_TCF;
    71b2:	62dd      	str	r5, [r3, #44]	; 0x2c
  SPI0_PUSHR = b;
    71b4:	635c      	str	r4, [r3, #52]	; 0x34
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    71b6:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    71b8:	4a15      	ldr	r2, [pc, #84]	; (7210 <Sd2Card::writeData(unsigned char, unsigned char const*)+0xc8>)
    71ba:	2b00      	cmp	r3, #0
    71bc:	dafb      	bge.n	71b6 <Sd2Card::writeData(unsigned char, unsigned char const*)+0x6e>
    nf--;
  }
}
/** SPI send a byte */
static void spiSend(uint8_t b) {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    71be:	6813      	ldr	r3, [r2, #0]
  SPI0_SR = SPI_SR_TCF;
    71c0:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
    nf--;
  }
}
/** SPI send a byte */
static void spiSend(uint8_t b) {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    71c4:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  SPI0_SR = SPI_SR_TCF;
  SPI0_PUSHR = b;
    71c8:	24ff      	movs	r4, #255	; 0xff
    nf--;
  }
}
/** SPI send a byte */
static void spiSend(uint8_t b) {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    71ca:	6013      	str	r3, [r2, #0]
  SPI0_SR = SPI_SR_TCF;
  SPI0_PUSHR = b;
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    71cc:	4611      	mov	r1, r2
  }
}
/** SPI send a byte */
static void spiSend(uint8_t b) {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
  SPI0_SR = SPI_SR_TCF;
    71ce:	62d5      	str	r5, [r2, #44]	; 0x2c
  SPI0_PUSHR = b;
    71d0:	6354      	str	r4, [r2, #52]	; 0x34
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    71d2:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    71d4:	4a0e      	ldr	r2, [pc, #56]	; (7210 <Sd2Card::writeData(unsigned char, unsigned char const*)+0xc8>)
    71d6:	2b00      	cmp	r3, #0
    71d8:	dafb      	bge.n	71d2 <Sd2Card::writeData(unsigned char, unsigned char const*)+0x8a>
  SPI.begin();
}

/** SPI receive a byte */
static  uint8_t spiRec() {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    71da:	6813      	ldr	r3, [r2, #0]
  SPI0_SR = SPI_SR_TCF;
    71dc:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
  SPI.begin();
}

/** SPI receive a byte */
static  uint8_t spiRec() {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    71e0:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  SPI0_SR = SPI_SR_TCF;
  SPI0_PUSHR = 0xFF;
    71e4:	24ff      	movs	r4, #255	; 0xff
  SPI.begin();
}

/** SPI receive a byte */
static  uint8_t spiRec() {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    71e6:	6013      	str	r3, [r2, #0]
  SPI0_SR = SPI_SR_TCF;
  SPI0_PUSHR = 0xFF;
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    71e8:	4611      	mov	r1, r2
}

/** SPI receive a byte */
static  uint8_t spiRec() {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
  SPI0_SR = SPI_SR_TCF;
    71ea:	62d5      	str	r5, [r2, #44]	; 0x2c
  SPI0_PUSHR = 0xFF;
    71ec:	6354      	str	r4, [r2, #52]	; 0x34
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    71ee:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    71f0:	4a07      	ldr	r2, [pc, #28]	; (7210 <Sd2Card::writeData(unsigned char, unsigned char const*)+0xc8>)
    71f2:	2b00      	cmp	r3, #0
    71f4:	dafb      	bge.n	71ee <Sd2Card::writeData(unsigned char, unsigned char const*)+0xa6>
  return SPI0_POPR;
    71f6:	6b93      	ldr	r3, [r2, #56]	; 0x38
    71f8:	b2db      	uxtb	r3, r3
    71fa:	f003 021f 	and.w	r2, r3, #31
  }
#endif  // OPTIMIZE_HARDWARE_SPI
  spiSend(0xff);  // dummy crc
  spiSend(0xff);  // dummy crc

  status_ = spiRec();
    71fe:	7043      	strb	r3, [r0, #1]
    7200:	f1a2 0005 	sub.w	r0, r2, #5
    7204:	fab0 f080 	clz	r0, r0
    7208:	0940      	lsrs	r0, r0, #5
  if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    return false; // SD_CARD_ERROR_WRITE
  }
  return true;
}
    720a:	bcf0      	pop	{r4, r5, r6, r7}
    720c:	4770      	bx	lr
    720e:	bf00      	nop
    7210:	4002c000 	.word	0x4002c000

00007214 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)>:
 * \param[in] blockNumber Logical block to be written.
 * \param[in] src Pointer to the location of the data to be written.
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::SD_writeBlock(uint32_t blockNumber, const uint8_t* src) {
    7214:	b570      	push	{r4, r5, r6, lr}
    7216:	4604      	mov	r4, r0
#if SD_PROTECT_BLOCK_ZERO
  // don't allow write to first block
  if (blockNumber == 0) {
    7218:	b171      	cbz	r1, 7238 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x24>
    goto fail; // SD_CARD_ERROR_WRITE_BLOCK_ZERO
  }
#endif  // SD_PROTECT_BLOCK_ZERO

  // use address if not SDHC card
  if (type_ != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
    721a:	7883      	ldrb	r3, [r0, #2]
    721c:	2b03      	cmp	r3, #3
    721e:	460d      	mov	r5, r1
    7220:	bf18      	it	ne
    7222:	024d      	lslne	r5, r1, #9
    7224:	4616      	mov	r6, r2
  chipSelectLow();
    7226:	f7ff fe2b 	bl	6e80 <Sd2Card::chipSelectLow()>
  if (cardCommand(CMD24, blockNumber)) {
    722a:	462a      	mov	r2, r5
    722c:	2118      	movs	r1, #24
    722e:	4620      	mov	r0, r4
    7230:	f7ff fe9e 	bl	6f70 <Sd2Card::cardCommand(unsigned char, unsigned long)>
    7234:	4605      	mov	r5, r0
    7236:	b120      	cbz	r0, 7242 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x2e>
  }
  chipSelectHigh();
  return true;

 fail:
  chipSelectHigh();
    7238:	4620      	mov	r0, r4
    723a:	f7ff fdf5 	bl	6e28 <Sd2Card::chipSelectHigh()>
  return false;
    723e:	2000      	movs	r0, #0
}
    7240:	bd70      	pop	{r4, r5, r6, pc}
  if (type_ != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
  chipSelectLow();
  if (cardCommand(CMD24, blockNumber)) {
    goto fail; // SD_CARD_ERROR_CMD24
  }
  if (!writeData(DATA_START_BLOCK, src)) goto fail;
    7242:	4632      	mov	r2, r6
    7244:	21fe      	movs	r1, #254	; 0xfe
    7246:	4620      	mov	r0, r4
    7248:	f7ff ff7e 	bl	7148 <Sd2Card::writeData(unsigned char, unsigned char const*)>
    724c:	2800      	cmp	r0, #0
    724e:	d0f3      	beq.n	7238 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x24>

  // wait for flash programming to complete
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7250:	f44f 7116 	mov.w	r1, #600	; 0x258
    7254:	4620      	mov	r0, r4
    7256:	f7ff fe61 	bl	6f1c <Sd2Card::waitNotBusy(unsigned int)>
    725a:	2800      	cmp	r0, #0
    725c:	d0ec      	beq.n	7238 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x24>
    goto fail; // SD_CARD_ERROR_WRITE_TIMEOUT
  }
  // response is r2 so get and check two bytes for nonzero
  if (cardCommand(CMD13, 0) || spiRec()) {
    725e:	462a      	mov	r2, r5
    7260:	210d      	movs	r1, #13
    7262:	4620      	mov	r0, r4
    7264:	f7ff fe84 	bl	6f70 <Sd2Card::cardCommand(unsigned char, unsigned long)>
    7268:	2800      	cmp	r0, #0
    726a:	d1e5      	bne.n	7238 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x24>
  SPI.begin();
}

/** SPI receive a byte */
static  uint8_t spiRec() {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    726c:	4b0b      	ldr	r3, [pc, #44]	; (729c <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x88>)
    726e:	681a      	ldr	r2, [r3, #0]
  SPI0_SR = SPI_SR_TCF;
    7270:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
  SPI.begin();
}

/** SPI receive a byte */
static  uint8_t spiRec() {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    7274:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
  SPI0_SR = SPI_SR_TCF;
  SPI0_PUSHR = 0xFF;
    7278:	20ff      	movs	r0, #255	; 0xff
  SPI.begin();
}

/** SPI receive a byte */
static  uint8_t spiRec() {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
    727a:	601a      	str	r2, [r3, #0]
  SPI0_SR = SPI_SR_TCF;
  SPI0_PUSHR = 0xFF;
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    727c:	4619      	mov	r1, r3
}

/** SPI receive a byte */
static  uint8_t spiRec() {
  SPI0_MCR |= SPI_MCR_CLR_RXF;
  SPI0_SR = SPI_SR_TCF;
    727e:	62dd      	str	r5, [r3, #44]	; 0x2c
  SPI0_PUSHR = 0xFF;
    7280:	6358      	str	r0, [r3, #52]	; 0x34
  while (!(SPI0_SR & SPI_SR_TCF)) {}
    7282:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    7284:	4a05      	ldr	r2, [pc, #20]	; (729c <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x88>)
    7286:	2b00      	cmp	r3, #0
    7288:	dafb      	bge.n	7282 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x6e>
  return SPI0_POPR;
    728a:	6b93      	ldr	r3, [r2, #56]	; 0x38
  // wait for flash programming to complete
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    goto fail; // SD_CARD_ERROR_WRITE_TIMEOUT
  }
  // response is r2 so get and check two bytes for nonzero
  if (cardCommand(CMD13, 0) || spiRec()) {
    728c:	f013 0fff 	tst.w	r3, #255	; 0xff
    7290:	d1d2      	bne.n	7238 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x24>
    goto fail; // SD_CARD_ERROR_WRITE_PROGRAMMING
  }
  chipSelectHigh();
    7292:	4620      	mov	r0, r4
    7294:	f7ff fdc8 	bl	6e28 <Sd2Card::chipSelectHigh()>
  return true;
    7298:	2001      	movs	r0, #1
    729a:	bd70      	pop	{r4, r5, r6, pc}
    729c:	4002c000 	.word	0x4002c000

000072a0 <_GLOBAL__sub_I__ZN7Sd2Card11cardCommandEhm>:
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
		}
		ctar = c | t;
    72a0:	4b01      	ldr	r3, [pc, #4]	; (72a8 <_GLOBAL__sub_I__ZN7Sd2Card11cardCommandEhm+0x8>)
    72a2:	4a02      	ldr	r2, [pc, #8]	; (72ac <_GLOBAL__sub_I__ZN7Sd2Card11cardCommandEhm+0xc>)
    72a4:	601a      	str	r2, [r3, #0]
    72a6:	4770      	bx	lr
    72a8:	20004380 	.word	0x20004380
    72ac:	38002003 	.word	0x38002003

000072b0 <SdFile::sync() [clone .part.23] [clone .constprop.37]>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 * Reasons for failure include a call to sync() before a file has been
 * opened or an I/O error.
 */
uint8_t SdFile::sync(void) {
    72b0:	b538      	push	{r3, r4, r5, lr}
  // only allow open files and directories
  if (!isOpen()) return false;

  if (flags_ & F_FILE_DIR_DIRTY) {
    72b2:	f990 3005 	ldrsb.w	r3, [r0, #5]
    72b6:	2b00      	cmp	r3, #0
    72b8:	db03      	blt.n	72c2 <SdFile::sync() [clone .part.23] [clone .constprop.37]+0x12>
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
  }
  return SdVolume::cacheFlush();
}
    72ba:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      d->lastAccessDate = d->lastWriteDate;
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
  }
  return SdVolume::cacheFlush();
    72be:	f000 b96d 	b.w	759c <SdVolume::cacheFlush()>
    72c2:	4604      	mov	r4, r0
}
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
dir_t* SdFile::cacheDirEntry(uint8_t action) {
  if (!SdVolume::cacheRawBlock(dirBlock_, action)) return NULL;
    72c4:	2101      	movs	r1, #1
    72c6:	6900      	ldr	r0, [r0, #16]
    72c8:	f000 f992 	bl	75f0 <SdVolume::cacheRawBlock(unsigned long, unsigned char)>
    72cc:	b1f8      	cbz	r0, 730e <SdFile::sync() [clone .part.23] [clone .constprop.37]+0x5e>
  return SdVolume::cacheBuffer_.dir + dirIndex_;
    72ce:	7d25      	ldrb	r5, [r4, #20]
    72d0:	4b10      	ldr	r3, [pc, #64]	; (7314 <SdFile::sync() [clone .part.23] [clone .constprop.37]+0x64>)
  // only allow open files and directories
  if (!isOpen()) return false;

  if (flags_ & F_FILE_DIR_DIRTY) {
    dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
    if (!d) return false;
    72d2:	eb13 1545 	adds.w	r5, r3, r5, lsl #5
    72d6:	d01a      	beq.n	730e <SdFile::sync() [clone .part.23] [clone .constprop.37]+0x5e>

    // do not set filesize for dir files
    if (!isDir()) d->fileSize = fileSize_;
    72d8:	79a3      	ldrb	r3, [r4, #6]
    // update first cluster fields
    d->firstClusterLow = firstCluster_ & 0XFFFF;
    d->firstClusterHigh = firstCluster_ >> 16;

    // set modify time if user supplied a callback date/time function
    if (dateTime_) {
    72da:	4a0f      	ldr	r2, [pc, #60]	; (7318 <SdFile::sync() [clone .part.23] [clone .constprop.37]+0x68>)
  if (flags_ & F_FILE_DIR_DIRTY) {
    dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
    if (!d) return false;

    // do not set filesize for dir files
    if (!isDir()) d->fileSize = fileSize_;
    72dc:	2b01      	cmp	r3, #1
    72de:	bf9c      	itt	ls
    72e0:	69a3      	ldrls	r3, [r4, #24]
    72e2:	61eb      	strls	r3, [r5, #28]

    // update first cluster fields
    d->firstClusterLow = firstCluster_ & 0XFFFF;
    72e4:	69e3      	ldr	r3, [r4, #28]
    d->firstClusterHigh = firstCluster_ >> 16;

    // set modify time if user supplied a callback date/time function
    if (dateTime_) {
    72e6:	6812      	ldr	r2, [r2, #0]

    // do not set filesize for dir files
    if (!isDir()) d->fileSize = fileSize_;

    // update first cluster fields
    d->firstClusterLow = firstCluster_ & 0XFFFF;
    72e8:	836b      	strh	r3, [r5, #26]
    d->firstClusterHigh = firstCluster_ >> 16;
    72ea:	0c1b      	lsrs	r3, r3, #16
    72ec:	82ab      	strh	r3, [r5, #20]

    // set modify time if user supplied a callback date/time function
    if (dateTime_) {
    72ee:	b132      	cbz	r2, 72fe <SdFile::sync() [clone .part.23] [clone .constprop.37]+0x4e>
      dateTime_(&d->lastWriteDate, &d->lastWriteTime);
    72f0:	f105 0116 	add.w	r1, r5, #22
    72f4:	f105 0018 	add.w	r0, r5, #24
    72f8:	4790      	blx	r2
      d->lastAccessDate = d->lastWriteDate;
    72fa:	8b2b      	ldrh	r3, [r5, #24]
    72fc:	826b      	strh	r3, [r5, #18]
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
    72fe:	7963      	ldrb	r3, [r4, #5]
    7300:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    7304:	7163      	strb	r3, [r4, #5]
  }
  return SdVolume::cacheFlush();
}
    7306:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      d->lastAccessDate = d->lastWriteDate;
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
  }
  return SdVolume::cacheFlush();
    730a:	f000 b947 	b.w	759c <SdVolume::cacheFlush()>
}
    730e:	2000      	movs	r0, #0
    7310:	bd38      	pop	{r3, r4, r5, pc}
    7312:	bf00      	nop
    7314:	20004394 	.word	0x20004394
    7318:	20004388 	.word	0x20004388

0000731c <SdFile::addCluster()>:
// suppress cpplint warnings with NOLINT comment
void (*SdFile::oldDateTime_)(uint16_t& date, uint16_t& time) = NULL;  // NOLINT
#endif  // ALLOW_DEPRECATED_FUNCTIONS
//------------------------------------------------------------------------------
// add a cluster to a file
uint8_t SdFile::addCluster() {
    731c:	b510      	push	{r4, lr}
  if (!vol_->allocContiguous(1, &curCluster_)) return false;
    731e:	f100 0208 	add.w	r2, r0, #8
// suppress cpplint warnings with NOLINT comment
void (*SdFile::oldDateTime_)(uint16_t& date, uint16_t& time) = NULL;  // NOLINT
#endif  // ALLOW_DEPRECATED_FUNCTIONS
//------------------------------------------------------------------------------
// add a cluster to a file
uint8_t SdFile::addCluster() {
    7322:	4604      	mov	r4, r0
  if (!vol_->allocContiguous(1, &curCluster_)) return false;
    7324:	2101      	movs	r1, #1
    7326:	6a00      	ldr	r0, [r0, #32]
    7328:	f000 fa00 	bl	772c <SdVolume::allocContiguous(unsigned long, unsigned long*)>
    732c:	b150      	cbz	r0, 7344 <SdFile::addCluster()+0x28>

  // if first cluster of file link to directory entry
  if (firstCluster_ == 0) {
    732e:	69e3      	ldr	r3, [r4, #28]
    7330:	b93b      	cbnz	r3, 7342 <SdFile::addCluster()+0x26>
    firstCluster_ = curCluster_;
    flags_ |= F_FILE_DIR_DIRTY;
    7332:	7963      	ldrb	r3, [r4, #5]
uint8_t SdFile::addCluster() {
  if (!vol_->allocContiguous(1, &curCluster_)) return false;

  // if first cluster of file link to directory entry
  if (firstCluster_ == 0) {
    firstCluster_ = curCluster_;
    7334:	68a2      	ldr	r2, [r4, #8]
    7336:	61e2      	str	r2, [r4, #28]
    flags_ |= F_FILE_DIR_DIRTY;
    7338:	f063 037f 	orn	r3, r3, #127	; 0x7f
    733c:	7163      	strb	r3, [r4, #5]
    733e:	2001      	movs	r0, #1
    7340:	bd10      	pop	{r4, pc}
  }
  return true;
    7342:	2001      	movs	r0, #1
}
    7344:	bd10      	pop	{r4, pc}
    7346:	bf00      	nop

00007348 <SdFile::seekSet(unsigned long)>:
 * \param[in] pos The new position in bytes from the beginning of the file.
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t SdFile::seekSet(uint32_t pos) {
    7348:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    734a:	7983      	ldrb	r3, [r0, #6]
  // error if file not open or seek past end of file
  if (!isOpen() || pos > fileSize_) return false;
    734c:	b113      	cbz	r3, 7354 <SdFile::seekSet(unsigned long)+0xc>
    734e:	6982      	ldr	r2, [r0, #24]
    7350:	428a      	cmp	r2, r1
    7352:	d201      	bcs.n	7358 <SdFile::seekSet(unsigned long)+0x10>
    7354:	2000      	movs	r0, #0
    7356:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  if (type_ == FAT_FILE_TYPE_ROOT16) {
    7358:	2b02      	cmp	r3, #2
    735a:	460f      	mov	r7, r1
    735c:	4605      	mov	r5, r0
    735e:	d01a      	beq.n	7396 <SdFile::seekSet(unsigned long)+0x4e>
    curPosition_ = pos;
    return true;
  }
  if (pos == 0) {
    7360:	b307      	cbz	r7, 73a4 <SdFile::seekSet(unsigned long)+0x5c>
    curCluster_ = 0;
    curPosition_ = 0;
    return true;
  }
  // calculate cluster index for cur and new position
  uint32_t nCur = (curPosition_ - 1) >> (vol_->clusterSizeShift_ + 9);
    7362:	6a2b      	ldr	r3, [r5, #32]
    7364:	68e9      	ldr	r1, [r5, #12]
    7366:	7c1c      	ldrb	r4, [r3, #16]
    7368:	1e4a      	subs	r2, r1, #1
    736a:	f104 0309 	add.w	r3, r4, #9
  uint32_t nNew = (pos - 1) >> (vol_->clusterSizeShift_ + 9);
    736e:	1e7c      	subs	r4, r7, #1
    curCluster_ = 0;
    curPosition_ = 0;
    return true;
  }
  // calculate cluster index for cur and new position
  uint32_t nCur = (curPosition_ - 1) >> (vol_->clusterSizeShift_ + 9);
    7370:	40da      	lsrs	r2, r3
  uint32_t nNew = (pos - 1) >> (vol_->clusterSizeShift_ + 9);
    7372:	40dc      	lsrs	r4, r3

  if (nNew < nCur || curPosition_ == 0) {
    7374:	42a2      	cmp	r2, r4
    7376:	d911      	bls.n	739c <SdFile::seekSet(unsigned long)+0x54>
    // must follow chain from first cluster
    curCluster_ = firstCluster_;
    7378:	69eb      	ldr	r3, [r5, #28]
    737a:	60ab      	str	r3, [r5, #8]
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (!vol_->fatGet(curCluster_, &curCluster_)) return false;
    737c:	f105 0608 	add.w	r6, r5, #8
    7380:	e006      	b.n	7390 <SdFile::seekSet(unsigned long)+0x48>
    7382:	68a9      	ldr	r1, [r5, #8]
    7384:	6a28      	ldr	r0, [r5, #32]
    7386:	f000 f999 	bl	76bc <SdVolume::fatGet(unsigned long, unsigned long*) const>
    738a:	3c01      	subs	r4, #1
    738c:	2800      	cmp	r0, #0
    738e:	d0e1      	beq.n	7354 <SdFile::seekSet(unsigned long)+0xc>
    7390:	4632      	mov	r2, r6
    curCluster_ = firstCluster_;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    7392:	2c00      	cmp	r4, #0
    7394:	d1f5      	bne.n	7382 <SdFile::seekSet(unsigned long)+0x3a>
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    curCluster_ = 0;
    curPosition_ = 0;
    7396:	60ef      	str	r7, [r5, #12]
    return true;
    7398:	2001      	movs	r0, #1
    739a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  }
  // calculate cluster index for cur and new position
  uint32_t nCur = (curPosition_ - 1) >> (vol_->clusterSizeShift_ + 9);
  uint32_t nNew = (pos - 1) >> (vol_->clusterSizeShift_ + 9);

  if (nNew < nCur || curPosition_ == 0) {
    739c:	2900      	cmp	r1, #0
    739e:	d0eb      	beq.n	7378 <SdFile::seekSet(unsigned long)+0x30>
    // must follow chain from first cluster
    curCluster_ = firstCluster_;
  } else {
    // advance from curPosition
    nNew -= nCur;
    73a0:	1aa4      	subs	r4, r4, r2
    73a2:	e7eb      	b.n	737c <SdFile::seekSet(unsigned long)+0x34>
    curPosition_ = pos;
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    curCluster_ = 0;
    73a4:	60af      	str	r7, [r5, #8]
    curPosition_ = 0;
    73a6:	60ef      	str	r7, [r5, #12]
    return true;
    73a8:	2001      	movs	r0, #1
    73aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000073ac <SdFile::write(void const*, unsigned int)>:
 * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
 * include write() is called before a file has been opened, write is called
 * for a read-only file, device is full, a corrupt file system or an I/O error.
 *
 */
size_t SdFile::write(const void* buf, size_t nbyte) {
    73ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    73b0:	468b      	mov	fp, r1

  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) goto writeErrorReturn;
    73b2:	7981      	ldrb	r1, [r0, #6]
 * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
 * include write() is called before a file has been opened, write is called
 * for a read-only file, device is full, a corrupt file system or an I/O error.
 *
 */
size_t SdFile::write(const void* buf, size_t nbyte) {
    73b4:	b085      	sub	sp, #20

  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) goto writeErrorReturn;
    73b6:	2901      	cmp	r1, #1
 * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
 * include write() is called before a file has been opened, write is called
 * for a read-only file, device is full, a corrupt file system or an I/O error.
 *
 */
size_t SdFile::write(const void* buf, size_t nbyte) {
    73b8:	4607      	mov	r7, r0
    73ba:	9201      	str	r2, [sp, #4]

  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) goto writeErrorReturn;
    73bc:	d005      	beq.n	73ca <SdFile::write(void const*, unsigned int)+0x1e>
	int getWriteError() { return write_error; }
	void clearWriteError() { setWriteError(0); }
	int printf(const char *format, ...);
	int printf(const __FlashStringHelper *format, ...);
  protected:
	void setWriteError(int err = 1) { write_error = err; }
    73be:	2301      	movs	r3, #1
    73c0:	713b      	strb	r3, [r7, #4]

 writeErrorReturn:
  // return for write error
  //writeError = true;
  setWriteError();
  return 0;
    73c2:	2000      	movs	r0, #0
}
    73c4:	b005      	add	sp, #20
    73c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) goto writeErrorReturn;
    73ca:	7942      	ldrb	r2, [r0, #5]
    73cc:	0791      	lsls	r1, r2, #30
    73ce:	d5f6      	bpl.n	73be <SdFile::write(void const*, unsigned int)+0x12>

  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    73d0:	0753      	lsls	r3, r2, #29
    73d2:	d508      	bpl.n	73e6 <SdFile::write(void const*, unsigned int)+0x3a>
    73d4:	68fc      	ldr	r4, [r7, #12]
    73d6:	69b9      	ldr	r1, [r7, #24]
    73d8:	428c      	cmp	r4, r1
    73da:	f000 80a8 	beq.w	752e <SdFile::write(void const*, unsigned int)+0x182>
  }
  /**
   *  Set the files current position to end of file.  Useful to position
   *  a file for append. See seekSet().
   */
  uint8_t seekEnd(void) {return seekSet(fileSize_);}
    73de:	f7ff ffb3 	bl	7348 <SdFile::seekSet(unsigned long)>
    if (!seekEnd()) goto writeErrorReturn;
    73e2:	2800      	cmp	r0, #0
    73e4:	d0eb      	beq.n	73be <SdFile::write(void const*, unsigned int)+0x12>
  }

  while (nToWrite > 0) {
    73e6:	9b01      	ldr	r3, [sp, #4]
    73e8:	68fc      	ldr	r4, [r7, #12]
    73ea:	2b00      	cmp	r3, #0
    73ec:	d049      	beq.n	7482 <SdFile::write(void const*, unsigned int)+0xd6>
        // rewrite part of block
        if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) {
          goto writeErrorReturn;
        }
      }
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
    73ee:	f8df 918c 	ldr.w	r9, [pc, #396]	; 757c <SdFile::write(void const*, unsigned int)+0x1d0>
      src += 512;
    } else {
      if (blockOffset == 0 && curPosition_ >= fileSize_) {
        // start of new block don't need to read into cache
        if (!SdVolume::cacheFlush()) goto writeErrorReturn;
        SdVolume::cacheBlockNumber_ = block;
    73f2:	f8df a18c 	ldr.w	sl, [pc, #396]	; 7580 <SdFile::write(void const*, unsigned int)+0x1d4>
 * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
 * include write() is called before a file has been opened, write is called
 * for a read-only file, device is full, a corrupt file system or an I/O error.
 *
 */
size_t SdFile::write(const void* buf, size_t nbyte) {
    73f6:	f8dd 8004 	ldr.w	r8, [sp, #4]
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    if (!seekEnd()) goto writeErrorReturn;
  }

  while (nToWrite > 0) {
    uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
    73fa:	6a38      	ldr	r0, [r7, #32]
  uint16_t rootDirEntryCount_;  // number of entries in FAT16 root dir
  uint32_t rootDirStart_;       // root start block for FAT16, cluster for FAT32
  //----------------------------------------------------------------------------
  uint8_t allocContiguous(uint32_t count, uint32_t* curCluster);
  uint8_t blockOfCluster(uint32_t position) const {
          return (position >> 9) & (blocksPerCluster_ - 1);}
    73fc:	7906      	ldrb	r6, [r0, #4]
    73fe:	3e01      	subs	r6, #1
    7400:	ea06 2654 	and.w	r6, r6, r4, lsr #9
    uint16_t blockOffset = curPosition_ & 0X1FF;
    if (blockOfCluster == 0 && blockOffset == 0) {
    7404:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
    if (!seekEnd()) goto writeErrorReturn;
  }

  while (nToWrite > 0) {
    uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
    uint16_t blockOffset = curPosition_ & 0X1FF;
    7408:	f3c4 0408 	ubfx	r4, r4, #0, #9
    if (blockOfCluster == 0 && blockOffset == 0) {
    740c:	d142      	bne.n	7494 <SdFile::write(void const*, unsigned int)+0xe8>
    740e:	2c00      	cmp	r4, #0
    7410:	d140      	bne.n	7494 <SdFile::write(void const*, unsigned int)+0xe8>
      // start of new cluster
      if (curCluster_ == 0) {
    7412:	68b9      	ldr	r1, [r7, #8]
    7414:	2900      	cmp	r1, #0
    7416:	d16f      	bne.n	74f8 <SdFile::write(void const*, unsigned int)+0x14c>
        if (firstCluster_ == 0) {
    7418:	69fa      	ldr	r2, [r7, #28]
    741a:	2a00      	cmp	r2, #0
    741c:	d07e      	beq.n	751c <SdFile::write(void const*, unsigned int)+0x170>
        if (!vol_->fatGet(curCluster_, &next)) return false;
        if (vol_->isEOC(next)) {
          // add cluster if at end of chain
          if (!addCluster()) goto writeErrorReturn;
        } else {
          curCluster_ = next;
    741e:	60ba      	str	r2, [r7, #8]
        }
      }
    }
    // max space in block
    uint16_t n = 512 - blockOffset;
    7420:	f5c4 7500 	rsb	r5, r4, #512	; 0x200
    7424:	b2ad      	uxth	r5, r5

    // lesser of space and amount to write
    if (n > nToWrite) n = nToWrite;
    7426:	4545      	cmp	r5, r8
    7428:	d93a      	bls.n	74a0 <SdFile::write(void const*, unsigned int)+0xf4>

    // block for data write
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
    742a:	7c05      	ldrb	r5, [r0, #16]
    742c:	6941      	ldr	r1, [r0, #20]
    742e:	3a02      	subs	r2, #2
    7430:	40aa      	lsls	r2, r5
    7432:	440e      	add	r6, r1
    7434:	4416      	add	r6, r2
    }
    // max space in block
    uint16_t n = 512 - blockOffset;

    // lesser of space and amount to write
    if (n > nToWrite) n = nToWrite;
    7436:	fa1f f588 	uxth.w	r5, r8
        SdVolume::cacheBlockNumber_ = 0XFFFFFFFF;
      }
      if (!vol_->writeBlock(block, src)) goto writeErrorReturn;
      src += 512;
    } else {
      if (blockOffset == 0 && curPosition_ >= fileSize_) {
    743a:	b91c      	cbnz	r4, 7444 <SdFile::write(void const*, unsigned int)+0x98>
    743c:	68f8      	ldr	r0, [r7, #12]
    743e:	69ba      	ldr	r2, [r7, #24]
    7440:	4290      	cmp	r0, r2
    7442:	d24c      	bcs.n	74de <SdFile::write(void const*, unsigned int)+0x132>
        if (!SdVolume::cacheFlush()) goto writeErrorReturn;
        SdVolume::cacheBlockNumber_ = block;
        SdVolume::cacheSetDirty();
      } else {
        // rewrite part of block
        if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) {
    7444:	4630      	mov	r0, r6
    7446:	2101      	movs	r1, #1
    7448:	f000 f8d2 	bl	75f0 <SdVolume::cacheRawBlock(unsigned long, unsigned char)>
    744c:	2800      	cmp	r0, #0
    744e:	d0b6      	beq.n	73be <SdFile::write(void const*, unsigned int)+0x12>
          goto writeErrorReturn;
        }
      }
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
    7450:	444c      	add	r4, r9
      uint8_t* end = dst + n;
    7452:	eb04 0e05 	add.w	lr, r4, r5
      while (dst != end) *dst++ = *src++;
    7456:	4574      	cmp	r4, lr
    7458:	d00d      	beq.n	7476 <SdFile::write(void const*, unsigned int)+0xca>
    745a:	f10b 31ff 	add.w	r1, fp, #4294967295	; 0xffffffff
    745e:	1e62      	subs	r2, r4, #1
    7460:	f10e 36ff 	add.w	r6, lr, #4294967295	; 0xffffffff
    7464:	f811 0f01 	ldrb.w	r0, [r1, #1]!
    7468:	f802 0f01 	strb.w	r0, [r2, #1]!
    746c:	4296      	cmp	r6, r2
    746e:	d1f9      	bne.n	7464 <SdFile::write(void const*, unsigned int)+0xb8>
    7470:	ebc4 040e 	rsb	r4, r4, lr
    7474:	44a3      	add	fp, r4
    }
    nToWrite -= n;
    curPosition_ += n;
    7476:	68fc      	ldr	r4, [r7, #12]
  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    if (!seekEnd()) goto writeErrorReturn;
  }

  while (nToWrite > 0) {
    7478:	ebb8 0805 	subs.w	r8, r8, r5
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
      uint8_t* end = dst + n;
      while (dst != end) *dst++ = *src++;
    }
    nToWrite -= n;
    curPosition_ += n;
    747c:	442c      	add	r4, r5
    747e:	60fc      	str	r4, [r7, #12]
  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    if (!seekEnd()) goto writeErrorReturn;
  }

  while (nToWrite > 0) {
    7480:	d1bb      	bne.n	73fa <SdFile::write(void const*, unsigned int)+0x4e>
      while (dst != end) *dst++ = *src++;
    }
    nToWrite -= n;
    curPosition_ += n;
  }
  if (curPosition_ > fileSize_) {
    7482:	69bb      	ldr	r3, [r7, #24]
    7484:	42a3      	cmp	r3, r4
    7486:	d257      	bcs.n	7538 <SdFile::write(void const*, unsigned int)+0x18c>
    // update fileSize and insure sync will update dir entry
    fileSize_ = curPosition_;
    flags_ |= F_FILE_DIR_DIRTY;
    7488:	797a      	ldrb	r2, [r7, #5]
    nToWrite -= n;
    curPosition_ += n;
  }
  if (curPosition_ > fileSize_) {
    // update fileSize and insure sync will update dir entry
    fileSize_ = curPosition_;
    748a:	61bc      	str	r4, [r7, #24]
    flags_ |= F_FILE_DIR_DIRTY;
    748c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    7490:	717a      	strb	r2, [r7, #5]
    7492:	e05a      	b.n	754a <SdFile::write(void const*, unsigned int)+0x19e>
          curCluster_ = next;
        }
      }
    }
    // max space in block
    uint16_t n = 512 - blockOffset;
    7494:	f5c4 7500 	rsb	r5, r4, #512	; 0x200
    7498:	b2ad      	uxth	r5, r5

    // lesser of space and amount to write
    if (n > nToWrite) n = nToWrite;
    749a:	4545      	cmp	r5, r8
    749c:	68ba      	ldr	r2, [r7, #8]
    749e:	d8c4      	bhi.n	742a <SdFile::write(void const*, unsigned int)+0x7e>

    // block for data write
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
    74a0:	7c01      	ldrb	r1, [r0, #16]
    74a2:	6940      	ldr	r0, [r0, #20]
    74a4:	3a02      	subs	r2, #2
    74a6:	408a      	lsls	r2, r1
    74a8:	4406      	add	r6, r0
    if (n == 512) {
    74aa:	f5b5 7f00 	cmp.w	r5, #512	; 0x200

    // lesser of space and amount to write
    if (n > nToWrite) n = nToWrite;

    // block for data write
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
    74ae:	4416      	add	r6, r2
    if (n == 512) {
    74b0:	d1c3      	bne.n	743a <SdFile::write(void const*, unsigned int)+0x8e>
      // full block - don't need to use cache
      // invalidate cache if block is in cache
      if (SdVolume::cacheBlockNumber_ == block) {
    74b2:	f8da 2000 	ldr.w	r2, [sl]
    74b6:	4296      	cmp	r6, r2
        SdVolume::cacheBlockNumber_ = 0XFFFFFFFF;
    74b8:	bf04      	itt	eq
    74ba:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
    74be:	f8ca 2000 	streq.w	r2, [sl]
  }
  uint8_t readBlock(uint32_t block, uint8_t* dst) {
    return sdCard_->readBlock(block, dst);
  }
  uint8_t writeBlock(uint32_t block, const uint8_t* dst) {
    return sdCard_->writeBlock(block, dst);
    74c2:	4a2a      	ldr	r2, [pc, #168]	; (756c <SdFile::write(void const*, unsigned int)+0x1c0>)
    #if defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__IMXRT1052__) || defined(__IMXRT1062__)
    if (chipSelectPin_ == BUILTIN_SDCARD) {
      return (SDHC_CardWriteBlock(src, block) == 0) ? true : false;
    }
    #endif
    return SD_writeBlock(block, src);
    74c4:	4631      	mov	r1, r6
    74c6:	6810      	ldr	r0, [r2, #0]
    74c8:	465a      	mov	r2, fp
    74ca:	f7ff fea3 	bl	7214 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)>
      }
      if (!vol_->writeBlock(block, src)) goto writeErrorReturn;
    74ce:	2800      	cmp	r0, #0
    74d0:	f43f af75 	beq.w	73be <SdFile::write(void const*, unsigned int)+0x12>
      src += 512;
    74d4:	f50b 7b00 	add.w	fp, fp, #512	; 0x200
    74d8:	f44f 7500 	mov.w	r5, #512	; 0x200
    74dc:	e7cb      	b.n	7476 <SdFile::write(void const*, unsigned int)+0xca>
    } else {
      if (blockOffset == 0 && curPosition_ >= fileSize_) {
        // start of new block don't need to read into cache
        if (!SdVolume::cacheFlush()) goto writeErrorReturn;
    74de:	f000 f85d 	bl	759c <SdVolume::cacheFlush()>
    74e2:	2800      	cmp	r0, #0
    74e4:	f43f af6b 	beq.w	73be <SdFile::write(void const*, unsigned int)+0x12>
           return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);}
  uint32_t blockNumber(uint32_t cluster, uint32_t position) const {
           return clusterStartBlock(cluster) + blockOfCluster(position);}
  static uint8_t cacheFlush(void);
  static uint8_t cacheRawBlock(uint32_t blockNumber, uint8_t action);
  static void cacheSetDirty(void) {cacheDirty_ |= CACHE_FOR_WRITE;}
    74e8:	4921      	ldr	r1, [pc, #132]	; (7570 <SdFile::write(void const*, unsigned int)+0x1c4>)
        SdVolume::cacheBlockNumber_ = block;
    74ea:	f8ca 6000 	str.w	r6, [sl]
    74ee:	780a      	ldrb	r2, [r1, #0]
    74f0:	f042 0201 	orr.w	r2, r2, #1
    74f4:	700a      	strb	r2, [r1, #0]
    74f6:	e7ab      	b.n	7450 <SdFile::write(void const*, unsigned int)+0xa4>
        } else {
          curCluster_ = firstCluster_;
        }
      } else {
        uint32_t next;
        if (!vol_->fatGet(curCluster_, &next)) return false;
    74f8:	aa03      	add	r2, sp, #12
    74fa:	f000 f8df 	bl	76bc <SdVolume::fatGet(unsigned long, unsigned long*) const>
    74fe:	2800      	cmp	r0, #0
    7500:	f43f af60 	beq.w	73c4 <SdFile::write(void const*, unsigned int)+0x18>
        if (vol_->isEOC(next)) {
    7504:	6a38      	ldr	r0, [r7, #32]
  uint8_t fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
  }
  uint8_t freeChain(uint32_t cluster);
  uint8_t isEOC(uint32_t cluster) const {
    return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
    7506:	4b1b      	ldr	r3, [pc, #108]	; (7574 <SdFile::write(void const*, unsigned int)+0x1c8>)
    7508:	f890 5020 	ldrb.w	r5, [r0, #32]
    750c:	9a03      	ldr	r2, [sp, #12]
    750e:	f64f 71f8 	movw	r1, #65528	; 0xfff8
    7512:	2d10      	cmp	r5, #16
    7514:	bf18      	it	ne
    7516:	4619      	movne	r1, r3
    7518:	428a      	cmp	r2, r1
    751a:	d380      	bcc.n	741e <SdFile::write(void const*, unsigned int)+0x72>
          // add cluster if at end of chain
          if (!addCluster()) goto writeErrorReturn;
    751c:	4638      	mov	r0, r7
    751e:	f7ff fefd 	bl	731c <SdFile::addCluster()>
    7522:	2800      	cmp	r0, #0
    7524:	f43f af4b 	beq.w	73be <SdFile::write(void const*, unsigned int)+0x12>
    7528:	6a38      	ldr	r0, [r7, #32]
    752a:	68ba      	ldr	r2, [r7, #8]
    752c:	e778      	b.n	7420 <SdFile::write(void const*, unsigned int)+0x74>
  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    if (!seekEnd()) goto writeErrorReturn;
  }

  while (nToWrite > 0) {
    752e:	9b01      	ldr	r3, [sp, #4]
    7530:	2b00      	cmp	r3, #0
    7532:	f47f af5c 	bne.w	73ee <SdFile::write(void const*, unsigned int)+0x42>
    7536:	e008      	b.n	754a <SdFile::write(void const*, unsigned int)+0x19e>
  }
  if (curPosition_ > fileSize_) {
    // update fileSize and insure sync will update dir entry
    fileSize_ = curPosition_;
    flags_ |= F_FILE_DIR_DIRTY;
  } else if (dateTime_ && nbyte) {
    7538:	4b0f      	ldr	r3, [pc, #60]	; (7578 <SdFile::write(void const*, unsigned int)+0x1cc>)
    753a:	797a      	ldrb	r2, [r7, #5]
    753c:	681b      	ldr	r3, [r3, #0]
    753e:	b123      	cbz	r3, 754a <SdFile::write(void const*, unsigned int)+0x19e>
    7540:	9b01      	ldr	r3, [sp, #4]
    7542:	b113      	cbz	r3, 754a <SdFile::write(void const*, unsigned int)+0x19e>
    // insure sync will update modified date and time
    flags_ |= F_FILE_DIR_DIRTY;
    7544:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    7548:	717a      	strb	r2, [r7, #5]
  }

  if (flags_ & O_SYNC) {
    754a:	0712      	lsls	r2, r2, #28
    754c:	d509      	bpl.n	7562 <SdFile::write(void const*, unsigned int)+0x1b6>
 * Reasons for failure include a call to sync() before a file has been
 * opened or an I/O error.
 */
uint8_t SdFile::sync(void) {
  // only allow open files and directories
  if (!isOpen()) return false;
    754e:	79bb      	ldrb	r3, [r7, #6]
    7550:	2b00      	cmp	r3, #0
    7552:	f43f af34 	beq.w	73be <SdFile::write(void const*, unsigned int)+0x12>
    7556:	4638      	mov	r0, r7
    7558:	f7ff feaa 	bl	72b0 <SdFile::sync() [clone .part.23] [clone .constprop.37]>
    // insure sync will update modified date and time
    flags_ |= F_FILE_DIR_DIRTY;
  }

  if (flags_ & O_SYNC) {
    if (!sync()) goto writeErrorReturn;
    755c:	2800      	cmp	r0, #0
    755e:	f43f af2e 	beq.w	73be <SdFile::write(void const*, unsigned int)+0x12>
        } else {
          curCluster_ = firstCluster_;
        }
      } else {
        uint32_t next;
        if (!vol_->fatGet(curCluster_, &next)) return false;
    7562:	9801      	ldr	r0, [sp, #4]
 writeErrorReturn:
  // return for write error
  //writeError = true;
  setWriteError();
  return 0;
}
    7564:	b005      	add	sp, #20
    7566:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    756a:	bf00      	nop
    756c:	20004390 	.word	0x20004390
    7570:	20004594 	.word	0x20004594
    7574:	0ffffff8 	.word	0x0ffffff8
    7578:	20004388 	.word	0x20004388
    757c:	20004394 	.word	0x20004394
    7580:	1fffb920 	.word	0x1fffb920

00007584 <SdFile::write(unsigned char)>:
/**
 * Write a byte to a file. Required by the Arduino Print class.
 *
 * Use SdFile::writeError to check for errors.
 */
size_t SdFile::write(uint8_t b) {
    7584:	b500      	push	{lr}
    7586:	b083      	sub	sp, #12
    7588:	ab02      	add	r3, sp, #8
  return write(&b, 1);
    758a:	2201      	movs	r2, #1
/**
 * Write a byte to a file. Required by the Arduino Print class.
 *
 * Use SdFile::writeError to check for errors.
 */
size_t SdFile::write(uint8_t b) {
    758c:	f803 1d01 	strb.w	r1, [r3, #-1]!
  return write(&b, 1);
    7590:	4619      	mov	r1, r3
    7592:	f7ff ff0b 	bl	73ac <SdFile::write(void const*, unsigned int)>
}
    7596:	b003      	add	sp, #12
    7598:	f85d fb04 	ldr.w	pc, [sp], #4

0000759c <SdVolume::cacheFlush()>:
  if (setStart) allocSearchStart_ = bgnCluster + 1;

  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheFlush(void) {
    759c:	b570      	push	{r4, r5, r6, lr}
  if (cacheDirty_) {
    759e:	4c0f      	ldr	r4, [pc, #60]	; (75dc <SdVolume::cacheFlush()+0x40>)
    75a0:	7823      	ldrb	r3, [r4, #0]
    75a2:	b90b      	cbnz	r3, 75a8 <SdVolume::cacheFlush()+0xc>
      }
      cacheMirrorBlock_ = 0;
    }
    cacheDirty_ = 0;
  }
  return true;
    75a4:	2001      	movs	r0, #1
}
    75a6:	bd70      	pop	{r4, r5, r6, pc}
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheFlush(void) {
  if (cacheDirty_) {
    if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data)) {
    75a8:	4b0d      	ldr	r3, [pc, #52]	; (75e0 <SdVolume::cacheFlush()+0x44>)
    75aa:	4d0e      	ldr	r5, [pc, #56]	; (75e4 <SdVolume::cacheFlush()+0x48>)
    75ac:	6819      	ldr	r1, [r3, #0]
    75ae:	6828      	ldr	r0, [r5, #0]
    75b0:	4a0d      	ldr	r2, [pc, #52]	; (75e8 <SdVolume::cacheFlush()+0x4c>)
    75b2:	f7ff fe2f 	bl	7214 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)>
    75b6:	b170      	cbz	r0, 75d6 <SdVolume::cacheFlush()+0x3a>
      return false;
    }
    // mirror FAT tables
    if (cacheMirrorBlock_) {
    75b8:	4e0c      	ldr	r6, [pc, #48]	; (75ec <SdVolume::cacheFlush()+0x50>)
    75ba:	6831      	ldr	r1, [r6, #0]
    75bc:	b919      	cbnz	r1, 75c6 <SdVolume::cacheFlush()+0x2a>
      if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data)) {
        return false;
      }
      cacheMirrorBlock_ = 0;
    }
    cacheDirty_ = 0;
    75be:	2300      	movs	r3, #0
    75c0:	7023      	strb	r3, [r4, #0]
  }
  return true;
    75c2:	2001      	movs	r0, #1
    75c4:	bd70      	pop	{r4, r5, r6, pc}
    75c6:	6828      	ldr	r0, [r5, #0]
    75c8:	4a07      	ldr	r2, [pc, #28]	; (75e8 <SdVolume::cacheFlush()+0x4c>)
    75ca:	f7ff fe23 	bl	7214 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)>
    if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data)) {
      return false;
    }
    // mirror FAT tables
    if (cacheMirrorBlock_) {
      if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data)) {
    75ce:	b110      	cbz	r0, 75d6 <SdVolume::cacheFlush()+0x3a>
        return false;
      }
      cacheMirrorBlock_ = 0;
    75d0:	2300      	movs	r3, #0
    75d2:	6033      	str	r3, [r6, #0]
    75d4:	e7f3      	b.n	75be <SdVolume::cacheFlush()+0x22>
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheFlush(void) {
  if (cacheDirty_) {
    if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data)) {
      return false;
    75d6:	2000      	movs	r0, #0
    75d8:	bd70      	pop	{r4, r5, r6, pc}
    75da:	bf00      	nop
    75dc:	20004594 	.word	0x20004594
    75e0:	1fffb920 	.word	0x1fffb920
    75e4:	20004390 	.word	0x20004390
    75e8:	20004394 	.word	0x20004394
    75ec:	2000438c 	.word	0x2000438c

000075f0 <SdVolume::cacheRawBlock(unsigned long, unsigned char)>:
    cacheDirty_ = 0;
  }
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheRawBlock(uint32_t blockNumber, uint8_t action) {
    75f0:	b570      	push	{r4, r5, r6, lr}
  if (cacheBlockNumber_ != blockNumber) {
    75f2:	4d0d      	ldr	r5, [pc, #52]	; (7628 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x38>)
    75f4:	682b      	ldr	r3, [r5, #0]
    75f6:	4283      	cmp	r3, r0
    cacheDirty_ = 0;
  }
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheRawBlock(uint32_t blockNumber, uint8_t action) {
    75f8:	460e      	mov	r6, r1
  if (cacheBlockNumber_ != blockNumber) {
    75fa:	d00e      	beq.n	761a <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x2a>
    75fc:	4604      	mov	r4, r0
    if (!cacheFlush()) return false;
    75fe:	f7ff ffcd 	bl	759c <SdVolume::cacheFlush()>
    7602:	b908      	cbnz	r0, 7608 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x18>
    7604:	2000      	movs	r0, #0
    7606:	bd70      	pop	{r4, r5, r6, pc}
    if (!sdCard_->readBlock(blockNumber, cacheBuffer_.data)) return false;
    7608:	4b08      	ldr	r3, [pc, #32]	; (762c <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x3c>)
    #if defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__IMXRT1052__) || defined(__IMXRT1062__)
    if (chipSelectPin_ == BUILTIN_SDCARD) {
      return (SDHC_CardReadBlock(dst, block) == 0) ? true : false;
    }
    #endif
    return SD_readBlock(block, dst);
    760a:	4a09      	ldr	r2, [pc, #36]	; (7630 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x40>)
    760c:	6818      	ldr	r0, [r3, #0]
    760e:	4621      	mov	r1, r4
    7610:	f7ff fd3a 	bl	7088 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)>
    7614:	2800      	cmp	r0, #0
    7616:	d0f5      	beq.n	7604 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x14>
    cacheBlockNumber_ = blockNumber;
    7618:	602c      	str	r4, [r5, #0]
  }
  cacheDirty_ |= action;
    761a:	4b06      	ldr	r3, [pc, #24]	; (7634 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x44>)
    761c:	7819      	ldrb	r1, [r3, #0]
    761e:	4331      	orrs	r1, r6
    7620:	7019      	strb	r1, [r3, #0]
  return true;
    7622:	2001      	movs	r0, #1
}
    7624:	bd70      	pop	{r4, r5, r6, pc}
    7626:	bf00      	nop
    7628:	1fffb920 	.word	0x1fffb920
    762c:	20004390 	.word	0x20004390
    7630:	20004394 	.word	0x20004394
    7634:	20004594 	.word	0x20004594

00007638 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]>:
  }
  return true;
}
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
    7638:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;

  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
    763a:	f890 3020 	ldrb.w	r3, [r0, #32]

  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;

  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
    763e:	69c4      	ldr	r4, [r0, #28]
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
    7640:	2b10      	cmp	r3, #16

  if (lba != cacheBlockNumber_) {
    7642:	4b1a      	ldr	r3, [pc, #104]	; (76ac <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x74>)
  }
  return true;
}
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
    7644:	4605      	mov	r5, r0
    7646:	460e      	mov	r6, r1
    7648:	4617      	mov	r7, r2

  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;

  if (lba != cacheBlockNumber_) {
    764a:	681b      	ldr	r3, [r3, #0]
  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;

  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
    764c:	d016      	beq.n	767c <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x44>
    764e:	eb04 14d1 	add.w	r4, r4, r1, lsr #7

  if (lba != cacheBlockNumber_) {
    7652:	429c      	cmp	r4, r3
    7654:	d116      	bne.n	7684 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x4c>
  }
  // store entry
  if (fatType_ == 16) {
    cacheBuffer_.fat16[cluster & 0XFF] = value;
  } else {
    cacheBuffer_.fat32[cluster & 0X7F] = value;
    7656:	f006 067f 	and.w	r6, r6, #127	; 0x7f
    765a:	4a15      	ldr	r2, [pc, #84]	; (76b0 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x78>)
    765c:	f842 7026 	str.w	r7, [r2, r6, lsl #2]
           return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);}
  uint32_t blockNumber(uint32_t cluster, uint32_t position) const {
           return clusterStartBlock(cluster) + blockOfCluster(position);}
  static uint8_t cacheFlush(void);
  static uint8_t cacheRawBlock(uint32_t blockNumber, uint8_t action);
  static void cacheSetDirty(void) {cacheDirty_ |= CACHE_FOR_WRITE;}
    7660:	4914      	ldr	r1, [pc, #80]	; (76b4 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x7c>)
  }
  cacheSetDirty();

  // mirror second FAT
  if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
    7662:	7e28      	ldrb	r0, [r5, #24]
    7664:	780a      	ldrb	r2, [r1, #0]
    7666:	2801      	cmp	r0, #1
    7668:	f042 0201 	orr.w	r2, r2, #1
    766c:	700a      	strb	r2, [r1, #0]
    766e:	d918      	bls.n	76a2 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x6a>
    7670:	68a9      	ldr	r1, [r5, #8]
    7672:	4a11      	ldr	r2, [pc, #68]	; (76b8 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x80>)
    7674:	440b      	add	r3, r1
    7676:	6013      	str	r3, [r2, #0]
  return true;
    7678:	2001      	movs	r0, #1
    767a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;

  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
    767c:	eb04 2411 	add.w	r4, r4, r1, lsr #8

  if (lba != cacheBlockNumber_) {
    7680:	429c      	cmp	r4, r3
    7682:	d008      	beq.n	7696 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x5e>
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
    7684:	2100      	movs	r1, #0
    7686:	4620      	mov	r0, r4
    7688:	f7ff ffb2 	bl	75f0 <SdVolume::cacheRawBlock(unsigned long, unsigned char)>
    768c:	b150      	cbz	r0, 76a4 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x6c>
  }
  // store entry
  if (fatType_ == 16) {
    768e:	f895 3020 	ldrb.w	r3, [r5, #32]
    7692:	2b10      	cmp	r3, #16
    7694:	d107      	bne.n	76a6 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x6e>
    cacheBuffer_.fat16[cluster & 0XFF] = value;
    7696:	b2f6      	uxtb	r6, r6
    7698:	4a05      	ldr	r2, [pc, #20]	; (76b0 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x78>)
    769a:	4623      	mov	r3, r4
    769c:	f822 7016 	strh.w	r7, [r2, r6, lsl #1]
    76a0:	e7de      	b.n	7660 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x28>
  }
  cacheSetDirty();

  // mirror second FAT
  if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
  return true;
    76a2:	2001      	movs	r0, #1
}
    76a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  if (lba != cacheBlockNumber_) {
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
  }
  // store entry
  if (fatType_ == 16) {
    76a6:	4623      	mov	r3, r4
    76a8:	e7d5      	b.n	7656 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x1e>
    76aa:	bf00      	nop
    76ac:	1fffb920 	.word	0x1fffb920
    76b0:	20004394 	.word	0x20004394
    76b4:	20004594 	.word	0x20004594
    76b8:	2000438c 	.word	0x2000438c

000076bc <SdVolume::fatGet(unsigned long, unsigned long*) const>:
  return true;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
  if (cluster > (clusterCount_ + 1)) return false;
    76bc:	68c3      	ldr	r3, [r0, #12]
    76be:	3301      	adds	r3, #1
    76c0:	428b      	cmp	r3, r1
    76c2:	d318      	bcc.n	76f6 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x3a>
  *size = s;
  return true;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
    76c4:	b570      	push	{r4, r5, r6, lr}
  if (cluster > (clusterCount_ + 1)) return false;
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
    76c6:	f890 3020 	ldrb.w	r3, [r0, #32]
    76ca:	2b10      	cmp	r3, #16
  if (lba != cacheBlockNumber_) {
    76cc:	4b15      	ldr	r3, [pc, #84]	; (7724 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x68>)
    76ce:	4604      	mov	r4, r0
    76d0:	4616      	mov	r6, r2
    76d2:	460d      	mov	r5, r1
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
  if (cluster > (clusterCount_ + 1)) return false;
  uint32_t lba = fatStartBlock_;
    76d4:	69c0      	ldr	r0, [r0, #28]
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
  if (lba != cacheBlockNumber_) {
    76d6:	681b      	ldr	r3, [r3, #0]
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
  if (cluster > (clusterCount_ + 1)) return false;
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
    76d8:	d00f      	beq.n	76fa <SdVolume::fatGet(unsigned long, unsigned long*) const+0x3e>
    76da:	eb00 10d1 	add.w	r0, r0, r1, lsr #7
  if (lba != cacheBlockNumber_) {
    76de:	4298      	cmp	r0, r3
    76e0:	d10f      	bne.n	7702 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x46>
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
  }
  if (fatType_ == 16) {
    *value = cacheBuffer_.fat16[cluster & 0XFF];
  } else {
    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
    76e2:	f005 017f 	and.w	r1, r5, #127	; 0x7f
    76e6:	4b10      	ldr	r3, [pc, #64]	; (7728 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x6c>)
    76e8:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    76ec:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
    76f0:	6033      	str	r3, [r6, #0]
    76f2:	2001      	movs	r0, #1
  }
  return true;
}
    76f4:	bd70      	pop	{r4, r5, r6, pc}
  return true;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
  if (cluster > (clusterCount_ + 1)) return false;
    76f6:	2000      	movs	r0, #0
    *value = cacheBuffer_.fat16[cluster & 0XFF];
  } else {
    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
  }
  return true;
}
    76f8:	4770      	bx	lr
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
  if (cluster > (clusterCount_ + 1)) return false;
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
    76fa:	eb00 2011 	add.w	r0, r0, r1, lsr #8
  if (lba != cacheBlockNumber_) {
    76fe:	4298      	cmp	r0, r3
    7700:	d007      	beq.n	7712 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x56>
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
    7702:	2100      	movs	r1, #0
    7704:	f7ff ff74 	bl	75f0 <SdVolume::cacheRawBlock(unsigned long, unsigned char)>
    7708:	b150      	cbz	r0, 7720 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x64>
  }
  if (fatType_ == 16) {
    770a:	f894 3020 	ldrb.w	r3, [r4, #32]
    770e:	2b10      	cmp	r3, #16
    7710:	d1e7      	bne.n	76e2 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x26>
    *value = cacheBuffer_.fat16[cluster & 0XFF];
    7712:	b2e9      	uxtb	r1, r5
    7714:	4b04      	ldr	r3, [pc, #16]	; (7728 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x6c>)
    7716:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
    771a:	6033      	str	r3, [r6, #0]
    771c:	2001      	movs	r0, #1
    771e:	bd70      	pop	{r4, r5, r6, pc}
  return true;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
  if (cluster > (clusterCount_ + 1)) return false;
    7720:	2000      	movs	r0, #0
    7722:	bd70      	pop	{r4, r5, r6, pc}
    7724:	1fffb920 	.word	0x1fffb920
    7728:	20004394 	.word	0x20004394

0000772c <SdVolume::allocContiguous(unsigned long, unsigned long*)>:
Sd2Card* SdVolume::sdCard_;          // pointer to SD card object
uint8_t  SdVolume::cacheDirty_ = 0;  // cacheFlush() will write block if true
uint32_t SdVolume::cacheMirrorBlock_ = 0;  // mirror  block for second FAT
//------------------------------------------------------------------------------
// find a contiguous group of clusters
uint8_t SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
    772c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  // flag to save place to start next search
  uint8_t setStart;

  // set search start cluster
  if (*curCluster) {
    7730:	6817      	ldr	r7, [r2, #0]
Sd2Card* SdVolume::sdCard_;          // pointer to SD card object
uint8_t  SdVolume::cacheDirty_ = 0;  // cacheFlush() will write block if true
uint32_t SdVolume::cacheMirrorBlock_ = 0;  // mirror  block for second FAT
//------------------------------------------------------------------------------
// find a contiguous group of clusters
uint8_t SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
    7732:	b083      	sub	sp, #12

  // flag to save place to start next search
  uint8_t setStart;

  // set search start cluster
  if (*curCluster) {
    7734:	b36f      	cbz	r7, 7792 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x66>
    // try to make file contiguous
    bgnCluster = *curCluster + 1;
    7736:	3701      	adds	r7, #1

    // don't save new start location
    setStart = false;
    7738:	f04f 0a00 	mov.w	sl, #0
  }
  // end of group
  uint32_t endCluster = bgnCluster;

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;
    773c:	68c3      	ldr	r3, [r0, #12]
    773e:	f103 0801 	add.w	r8, r3, #1

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
    // can't find space checked all clusters
    if (n >= clusterCount_) return false;
    7742:	b313      	cbz	r3, 778a <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5e>
    7744:	468b      	mov	fp, r1
    7746:	4606      	mov	r6, r0
    7748:	4691      	mov	r9, r2
    774a:	463c      	mov	r4, r7
    774c:	2500      	movs	r5, #0
    774e:	e005      	b.n	775c <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x30>
    uint32_t f;
    if (!fatGet(endCluster, &f)) return false;

    if (f != 0) {
      // cluster in use try next cluster as bgnCluster
      bgnCluster = endCluster + 1;
    7750:	461c      	mov	r4, r3
    7752:	461f      	mov	r7, r3
  uint32_t fatEnd = clusterCount_ + 1;

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
    // can't find space checked all clusters
    if (n >= clusterCount_) return false;
    7754:	68f3      	ldr	r3, [r6, #12]

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
    7756:	3501      	adds	r5, #1
    // can't find space checked all clusters
    if (n >= clusterCount_) return false;
    7758:	42ab      	cmp	r3, r5
    775a:	d916      	bls.n	778a <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5e>

    // past end - start from beginning of FAT
    if (endCluster > fatEnd) {
    775c:	45a0      	cmp	r8, r4
      bgnCluster = endCluster = 2;
    775e:	bf38      	it	cc
    7760:	2402      	movcc	r4, #2
    }
    uint32_t f;
    if (!fatGet(endCluster, &f)) return false;
    7762:	4621      	mov	r1, r4
    7764:	aa01      	add	r2, sp, #4
    7766:	4630      	mov	r0, r6
    // can't find space checked all clusters
    if (n >= clusterCount_) return false;

    // past end - start from beginning of FAT
    if (endCluster > fatEnd) {
      bgnCluster = endCluster = 2;
    7768:	bf38      	it	cc
    776a:	4627      	movcc	r7, r4
    }
    uint32_t f;
    if (!fatGet(endCluster, &f)) return false;
    776c:	f7ff ffa6 	bl	76bc <SdVolume::fatGet(unsigned long, unsigned long*) const>
    7770:	1c63      	adds	r3, r4, #1

    if (f != 0) {
      // cluster in use try next cluster as bgnCluster
      bgnCluster = endCluster + 1;
    } else if ((endCluster - bgnCluster + 1) == count) {
    7772:	1bd9      	subs	r1, r3, r7
    // past end - start from beginning of FAT
    if (endCluster > fatEnd) {
      bgnCluster = endCluster = 2;
    }
    uint32_t f;
    if (!fatGet(endCluster, &f)) return false;
    7774:	b148      	cbz	r0, 778a <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5e>

    if (f != 0) {
    7776:	9a01      	ldr	r2, [sp, #4]
    7778:	2a00      	cmp	r2, #0
    777a:	d1e9      	bne.n	7750 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x24>
      // cluster in use try next cluster as bgnCluster
      bgnCluster = endCluster + 1;
    } else if ((endCluster - bgnCluster + 1) == count) {
    777c:	458b      	cmp	fp, r1
    777e:	d010      	beq.n	77a2 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x76>
    7780:	461c      	mov	r4, r3
  uint32_t fatEnd = clusterCount_ + 1;

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
    // can't find space checked all clusters
    if (n >= clusterCount_) return false;
    7782:	68f3      	ldr	r3, [r6, #12]

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
    7784:	3501      	adds	r5, #1
    // can't find space checked all clusters
    if (n >= clusterCount_) return false;
    7786:	42ab      	cmp	r3, r5
    7788:	d8e8      	bhi.n	775c <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x30>
      // done - found space
      break;
    }
  }
  // mark end of chain
  if (!fatPutEOC(endCluster)) return false;
    778a:	2000      	movs	r0, #0

  // remember possible next free cluster
  if (setStart) allocSearchStart_ = bgnCluster + 1;

  return true;
}
    778c:	b003      	add	sp, #12
    778e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  } else {
    // start at likely place for free cluster
    bgnCluster = allocSearchStart_;

    // save next search start if one cluster
    setStart = 1 == count;
    7792:	f1a1 0a01 	sub.w	sl, r1, #1
    7796:	faba fa8a 	clz	sl, sl

    // don't save new start location
    setStart = false;
  } else {
    // start at likely place for free cluster
    bgnCluster = allocSearchStart_;
    779a:	6807      	ldr	r7, [r0, #0]

    // save next search start if one cluster
    setStart = 1 == count;
    779c:	ea4f 1a5a 	mov.w	sl, sl, lsr #5
    77a0:	e7cc      	b.n	773c <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x10>
}
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
  // error if reserved cluster
  if (cluster < 2) return false;
    77a2:	2c01      	cmp	r4, #1
    77a4:	d9f1      	bls.n	778a <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5e>

  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;
    77a6:	68f3      	ldr	r3, [r6, #12]
    77a8:	3301      	adds	r3, #1
    77aa:	429c      	cmp	r4, r3
    77ac:	d8ed      	bhi.n	778a <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5e>
    77ae:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
    77b2:	4621      	mov	r1, r4
    77b4:	4630      	mov	r0, r6
    77b6:	f7ff ff3f 	bl	7638 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]>
      // done - found space
      break;
    }
  }
  // mark end of chain
  if (!fatPutEOC(endCluster)) return false;
    77ba:	2800      	cmp	r0, #0
    77bc:	d0e5      	beq.n	778a <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5e>

  // link clusters
  while (endCluster > bgnCluster) {
    77be:	42a7      	cmp	r7, r4
    77c0:	d214      	bcs.n	77ec <SdVolume::allocContiguous(unsigned long, unsigned long*)+0xc0>
    if (!fatPut(endCluster - 1, endCluster)) return false;
    77c2:	3c01      	subs	r4, #1
}
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
  // error if reserved cluster
  if (cluster < 2) return false;
    77c4:	2c01      	cmp	r4, #1
    77c6:	d9e0      	bls.n	778a <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5e>

  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;
    77c8:	68f3      	ldr	r3, [r6, #12]
    77ca:	3301      	adds	r3, #1
    77cc:	429c      	cmp	r4, r3
    77ce:	d8dc      	bhi.n	778a <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5e>
    77d0:	1c62      	adds	r2, r4, #1
    77d2:	4621      	mov	r1, r4
    77d4:	4630      	mov	r0, r6
    77d6:	f7ff ff2f 	bl	7638 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]>
  // mark end of chain
  if (!fatPutEOC(endCluster)) return false;

  // link clusters
  while (endCluster > bgnCluster) {
    if (!fatPut(endCluster - 1, endCluster)) return false;
    77da:	2800      	cmp	r0, #0
    77dc:	d0d5      	beq.n	778a <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5e>
  }
  // mark end of chain
  if (!fatPutEOC(endCluster)) return false;

  // link clusters
  while (endCluster > bgnCluster) {
    77de:	42a7      	cmp	r7, r4
    if (!fatPut(endCluster - 1, endCluster)) return false;
    77e0:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
  }
  // mark end of chain
  if (!fatPutEOC(endCluster)) return false;

  // link clusters
  while (endCluster > bgnCluster) {
    77e4:	d002      	beq.n	77ec <SdVolume::allocContiguous(unsigned long, unsigned long*)+0xc0>
}
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
  // error if reserved cluster
  if (cluster < 2) return false;
    77e6:	2c01      	cmp	r4, #1
    77e8:	d1ee      	bne.n	77c8 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x9c>
    77ea:	e7ce      	b.n	778a <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5e>
  // link clusters
  while (endCluster > bgnCluster) {
    if (!fatPut(endCluster - 1, endCluster)) return false;
    endCluster--;
  }
  if (*curCluster != 0) {
    77ec:	f8d9 1000 	ldr.w	r1, [r9]
    77f0:	b159      	cbz	r1, 780a <SdVolume::allocContiguous(unsigned long, unsigned long*)+0xde>
}
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
  // error if reserved cluster
  if (cluster < 2) return false;
    77f2:	2901      	cmp	r1, #1
    77f4:	d9c9      	bls.n	778a <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5e>

  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;
    77f6:	68f3      	ldr	r3, [r6, #12]
    77f8:	3301      	adds	r3, #1
    77fa:	4299      	cmp	r1, r3
    77fc:	d8c5      	bhi.n	778a <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5e>
    77fe:	463a      	mov	r2, r7
    7800:	4630      	mov	r0, r6
    7802:	f7ff ff19 	bl	7638 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]>
    if (!fatPut(endCluster - 1, endCluster)) return false;
    endCluster--;
  }
  if (*curCluster != 0) {
    // connect chains
    if (!fatPut(*curCluster, bgnCluster)) return false;
    7806:	2800      	cmp	r0, #0
    7808:	d0bf      	beq.n	778a <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5e>
  }
  // return first cluster number to caller
  *curCluster = bgnCluster;
    780a:	f8c9 7000 	str.w	r7, [r9]

  // remember possible next free cluster
  if (setStart) allocSearchStart_ = bgnCluster + 1;
    780e:	f1ba 0f00 	cmp.w	sl, #0
    7812:	d001      	beq.n	7818 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0xec>
    7814:	3701      	adds	r7, #1
    7816:	6037      	str	r7, [r6, #0]

  return true;
    7818:	2001      	movs	r0, #1
    781a:	e7b7      	b.n	778c <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x60>

0000781c <WS2812Serial::begin()>:
*/

#include "WS2812Serial.h"

bool WS2812Serial::begin()
{
    781c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t divisor, portconfig, hwtrigger;
	KINETISK_UART_t *uart;

	switch (pin) {
    7820:	7883      	ldrb	r3, [r0, #2]
    7822:	3b01      	subs	r3, #1
*/

#include "WS2812Serial.h"

bool WS2812Serial::begin()
{
    7824:	4605      	mov	r5, r0
	uint32_t divisor, portconfig, hwtrigger;
	KINETISK_UART_t *uart;

	switch (pin) {
    7826:	2b1e      	cmp	r3, #30
    7828:	d874      	bhi.n	7914 <WS2812Serial::begin()+0xf8>
    782a:	e8df f003 	tbb	[pc, r3]
    782e:	735e      	.short	0x735e
    7830:	735e7373 	.word	0x735e7373
    7834:	10735373 	.word	0x10735373
    7838:	73737373 	.word	0x73737373
    783c:	73737373 	.word	0x73737373
    7840:	73737373 	.word	0x73737373
    7844:	73737373 	.word	0x73737373
    7848:	73737373 	.word	0x73737373
    784c:	10          	.byte	0x10
    784d:	00          	.byte	0x00
	#endif
		uart = &KINETISK_UART1;
		divisor = BAUD2DIV2(4000000);
		portconfig = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3);
		hwtrigger = DMAMUX_SOURCE_UART1_TX;
		SIM_SCGC4 |= SIM_SCGC4_UART1;
    784e:	4a39      	ldr	r2, [pc, #228]	; (7934 <WS2812Serial::begin()+0x118>)
		break;
#endif
	  default:
		return false; // pin not supported
	}
	if (!dma) {
    7850:	68ef      	ldr	r7, [r5, #12]
	#endif
		uart = &KINETISK_UART1;
		divisor = BAUD2DIV2(4000000);
		portconfig = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3);
		hwtrigger = DMAMUX_SOURCE_UART1_TX;
		SIM_SCGC4 |= SIM_SCGC4_UART1;
    7852:	6813      	ldr	r3, [r2, #0]
	#if defined(__MK20DX128__) || defined(__MK20DX256__)
	  case 31:
	#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	  case 58:
	#endif
		uart = &KINETISK_UART1;
    7854:	4c38      	ldr	r4, [pc, #224]	; (7938 <WS2812Serial::begin()+0x11c>)
		divisor = BAUD2DIV2(4000000);
		portconfig = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3);
		hwtrigger = DMAMUX_SOURCE_UART1_TX;
		SIM_SCGC4 |= SIM_SCGC4_UART1;
    7856:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
    785a:	6013      	str	r3, [r2, #0]
		break;
    785c:	2685      	movs	r6, #133	; 0x85
		break;
#endif
	  default:
		return false; // pin not supported
	}
	if (!dma) {
    785e:	2f00      	cmp	r7, #0
    7860:	d04d      	beq.n	78fe <WS2812Serial::begin()+0xe2>
    7862:	221c      	movs	r2, #28
		dma = new DMAChannel;
		if (!dma) return false; // unable to allocate DMA channel
	}
#if defined(KINETISK)
	if (divisor < 32) divisor = 32;
	uart->BDH = (divisor >> 13) & 0x1F;
    7864:	2300      	movs	r3, #0
	uart->BDL = (divisor >> 5) & 0xFF;
    7866:	2101      	movs	r1, #1
		dma = new DMAChannel;
		if (!dma) return false; // unable to allocate DMA channel
	}
#if defined(KINETISK)
	if (divisor < 32) divisor = 32;
	uart->BDH = (divisor >> 13) & 0x1F;
    7868:	7023      	strb	r3, [r4, #0]
	uart->BDH = (divisor >> 8) & 0x1F;
	uart->BDL = divisor & 0xFF;
	uart->C4 = 11;
#endif
	uart->C1 = 0;
	uart->C2 = UART_C2_TE | UART_C2_TIE;
    786a:	2788      	movs	r7, #136	; 0x88
		if (!dma) return false; // unable to allocate DMA channel
	}
#if defined(KINETISK)
	if (divisor < 32) divisor = 32;
	uart->BDH = (divisor >> 13) & 0x1F;
	uart->BDL = (divisor >> 5) & 0xFF;
    786c:	7061      	strb	r1, [r4, #1]
	uart->BDL = divisor & 0xFF;
	uart->C4 = 11;
#endif
	uart->C1 = 0;
	uart->C2 = UART_C2_TE | UART_C2_TIE;
	uart->C3 = UART_C3_TXINV;
    786e:	2010      	movs	r0, #16
	uart->C5 = UART_C5_TDMAS;
    7870:	2180      	movs	r1, #128	; 0x80
	}
#if defined(KINETISK)
	if (divisor < 32) divisor = 32;
	uart->BDH = (divisor >> 13) & 0x1F;
	uart->BDL = (divisor >> 5) & 0xFF;
	uart->C4 = divisor & 0x1F;
    7872:	72a2      	strb	r2, [r4, #10]
#elif defined(KINETISL)
	uart->BDH = (divisor >> 8) & 0x1F;
	uart->BDL = divisor & 0xFF;
	uart->C4 = 11;
#endif
	uart->C1 = 0;
    7874:	70a3      	strb	r3, [r4, #2]
	uart->C2 = UART_C2_TE | UART_C2_TIE;
    7876:	70e7      	strb	r7, [r4, #3]
	uart->C3 = UART_C3_TXINV;
    7878:	71a0      	strb	r0, [r4, #6]
	uart->C5 = UART_C5_TDMAS;
    787a:	72e1      	strb	r1, [r4, #11]
#if defined(KINETISK)
	uart->PFIFO = 0; // TODO: is this ok for Serial3-6?
    787c:	7423      	strb	r3, [r4, #16]
#endif
	*(portConfigRegister(pin)) = portconfig;
    787e:	78a9      	ldrb	r1, [r5, #2]
    7880:	4a2e      	ldr	r2, [pc, #184]	; (793c <WS2812Serial::begin()+0x120>)
	dma->destination(uart->D);
    7882:	68e8      	ldr	r0, [r5, #12]
	uart->C3 = UART_C3_TXINV;
	uart->C5 = UART_C5_TDMAS;
#if defined(KINETISK)
	uart->PFIFO = 0; // TODO: is this ok for Serial3-6?
#endif
	*(portConfigRegister(pin)) = portconfig;
    7884:	eb02 01c1 	add.w	r1, r2, r1, lsl #3

	// Use a single variable as the data destination.  Typically a register
	// for transmitting data to one of the hardware peripherals is used.
	void destination(volatile signed char &p) { destination(*(volatile uint8_t *)&p); }
	void destination(volatile unsigned char &p) {
		TCD->DADDR = &p;
    7888:	6802      	ldr	r2, [r0, #0]
    788a:	6849      	ldr	r1, [r1, #4]
	dma->destination(uart->D);
    788c:	3407      	adds	r4, #7
	uart->C3 = UART_C3_TXINV;
	uart->C5 = UART_C5_TDMAS;
#if defined(KINETISK)
	uart->PFIFO = 0; // TODO: is this ok for Serial3-6?
#endif
	*(portConfigRegister(pin)) = portconfig;
    788e:	f44f 7751 	mov.w	r7, #836	; 0x344
    7892:	600f      	str	r7, [r1, #0]
		TCD->DOFF = 0;
		TCD->ATTR_DST = 0;
		if ((uint32_t)&p < 0x40000000 || TCD->NBYTES == 0) TCD->NBYTES = 1;
    7894:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
	// for transmitting data to one of the hardware peripherals is used.
	void destination(volatile signed char &p) { destination(*(volatile uint8_t *)&p); }
	void destination(volatile unsigned char &p) {
		TCD->DADDR = &p;
		TCD->DOFF = 0;
		TCD->ATTR_DST = 0;
    7898:	7193      	strb	r3, [r2, #6]
	// Use a single variable as the data destination.  Typically a register
	// for transmitting data to one of the hardware peripherals is used.
	void destination(volatile signed char &p) { destination(*(volatile uint8_t *)&p); }
	void destination(volatile unsigned char &p) {
		TCD->DADDR = &p;
		TCD->DOFF = 0;
    789a:	8293      	strh	r3, [r2, #20]

	// Use a single variable as the data destination.  Typically a register
	// for transmitting data to one of the hardware peripherals is used.
	void destination(volatile signed char &p) { destination(*(volatile uint8_t *)&p); }
	void destination(volatile unsigned char &p) {
		TCD->DADDR = &p;
    789c:	6114      	str	r4, [r2, #16]
    789e:	6803      	ldr	r3, [r0, #0]
		TCD->DOFF = 0;
		TCD->ATTR_DST = 0;
		if ((uint32_t)&p < 0x40000000 || TCD->NBYTES == 0) TCD->NBYTES = 1;
    78a0:	d301      	bcc.n	78a6 <WS2812Serial::begin()+0x8a>
    78a2:	689a      	ldr	r2, [r3, #8]
    78a4:	b912      	cbnz	r2, 78ac <WS2812Serial::begin()+0x90>
    78a6:	2201      	movs	r2, #1
    78a8:	609a      	str	r2, [r3, #8]
    78aa:	6803      	ldr	r3, [r0, #0]
    78ac:	68e9      	ldr	r1, [r5, #12]
		TCD->DLASTSGA = 0;
    78ae:	2200      	movs	r2, #0
    78b0:	619a      	str	r2, [r3, #24]
	// 32 bits.  If a channel is configured for 200 transfers

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
    78b2:	790b      	ldrb	r3, [r1, #4]
    78b4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    78b8:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
	dma->destination(uart->D);
	dma->triggerAtHardwareEvent(hwtrigger);
	memset(drawBuffer, 0, numled * 3);
    78bc:	4611      	mov	r1, r2
		*mux = 0;
    78be:	701a      	strb	r2, [r3, #0]
		*mux = (source & 63) | DMAMUX_ENABLE;
    78c0:	701e      	strb	r6, [r3, #0]
    78c2:	882a      	ldrh	r2, [r5, #0]
    78c4:	68a8      	ldr	r0, [r5, #8]
    78c6:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    78ca:	f006 fc83 	bl	e1d4 <memset>
	return true;
    78ce:	2001      	movs	r0, #1
    78d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	  case 8: // Serial3
		uart = &KINETISK_UART2;
		divisor = BAUD2DIV3(4000000);
		portconfig = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3);
		hwtrigger = DMAMUX_SOURCE_UART2_TX;
		SIM_SCGC4 |= SIM_SCGC4_UART2;
    78d4:	4a17      	ldr	r2, [pc, #92]	; (7934 <WS2812Serial::begin()+0x118>)
		break;
#endif
	  default:
		return false; // pin not supported
	}
	if (!dma) {
    78d6:	68c4      	ldr	r4, [r0, #12]
	  case 8: // Serial3
		uart = &KINETISK_UART2;
		divisor = BAUD2DIV3(4000000);
		portconfig = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3);
		hwtrigger = DMAMUX_SOURCE_UART2_TX;
		SIM_SCGC4 |= SIM_SCGC4_UART2;
    78d8:	6813      	ldr	r3, [r2, #0]
    78da:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    78de:	6013      	str	r3, [r2, #0]
		break;
#endif
	  default:
		return false; // pin not supported
	}
	if (!dma) {
    78e0:	b1dc      	cbz	r4, 791a <WS2812Serial::begin()+0xfe>
    78e2:	2687      	movs	r6, #135	; 0x87
    78e4:	2200      	movs	r2, #0
		hwtrigger = DMAMUX_SOURCE_UART1_TX;
		SIM_SCGC4 |= SIM_SCGC4_UART1;
		break;

	  case 8: // Serial3
		uart = &KINETISK_UART2;
    78e6:	4c16      	ldr	r4, [pc, #88]	; (7940 <WS2812Serial::begin()+0x124>)
    78e8:	e7bc      	b.n	7864 <WS2812Serial::begin()+0x48>
	#endif
		uart = &KINETISK_UART0;
		divisor = BAUD2DIV(4000000);
		portconfig = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3);
		hwtrigger = DMAMUX_SOURCE_UART0_TX;
		SIM_SCGC4 |= SIM_SCGC4_UART0;
    78ea:	4a12      	ldr	r2, [pc, #72]	; (7934 <WS2812Serial::begin()+0x118>)
		break;
#endif
	  default:
		return false; // pin not supported
	}
	if (!dma) {
    78ec:	68ef      	ldr	r7, [r5, #12]
	#endif
		uart = &KINETISK_UART0;
		divisor = BAUD2DIV(4000000);
		portconfig = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3);
		hwtrigger = DMAMUX_SOURCE_UART0_TX;
		SIM_SCGC4 |= SIM_SCGC4_UART0;
    78ee:	6813      	ldr	r3, [r2, #0]
	  case 1: // Serial1
	  case 5:
	#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	  case 26:
	#endif
		uart = &KINETISK_UART0;
    78f0:	4c14      	ldr	r4, [pc, #80]	; (7944 <WS2812Serial::begin()+0x128>)
		divisor = BAUD2DIV(4000000);
		portconfig = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3);
		hwtrigger = DMAMUX_SOURCE_UART0_TX;
		SIM_SCGC4 |= SIM_SCGC4_UART0;
    78f2:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    78f6:	6013      	str	r3, [r2, #0]
		break;
    78f8:	2683      	movs	r6, #131	; 0x83
		break;
#endif
	  default:
		return false; // pin not supported
	}
	if (!dma) {
    78fa:	2f00      	cmp	r7, #0
    78fc:	d1b1      	bne.n	7862 <WS2812Serial::begin()+0x46>
		dma = new DMAChannel;
    78fe:	2008      	movs	r0, #8
    7900:	f002 f8b8 	bl	9a74 <operator new(unsigned int)>
	/*************************************************/
	/**    Channel Allocation                       **/
	/*************************************************/

	DMAChannel() {
		begin();
    7904:	4639      	mov	r1, r7
    7906:	4680      	mov	r8, r0
    7908:	f001 fb0e 	bl	8f28 <DMAChannel::begin(bool)>
    790c:	f8c5 800c 	str.w	r8, [r5, #12]
    7910:	221c      	movs	r2, #28
    7912:	e7a7      	b.n	7864 <WS2812Serial::begin()+0x48>
		hwtrigger = DMAMUX_SOURCE_UART0_TX;
		SIM_SCGC4 |= SIM_SCGC4_UART0;
		break;
#endif
	  default:
		return false; // pin not supported
    7914:	2000      	movs	r0, #0
    7916:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}
	if (!dma) {
		dma = new DMAChannel;
    791a:	2008      	movs	r0, #8
    791c:	f002 f8aa 	bl	9a74 <operator new(unsigned int)>
    7920:	4621      	mov	r1, r4
    7922:	4607      	mov	r7, r0
    7924:	2687      	movs	r6, #135	; 0x87
    7926:	f001 faff 	bl	8f28 <DMAChannel::begin(bool)>
    792a:	4622      	mov	r2, r4
    792c:	60ef      	str	r7, [r5, #12]
		hwtrigger = DMAMUX_SOURCE_UART1_TX;
		SIM_SCGC4 |= SIM_SCGC4_UART1;
		break;

	  case 8: // Serial3
		uart = &KINETISK_UART2;
    792e:	4c04      	ldr	r4, [pc, #16]	; (7940 <WS2812Serial::begin()+0x124>)
    7930:	e798      	b.n	7864 <WS2812Serial::begin()+0x48>
    7932:	bf00      	nop
    7934:	40048034 	.word	0x40048034
    7938:	4006b000 	.word	0x4006b000
    793c:	000123c8 	.word	0x000123c8
    7940:	4006c000 	.word	0x4006c000
    7944:	4006a000 	.word	0x4006a000

00007948 <WS2812Serial::show()>:
	memset(drawBuffer, 0, numled * 3);
	return true;
}

void WS2812Serial::show()
{
    7948:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	// wait if prior DMA still in progress
#if defined(KINETISK)
	while ((DMA_ERQ & (1 << dma->channel))) {
    794a:	68c3      	ldr	r3, [r0, #12]
    794c:	4e64      	ldr	r6, [pc, #400]	; (7ae0 <WS2812Serial::show()+0x198>)
    794e:	791b      	ldrb	r3, [r3, #4]
    7950:	6832      	ldr	r2, [r6, #0]
    7952:	2401      	movs	r4, #1
    7954:	fa04 f303 	lsl.w	r3, r4, r3
    7958:	4213      	tst	r3, r2
	memset(drawBuffer, 0, numled * 3);
	return true;
}

void WS2812Serial::show()
{
    795a:	4605      	mov	r5, r0
	// wait if prior DMA still in progress
#if defined(KINETISK)
	while ((DMA_ERQ & (1 << dma->channel))) {
    795c:	d008      	beq.n	7970 <WS2812Serial::show()+0x28>
		yield();
    795e:	f003 ff53 	bl	b808 <yield>

void WS2812Serial::show()
{
	// wait if prior DMA still in progress
#if defined(KINETISK)
	while ((DMA_ERQ & (1 << dma->channel))) {
    7962:	68eb      	ldr	r3, [r5, #12]
    7964:	6832      	ldr	r2, [r6, #0]
    7966:	791b      	ldrb	r3, [r3, #4]
    7968:	fa04 f303 	lsl.w	r3, r4, r3
    796c:	4213      	tst	r3, r2
    796e:	d1f6      	bne.n	795e <WS2812Serial::show()+0x16>
		yield();
	}
#endif
	// copy drawing buffer to frame buffer
	const uint8_t *p = drawBuffer;
	const uint8_t *end = p + (numled * 3);
    7970:	882b      	ldrh	r3, [r5, #0]
	while ((dma->CFG->DCR & DMA_DCR_ERQ)) {
		yield();
	}
#endif
	// copy drawing buffer to frame buffer
	const uint8_t *p = drawBuffer;
    7972:	68ac      	ldr	r4, [r5, #8]
	const uint8_t *end = p + (numled * 3);
	uint8_t *fb = frameBuffer;
    7974:	686a      	ldr	r2, [r5, #4]
		yield();
	}
#endif
	// copy drawing buffer to frame buffer
	const uint8_t *p = drawBuffer;
	const uint8_t *end = p + (numled * 3);
    7976:	eb03 0643 	add.w	r6, r3, r3, lsl #1
    797a:	4426      	add	r6, r4
	uint8_t *fb = frameBuffer;
	while (p < end) {
    797c:	42b4      	cmp	r4, r6
    797e:	d225      	bcs.n	79cc <WS2812Serial::show()+0x84>
		uint8_t b = *p++;
    7980:	7827      	ldrb	r7, [r4, #0]
		uint8_t g = *p++;
    7982:	7860      	ldrb	r0, [r4, #1]
		uint8_t r = *p++;
		uint32_t n=0;
		switch (config) {
    7984:	78e9      	ldrb	r1, [r5, #3]
	const uint8_t *end = p + (numled * 3);
	uint8_t *fb = frameBuffer;
	while (p < end) {
		uint8_t b = *p++;
		uint8_t g = *p++;
		uint8_t r = *p++;
    7986:	78a3      	ldrb	r3, [r4, #2]
    7988:	3403      	adds	r4, #3
		uint32_t n=0;
		switch (config) {
    798a:	2905      	cmp	r1, #5
    798c:	f200 80a5 	bhi.w	7ada <WS2812Serial::show()+0x192>
    7990:	e8df f001 	tbb	[pc, r1]
    7994:	767b8085 	.word	0x767b8085
    7998:	0371      	.short	0x0371
		  case WS2812_RGB: n = (r << 16) | (g << 8) | b; break;
		  case WS2812_RBG: n = (r << 16) | (b << 8) | g; break;
		  case WS2812_GRB: n = (g << 16) | (r << 8) | b; break;
		  case WS2812_GBR: n = (g << 16) | (b << 8) | r; break;
		  case WS2812_BRG: n = (b << 16) | (r << 8) | g; break;
		  case WS2812_BGR: n = (b << 16) | (g << 8) | r; break;
    799a:	0200      	lsls	r0, r0, #8
    799c:	ea40 4107 	orr.w	r1, r0, r7, lsl #16
    79a0:	430b      	orrs	r3, r1
    79a2:	f102 000c 	add.w	r0, r2, #12
		}
		const uint8_t *stop = fb + 12;
		do {
			uint8_t x = 0x08;
    79a6:	f413 0f00 	tst.w	r3, #8388608	; 0x800000
    79aa:	bf0c      	ite	eq
    79ac:	210f      	moveq	r1, #15
    79ae:	2108      	movne	r1, #8
			if (!(n & 0x00800000)) x |= 0x07;
			if (!(n & 0x00400000)) x |= 0xE0;
    79b0:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
    79b4:	bf08      	it	eq
    79b6:	f041 01e0 	orreq.w	r1, r1, #224	; 0xe0
			n <<= 2;
			*fb++ = x;
    79ba:	f802 1b01 	strb.w	r1, [r2], #1
		} while (fb < stop);
    79be:	4282      	cmp	r2, r0
		const uint8_t *stop = fb + 12;
		do {
			uint8_t x = 0x08;
			if (!(n & 0x00800000)) x |= 0x07;
			if (!(n & 0x00400000)) x |= 0xE0;
			n <<= 2;
    79c0:	ea4f 0383 	mov.w	r3, r3, lsl #2
			*fb++ = x;
		} while (fb < stop);
    79c4:	d1ef      	bne.n	79a6 <WS2812Serial::show()+0x5e>
#endif
	// copy drawing buffer to frame buffer
	const uint8_t *p = drawBuffer;
	const uint8_t *end = p + (numled * 3);
	uint8_t *fb = frameBuffer;
	while (p < end) {
    79c6:	42a6      	cmp	r6, r4
    79c8:	d8da      	bhi.n	7980 <WS2812Serial::show()+0x38>
    79ca:	882b      	ldrh	r3, [r5, #0]
			n <<= 2;
			*fb++ = x;
		} while (fb < stop);
	}
	// wait 300us WS2812 reset time
	uint32_t min_elapsed = (numled * 30) + 300;
    79cc:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
    79d0:	005b      	lsls	r3, r3, #1
    79d2:	f503 7396 	add.w	r3, r3, #300	; 0x12c
	if (min_elapsed < 2500) min_elapsed = 2500;
    79d6:	f640 14c3 	movw	r4, #2499	; 0x9c3
			n <<= 2;
			*fb++ = x;
		} while (fb < stop);
	}
	// wait 300us WS2812 reset time
	uint32_t min_elapsed = (numled * 30) + 300;
    79da:	f640 12c4 	movw	r2, #2500	; 0x9c4
    79de:	42a3      	cmp	r3, r4
    79e0:	bfcc      	ite	gt
    79e2:	461c      	movgt	r4, r3
    79e4:	4614      	movle	r4, r2
    79e6:	e001      	b.n	79ec <WS2812Serial::show()+0xa4>
	if (min_elapsed < 2500) min_elapsed = 2500;
	uint32_t m;
	while (1) {
		m = micros();
		if ((m - prior_micros) > min_elapsed) break;
		yield();
    79e8:	f003 ff0e 	bl	b808 <yield>
	// wait 300us WS2812 reset time
	uint32_t min_elapsed = (numled * 30) + 300;
	if (min_elapsed < 2500) min_elapsed = 2500;
	uint32_t m;
	while (1) {
		m = micros();
    79ec:	f002 fb6e 	bl	a0cc <micros>
		if ((m - prior_micros) > min_elapsed) break;
    79f0:	692b      	ldr	r3, [r5, #16]
    79f2:	1ac3      	subs	r3, r0, r3
    79f4:	429c      	cmp	r4, r3
    79f6:	d2f7      	bcs.n	79e8 <WS2812Serial::show()+0xa0>
		yield();
	}
	prior_micros = m;
	// start DMA transfer to update LEDs  :-)
#if defined(KINETISK)
	dma->sourceBuffer(frameBuffer, numled * 12);
    79f8:	68ea      	ldr	r2, [r5, #12]
	while (1) {
		m = micros();
		if ((m - prior_micros) > min_elapsed) break;
		yield();
	}
	prior_micros = m;
    79fa:	6128      	str	r0, [r5, #16]
	// Use a buffer (array of data) as the data source.  Typically a
	// buffer for transmitting data is used.
	void sourceBuffer(volatile const signed char p[], unsigned int len) {
		sourceBuffer((volatile const uint8_t *)p, len); }
	void sourceBuffer(volatile const unsigned char p[], unsigned int len) {
		TCD->SADDR = p;
    79fc:	6810      	ldr	r0, [r2, #0]
	// start DMA transfer to update LEDs  :-)
#if defined(KINETISK)
	dma->sourceBuffer(frameBuffer, numled * 12);
    79fe:	6869      	ldr	r1, [r5, #4]
    7a00:	882b      	ldrh	r3, [r5, #0]
    7a02:	6001      	str	r1, [r0, #0]
		TCD->SOFF = 1;
		TCD->ATTR_SRC = 0;
    7a04:	2100      	movs	r1, #0
    7a06:	71c1      	strb	r1, [r0, #7]
		TCD->NBYTES = 1;
    7a08:	6814      	ldr	r4, [r2, #0]
	// buffer for transmitting data is used.
	void sourceBuffer(volatile const signed char p[], unsigned int len) {
		sourceBuffer((volatile const uint8_t *)p, len); }
	void sourceBuffer(volatile const unsigned char p[], unsigned int len) {
		TCD->SADDR = p;
		TCD->SOFF = 1;
    7a0a:	2101      	movs	r1, #1
    7a0c:	8081      	strh	r1, [r0, #4]
    7a0e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
		TCD->ATTR_SRC = 0;
		TCD->NBYTES = 1;
    7a12:	60a1      	str	r1, [r4, #8]
		TCD->SLAST = -len;
    7a14:	6814      	ldr	r4, [r2, #0]
    7a16:	009b      	lsls	r3, r3, #2
		TCD->BITER = len;
    7a18:	b298      	uxth	r0, r3
    7a1a:	83e0      	strh	r0, [r4, #30]
		TCD->CITER = len;
    7a1c:	6812      	ldr	r2, [r2, #0]
	void sourceBuffer(volatile const unsigned char p[], unsigned int len) {
		TCD->SADDR = p;
		TCD->SOFF = 1;
		TCD->ATTR_SRC = 0;
		TCD->NBYTES = 1;
		TCD->SLAST = -len;
    7a1e:	425b      	negs	r3, r3
    7a20:	60e3      	str	r3, [r4, #12]
		TCD->BITER = len;
		TCD->CITER = len;
    7a22:	82d0      	strh	r0, [r2, #22]
	dma->transferSize(1);
    7a24:	68eb      	ldr	r3, [r5, #12]
			TCD->NBYTES = 2;
			if (TCD->SOFF != 0) TCD->SOFF = 2;
			if (TCD->DOFF != 0) TCD->DOFF = 2;
			TCD->ATTR = (TCD->ATTR & 0xF8F8) | 0x0101;
		} else {
			TCD->NBYTES = 1;
    7a26:	681a      	ldr	r2, [r3, #0]
    7a28:	6091      	str	r1, [r2, #8]
			if (TCD->SOFF != 0) TCD->SOFF = 1;
    7a2a:	681b      	ldr	r3, [r3, #0]
    7a2c:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
    7a30:	b102      	cbz	r2, 7a34 <WS2812Serial::show()+0xec>
    7a32:	8099      	strh	r1, [r3, #4]
			if (TCD->DOFF != 0) TCD->DOFF = 1;
    7a34:	f9b3 2014 	ldrsh.w	r2, [r3, #20]
    7a38:	b10a      	cbz	r2, 7a3e <WS2812Serial::show()+0xf6>
    7a3a:	2201      	movs	r2, #1
    7a3c:	829a      	strh	r2, [r3, #20]
			TCD->ATTR = TCD->ATTR & 0xF8F8;
    7a3e:	88da      	ldrh	r2, [r3, #6]
    7a40:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    7a44:	f022 0207 	bic.w	r2, r2, #7
    7a48:	80da      	strh	r2, [r3, #6]
	dma->transferCount(numled * 12);
    7a4a:	68e9      	ldr	r1, [r5, #12]
    7a4c:	882b      	ldrh	r3, [r5, #0]
		}
	}

	// Set the number of transfers (number of triggers until complete)
	void transferCount(unsigned int len) {
		if (!(TCD->BITER & DMA_TCD_BITER_ELINK)) {
    7a4e:	680a      	ldr	r2, [r1, #0]
    7a50:	8bd0      	ldrh	r0, [r2, #30]
    7a52:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    7a56:	0400      	lsls	r0, r0, #16
    7a58:	ea4f 0383 	mov.w	r3, r3, lsl #2
    7a5c:	d42b      	bmi.n	7ab6 <WS2812Serial::show()+0x16e>
			if (len > 32767) return;
    7a5e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    7a62:	db21      	blt.n	7aa8 <WS2812Serial::show()+0x160>
	void interruptAtHalf(void) {
		TCD->CSR |= DMA_TCD_CSR_INTHALF;
	}

	void disableOnCompletion(void) {
		TCD->CSR |= DMA_TCD_CSR_DREQ;
    7a64:	8b93      	ldrh	r3, [r2, #28]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    7a66:	481f      	ldr	r0, [pc, #124]	; (7ae4 <WS2812Serial::show()+0x19c>)
	void interruptAtHalf(void) {
		TCD->CSR |= DMA_TCD_CSR_INTHALF;
	}

	void disableOnCompletion(void) {
		TCD->CSR |= DMA_TCD_CSR_DREQ;
    7a68:	b29b      	uxth	r3, r3
    7a6a:	f043 0308 	orr.w	r3, r3, #8
    7a6e:	8393      	strh	r3, [r2, #28]
    7a70:	790b      	ldrb	r3, [r1, #4]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    7a72:	7003      	strb	r3, [r0, #0]
    7a74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		switch (config) {
		  case WS2812_RGB: n = (r << 16) | (g << 8) | b; break;
		  case WS2812_RBG: n = (r << 16) | (b << 8) | g; break;
		  case WS2812_GRB: n = (g << 16) | (r << 8) | b; break;
		  case WS2812_GBR: n = (g << 16) | (b << 8) | r; break;
		  case WS2812_BRG: n = (b << 16) | (r << 8) | g; break;
    7a76:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
    7a7a:	ea40 2303 	orr.w	r3, r0, r3, lsl #8
    7a7e:	e790      	b.n	79a2 <WS2812Serial::show()+0x5a>
		uint32_t n=0;
		switch (config) {
		  case WS2812_RGB: n = (r << 16) | (g << 8) | b; break;
		  case WS2812_RBG: n = (r << 16) | (b << 8) | g; break;
		  case WS2812_GRB: n = (g << 16) | (r << 8) | b; break;
		  case WS2812_GBR: n = (g << 16) | (b << 8) | r; break;
    7a80:	0239      	lsls	r1, r7, #8
    7a82:	ea41 4000 	orr.w	r0, r1, r0, lsl #16
    7a86:	4303      	orrs	r3, r0
    7a88:	e78b      	b.n	79a2 <WS2812Serial::show()+0x5a>
		uint8_t r = *p++;
		uint32_t n=0;
		switch (config) {
		  case WS2812_RGB: n = (r << 16) | (g << 8) | b; break;
		  case WS2812_RBG: n = (r << 16) | (b << 8) | g; break;
		  case WS2812_GRB: n = (g << 16) | (r << 8) | b; break;
    7a8a:	ea47 4000 	orr.w	r0, r7, r0, lsl #16
    7a8e:	ea40 2303 	orr.w	r3, r0, r3, lsl #8
    7a92:	e786      	b.n	79a2 <WS2812Serial::show()+0x5a>
		uint8_t g = *p++;
		uint8_t r = *p++;
		uint32_t n=0;
		switch (config) {
		  case WS2812_RGB: n = (r << 16) | (g << 8) | b; break;
		  case WS2812_RBG: n = (r << 16) | (b << 8) | g; break;
    7a94:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
    7a98:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
    7a9c:	e781      	b.n	79a2 <WS2812Serial::show()+0x5a>
		uint8_t b = *p++;
		uint8_t g = *p++;
		uint8_t r = *p++;
		uint32_t n=0;
		switch (config) {
		  case WS2812_RGB: n = (r << 16) | (g << 8) | b; break;
    7a9e:	ea47 2000 	orr.w	r0, r7, r0, lsl #8
    7aa2:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
    7aa6:	e77c      	b.n	79a2 <WS2812Serial::show()+0x5a>

	// Set the number of transfers (number of triggers until complete)
	void transferCount(unsigned int len) {
		if (!(TCD->BITER & DMA_TCD_BITER_ELINK)) {
			if (len > 32767) return;
			TCD->BITER = len;
    7aa8:	b29b      	uxth	r3, r3
    7aaa:	83d3      	strh	r3, [r2, #30]
			TCD->CITER = len;
    7aac:	680a      	ldr	r2, [r1, #0]
    7aae:	82d3      	strh	r3, [r2, #22]
    7ab0:	68e9      	ldr	r1, [r5, #12]
    7ab2:	680a      	ldr	r2, [r1, #0]
    7ab4:	e7d6      	b.n	7a64 <WS2812Serial::show()+0x11c>
		} else {
			if (len > 511) return;
    7ab6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    7aba:	dad3      	bge.n	7a64 <WS2812Serial::show()+0x11c>
			TCD->BITER = (TCD->BITER & 0xFE00) | len;
    7abc:	8bd0      	ldrh	r0, [r2, #30]
    7abe:	b29b      	uxth	r3, r3
    7ac0:	f400 407e 	and.w	r0, r0, #65024	; 0xfe00
    7ac4:	4318      	orrs	r0, r3
    7ac6:	83d0      	strh	r0, [r2, #30]
			TCD->CITER = (TCD->CITER & 0xFE00) | len;
    7ac8:	6809      	ldr	r1, [r1, #0]
    7aca:	8aca      	ldrh	r2, [r1, #22]
    7acc:	f402 427e 	and.w	r2, r2, #65024	; 0xfe00
    7ad0:	4313      	orrs	r3, r2
    7ad2:	82cb      	strh	r3, [r1, #22]
    7ad4:	68e9      	ldr	r1, [r5, #12]
    7ad6:	680a      	ldr	r2, [r1, #0]
    7ad8:	e7c4      	b.n	7a64 <WS2812Serial::show()+0x11c>
	uint8_t *fb = frameBuffer;
	while (p < end) {
		uint8_t b = *p++;
		uint8_t g = *p++;
		uint8_t r = *p++;
		uint32_t n=0;
    7ada:	2300      	movs	r3, #0
    7adc:	e761      	b.n	79a2 <WS2812Serial::show()+0x5a>
    7ade:	bf00      	nop
    7ae0:	4000800c 	.word	0x4000800c
    7ae4:	4000801b 	.word	0x4000801b

00007ae8 <Adafruit_VEML7700::Adafruit_VEML7700()>:
#include "Adafruit_VEML7700.h"

/*!
 *    @brief  Instantiates a new VEML7700 class
 */
Adafruit_VEML7700::Adafruit_VEML7700(void) {}
    7ae8:	4770      	bx	lr
    7aea:	bf00      	nop

00007aec <Adafruit_VEML7700::begin(TwoWire*)>:
/*!
 *    @brief  Setups the HW
 *    @param  addr
 *    @return True if initialization was successful, otherwise false.
 */
boolean Adafruit_VEML7700::begin(TwoWire *theWire) {
    7aec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7af0:	4604      	mov	r4, r0
    7af2:	b082      	sub	sp, #8
  i2c_dev = new Adafruit_I2CDevice(VEML7700_I2CADDR_DEFAULT);
    7af4:	200c      	movs	r0, #12
    7af6:	f001 ffbd 	bl	9a74 <operator new(unsigned int)>
    7afa:	4a6b      	ldr	r2, [pc, #428]	; (7ca8 <Adafruit_VEML7700::begin(TwoWire*)+0x1bc>)
    7afc:	4605      	mov	r5, r0
    7afe:	2110      	movs	r1, #16
    7b00:	f000 fdc6 	bl	8690 <Adafruit_I2CDevice::Adafruit_I2CDevice(unsigned char, TwoWire*)>
    7b04:	63a5      	str	r5, [r4, #56]	; 0x38

  if (!i2c_dev->begin()) {
    7b06:	4628      	mov	r0, r5
    7b08:	f000 fde4 	bl	86d4 <Adafruit_I2CDevice::begin()>
    7b0c:	4607      	mov	r7, r0
    7b0e:	2800      	cmp	r0, #0
    7b10:	f000 80c6 	beq.w	7ca0 <Adafruit_VEML7700::begin(TwoWire*)+0x1b4>
    return false;
  }

  ALS_Config = new Adafruit_I2CRegister(i2c_dev, VEML7700_ALS_CONFIG, 2, LSBFIRST);
    7b14:	2014      	movs	r0, #20
    7b16:	f001 ffad 	bl	9a74 <operator new(unsigned int)>
    7b1a:	2500      	movs	r5, #0
    7b1c:	2601      	movs	r6, #1
    7b1e:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    7b20:	4680      	mov	r8, r0
    7b22:	462a      	mov	r2, r5
    7b24:	2302      	movs	r3, #2
    7b26:	e88d 0060 	stmia.w	sp, {r5, r6}
    7b2a:	f000 fcbb 	bl	84a4 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, unsigned short, unsigned char, unsigned char, unsigned char)>
    7b2e:	f8c4 8000 	str.w	r8, [r4]
  ALS_HighThreshold = new Adafruit_I2CRegister(i2c_dev, VEML7700_ALS_THREHOLD_HIGH, 2, LSBFIRST);
    7b32:	2014      	movs	r0, #20
    7b34:	f001 ff9e 	bl	9a74 <operator new(unsigned int)>
    7b38:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    7b3a:	4680      	mov	r8, r0
    7b3c:	4632      	mov	r2, r6
    7b3e:	2302      	movs	r3, #2
    7b40:	e88d 0060 	stmia.w	sp, {r5, r6}
    7b44:	f000 fcae 	bl	84a4 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, unsigned short, unsigned char, unsigned char, unsigned char)>
    7b48:	f8c4 800c 	str.w	r8, [r4, #12]
  ALS_LowThreshold = new Adafruit_I2CRegister(i2c_dev, VEML7700_ALS_THREHOLD_LOW, 2, LSBFIRST);
    7b4c:	2014      	movs	r0, #20
    7b4e:	f001 ff91 	bl	9a74 <operator new(unsigned int)>
    7b52:	2302      	movs	r3, #2
    7b54:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    7b56:	9601      	str	r6, [sp, #4]
    7b58:	461a      	mov	r2, r3
    7b5a:	4680      	mov	r8, r0
    7b5c:	9500      	str	r5, [sp, #0]
    7b5e:	f000 fca1 	bl	84a4 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, unsigned short, unsigned char, unsigned char, unsigned char)>
    7b62:	f8c4 8010 	str.w	r8, [r4, #16]
  Power_Saving =  new Adafruit_I2CRegister(i2c_dev, VEML7700_ALS_POWER_SAVE, 2, LSBFIRST);
    7b66:	2014      	movs	r0, #20
    7b68:	f001 ff84 	bl	9a74 <operator new(unsigned int)>
    7b6c:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    7b6e:	4680      	mov	r8, r0
    7b70:	2302      	movs	r3, #2
    7b72:	2203      	movs	r2, #3
    7b74:	e88d 0060 	stmia.w	sp, {r5, r6}
    7b78:	f000 fc94 	bl	84a4 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, unsigned short, unsigned char, unsigned char, unsigned char)>
    7b7c:	f8c4 8014 	str.w	r8, [r4, #20]
  ALS_Data = new Adafruit_I2CRegister(i2c_dev, VEML7700_ALS_DATA, 2, LSBFIRST);
    7b80:	2014      	movs	r0, #20
    7b82:	f001 ff77 	bl	9a74 <operator new(unsigned int)>
    7b86:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    7b88:	4680      	mov	r8, r0
    7b8a:	2302      	movs	r3, #2
    7b8c:	2204      	movs	r2, #4
    7b8e:	e88d 0060 	stmia.w	sp, {r5, r6}
    7b92:	f000 fc87 	bl	84a4 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, unsigned short, unsigned char, unsigned char, unsigned char)>
    7b96:	f8c4 8004 	str.w	r8, [r4, #4]
  White_Data = new Adafruit_I2CRegister(i2c_dev, VEML7700_WHITE_DATA, 2, LSBFIRST);
    7b9a:	2014      	movs	r0, #20
    7b9c:	f001 ff6a 	bl	9a74 <operator new(unsigned int)>
    7ba0:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    7ba2:	4680      	mov	r8, r0
    7ba4:	2302      	movs	r3, #2
    7ba6:	2205      	movs	r2, #5
    7ba8:	e88d 0060 	stmia.w	sp, {r5, r6}
    7bac:	f000 fc7a 	bl	84a4 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, unsigned short, unsigned char, unsigned char, unsigned char)>
    7bb0:	f8c4 8008 	str.w	r8, [r4, #8]
  Interrupt_Status = new Adafruit_I2CRegister(i2c_dev, VEML7700_INTERRUPTSTATUS, 2, LSBFIRST);
    7bb4:	2014      	movs	r0, #20
    7bb6:	f001 ff5d 	bl	9a74 <operator new(unsigned int)>
    7bba:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    7bbc:	4680      	mov	r8, r0
    7bbe:	2302      	movs	r3, #2
    7bc0:	2206      	movs	r2, #6
    7bc2:	e88d 0060 	stmia.w	sp, {r5, r6}
    7bc6:	f000 fc6d 	bl	84a4 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, unsigned short, unsigned char, unsigned char, unsigned char)>
    7bca:	f8c4 8018 	str.w	r8, [r4, #24]

  ALS_Shutdown = new Adafruit_I2CRegisterBits(ALS_Config, 1, 0);  // # bits, bit_shift
    7bce:	2008      	movs	r0, #8
    7bd0:	f001 ff50 	bl	9a74 <operator new(unsigned int)>
    7bd4:	462b      	mov	r3, r5
    7bd6:	4680      	mov	r8, r0
    7bd8:	4632      	mov	r2, r6
    7bda:	6821      	ldr	r1, [r4, #0]
    7bdc:	f000 fd14 	bl	8608 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
    7be0:	f8c4 801c 	str.w	r8, [r4, #28]
  ALS_Interrupt_Enable = new Adafruit_I2CRegisterBits(ALS_Config, 1, 1); 
    7be4:	2008      	movs	r0, #8
    7be6:	f001 ff45 	bl	9a74 <operator new(unsigned int)>
    7bea:	4633      	mov	r3, r6
    7bec:	4680      	mov	r8, r0
    7bee:	4632      	mov	r2, r6
    7bf0:	6821      	ldr	r1, [r4, #0]
    7bf2:	f000 fd09 	bl	8608 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
    7bf6:	f8c4 8020 	str.w	r8, [r4, #32]
  ALS_Persistence = new Adafruit_I2CRegisterBits(ALS_Config, 2, 4); 
    7bfa:	2008      	movs	r0, #8
    7bfc:	f001 ff3a 	bl	9a74 <operator new(unsigned int)>
    7c00:	2304      	movs	r3, #4
    7c02:	4680      	mov	r8, r0
    7c04:	2202      	movs	r2, #2
    7c06:	6821      	ldr	r1, [r4, #0]
    7c08:	f000 fcfe 	bl	8608 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
    7c0c:	f8c4 8024 	str.w	r8, [r4, #36]	; 0x24
  ALS_Integration_Time = new Adafruit_I2CRegisterBits(ALS_Config, 4, 6); 
    7c10:	2008      	movs	r0, #8
    7c12:	f001 ff2f 	bl	9a74 <operator new(unsigned int)>
    7c16:	2306      	movs	r3, #6
    7c18:	4680      	mov	r8, r0
    7c1a:	2204      	movs	r2, #4
    7c1c:	6821      	ldr	r1, [r4, #0]
    7c1e:	f000 fcf3 	bl	8608 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
    7c22:	f8c4 8028 	str.w	r8, [r4, #40]	; 0x28
  ALS_Gain = new Adafruit_I2CRegisterBits(ALS_Config, 2, 11); 
    7c26:	2008      	movs	r0, #8
    7c28:	f001 ff24 	bl	9a74 <operator new(unsigned int)>
    7c2c:	230b      	movs	r3, #11
    7c2e:	4680      	mov	r8, r0
    7c30:	2202      	movs	r2, #2
    7c32:	6821      	ldr	r1, [r4, #0]
    7c34:	f000 fce8 	bl	8608 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
    7c38:	f8c4 802c 	str.w	r8, [r4, #44]	; 0x2c
  PowerSave_Enable = new Adafruit_I2CRegisterBits(Power_Saving, 1, 0);
    7c3c:	2008      	movs	r0, #8
    7c3e:	f001 ff19 	bl	9a74 <operator new(unsigned int)>
    7c42:	462b      	mov	r3, r5
    7c44:	4680      	mov	r8, r0
    7c46:	4632      	mov	r2, r6
    7c48:	6961      	ldr	r1, [r4, #20]
    7c4a:	f000 fcdd 	bl	8608 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
    7c4e:	f8c4 8030 	str.w	r8, [r4, #48]	; 0x30
  PowerSave_Mode = new Adafruit_I2CRegisterBits(Power_Saving, 2, 1);
    7c52:	2008      	movs	r0, #8
    7c54:	f001 ff0e 	bl	9a74 <operator new(unsigned int)>
    7c58:	4633      	mov	r3, r6
    7c5a:	2202      	movs	r2, #2
    7c5c:	4680      	mov	r8, r0
    7c5e:	6961      	ldr	r1, [r4, #20]
    7c60:	f000 fcd2 	bl	8608 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  return normalize(White_Data->read()) * 0.0576; // Unclear if this is the right multiplier
}


void Adafruit_VEML7700::enable(bool enable) {
  ALS_Shutdown->write(!enable);
    7c64:	4631      	mov	r1, r6
    7c66:	69e0      	ldr	r0, [r4, #28]
  ALS_Interrupt_Enable = new Adafruit_I2CRegisterBits(ALS_Config, 1, 1); 
  ALS_Persistence = new Adafruit_I2CRegisterBits(ALS_Config, 2, 4); 
  ALS_Integration_Time = new Adafruit_I2CRegisterBits(ALS_Config, 4, 6); 
  ALS_Gain = new Adafruit_I2CRegisterBits(ALS_Config, 2, 11); 
  PowerSave_Enable = new Adafruit_I2CRegisterBits(Power_Saving, 1, 0);
  PowerSave_Mode = new Adafruit_I2CRegisterBits(Power_Saving, 2, 1);
    7c68:	f8c4 8034 	str.w	r8, [r4, #52]	; 0x34
  return normalize(White_Data->read()) * 0.0576; // Unclear if this is the right multiplier
}


void Adafruit_VEML7700::enable(bool enable) {
  ALS_Shutdown->write(!enable);
    7c6c:	f000 fce0 	bl	8630 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
bool Adafruit_VEML7700::enabled(void) {
  return !ALS_Shutdown->read();
}

void Adafruit_VEML7700::interruptEnable(bool enable) {
  ALS_Interrupt_Enable->write(enable);
    7c70:	4629      	mov	r1, r5
    7c72:	6a20      	ldr	r0, [r4, #32]
    7c74:	f000 fcdc 	bl	8630 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
bool Adafruit_VEML7700::interruptEnabled(void) {
  return ALS_Interrupt_Enable->read();
}

void Adafruit_VEML7700::setPersistence(uint8_t pers) {
  ALS_Persistence->write(pers);
    7c78:	4629      	mov	r1, r5
    7c7a:	6a60      	ldr	r0, [r4, #36]	; 0x24
    7c7c:	f000 fcd8 	bl	8630 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
uint8_t Adafruit_VEML7700::getIntegrationTime(void) {
  return ALS_Integration_Time->read();
}

void Adafruit_VEML7700::setGain(uint8_t gain) {
  ALS_Gain->write(gain);
    7c80:	4629      	mov	r1, r5
    7c82:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    7c84:	f000 fcd4 	bl	8630 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
uint8_t Adafruit_VEML7700::getPersistence(void) {
  return ALS_Persistence->read();
}

void Adafruit_VEML7700::setIntegrationTime(uint8_t it) {
  ALS_Integration_Time->write(it);
    7c88:	4629      	mov	r1, r5
    7c8a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    7c8c:	f000 fcd0 	bl	8630 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
uint8_t Adafruit_VEML7700::getGain(void) {
  return ALS_Gain->read();
}

void Adafruit_VEML7700::powerSaveEnable(bool enable) {
  PowerSave_Enable->write(enable);
    7c90:	4629      	mov	r1, r5
    7c92:	6b20      	ldr	r0, [r4, #48]	; 0x30
    7c94:	f000 fccc 	bl	8630 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
  return normalize(White_Data->read()) * 0.0576; // Unclear if this is the right multiplier
}


void Adafruit_VEML7700::enable(bool enable) {
  ALS_Shutdown->write(!enable);
    7c98:	4629      	mov	r1, r5
    7c9a:	69e0      	ldr	r0, [r4, #28]
    7c9c:	f000 fcc8 	bl	8630 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
  setIntegrationTime(VEML7700_IT_100MS);
  powerSaveEnable(false);
  enable(true);

  return true;
}
    7ca0:	4638      	mov	r0, r7
    7ca2:	b002      	add	sp, #8
    7ca4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7ca8:	1fffb924 	.word	0x1fffb924

00007cac <Adafruit_VEML7700::normalize(float)>:


float Adafruit_VEML7700::normalize(float value) {
    7cac:	b538      	push	{r3, r4, r5, lr}
    7cae:	4605      	mov	r5, r0
void Adafruit_VEML7700::setGain(uint8_t gain) {
  ALS_Gain->write(gain);
}

uint8_t Adafruit_VEML7700::getGain(void) {
  return ALS_Gain->read();
    7cb0:	6ac0      	ldr	r0, [r0, #44]	; 0x2c

  return true;
}


float Adafruit_VEML7700::normalize(float value) {
    7cb2:	460c      	mov	r4, r1
void Adafruit_VEML7700::setGain(uint8_t gain) {
  ALS_Gain->write(gain);
}

uint8_t Adafruit_VEML7700::getGain(void) {
  return ALS_Gain->read();
    7cb4:	f000 fcae 	bl	8614 <Adafruit_BusIO_RegisterBits::read()>
}


float Adafruit_VEML7700::normalize(float value) {
  // adjust for gain (1x is normalized)
  switch (getGain()) {
    7cb8:	b2c0      	uxtb	r0, r0
    7cba:	2802      	cmp	r0, #2
    7cbc:	d028      	beq.n	7d10 <Adafruit_VEML7700::normalize(float)+0x64>
    7cbe:	2803      	cmp	r0, #3
    7cc0:	d01f      	beq.n	7d02 <Adafruit_VEML7700::normalize(float)+0x56>
    7cc2:	2801      	cmp	r0, #1
    7cc4:	d016      	beq.n	7cf4 <Adafruit_VEML7700::normalize(float)+0x48>
void Adafruit_VEML7700::setIntegrationTime(uint8_t it) {
  ALS_Integration_Time->write(it);
}

uint8_t Adafruit_VEML7700::getIntegrationTime(void) {
  return ALS_Integration_Time->read();
    7cc6:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    7cc8:	f000 fca4 	bl	8614 <Adafruit_BusIO_RegisterBits::read()>
  case VEML7700_GAIN_1_8:
    value *= 8; break;
  }
  
  // adjust for integrationtime (100ms is normalized)
  switch (getIntegrationTime()) {
    7ccc:	b2c0      	uxtb	r0, r0
    7cce:	3801      	subs	r0, #1
    7cd0:	280b      	cmp	r0, #11
    7cd2:	d80d      	bhi.n	7cf0 <Adafruit_VEML7700::normalize(float)+0x44>
    7cd4:	e8df f000 	tbb	[pc, r0]
    7cd8:	0c06332b 	.word	0x0c06332b
    7cdc:	3b0c0c0c 	.word	0x3b0c0c0c
    7ce0:	230c0c0c 	.word	0x230c0c0c
  case VEML7700_IT_200MS:
    value /= 2.0; break;
  case VEML7700_IT_400MS:
    value /= 4.0; break;
  case VEML7700_IT_800MS:
    value /= 8.0; break;
    7ce4:	4620      	mov	r0, r4
    7ce6:	f04f 5178 	mov.w	r1, #1040187392	; 0x3e000000
    7cea:	f005 fb37 	bl	d35c <__aeabi_fmul>
    7cee:	4604      	mov	r4, r0
  }

  return value;
}
    7cf0:	4620      	mov	r0, r4
    7cf2:	bd38      	pop	{r3, r4, r5, pc}

float Adafruit_VEML7700::normalize(float value) {
  // adjust for gain (1x is normalized)
  switch (getGain()) {
  case VEML7700_GAIN_2:  
    value /= 2.0;  break;
    7cf4:	4620      	mov	r0, r4
    7cf6:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
    7cfa:	f005 fb2f 	bl	d35c <__aeabi_fmul>
    7cfe:	4604      	mov	r4, r0
    7d00:	e7e1      	b.n	7cc6 <Adafruit_VEML7700::normalize(float)+0x1a>
  case VEML7700_GAIN_1_4: 
    value *= 4; break;
    7d02:	4620      	mov	r0, r4
    7d04:	f04f 4181 	mov.w	r1, #1082130432	; 0x40800000
    7d08:	f005 fb28 	bl	d35c <__aeabi_fmul>
    7d0c:	4604      	mov	r4, r0
    7d0e:	e7da      	b.n	7cc6 <Adafruit_VEML7700::normalize(float)+0x1a>
  case VEML7700_GAIN_1_8:
    value *= 8; break;
    7d10:	4620      	mov	r0, r4
    7d12:	f04f 4182 	mov.w	r1, #1090519040	; 0x41000000
    7d16:	f005 fb21 	bl	d35c <__aeabi_fmul>
    7d1a:	4604      	mov	r4, r0
    7d1c:	e7d3      	b.n	7cc6 <Adafruit_VEML7700::normalize(float)+0x1a>
  }
  
  // adjust for integrationtime (100ms is normalized)
  switch (getIntegrationTime()) {
  case VEML7700_IT_25MS:
    value *= 4; break;
    7d1e:	4620      	mov	r0, r4
    7d20:	f04f 4181 	mov.w	r1, #1082130432	; 0x40800000
    7d24:	f005 fb1a 	bl	d35c <__aeabi_fmul>
    7d28:	4604      	mov	r4, r0
  case VEML7700_IT_800MS:
    value /= 8.0; break;
  }

  return value;
}
    7d2a:	4620      	mov	r0, r4
    7d2c:	bd38      	pop	{r3, r4, r5, pc}
  case VEML7700_IT_25MS:
    value *= 4; break;
  case VEML7700_IT_50MS:
    value *= 2; break;
  case VEML7700_IT_200MS:
    value /= 2.0; break;
    7d2e:	4620      	mov	r0, r4
    7d30:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
    7d34:	f005 fb12 	bl	d35c <__aeabi_fmul>
    7d38:	4604      	mov	r4, r0
  case VEML7700_IT_800MS:
    value /= 8.0; break;
  }

  return value;
}
    7d3a:	4620      	mov	r0, r4
    7d3c:	bd38      	pop	{r3, r4, r5, pc}
  case VEML7700_IT_50MS:
    value *= 2; break;
  case VEML7700_IT_200MS:
    value /= 2.0; break;
  case VEML7700_IT_400MS:
    value /= 4.0; break;
    7d3e:	4620      	mov	r0, r4
    7d40:	f04f 517a 	mov.w	r1, #1048576000	; 0x3e800000
    7d44:	f005 fb0a 	bl	d35c <__aeabi_fmul>
    7d48:	4604      	mov	r4, r0
  case VEML7700_IT_800MS:
    value /= 8.0; break;
  }

  return value;
}
    7d4a:	4620      	mov	r0, r4
    7d4c:	bd38      	pop	{r3, r4, r5, pc}
  // adjust for integrationtime (100ms is normalized)
  switch (getIntegrationTime()) {
  case VEML7700_IT_25MS:
    value *= 4; break;
  case VEML7700_IT_50MS:
    value *= 2; break;
    7d4e:	4621      	mov	r1, r4
    7d50:	4620      	mov	r0, r4
    7d52:	f005 f9fb 	bl	d14c <__addsf3>
    7d56:	4604      	mov	r4, r0
  case VEML7700_IT_800MS:
    value /= 8.0; break;
  }

  return value;
}
    7d58:	4620      	mov	r0, r4
    7d5a:	bd38      	pop	{r3, r4, r5, pc}

00007d5c <Adafruit_VEML7700::readLux()>:

float Adafruit_VEML7700::readLux() {
    7d5c:	b510      	push	{r4, lr}
    7d5e:	4604      	mov	r4, r0
  return normalize(ALS_Data->read()) * 0.0576;  // see app note lux table on page 5
    7d60:	6840      	ldr	r0, [r0, #4]
    7d62:	f000 fc27 	bl	85b4 <Adafruit_BusIO_Register::read()>
    7d66:	f005 faa1 	bl	d2ac <__aeabi_ui2f>
    7d6a:	4601      	mov	r1, r0
    7d6c:	4620      	mov	r0, r4
    7d6e:	f7ff ff9d 	bl	7cac <Adafruit_VEML7700::normalize(float)>
    7d72:	4902      	ldr	r1, [pc, #8]	; (7d7c <Adafruit_VEML7700::readLux()+0x20>)
    7d74:	f005 faf2 	bl	d35c <__aeabi_fmul>
}
    7d78:	bd10      	pop	{r4, pc}
    7d7a:	bf00      	nop
    7d7c:	3d6bedfa 	.word	0x3d6bedfa

00007d80 <Adafruit_VEML7700::setIntegrationTime(unsigned char)>:
uint8_t Adafruit_VEML7700::getPersistence(void) {
  return ALS_Persistence->read();
}

void Adafruit_VEML7700::setIntegrationTime(uint8_t it) {
  ALS_Integration_Time->write(it);
    7d80:	6a80      	ldr	r0, [r0, #40]	; 0x28
    7d82:	f000 bc55 	b.w	8630 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
    7d86:	bf00      	nop

00007d88 <Adafruit_VEML7700::setGain(unsigned char)>:
uint8_t Adafruit_VEML7700::getIntegrationTime(void) {
  return ALS_Integration_Time->read();
}

void Adafruit_VEML7700::setGain(uint8_t gain) {
  ALS_Gain->write(gain);
    7d88:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
    7d8a:	f000 bc51 	b.w	8630 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
    7d8e:	bf00      	nop

00007d90 <TwoWire::available()>:
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    7d90:	f890 2039 	ldrb.w	r2, [r0, #57]	; 0x39
    7d94:	f890 0038 	ldrb.w	r0, [r0, #56]	; 0x38
	}
    7d98:	1a10      	subs	r0, r2, r0
    7d9a:	4770      	bx	lr

00007d9c <TwoWire::read()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    7d9c:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
    7da0:	f890 2039 	ldrb.w	r2, [r0, #57]	; 0x39
    7da4:	429a      	cmp	r2, r3
    7da6:	d905      	bls.n	7db4 <TwoWire::read()+0x18>
		return rxBuffer[rxBufferIndex++];
    7da8:	1c5a      	adds	r2, r3, #1
    7daa:	4403      	add	r3, r0
    7dac:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    7db0:	7e18      	ldrb	r0, [r3, #24]
    7db2:	4770      	bx	lr
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    7db4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		return rxBuffer[rxBufferIndex++];
	}
    7db8:	4770      	bx	lr
    7dba:	bf00      	nop

00007dbc <TwoWire::peek()>:
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    7dbc:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
    7dc0:	f890 2039 	ldrb.w	r2, [r0, #57]	; 0x39
    7dc4:	429a      	cmp	r2, r3
		return rxBuffer[rxBufferIndex];
    7dc6:	bf86      	itte	hi
    7dc8:	181b      	addhi	r3, r3, r0
    7dca:	7e18      	ldrbhi	r0, [r3, #24]
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    7dcc:	f04f 30ff 	movls.w	r0, #4294967295	; 0xffffffff
		return rxBuffer[rxBufferIndex];
	}
    7dd0:	4770      	bx	lr
    7dd2:	bf00      	nop

00007dd4 <TwoWire::flush()>:
	virtual void flush(void) {
    7dd4:	4770      	bx	lr
    7dd6:	bf00      	nop

00007dd8 <TwoWire::write(unsigned char const*, unsigned int)>:
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    7dd8:	b538      	push	{r3, r4, r5, lr}
    7dda:	4605      	mov	r5, r0
	if (transmitting || slave_mode) {
    7ddc:	f8b0 005e 	ldrh.w	r0, [r0, #94]	; 0x5e
    7de0:	b190      	cbz	r0, 7e08 <TwoWire::write(unsigned char const*, unsigned int)+0x30>
		size_t avail = BUFFER_LENGTH+1 - txBufferLength;
    7de2:	f895 305d 	ldrb.w	r3, [r5, #93]	; 0x5d
    7de6:	4614      	mov	r4, r2
    7de8:	f1c3 0221 	rsb	r2, r3, #33	; 0x21
		if (quantity > avail) {
    7dec:	4294      	cmp	r4, r2
    7dee:	d80c      	bhi.n	7e0a <TwoWire::write(unsigned char const*, unsigned int)+0x32>
			quantity = avail;
			setWriteError();
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
    7df0:	f105 003b 	add.w	r0, r5, #59	; 0x3b
    7df4:	4418      	add	r0, r3
    7df6:	4622      	mov	r2, r4
    7df8:	f001 fd5a 	bl	98b0 <memcpy>
		txBufferLength += quantity;
    7dfc:	f895 305d 	ldrb.w	r3, [r5, #93]	; 0x5d
    7e00:	4423      	add	r3, r4
    7e02:	f885 305d 	strb.w	r3, [r5, #93]	; 0x5d
    7e06:	4620      	mov	r0, r4
		return quantity;
	}
	return 0;
}
    7e08:	bd38      	pop	{r3, r4, r5, pc}
    7e0a:	2001      	movs	r0, #1
    7e0c:	4614      	mov	r4, r2
    7e0e:	7128      	strb	r0, [r5, #4]
    7e10:	e7ee      	b.n	7df0 <TwoWire::write(unsigned char const*, unsigned int)+0x18>
    7e12:	bf00      	nop

00007e14 <TwoWire::write(unsigned char)>:
//  I2C0_C2      // I2C Control Register 2
//  I2C0_FLT     // I2C Programmable Input Glitch Filter register

size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
    7e14:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
    7e18:	b16b      	cbz	r3, 7e36 <TwoWire::write(unsigned char)+0x22>
		if (txBufferLength >= BUFFER_LENGTH+1) {
    7e1a:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
    7e1e:	2b20      	cmp	r3, #32
    7e20:	d807      	bhi.n	7e32 <TwoWire::write(unsigned char)+0x1e>
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    7e22:	18c2      	adds	r2, r0, r3
    7e24:	3301      	adds	r3, #1
    7e26:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d
		return 1;
    7e2a:	2001      	movs	r0, #1
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    7e2c:	f882 103b 	strb.w	r1, [r2, #59]	; 0x3b
    7e30:	4770      	bx	lr
    7e32:	2301      	movs	r3, #1
    7e34:	7103      	strb	r3, [r0, #4]
size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
    7e36:	2000      	movs	r0, #0
    7e38:	4770      	bx	lr
    7e3a:	bf00      	nop

00007e3c <TwoWire::begin()>:
void TwoWire::begin(void)
{
	//serial_begin(BAUD2DIV(115200));
	//serial_print("\nWire Begin\n");

	rxBufferIndex = 0;
    7e3c:	2300      	movs	r3, #0
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    7e3e:	6942      	ldr	r2, [r0, #20]
void TwoWire::begin(void)
{
	//serial_begin(BAUD2DIV(115200));
	//serial_print("\nWire Begin\n");

	rxBufferIndex = 0;
    7e40:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
	rxBufferLength = 0;
    7e44:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
	txBufferIndex = 0;
    7e48:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
	txBufferLength = 0;
    7e4c:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d
	transmitting = 0;
    7e50:	f880 305e 	strb.w	r3, [r0, #94]	; 0x5e
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
    7e54:	f880 305f 	strb.w	r3, [r0, #95]	; 0x5f
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    7e58:	ca06      	ldmia	r2, {r1, r2}

void sda_rising_isr0(void);
void sda_rising_isr1(void);

void TwoWire::begin(void)
{
    7e5a:	b430      	push	{r4, r5}
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    7e5c:	680d      	ldr	r5, [r1, #0]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    7e5e:	6904      	ldr	r4, [r0, #16]
	rxBufferIndex = 0;
	rxBufferLength = 0;
	txBufferIndex = 0;
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
    7e60:	6643      	str	r3, [r0, #100]	; 0x64
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    7e62:	432a      	orrs	r2, r5
	rxBufferLength = 0;
	txBufferIndex = 0;
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
    7e64:	6683      	str	r3, [r0, #104]	; 0x68
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    7e66:	600a      	str	r2, [r1, #0]
	port().C1 = 0;
    7e68:	70a3      	strb	r3, [r4, #2]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    7e6a:	6942      	ldr	r2, [r0, #20]
    7e6c:	f890 3061 	ldrb.w	r3, [r0, #97]	; 0x61
    7e70:	4916      	ldr	r1, [pc, #88]	; (7ecc <TwoWire::begin()+0x90>)
	//pinMode(4, OUTPUT);
}

void TwoWire::setClock(uint32_t frequency)
{
	if (!(hardware.clock_gate_register & hardware.clock_gate_mask)) return;
    7e72:	6814      	ldr	r4, [r2, #0]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    7e74:	4413      	add	r3, r2
    7e76:	7a1d      	ldrb	r5, [r3, #8]
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    7e78:	7b5b      	ldrb	r3, [r3, #13]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    7e7a:	eb01 05c5 	add.w	r5, r1, r5, lsl #3
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    7e7e:	021b      	lsls	r3, r3, #8
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    7e80:	686d      	ldr	r5, [r5, #4]
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    7e82:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    7e86:	f043 0364 	orr.w	r3, r3, #100	; 0x64
    7e8a:	602b      	str	r3, [r5, #0]
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    7e8c:	f890 3062 	ldrb.w	r3, [r0, #98]	; 0x62
    7e90:	4413      	add	r3, r2
    7e92:	7c9d      	ldrb	r5, [r3, #18]
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    7e94:	7ddb      	ldrb	r3, [r3, #23]
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    7e96:	eb01 01c5 	add.w	r1, r1, r5, lsl #3
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    7e9a:	021b      	lsls	r3, r3, #8
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    7e9c:	6849      	ldr	r1, [r1, #4]
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    7e9e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    7ea2:	f043 0364 	orr.w	r3, r3, #100	; 0x64
    7ea6:	600b      	str	r3, [r1, #0]
	//pinMode(4, OUTPUT);
}

void TwoWire::setClock(uint32_t frequency)
{
	if (!(hardware.clock_gate_register & hardware.clock_gate_mask)) return;
    7ea8:	6821      	ldr	r1, [r4, #0]
    7eaa:	6853      	ldr	r3, [r2, #4]
    7eac:	4219      	tst	r1, r3
    7eae:	d005      	beq.n	7ebc <TwoWire::begin()+0x80>
    7eb0:	6903      	ldr	r3, [r0, #16]
		port().F = I2C_F_DIV64; // 1.0 MHz
	}
	port().FLT = 4;
#elif F_BUS == 60000000
	if (frequency < 400000) {
		port().F = 0x2C;	// 104 kHz
    7eb2:	222c      	movs	r2, #44	; 0x2c
    7eb4:	705a      	strb	r2, [r3, #1]
    7eb6:	6903      	ldr	r3, [r0, #16]
	} else if (frequency < 1000000) {
		port().F = 0x1C; // 416 kHz
	} else {
		port().F = 0x12; // 938 kHz
	}
	port().FLT = 4;
    7eb8:	2204      	movs	r2, #4
    7eba:	719a      	strb	r2, [r3, #6]
    7ebc:	6903      	ldr	r3, [r0, #16]
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	setClock(100000);
	port().C2 = I2C_C2_HDRS;
    7ebe:	2220      	movs	r2, #32
    7ec0:	715a      	strb	r2, [r3, #5]
    7ec2:	6903      	ldr	r3, [r0, #16]
	port().C1 = I2C_C1_IICEN;
    7ec4:	2280      	movs	r2, #128	; 0x80
    7ec6:	709a      	strb	r2, [r3, #2]
	//pinMode(3, OUTPUT);
	//pinMode(4, OUTPUT);
}
    7ec8:	bc30      	pop	{r4, r5}
    7eca:	4770      	bx	lr
    7ecc:	000123c8 	.word	0x000123c8

00007ed0 <TwoWire::isr()>:
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    7ed0:	b510      	push	{r4, lr}
    7ed2:	6902      	ldr	r2, [r0, #16]
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
    7ed4:	78d3      	ldrb	r3, [r2, #3]
    7ed6:	b2db      	uxtb	r3, r3
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    7ed8:	06d9      	lsls	r1, r3, #27
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    7eda:	4604      	mov	r4, r0
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    7edc:	d53d      	bpl.n	7f5a <TwoWire::isr()+0x8a>
		// Arbitration Lost
		port().S = I2C_S_ARBL;
    7ede:	2110      	movs	r1, #16
		if (receiving && rxBufferLength > 0) {
			// TODO: does this detect the STOP condition in slave receive mode?


		}
		if (!(status & I2C_S_IAAS)) return;
    7ee0:	0658      	lsls	r0, r3, #25

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
		// Arbitration Lost
		port().S = I2C_S_ARBL;
    7ee2:	70d1      	strb	r1, [r2, #3]
		if (receiving && rxBufferLength > 0) {
			// TODO: does this detect the STOP condition in slave receive mode?


		}
		if (!(status & I2C_S_IAAS)) return;
    7ee4:	d538      	bpl.n	7f58 <TwoWire::isr()+0x88>
	}
	if (status & I2C_S_IAAS) {
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
    7ee6:	f003 0304 	and.w	r3, r3, #4
    7eea:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    7eee:	2b00      	cmp	r3, #0
    7ef0:	d051      	beq.n	7f96 <TwoWire::isr()+0xc6>
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    7ef2:	493d      	ldr	r1, [pc, #244]	; (7fe8 <TwoWire::isr()+0x118>)
			txBufferLength = 0;
			if (user_onRequest != NULL) {
    7ef4:	6e62      	ldr	r2, [r4, #100]	; 0x64
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    7ef6:	2300      	movs	r3, #0
    7ef8:	700b      	strb	r3, [r1, #0]
			txBufferLength = 0;
    7efa:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
			if (user_onRequest != NULL) {
    7efe:	2a00      	cmp	r2, #0
    7f00:	d05b      	beq.n	7fba <TwoWire::isr()+0xea>
				user_onRequest();
    7f02:	4790      	blx	r2
			}
			if (txBufferLength == 0) {
    7f04:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
    7f08:	2b00      	cmp	r3, #0
    7f0a:	d056      	beq.n	7fba <TwoWire::isr()+0xea>
    7f0c:	6923      	ldr	r3, [r4, #16]
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
				txBuffer[0] = 0;
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    7f0e:	22d0      	movs	r2, #208	; 0xd0
    7f10:	709a      	strb	r2, [r3, #2]
    7f12:	6923      	ldr	r3, [r4, #16]
			port().D = txBuffer[0];
    7f14:	f894 203b 	ldrb.w	r2, [r4, #59]	; 0x3b
    7f18:	711a      	strb	r2, [r3, #4]
    7f1a:	6923      	ldr	r3, [r4, #16]
			txBufferIndex = 1;
    7f1c:	2201      	movs	r2, #1
    7f1e:	f884 205c 	strb.w	r2, [r4, #92]	; 0x5c
			receiving = 1;
			rxBufferLength = 0;
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
			data = port().D;
		}
		port().S = I2C_S_IICIF;
    7f22:	2202      	movs	r2, #2
    7f24:	70da      	strb	r2, [r3, #3]
		return;
    7f26:	bd10      	pop	{r4, pc}
		#if defined(WIRE_IMPLEMENT_WIRE) && !defined(WIRE_IMPLEMENT_WIRE1)
		attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr0, RISING);
		#elif !defined(WIRE_IMPLEMENT_WIRE) && defined(WIRE_IMPLEMENT_WIRE1)
		attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		#elif defined(WIRE_IMPLEMENT_WIRE) && defined(WIRE_IMPLEMENT_WIRE1)
		if (this == &Wire) {
    7f28:	4b30      	ldr	r3, [pc, #192]	; (7fec <TwoWire::isr()+0x11c>)
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
			data = port().D;
		}
	} else {
		// Continue Slave Receive
		irqcount = 0;
    7f2a:	f884 0060 	strb.w	r0, [r4, #96]	; 0x60
		#if defined(WIRE_IMPLEMENT_WIRE) && !defined(WIRE_IMPLEMENT_WIRE1)
		attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr0, RISING);
		#elif !defined(WIRE_IMPLEMENT_WIRE) && defined(WIRE_IMPLEMENT_WIRE1)
		attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		#elif defined(WIRE_IMPLEMENT_WIRE) && defined(WIRE_IMPLEMENT_WIRE1)
		if (this == &Wire) {
    7f2e:	429c      	cmp	r4, r3
    7f30:	d04a      	beq.n	7fc8 <TwoWire::isr()+0xf8>
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr0, RISING);
		} else if (this == &Wire1) {
    7f32:	4b2f      	ldr	r3, [pc, #188]	; (7ff0 <TwoWire::isr()+0x120>)
    7f34:	429c      	cmp	r4, r3
    7f36:	d052      	beq.n	7fde <TwoWire::isr()+0x10e>
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    7f38:	f894 1039 	ldrb.w	r1, [r4, #57]	; 0x39
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    7f3c:	7913      	ldrb	r3, [r2, #4]
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    7f3e:	291f      	cmp	r1, #31
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    7f40:	b2db      	uxtb	r3, r3
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    7f42:	d807      	bhi.n	7f54 <TwoWire::isr()+0x84>
    7f44:	4828      	ldr	r0, [pc, #160]	; (7fe8 <TwoWire::isr()+0x118>)
    7f46:	7800      	ldrb	r0, [r0, #0]
    7f48:	b120      	cbz	r0, 7f54 <TwoWire::isr()+0x84>
			rxBuffer[rxBufferLength++] = data;
    7f4a:	1860      	adds	r0, r4, r1
    7f4c:	3101      	adds	r1, #1
    7f4e:	f884 1039 	strb.w	r1, [r4, #57]	; 0x39
    7f52:	7603      	strb	r3, [r0, #24]
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    7f54:	2302      	movs	r3, #2
    7f56:	70d3      	strb	r3, [r2, #3]
    7f58:	bd10      	pop	{r4, pc}


		}
		if (!(status & I2C_S_IAAS)) return;
	}
	if (status & I2C_S_IAAS) {
    7f5a:	0659      	lsls	r1, r3, #25
    7f5c:	d4c3      	bmi.n	7ee6 <TwoWire::isr()+0x16>
			rxBufferIndex = 0;
			user_onReceive(rxBufferLength);
		}
	}
	#endif
	c1 = port().C1;
    7f5e:	7891      	ldrb	r1, [r2, #2]
	if (c1 & I2C_C1_TX) {
    7f60:	f001 0110 	and.w	r1, r1, #16
    7f64:	f001 00ff 	and.w	r0, r1, #255	; 0xff
    7f68:	2900      	cmp	r1, #0
    7f6a:	d0dd      	beq.n	7f28 <TwoWire::isr()+0x58>
		// Continue Slave Transmit
		//serial_print("t");
		if ((status & I2C_S_RXAK) == 0) {
    7f6c:	f013 0301 	ands.w	r3, r3, #1
    7f70:	d11e      	bne.n	7fb0 <TwoWire::isr()+0xe0>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
    7f72:	f894 105c 	ldrb.w	r1, [r4, #92]	; 0x5c
    7f76:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
    7f7a:	4288      	cmp	r0, r1
				port().D = txBuffer[txBufferIndex++];
    7f7c:	bf81      	itttt	hi
    7f7e:	1c4b      	addhi	r3, r1, #1
    7f80:	1909      	addhi	r1, r1, r4
    7f82:	f884 305c 	strbhi.w	r3, [r4, #92]	; 0x5c
    7f86:	f891 303b 	ldrbhi.w	r3, [r1, #59]	; 0x3b
			} else {
				port().D = 0;
    7f8a:	7113      	strb	r3, [r2, #4]
    7f8c:	6923      	ldr	r3, [r4, #16]
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    7f8e:	22d0      	movs	r2, #208	; 0xd0
    7f90:	709a      	strb	r2, [r3, #2]
    7f92:	6922      	ldr	r2, [r4, #16]
    7f94:	e7de      	b.n	7f54 <TwoWire::isr()+0x84>
    7f96:	6923      	ldr	r3, [r4, #16]
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
			rxBufferLength = 0;
    7f98:	f884 2039 	strb.w	r2, [r4, #57]	; 0x39
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    7f9c:	22c0      	movs	r2, #192	; 0xc0
    7f9e:	709a      	strb	r2, [r3, #2]
    7fa0:	6923      	ldr	r3, [r4, #16]
			port().D = txBuffer[0];
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    7fa2:	4a11      	ldr	r2, [pc, #68]	; (7fe8 <TwoWire::isr()+0x118>)
			rxBufferLength = 0;
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
			data = port().D;
    7fa4:	7919      	ldrb	r1, [r3, #4]
			port().D = txBuffer[0];
			txBufferIndex = 1;
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    7fa6:	2101      	movs	r1, #1
    7fa8:	7011      	strb	r1, [r2, #0]
			rxBufferLength = 0;
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
			data = port().D;
		}
		port().S = I2C_S_IICIF;
    7faa:	2202      	movs	r2, #2
    7fac:	70da      	strb	r2, [r3, #3]
		return;
    7fae:	bd10      	pop	{r4, pc}
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
		} else {
			//serial_print("*");
			// Master did not ACK previous byte
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    7fb0:	23c0      	movs	r3, #192	; 0xc0
    7fb2:	7093      	strb	r3, [r2, #2]
    7fb4:	6922      	ldr	r2, [r4, #16]
			data = port().D;
    7fb6:	7913      	ldrb	r3, [r2, #4]
    7fb8:	e7cc      	b.n	7f54 <TwoWire::isr()+0x84>
			}
			if (txBufferLength == 0) {
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    7fba:	2201      	movs	r2, #1
				txBuffer[0] = 0;
    7fbc:	2300      	movs	r3, #0
			}
			if (txBufferLength == 0) {
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    7fbe:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
				txBuffer[0] = 0;
    7fc2:	f884 303b 	strb.w	r3, [r4, #59]	; 0x3b
    7fc6:	e7a1      	b.n	7f0c <TwoWire::isr()+0x3c>
		attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr0, RISING);
		#elif !defined(WIRE_IMPLEMENT_WIRE) && defined(WIRE_IMPLEMENT_WIRE1)
		attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		#elif defined(WIRE_IMPLEMENT_WIRE) && defined(WIRE_IMPLEMENT_WIRE1)
		if (this == &Wire) {
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr0, RISING);
    7fc8:	6962      	ldr	r2, [r4, #20]
    7fca:	f894 3061 	ldrb.w	r3, [r4, #97]	; 0x61
    7fce:	4909      	ldr	r1, [pc, #36]	; (7ff4 <TwoWire::isr()+0x124>)
		} else if (this == &Wire1) {
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
    7fd0:	4413      	add	r3, r2
    7fd2:	2203      	movs	r2, #3
    7fd4:	7a18      	ldrb	r0, [r3, #8]
    7fd6:	f001 ff8d 	bl	9ef4 <attachInterrupt>
    7fda:	6922      	ldr	r2, [r4, #16]
    7fdc:	e7ac      	b.n	7f38 <TwoWire::isr()+0x68>
    7fde:	6962      	ldr	r2, [r4, #20]
    7fe0:	f894 3061 	ldrb.w	r3, [r4, #97]	; 0x61
    7fe4:	4904      	ldr	r1, [pc, #16]	; (7ff8 <TwoWire::isr()+0x128>)
    7fe6:	e7f3      	b.n	7fd0 <TwoWire::isr()+0x100>
    7fe8:	20004595 	.word	0x20004595
    7fec:	1fffb924 	.word	0x1fffb924
    7ff0:	1fffb990 	.word	0x1fffb990
    7ff4:	00008059 	.word	0x00008059
    7ff8:	00008065 	.word	0x00008065

00007ffc <TwoWire::sda_rising_isr()>:
    7ffc:	6903      	ldr	r3, [r0, #16]
#endif

void TwoWire::sda_rising_isr(void)
{
	//digitalWrite(3, HIGH);
	if (!(port().S & I2C_S_BUSY)) {
    7ffe:	78db      	ldrb	r3, [r3, #3]
    8000:	f003 0320 	and.w	r3, r3, #32
    8004:	b173      	cbz	r3, 8024 <TwoWire::sda_rising_isr()+0x28>
			rxBufferIndex = 0;
			user_onReceive(rxBufferLength);
		}
		//delayMicroseconds(100);
	} else {
		if (++irqcount >= 2 || !slave_mode) {
    8006:	f890 3060 	ldrb.w	r3, [r0, #96]	; 0x60
    800a:	3301      	adds	r3, #1
    800c:	b2db      	uxtb	r3, r3
    800e:	2b01      	cmp	r3, #1
    8010:	f880 3060 	strb.w	r3, [r0, #96]	; 0x60
    8014:	d91a      	bls.n	804c <TwoWire::sda_rising_isr()+0x50>
			detachInterrupt(hardware.sda_pin[sda_pin_index]);
    8016:	6942      	ldr	r2, [r0, #20]
    8018:	f890 3061 	ldrb.w	r3, [r0, #97]	; 0x61
    801c:	4413      	add	r3, r2
    801e:	7a18      	ldrb	r0, [r3, #8]
    8020:	f001 bfe4 	b.w	9fec <detachInterrupt>
	Wire1.sda_rising_isr();
}
#endif

void TwoWire::sda_rising_isr(void)
{
    8024:	b570      	push	{r4, r5, r6, lr}
	//digitalWrite(3, HIGH);
	if (!(port().S & I2C_S_BUSY)) {
		detachInterrupt(hardware.sda_pin[sda_pin_index]);
    8026:	6942      	ldr	r2, [r0, #20]
    8028:	f003 05ff 	and.w	r5, r3, #255	; 0xff
    802c:	f890 3061 	ldrb.w	r3, [r0, #97]	; 0x61
    8030:	4413      	add	r3, r2
    8032:	4604      	mov	r4, r0
    8034:	7a18      	ldrb	r0, [r3, #8]
    8036:	f001 ffd9 	bl	9fec <detachInterrupt>
		if (user_onReceive != NULL) {
    803a:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    803c:	b15b      	cbz	r3, 8056 <TwoWire::sda_rising_isr()+0x5a>
			rxBufferIndex = 0;
    803e:	f884 5038 	strb.w	r5, [r4, #56]	; 0x38
			user_onReceive(rxBufferLength);
    8042:	f894 0039 	ldrb.w	r0, [r4, #57]	; 0x39
		if (++irqcount >= 2 || !slave_mode) {
			detachInterrupt(hardware.sda_pin[sda_pin_index]);
		}
	}
	//digitalWrite(3, LOW);
}
    8046:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	//digitalWrite(3, HIGH);
	if (!(port().S & I2C_S_BUSY)) {
		detachInterrupt(hardware.sda_pin[sda_pin_index]);
		if (user_onReceive != NULL) {
			rxBufferIndex = 0;
			user_onReceive(rxBufferLength);
    804a:	4718      	bx	r3
		}
		//delayMicroseconds(100);
	} else {
		if (++irqcount >= 2 || !slave_mode) {
    804c:	f890 305f 	ldrb.w	r3, [r0, #95]	; 0x5f
    8050:	2b00      	cmp	r3, #0
    8052:	d0e0      	beq.n	8016 <TwoWire::sda_rising_isr()+0x1a>
    8054:	4770      	bx	lr
    8056:	bd70      	pop	{r4, r5, r6, pc}

00008058 <sda_rising_isr0()>:
#if !defined(WIRE_HAS_STOP_INTERRUPT)

#if defined(WIRE_IMPLEMENT_WIRE)
void sda_rising_isr0(void)
{
	Wire.sda_rising_isr();
    8058:	4801      	ldr	r0, [pc, #4]	; (8060 <sda_rising_isr0()+0x8>)
    805a:	f7ff bfcf 	b.w	7ffc <TwoWire::sda_rising_isr()>
    805e:	bf00      	nop
    8060:	1fffb924 	.word	0x1fffb924

00008064 <sda_rising_isr1()>:
}
#endif
#if defined(WIRE_IMPLEMENT_WIRE1)
void sda_rising_isr1(void)
{
	Wire1.sda_rising_isr();
    8064:	4801      	ldr	r0, [pc, #4]	; (806c <sda_rising_isr1()+0x8>)
    8066:	f7ff bfc9 	b.w	7ffc <TwoWire::sda_rising_isr()>
    806a:	bf00      	nop
    806c:	1fffb990 	.word	0x1fffb990

00008070 <TwoWire::wait_idle()>:
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
    8070:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    8074:	4f37      	ldr	r7, [pc, #220]	; (8154 <L_1545_delayMicroseconds+0x1a>)
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    8076:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 8158 <L_1545_delayMicroseconds+0x1e>
    807a:	683b      	ldr	r3, [r7, #0]
    807c:	6902      	ldr	r2, [r0, #16]
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
    807e:	b082      	sub	sp, #8
    8080:	4606      	mov	r6, r0
    8082:	9300      	str	r3, [sp, #0]
	return ret;
    8084:	f8dd 8000 	ldr.w	r8, [sp]
	bool reset=false;
    8088:	2100      	movs	r1, #0
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    808a:	25c8      	movs	r5, #200	; 0xc8
	uint8_t i2c_status(void) {
		return port().S;
    808c:	78d3      	ldrb	r3, [r2, #3]
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    808e:	069b      	lsls	r3, r3, #26
    8090:	d55b      	bpl.n	814a <L_1545_delayMicroseconds+0x10>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    8092:	683b      	ldr	r3, [r7, #0]
    8094:	9301      	str	r3, [sp, #4]
	return ret;
    8096:	9b01      	ldr	r3, [sp, #4]
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
    8098:	ebc8 0303 	rsb	r3, r8, r3
#if 1
		if (waited > 15 && !reset) {
    809c:	2b0f      	cmp	r3, #15
    809e:	d9f5      	bls.n	808c <TwoWire::wait_idle()+0x1c>
    80a0:	b149      	cbz	r1, 80b6 <TwoWire::wait_idle()+0x46>
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			delayMicroseconds(10);
			continue;
		}
#endif
		if (waited > 16) {
    80a2:	2b10      	cmp	r3, #16
    80a4:	d0f2      	beq.n	808c <TwoWire::wait_idle()+0x1c>
			// bus stuck busy too long
			port().C1 = 0;
    80a6:	2000      	movs	r0, #0
    80a8:	7090      	strb	r0, [r2, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    80aa:	6933      	ldr	r3, [r6, #16]
			port().C1 = I2C_C1_IICEN;
    80ac:	2280      	movs	r2, #128	; 0x80
    80ae:	709a      	strb	r2, [r3, #2]
			//return 4; // timeout waiting for bus
			return false;
		}
	}
	return true;
}
    80b0:	b002      	add	sp, #8
    80b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uint32_t waited = millis() - wait_begin;
#if 1
		if (waited > 15 && !reset) {
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
    80b6:	6972      	ldr	r2, [r6, #20]
    80b8:	f896 3061 	ldrb.w	r3, [r6, #97]	; 0x61
    80bc:	4413      	add	r3, r2
			pinMode(sda_pin, INPUT_DISABLE);
    80be:	2105      	movs	r1, #5
    80c0:	7a18      	ldrb	r0, [r3, #8]
    80c2:	f001 fffd 	bl	a0c0 <pinMode>
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
    80c6:	6972      	ldr	r2, [r6, #20]
    80c8:	f896 3061 	ldrb.w	r3, [r6, #97]	; 0x61
    80cc:	4413      	add	r3, r2
			pinMode(scl_pin, OUTPUT);
    80ce:	2101      	movs	r1, #1
		if (waited > 15 && !reset) {
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
    80d0:	f893 a012 	ldrb.w	sl, [r3, #18]
			pinMode(scl_pin, OUTPUT);
    80d4:	4650      	mov	r0, sl
    80d6:	f001 fff3 	bl	a0c0 <pinMode>
    80da:	2409      	movs	r4, #9
			for (int i=0; i < 9; i++) {
				digitalWrite(scl_pin, LOW);
    80dc:	2100      	movs	r1, #0
    80de:	4650      	mov	r0, sl
    80e0:	f001 ffda 	bl	a098 <digitalWrite>
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    80e4:	462b      	mov	r3, r5

000080e6 <L_1480_delayMicroseconds>:
    80e6:	3b01      	subs	r3, #1
    80e8:	d1fd      	bne.n	80e6 <L_1480_delayMicroseconds>
				delayMicroseconds(5);
				digitalWrite(scl_pin, HIGH);
    80ea:	2101      	movs	r1, #1
    80ec:	4650      	mov	r0, sl
    80ee:	f001 ffd3 	bl	a098 <digitalWrite>
    80f2:	462b      	mov	r3, r5

000080f4 <L_1494_delayMicroseconds>:
    80f4:	3b01      	subs	r3, #1
    80f6:	d1fd      	bne.n	80f4 <L_1494_delayMicroseconds>
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
			pinMode(scl_pin, OUTPUT);
			for (int i=0; i < 9; i++) {
    80f8:	3c01      	subs	r4, #1
    80fa:	d1ef      	bne.n	80dc <TwoWire::wait_idle()+0x6c>
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    80fc:	6970      	ldr	r0, [r6, #20]
    80fe:	f896 1061 	ldrb.w	r1, [r6, #97]	; 0x61
    8102:	4401      	add	r1, r0
    8104:	f44f 72c8 	mov.w	r2, #400	; 0x190
    8108:	7a0c      	ldrb	r4, [r1, #8]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    810a:	7b4b      	ldrb	r3, [r1, #13]
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    810c:	eb09 01c4 	add.w	r1, r9, r4, lsl #3
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    8110:	021b      	lsls	r3, r3, #8
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    8112:	6849      	ldr	r1, [r1, #4]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    8114:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    8118:	f043 0364 	orr.w	r3, r3, #100	; 0x64
    811c:	600b      	str	r3, [r1, #0]
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    811e:	f896 3062 	ldrb.w	r3, [r6, #98]	; 0x62
    8122:	4403      	add	r3, r0
    8124:	7c99      	ldrb	r1, [r3, #18]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    8126:	7ddb      	ldrb	r3, [r3, #23]
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    8128:	eb09 01c1 	add.w	r1, r9, r1, lsl #3
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    812c:	021b      	lsls	r3, r3, #8
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    812e:	6849      	ldr	r1, [r1, #4]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    8130:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    8134:	f043 0364 	orr.w	r3, r3, #100	; 0x64
    8138:	600b      	str	r3, [r1, #0]

0000813a <L_1545_delayMicroseconds>:
    813a:	3a01      	subs	r2, #1
    813c:	d1fd      	bne.n	813a <L_1545_delayMicroseconds>
    813e:	6932      	ldr	r2, [r6, #16]
	uint8_t i2c_status(void) {
		return port().S;
    8140:	78d3      	ldrb	r3, [r2, #3]
{
	bool reset=false;
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    8142:	069b      	lsls	r3, r3, #26
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
#if 1
		if (waited > 15 && !reset) {
			reset = true;
    8144:	f04f 0101 	mov.w	r1, #1
{
	bool reset=false;
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    8148:	d4a3      	bmi.n	8092 <TwoWire::wait_idle()+0x22>
			//Serial.println("abort");
			//return 4; // timeout waiting for bus
			return false;
		}
	}
	return true;
    814a:	2001      	movs	r0, #1
}
    814c:	b002      	add	sp, #8
    814e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8152:	bf00      	nop
    8154:	200045ec 	.word	0x200045ec
    8158:	000123c8 	.word	0x000123c8

0000815c <TwoWire::endTransmission(unsigned char)>:

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    815c:	b5f0      	push	{r4, r5, r6, r7, lr}
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    815e:	6903      	ldr	r3, [r0, #16]
	uint8_t i, status, ret=0;
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    8160:	2212      	movs	r2, #18
    8162:	70da      	strb	r2, [r3, #3]
    8164:	6902      	ldr	r2, [r0, #16]
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    8166:	7893      	ldrb	r3, [r2, #2]
    8168:	f003 0320 	and.w	r3, r3, #32
	}
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    816c:	b085      	sub	sp, #20
    816e:	4604      	mov	r4, r0
    8170:	460d      	mov	r5, r1
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    8172:	2b00      	cmp	r3, #0
    8174:	d05e      	beq.n	8234 <TwoWire::endTransmission(unsigned char)+0xd8>
		// we are already the bus master, so send a repeated start
		//Serial.print("rstart:");
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    8176:	23b4      	movs	r3, #180	; 0xb4
    8178:	7093      	strb	r3, [r2, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    817a:	493c      	ldr	r1, [pc, #240]	; (826c <TwoWire::endTransmission(unsigned char)+0x110>)
    817c:	6922      	ldr	r2, [r4, #16]
    817e:	680b      	ldr	r3, [r1, #0]
    8180:	9300      	str	r3, [sp, #0]
	return ret;
    8182:	9e00      	ldr	r6, [sp, #0]
    8184:	e005      	b.n	8192 <TwoWire::endTransmission(unsigned char)+0x36>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    8186:	680b      	ldr	r3, [r1, #0]
    8188:	9301      	str	r3, [sp, #4]
	return ret;
    818a:	9b01      	ldr	r3, [sp, #4]
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		//Serial.write('*') ;
		if (millis() - wait_begin > 4) {
    818c:	1b9b      	subs	r3, r3, r6
    818e:	2b04      	cmp	r3, #4
    8190:	d842      	bhi.n	8218 <TwoWire::endTransmission(unsigned char)+0xbc>
	uint8_t i2c_status(void) {
		return port().S;
    8192:	78d3      	ldrb	r3, [r2, #3]
	}
	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
    8194:	f003 0320 	and.w	r3, r3, #32
    8198:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    819c:	2b00      	cmp	r3, #0
    819e:	d0f2      	beq.n	8186 <TwoWire::endTransmission(unsigned char)+0x2a>
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
    81a0:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
    81a4:	2b00      	cmp	r3, #0
    81a6:	d031      	beq.n	820c <TwoWire::endTransmission(unsigned char)+0xb0>
    81a8:	f04f 0e00 	mov.w	lr, #0
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
    81ac:	f04f 0c02 	mov.w	ip, #2
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
		port().D = txBuffer[i];
    81b0:	eb04 030e 	add.w	r3, r4, lr
    81b4:	f893 303b 	ldrb.w	r3, [r3, #59]	; 0x3b
    81b8:	7113      	strb	r3, [r2, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    81ba:	680b      	ldr	r3, [r1, #0]
    81bc:	9303      	str	r3, [sp, #12]
	return ret;
    81be:	9f03      	ldr	r7, [sp, #12]
    81c0:	6920      	ldr	r0, [r4, #16]
    81c2:	e007      	b.n	81d4 <TwoWire::endTransmission(unsigned char)+0x78>
		//Serial.write('^');
		wait_begin = millis();
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
    81c4:	069b      	lsls	r3, r3, #26
    81c6:	d50d      	bpl.n	81e4 <TwoWire::endTransmission(unsigned char)+0x88>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    81c8:	680b      	ldr	r3, [r1, #0]
    81ca:	9302      	str	r3, [sp, #8]
	return ret;
    81cc:	9b02      	ldr	r3, [sp, #8]
			if (millis() - wait_begin > 5) {
    81ce:	1bdb      	subs	r3, r3, r7
    81d0:	2b05      	cmp	r3, #5
    81d2:	d828      	bhi.n	8226 <TwoWire::endTransmission(unsigned char)+0xca>
    81d4:	78c3      	ldrb	r3, [r0, #3]
    81d6:	b2db      	uxtb	r3, r3
		port().D = txBuffer[i];
		//Serial.write('^');
		wait_begin = millis();
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
    81d8:	f003 0202 	and.w	r2, r3, #2
    81dc:	f002 06ff 	and.w	r6, r2, #255	; 0xff
    81e0:	2a00      	cmp	r2, #0
    81e2:	d0ef      	beq.n	81c4 <TwoWire::endTransmission(unsigned char)+0x68>
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
    81e4:	f880 c003 	strb.w	ip, [r0, #3]
    81e8:	6926      	ldr	r6, [r4, #16]
    81ea:	78f3      	ldrb	r3, [r6, #3]
    81ec:	b2db      	uxtb	r3, r3
		//Serial.write('$');
		status = i2c_status();
		if ((status & I2C_S_ARBL)) {
    81ee:	06df      	lsls	r7, r3, #27
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    81f0:	4632      	mov	r2, r6
    81f2:	d42d      	bmi.n	8250 <TwoWire::endTransmission(unsigned char)+0xf4>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("endTransmission err4\n");
			ret = 4; // 4:other error
			break;
		}
		if (!(status & I2C_S_BUSY)) {
    81f4:	069f      	lsls	r7, r3, #26
    81f6:	d52b      	bpl.n	8250 <TwoWire::endTransmission(unsigned char)+0xf4>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("endTransmission err5\n");
			ret = 4; // 4:other error
			break;
		}
		if (status & I2C_S_RXAK) {
    81f8:	07db      	lsls	r3, r3, #31
    81fa:	d431      	bmi.n	8260 <TwoWire::endTransmission(unsigned char)+0x104>
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
    81fc:	f10e 0e01 	add.w	lr, lr, #1
    8200:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
    8204:	fa5f fe8e 	uxtb.w	lr, lr
    8208:	4573      	cmp	r3, lr
    820a:	d8d1      	bhi.n	81b0 <TwoWire::endTransmission(unsigned char)+0x54>
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
	uint8_t i, status, ret=0;
    820c:	2000      	movs	r0, #0
			}
			sendStop = 1;
			break;
		}
	}
	if (sendStop) {
    820e:	bb1d      	cbnz	r5, 8258 <TwoWire::endTransmission(unsigned char)+0xfc>
		// send the stop condition
		port().C1 = I2C_C1_IICEN;
		// TODO: do we wait for this somehow?
	}
	transmitting = 0;
    8210:	2300      	movs	r3, #0
    8212:	f884 305e 	strb.w	r3, [r4, #94]	; 0x5e
    8216:	e004      	b.n	8222 <TwoWire::endTransmission(unsigned char)+0xc6>
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		//Serial.write('*') ;
		if (millis() - wait_begin > 4) {
			port().C1 = 0;
    8218:	7090      	strb	r0, [r2, #2]
    821a:	6923      	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    821c:	2280      	movs	r2, #128	; 0x80
    821e:	709a      	strb	r2, [r3, #2]
			//Serial.println("abort2");
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
    8220:	2004      	movs	r0, #4
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    8222:	b005      	add	sp, #20
    8224:	bdf0      	pop	{r4, r5, r6, r7, pc}
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
    8226:	7086      	strb	r6, [r0, #2]
    8228:	6923      	ldr	r3, [r4, #16]
				port().C1 = I2C_C1_IICEN;
    822a:	2280      	movs	r2, #128	; 0x80
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
    822c:	2004      	movs	r0, #4
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
			if (!(status & I2C_S_BUSY)) break;
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
				port().C1 = I2C_C1_IICEN;
    822e:	709a      	strb	r2, [r3, #2]
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    8230:	b005      	add	sp, #20
    8232:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8234:	f003 06ff 	and.w	r6, r3, #255	; 0xff
		// we are already the bus master, so send a repeated start
		//Serial.print("rstart:");
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
    8238:	f7ff ff1a 	bl	8070 <TwoWire::wait_idle()>
    823c:	b910      	cbnz	r0, 8244 <TwoWire::endTransmission(unsigned char)+0xe8>
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
    823e:	2004      	movs	r0, #4
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    8240:	b005      	add	sp, #20
    8242:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8244:	6923      	ldr	r3, [r4, #16]
		if (!wait_idle()) {
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
    8246:	f884 605f 	strb.w	r6, [r4, #95]	; 0x5f
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    824a:	22b0      	movs	r2, #176	; 0xb0
    824c:	709a      	strb	r2, [r3, #2]
    824e:	e794      	b.n	817a <TwoWire::endTransmission(unsigned char)+0x1e>
			ret = 4; // 4:other error
			break;
		}
		if (!(status & I2C_S_BUSY)) {
			// suddenly lost control of the bus!
			port().C1 = I2C_C1_IICEN;
    8250:	2380      	movs	r3, #128	; 0x80
    8252:	70b3      	strb	r3, [r6, #2]
			//Serial.printf("endTransmission err5\n");
			ret = 4; // 4:other error
    8254:	2004      	movs	r0, #4
    8256:	e7da      	b.n	820e <TwoWire::endTransmission(unsigned char)+0xb2>
    8258:	6926      	ldr	r6, [r4, #16]
			break;
		}
	}
	if (sendStop) {
		// send the stop condition
		port().C1 = I2C_C1_IICEN;
    825a:	2380      	movs	r3, #128	; 0x80
    825c:	70b3      	strb	r3, [r6, #2]
    825e:	e7d7      	b.n	8210 <TwoWire::endTransmission(unsigned char)+0xb4>
			if (i == 0) {
				//Serial.printf("endTransmission err6\n");
				ret = 2; // 2:received NACK on transmit of address
			} else {
				//Serial.printf("endTransmission err7\n");
				ret = 3; // 3:received NACK on transmit of data 
    8260:	f1be 0f00 	cmp.w	lr, #0
    8264:	bf0c      	ite	eq
    8266:	2002      	moveq	r0, #2
    8268:	2003      	movne	r0, #3
    826a:	e7f6      	b.n	825a <TwoWire::endTransmission(unsigned char)+0xfe>
    826c:	200045ec 	.word	0x200045ec

00008270 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>:
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    8270:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8274:	6906      	ldr	r6, [r0, #16]
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
	uint32_t wait_begin;

	rxBufferIndex = 0;
    8276:	2500      	movs	r5, #0
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    8278:	2712      	movs	r7, #18
{
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
	uint32_t wait_begin;

	rxBufferIndex = 0;
    827a:	f880 5038 	strb.w	r5, [r0, #56]	; 0x38
	rxBufferLength = 0;
    827e:	f880 5039 	strb.w	r5, [r0, #57]	; 0x39
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    8282:	70f7      	strb	r7, [r6, #3]
    8284:	f8d0 c010 	ldr.w	ip, [r0, #16]
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    8288:	f89c e002 	ldrb.w	lr, [ip, #2]
    828c:	f00e 0e20 	and.w	lr, lr, #32
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    8290:	b088      	sub	sp, #32
    8292:	4604      	mov	r4, r0
    8294:	4688      	mov	r8, r1
    8296:	4615      	mov	r5, r2
    8298:	461e      	mov	r6, r3
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    829a:	f1be 0f00 	cmp.w	lr, #0
    829e:	d049      	beq.n	8334 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xc4>
		// we are already the bus master, so send a repeated start
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    82a0:	23b4      	movs	r3, #180	; 0xb4
    82a2:	f88c 3002 	strb.w	r3, [ip, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    82a6:	4b78      	ldr	r3, [pc, #480]	; (8488 <L_3073_delayMicroseconds+0x1a>)
    82a8:	6921      	ldr	r1, [r4, #16]
    82aa:	681a      	ldr	r2, [r3, #0]
    82ac:	9200      	str	r2, [sp, #0]
	return ret;
    82ae:	f8dd e000 	ldr.w	lr, [sp]
    82b2:	e006      	b.n	82c2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x52>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    82b4:	681a      	ldr	r2, [r3, #0]
    82b6:	9201      	str	r2, [sp, #4]
	return ret;
    82b8:	9801      	ldr	r0, [sp, #4]
	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		if (millis() - wait_begin > 4) {
    82ba:	ebce 0000 	rsb	r0, lr, r0
    82be:	2804      	cmp	r0, #4
    82c0:	d830      	bhi.n	8324 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xb4>
	uint8_t i2c_status(void) {
		return port().S;
    82c2:	78c8      	ldrb	r0, [r1, #3]
    82c4:	f000 0020 	and.w	r0, r0, #32

	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
    82c8:	f000 07ff 	and.w	r7, r0, #255	; 0xff
    82cc:	2800      	cmp	r0, #0
    82ce:	d0f1      	beq.n	82b4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x44>
			//Serial.printf("requestFrom err2\n");
			return 0; // error generating start condition
		}
	}
	// send the address
	port().D = (address << 1) | 1;
    82d0:	ea4f 0248 	mov.w	r2, r8, lsl #1
    82d4:	f042 0201 	orr.w	r2, r2, #1
    82d8:	b2d2      	uxtb	r2, r2
    82da:	710a      	strb	r2, [r1, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    82dc:	681a      	ldr	r2, [r3, #0]
    82de:	9202      	str	r2, [sp, #8]
	return ret;
    82e0:	f8dd e008 	ldr.w	lr, [sp, #8]
    82e4:	6920      	ldr	r0, [r4, #16]
    82e6:	e006      	b.n	82f6 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x86>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    82e8:	681a      	ldr	r2, [r3, #0]
    82ea:	9203      	str	r2, [sp, #12]
	return ret;
    82ec:	9903      	ldr	r1, [sp, #12]
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
    82ee:	ebce 0101 	rsb	r1, lr, r1
    82f2:	2905      	cmp	r1, #5
    82f4:	d82a      	bhi.n	834c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xdc>
		}
	}
	// send the address
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
    82f6:	78c1      	ldrb	r1, [r0, #3]
    82f8:	f001 0102 	and.w	r1, r1, #2
    82fc:	f001 07ff 	and.w	r7, r1, #255	; 0xff
    8300:	2900      	cmp	r1, #0
    8302:	d0f1      	beq.n	82e8 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x78>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("requestFrom err3\n");
			return 0; // clock stretch too long (during address)
		}
	}
	port().S = I2C_S_IICIF;
    8304:	f04f 0c02 	mov.w	ip, #2
    8308:	f880 c003 	strb.w	ip, [r0, #3]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    830c:	6922      	ldr	r2, [r4, #16]
	uint8_t i2c_status(void) {
		return port().S;
    830e:	78d1      	ldrb	r1, [r2, #3]
	status = i2c_status();
	if ((status & I2C_S_RXAK) || (status & I2C_S_ARBL)) {
    8310:	f011 0711 	ands.w	r7, r1, #17
    8314:	d122      	bne.n	835c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xec>
		// or we lost bus arbitration to another master
		port().C1 = I2C_C1_IICEN;
		//Serial.printf("requestFrom err4\n");
		return 0;
	}
	if (length == 0) {
    8316:	bb2d      	cbnz	r5, 8364 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf4>
		// TODO: does anybody really do zero length reads?
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
    8318:	2e00      	cmp	r6, #0
    831a:	bf0c      	ite	eq
    831c:	23a0      	moveq	r3, #160	; 0xa0
    831e:	2380      	movne	r3, #128	; 0x80
    8320:	7093      	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err5\n");
		return 0;
    8322:	e003      	b.n	832c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		if (millis() - wait_begin > 4) {
			port().C1 = 0;
    8324:	708f      	strb	r7, [r1, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    8326:	6923      	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    8328:	2280      	movs	r2, #128	; 0x80
    832a:	709a      	strb	r2, [r3, #2]
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
	rxBufferLength = count;
	return count;
}
    832c:	4638      	mov	r0, r7
    832e:	b008      	add	sp, #32
    8330:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8334:	f00e 07ff 	and.w	r7, lr, #255	; 0xff
	if (port().C1 & I2C_C1_MST) {
		// we are already the bus master, so send a repeated start
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
    8338:	f7ff fe9a 	bl	8070 <TwoWire::wait_idle()>
    833c:	2800      	cmp	r0, #0
    833e:	d0f5      	beq.n	832c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
    8340:	6923      	ldr	r3, [r4, #16]
			//Serial.printf("requestFrom err1\n");
			return 0; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
    8342:	f884 705f 	strb.w	r7, [r4, #95]	; 0x5f
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    8346:	22b0      	movs	r2, #176	; 0xb0
    8348:	709a      	strb	r2, [r3, #2]
    834a:	e7ac      	b.n	82a6 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x36>
	// send the address
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
    834c:	7087      	strb	r7, [r0, #2]
    834e:	6923      	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    8350:	2280      	movs	r2, #128	; 0x80
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
	rxBufferLength = count;
	return count;
}
    8352:	4638      	mov	r0, r7
	port().D = (address << 1) | 1;
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
    8354:	709a      	strb	r2, [r3, #2]
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
	rxBufferLength = count;
	return count;
}
    8356:	b008      	add	sp, #32
    8358:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	port().S = I2C_S_IICIF;
	status = i2c_status();
	if ((status & I2C_S_RXAK) || (status & I2C_S_ARBL)) {
		// the slave device did not acknowledge
		// or we lost bus arbitration to another master
		port().C1 = I2C_C1_IICEN;
    835c:	2380      	movs	r3, #128	; 0x80
    835e:	7093      	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err4\n");
		return 0;
    8360:	2700      	movs	r7, #0
    8362:	e7e3      	b.n	832c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
		// TODO: does anybody really do zero length reads?
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
		//Serial.printf("requestFrom err5\n");
		return 0;
	} else if (length == 1) {
    8364:	2d01      	cmp	r5, #1
    8366:	d075      	beq.n	8454 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1e4>
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
    8368:	21a0      	movs	r1, #160	; 0xa0
    836a:	7091      	strb	r1, [r2, #2]
    836c:	6921      	ldr	r1, [r4, #16]
	}
	tmp = port().D; // initiate the first receive
    836e:	790a      	ldrb	r2, [r1, #4]
    8370:	46be      	mov	lr, r7
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
    8372:	4667      	mov	r7, ip
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    8374:	f04f 0ca8 	mov.w	ip, #168	; 0xa8
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    8378:	681a      	ldr	r2, [r3, #0]
    837a:	9204      	str	r2, [sp, #16]
	return ret;
    837c:	9804      	ldr	r0, [sp, #16]
    837e:	e005      	b.n	838c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x11c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    8380:	681a      	ldr	r2, [r3, #0]
    8382:	9205      	str	r2, [sp, #20]
	return ret;
    8384:	9a05      	ldr	r2, [sp, #20]
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
			if (millis() - wait_begin > 5) {
    8386:	1a12      	subs	r2, r2, r0
    8388:	2a05      	cmp	r2, #5
    838a:	d84a      	bhi.n	8422 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1b2>
	}
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
    838c:	78ca      	ldrb	r2, [r1, #3]
    838e:	f002 0202 	and.w	r2, r2, #2
    8392:	f002 08ff 	and.w	r8, r2, #255	; 0xff
    8396:	2a00      	cmp	r2, #0
    8398:	d0f2      	beq.n	8380 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x110>
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
    839a:	70cf      	strb	r7, [r1, #3]
    839c:	6921      	ldr	r1, [r4, #16]
		status = port().S;
    839e:	78ca      	ldrb	r2, [r1, #3]
    83a0:	b2d2      	uxtb	r2, r2
		if ((status & I2C_S_ARBL)) {
    83a2:	f012 0f10 	tst.w	r2, #16
    83a6:	4608      	mov	r0, r1
    83a8:	d15a      	bne.n	8460 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f0>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7a\n");
			return count;
		}
		if (!(status & I2C_S_BUSY)) {
    83aa:	0692      	lsls	r2, r2, #26
    83ac:	d558      	bpl.n	8460 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f0>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
    83ae:	3d01      	subs	r5, #1
    83b0:	b2ed      	uxtb	r5, r5
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    83b2:	2d01      	cmp	r5, #1
    83b4:	d049      	beq.n	844a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1da>
		if (count < BUFFER_LENGTH) {
    83b6:	f1be 0f1f 	cmp.w	lr, #31
    83ba:	d93b      	bls.n	8434 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1c4>
			rxBuffer[count++] = port().D;
		} else {
			tmp = port().D;
    83bc:	790a      	ldrb	r2, [r1, #4]
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
	}
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
    83be:	2d01      	cmp	r5, #1
    83c0:	d1da      	bne.n	8378 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x108>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    83c2:	681a      	ldr	r2, [r3, #0]
    83c4:	9206      	str	r2, [sp, #24]
	return ret;
    83c6:	9d06      	ldr	r5, [sp, #24]
    83c8:	e005      	b.n	83d6 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x166>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    83ca:	681a      	ldr	r2, [r3, #0]
    83cc:	9207      	str	r2, [sp, #28]
	return ret;
    83ce:	9a07      	ldr	r2, [sp, #28]
			tmp = port().D;
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
    83d0:	1b52      	subs	r2, r2, r5
    83d2:	2a05      	cmp	r2, #5
    83d4:	d846      	bhi.n	8464 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f4>
		} else {
			tmp = port().D;
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
    83d6:	78c2      	ldrb	r2, [r0, #3]
    83d8:	f002 0202 	and.w	r2, r2, #2
    83dc:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    83e0:	2a00      	cmp	r2, #0
    83e2:	d0f2      	beq.n	83ca <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x15a>
			rxBufferLength = count;
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
		}
	}
	port().S = I2C_S_IICIF;
    83e4:	2302      	movs	r3, #2
    83e6:	70c3      	strb	r3, [r0, #3]
    83e8:	6922      	ldr	r2, [r4, #16]
	status = port().S;
    83ea:	78d3      	ldrb	r3, [r2, #3]
    83ec:	b2db      	uxtb	r3, r3
	if ((status & I2C_S_ARBL)) {
    83ee:	06d9      	lsls	r1, r3, #27
    83f0:	d43a      	bmi.n	8468 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f8>
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
		//Serial.printf("requestFrom err9a\n");
		return count;
	}
	if (!(status & I2C_S_BUSY)) {
    83f2:	069b      	lsls	r3, r3, #26
    83f4:	d534      	bpl.n	8460 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1f0>
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    83f6:	23b0      	movs	r3, #176	; 0xb0
	if (count < BUFFER_LENGTH) {
    83f8:	f1be 0f1f 	cmp.w	lr, #31
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    83fc:	7093      	strb	r3, [r2, #2]
	if (count < BUFFER_LENGTH) {
    83fe:	d83f      	bhi.n	8480 <L_3073_delayMicroseconds+0x12>
    8400:	6922      	ldr	r2, [r4, #16]
		rxBuffer[count++] = port().D;
    8402:	eb04 030e 	add.w	r3, r4, lr
    8406:	7912      	ldrb	r2, [r2, #4]
    8408:	761a      	strb	r2, [r3, #24]
    840a:	f10e 0e01 	add.w	lr, lr, #1
    840e:	fa5f fe8e 	uxtb.w	lr, lr
#if F_CPU > 120000000
	__asm__("nop");
	__asm__("nop");
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
    8412:	b116      	cbz	r6, 841a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1aa>
    8414:	6923      	ldr	r3, [r4, #16]
    8416:	2280      	movs	r2, #128	; 0x80
    8418:	709a      	strb	r2, [r3, #2]
	rxBufferLength = count;
    841a:	f884 e039 	strb.w	lr, [r4, #57]	; 0x39
	return count;
    841e:	4677      	mov	r7, lr
    8420:	e784      	b.n	832c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
	//delayMicroseconds(250);
	while (length > 1) {
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
			if (millis() - wait_begin > 5) {
				port().C1 = 0;
    8422:	f881 8002 	strb.w	r8, [r1, #2]
    8426:	6923      	ldr	r3, [r4, #16]
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
    8428:	2280      	movs	r2, #128	; 0x80
    842a:	709a      	strb	r2, [r3, #2]
			rxBufferLength = count;
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
    842c:	4677      	mov	r7, lr
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
			port().C1 = I2C_C1_IICEN;
			rxBufferLength = count;
    842e:	f884 e039 	strb.w	lr, [r4, #57]	; 0x39
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
    8432:	e77b      	b.n	832c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
		if (count < BUFFER_LENGTH) {
			rxBuffer[count++] = port().D;
    8434:	eb04 020e 	add.w	r2, r4, lr
    8438:	f891 8004 	ldrb.w	r8, [r1, #4]
    843c:	f882 8018 	strb.w	r8, [r2, #24]
    8440:	f10e 0e01 	add.w	lr, lr, #1
    8444:	fa5f fe8e 	uxtb.w	lr, lr
    8448:	e7b9      	b.n	83be <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x14e>
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    844a:	f881 c002 	strb.w	ip, [r1, #2]
    844e:	6921      	ldr	r1, [r4, #16]
    8450:	4608      	mov	r0, r1
    8452:	e7b0      	b.n	83b6 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x146>
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
		//Serial.printf("requestFrom err5\n");
		return 0;
	} else if (length == 1) {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    8454:	21a8      	movs	r1, #168	; 0xa8
    8456:	7091      	strb	r1, [r2, #2]
    8458:	6920      	ldr	r0, [r4, #16]


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
    845a:	46be      	mov	lr, r7
	} else if (length == 1) {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
	}
	tmp = port().D; // initiate the first receive
    845c:	7902      	ldrb	r2, [r0, #4]
    845e:	e7b0      	b.n	83c2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x152>
    8460:	4677      	mov	r7, lr
    8462:	e763      	b.n	832c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
		if (millis() - wait_begin > 5) {
			port().C1 = 0;
    8464:	7081      	strb	r1, [r0, #2]
    8466:	e7de      	b.n	8426 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1b6>
	if ((status & I2C_S_ARBL)) {
		// we lost bus arbitration to another master
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//digitalWriteFast(13, HIGH);
		port().S = I2C_S_ARBL;
    8468:	2110      	movs	r1, #16
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    846a:	23c8      	movs	r3, #200	; 0xc8
    846c:	70d1      	strb	r1, [r2, #3]

0000846e <L_3073_delayMicroseconds>:
    846e:	3b01      	subs	r3, #1
    8470:	d1fd      	bne.n	846e <L_3073_delayMicroseconds>
    8472:	6922      	ldr	r2, [r4, #16]
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
    8474:	7893      	ldrb	r3, [r2, #2]
    8476:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		//Serial.printf("requestFrom err9a\n");
		return count;
    847a:	4677      	mov	r7, lr
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//digitalWriteFast(13, HIGH);
		port().S = I2C_S_ARBL;
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
    847c:	7093      	strb	r3, [r2, #2]
		//Serial.printf("requestFrom err9a\n");
		return count;
    847e:	e755      	b.n	832c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xbc>
    8480:	6923      	ldr	r3, [r4, #16]
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
	if (count < BUFFER_LENGTH) {
		rxBuffer[count++] = port().D;
	} else {
		tmp = port().D;
    8482:	791b      	ldrb	r3, [r3, #4]
    8484:	e7c5      	b.n	8412 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x1a2>
    8486:	bf00      	nop
    8488:	200045ec 	.word	0x200045ec

0000848c <i2c0_isr>:
#define MAKE_CONST(x) (__builtin_constant_p(x) ? (x) : (x))

#ifdef WIRE_IMPLEMENT_WIRE
constexpr uintptr_t i2c0_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C0));
TwoWire Wire(i2c0_addr, TwoWire::i2c0_hardware);
void i2c0_isr(void) { Wire.isr(); }
    848c:	4801      	ldr	r0, [pc, #4]	; (8494 <i2c0_isr+0x8>)
    848e:	f7ff bd1f 	b.w	7ed0 <TwoWire::isr()>
    8492:	bf00      	nop
    8494:	1fffb924 	.word	0x1fffb924

00008498 <i2c1_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE1
constexpr uintptr_t i2c1_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C1));
TwoWire Wire1(i2c1_addr, TwoWire::i2c1_hardware);
void i2c1_isr(void) { Wire1.isr(); }
    8498:	4801      	ldr	r0, [pc, #4]	; (84a0 <i2c1_isr+0x8>)
    849a:	f7ff bd19 	b.w	7ed0 <TwoWire::isr()>
    849e:	bf00      	nop
    84a0:	1fffb990 	.word	0x1fffb990

000084a4 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, unsigned short, unsigned char, unsigned char, unsigned char)>:
 *    @param  reg_addr The address pointer value for the I2C/SMBus register, can be 8 or 16 bits
 *    @param  width    The width of the register data itself, defaults to 1 byte
 *    @param  bitorder The bit order of the register (used when width is > 1), defaults to LSBFIRST
 *    @param  address_width The width of the register address itself, defaults to 1 byte
 */
Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice *i2cdevice, uint16_t reg_addr, 
    84a4:	b4f0      	push	{r4, r5, r6, r7}
						 uint8_t width, uint8_t bitorder, uint8_t address_width) {
  _i2cdevice = i2cdevice;
  _spidevice = NULL;
    84a6:	2700      	movs	r7, #0
 *    @param  reg_addr The address pointer value for the I2C/SMBus register, can be 8 or 16 bits
 *    @param  width    The width of the register data itself, defaults to 1 byte
 *    @param  bitorder The bit order of the register (used when width is > 1), defaults to LSBFIRST
 *    @param  address_width The width of the register address itself, defaults to 1 byte
 */
Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice *i2cdevice, uint16_t reg_addr, 
    84a8:	f89d 6014 	ldrb.w	r6, [sp, #20]
    84ac:	f89d 5010 	ldrb.w	r5, [sp, #16]
						 uint8_t width, uint8_t bitorder, uint8_t address_width) {
  _i2cdevice = i2cdevice;
  _spidevice = NULL;
    84b0:	6047      	str	r7, [r0, #4]
  _addrwidth = address_width;
    84b2:	7346      	strb	r6, [r0, #13]
  _address = reg_addr;
  _bitorder = bitorder;
    84b4:	7385      	strb	r5, [r0, #14]
 *    @param  bitorder The bit order of the register (used when width is > 1), defaults to LSBFIRST
 *    @param  address_width The width of the register address itself, defaults to 1 byte
 */
Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice *i2cdevice, uint16_t reg_addr, 
						 uint8_t width, uint8_t bitorder, uint8_t address_width) {
  _i2cdevice = i2cdevice;
    84b6:	6001      	str	r1, [r0, #0]
  _spidevice = NULL;
  _addrwidth = address_width;
  _address = reg_addr;
    84b8:	8142      	strh	r2, [r0, #10]
  _bitorder = bitorder;
  _width = width;
    84ba:	7303      	strb	r3, [r0, #12]
}
    84bc:	bcf0      	pop	{r4, r5, r6, r7}
    84be:	4770      	bx	lr

000084c0 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)>:
 *    @brief  Write a buffer of data to the register location
 *    @param  buffer Pointer to data to write
 *    @param  len Number of bytes to write
 *    @return True on successful write (only really useful for I2C as SPI is uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint8_t *buffer, uint8_t len) {
    84c0:	b5f0      	push	{r4, r5, r6, r7, lr}

  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF), (uint8_t)(_address>>8)};
    84c2:	8943      	ldrh	r3, [r0, #10]

  if (_i2cdevice) {
    84c4:	6804      	ldr	r4, [r0, #0]
 *    @brief  Write a buffer of data to the register location
 *    @param  buffer Pointer to data to write
 *    @param  len Number of bytes to write
 *    @return True on successful write (only really useful for I2C as SPI is uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint8_t *buffer, uint8_t len) {
    84c6:	b085      	sub	sp, #20

  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF), (uint8_t)(_address>>8)};
    84c8:	b2dd      	uxtb	r5, r3
    84ca:	121b      	asrs	r3, r3, #8
    84cc:	f88d 500c 	strb.w	r5, [sp, #12]
    84d0:	f88d 300d 	strb.w	r3, [sp, #13]

  if (_i2cdevice) {
    84d4:	b14c      	cbz	r4, 84ea <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x2a>
    return _i2cdevice->write(buffer, len, true, addrbuffer, _addrwidth);
    84d6:	7b43      	ldrb	r3, [r0, #13]
    84d8:	9301      	str	r3, [sp, #4]
    84da:	ab03      	add	r3, sp, #12
    84dc:	9300      	str	r3, [sp, #0]
    84de:	4620      	mov	r0, r4
    84e0:	2301      	movs	r3, #1
    84e2:	f000 f903 	bl	86ec <Adafruit_I2CDevice::write(unsigned char*, unsigned int, bool, unsigned char*, unsigned int)>
      addrbuffer[0] &= ~0x80;
    }
    return _spidevice->write( buffer, len, addrbuffer, _addrwidth);
  }
  return false;
}
    84e6:	b005      	add	sp, #20
    84e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF), (uint8_t)(_address>>8)};

  if (_i2cdevice) {
    return _i2cdevice->write(buffer, len, true, addrbuffer, _addrwidth);
  }
  if (_spidevice) {
    84ea:	6843      	ldr	r3, [r0, #4]
    84ec:	b18b      	cbz	r3, 8512 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x52>
    84ee:	4617      	mov	r7, r2
    if (_spiregtype == ADDRBIT8_HIGH_TOREAD) {
    84f0:	7a02      	ldrb	r2, [r0, #8]
    84f2:	460e      	mov	r6, r1
    84f4:	b91a      	cbnz	r2, 84fe <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x3e>
      addrbuffer[0] &= ~0x80;
    84f6:	f005 057f 	and.w	r5, r5, #127	; 0x7f
    84fa:	f88d 500c 	strb.w	r5, [sp, #12]
    }
    return _spidevice->write( buffer, len, addrbuffer, _addrwidth);
    84fe:	7b42      	ldrb	r2, [r0, #13]
    8500:	9200      	str	r2, [sp, #0]
    8502:	4631      	mov	r1, r6
    8504:	463a      	mov	r2, r7
    8506:	4618      	mov	r0, r3
    8508:	ab03      	add	r3, sp, #12
    850a:	f000 fa1b 	bl	8944 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)>
  }
  return false;
}
    850e:	b005      	add	sp, #20
    8510:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (_spiregtype == ADDRBIT8_HIGH_TOREAD) {
      addrbuffer[0] &= ~0x80;
    }
    return _spidevice->write( buffer, len, addrbuffer, _addrwidth);
  }
  return false;
    8512:	4618      	mov	r0, r3
    8514:	e7e7      	b.n	84e6 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x26>
    8516:	bf00      	nop

00008518 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)>:
 *    @param  value Data to write
 *    @param  numbytes How many bytes from 'value' to write
 *    @return True on successful write (only really useful for I2C as SPI is uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint32_t value, uint8_t numbytes) {
  if (numbytes == 0) {
    8518:	b902      	cbnz	r2, 851c <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x4>
    numbytes = _width;
    851a:	7b02      	ldrb	r2, [r0, #12]
  }
  if (numbytes > 4) {
    851c:	2a04      	cmp	r2, #4
    851e:	d819      	bhi.n	8554 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x3c>
 *    @brief  Write up to 4 bytes of data to the register location
 *    @param  value Data to write
 *    @param  numbytes How many bytes from 'value' to write
 *    @return True on successful write (only really useful for I2C as SPI is uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint32_t value, uint8_t numbytes) {
    8520:	b4f0      	push	{r4, r5, r6, r7}
    8522:	f100 070f 	add.w	r7, r0, #15
  }
  if (numbytes > 4) {
    return false;
  }

  for (int i=0; i<numbytes; i++) {
    8526:	b17a      	cbz	r2, 8548 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x30>
    8528:	f102 030e 	add.w	r3, r2, #14
    852c:	7b86      	ldrb	r6, [r0, #14]
    852e:	463c      	mov	r4, r7
    8530:	4403      	add	r3, r0
    8532:	f100 050e 	add.w	r5, r0, #14
    if (_bitorder == LSBFIRST) {
    8536:	b95e      	cbnz	r6, 8550 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x38>
      _buffer[i] = value & 0xFF;
    8538:	7021      	strb	r1, [r4, #0]
    853a:	3b01      	subs	r3, #1
  }
  if (numbytes > 4) {
    return false;
  }

  for (int i=0; i<numbytes; i++) {
    853c:	42ab      	cmp	r3, r5
    if (_bitorder == LSBFIRST) {
      _buffer[i] = value & 0xFF;
    } else {
      _buffer[numbytes-i-1] = value & 0xFF;
    }
    value >>= 8;
    853e:	ea4f 2111 	mov.w	r1, r1, lsr #8
    8542:	f104 0401 	add.w	r4, r4, #1
  }
  if (numbytes > 4) {
    return false;
  }

  for (int i=0; i<numbytes; i++) {
    8546:	d1f6      	bne.n	8536 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x1e>
    } else {
      _buffer[numbytes-i-1] = value & 0xFF;
    }
    value >>= 8;
  }
  return write(_buffer, numbytes);
    8548:	4639      	mov	r1, r7
}
    854a:	bcf0      	pop	{r4, r5, r6, r7}
    } else {
      _buffer[numbytes-i-1] = value & 0xFF;
    }
    value >>= 8;
  }
  return write(_buffer, numbytes);
    854c:	f7ff bfb8 	b.w	84c0 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)>

  for (int i=0; i<numbytes; i++) {
    if (_bitorder == LSBFIRST) {
      _buffer[i] = value & 0xFF;
    } else {
      _buffer[numbytes-i-1] = value & 0xFF;
    8550:	7019      	strb	r1, [r3, #0]
    8552:	e7f2      	b.n	853a <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x22>
    }
    value >>= 8;
  }
  return write(_buffer, numbytes);
}
    8554:	2000      	movs	r0, #0
    8556:	4770      	bx	lr

00008558 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>:
 *    @brief  Read a buffer of data from the register location
 *    @param  buffer Pointer to data to read into
 *    @param  len Number of bytes to read
 *    @return True on successful write (only really useful for I2C as SPI is uncheckable)
 */
bool Adafruit_BusIO_Register::read(uint8_t *buffer, uint8_t len) {
    8558:	b570      	push	{r4, r5, r6, lr}
  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF), (uint8_t)(_address>>8)};
    855a:	8944      	ldrh	r4, [r0, #10]

  if (_i2cdevice) {
    855c:	6805      	ldr	r5, [r0, #0]
 *    @brief  Read a buffer of data from the register location
 *    @param  buffer Pointer to data to read into
 *    @param  len Number of bytes to read
 *    @return True on successful write (only really useful for I2C as SPI is uncheckable)
 */
bool Adafruit_BusIO_Register::read(uint8_t *buffer, uint8_t len) {
    855e:	b084      	sub	sp, #16
  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF), (uint8_t)(_address>>8)};
    8560:	b2e6      	uxtb	r6, r4
    8562:	1224      	asrs	r4, r4, #8
    8564:	f88d 600c 	strb.w	r6, [sp, #12]
    8568:	f88d 400d 	strb.w	r4, [sp, #13]

  if (_i2cdevice) {
    856c:	b15d      	cbz	r5, 8586 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x2e>
    return _i2cdevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
    856e:	7b43      	ldrb	r3, [r0, #13]
    8570:	9200      	str	r2, [sp, #0]
    8572:	2400      	movs	r4, #0
    8574:	461a      	mov	r2, r3
    8576:	4628      	mov	r0, r5
    8578:	460b      	mov	r3, r1
    857a:	9401      	str	r4, [sp, #4]
    857c:	a903      	add	r1, sp, #12
    857e:	f000 f925 	bl	87cc <Adafruit_I2CDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, bool)>
      addrbuffer[0] |= 0x80;
    }
    return _spidevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
  }
  return false;
}
    8582:	b004      	add	sp, #16
    8584:	bd70      	pop	{r4, r5, r6, pc}
  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF), (uint8_t)(_address>>8)};

  if (_i2cdevice) {
    return _i2cdevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
  }
  if (_spidevice) {
    8586:	6844      	ldr	r4, [r0, #4]
    8588:	b18c      	cbz	r4, 85ae <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x56>
    if (_spiregtype == ADDRBIT8_HIGH_TOREAD) {
    858a:	7a03      	ldrb	r3, [r0, #8]
    858c:	b91b      	cbnz	r3, 8596 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x3e>
      addrbuffer[0] |= 0x80;
    858e:	f066 067f 	orn	r6, r6, #127	; 0x7f
    8592:	f88d 600c 	strb.w	r6, [sp, #12]
    }
    return _spidevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
    8596:	7b43      	ldrb	r3, [r0, #13]
    8598:	9200      	str	r2, [sp, #0]
    859a:	25ff      	movs	r5, #255	; 0xff
    859c:	461a      	mov	r2, r3
    859e:	4620      	mov	r0, r4
    85a0:	460b      	mov	r3, r1
    85a2:	9501      	str	r5, [sp, #4]
    85a4:	a903      	add	r1, sp, #12
    85a6:	f000 fa63 	bl	8a70 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)>
  }
  return false;
}
    85aa:	b004      	add	sp, #16
    85ac:	bd70      	pop	{r4, r5, r6, pc}
    if (_spiregtype == ADDRBIT8_HIGH_TOREAD) {
      addrbuffer[0] |= 0x80;
    }
    return _spidevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
  }
  return false;
    85ae:	4620      	mov	r0, r4
    85b0:	e7e7      	b.n	8582 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x2a>
    85b2:	bf00      	nop

000085b4 <Adafruit_BusIO_Register::read()>:

/*!
 *    @brief  Read data from the register location. This does not do any error checking! 
 *    @return Returns 0xFFFFFFFF on failure, value otherwise
 */
uint32_t Adafruit_BusIO_Register::read(void) {
    85b4:	b538      	push	{r3, r4, r5, lr}
  if (! read(_buffer, _width)) {
    85b6:	f100 040f 	add.w	r4, r0, #15
    85ba:	4621      	mov	r1, r4
    85bc:	7b02      	ldrb	r2, [r0, #12]

/*!
 *    @brief  Read data from the register location. This does not do any error checking! 
 *    @return Returns 0xFFFFFFFF on failure, value otherwise
 */
uint32_t Adafruit_BusIO_Register::read(void) {
    85be:	4605      	mov	r5, r0
  if (! read(_buffer, _width)) {
    85c0:	f7ff ffca 	bl	8558 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
    85c4:	b910      	cbnz	r0, 85cc <Adafruit_BusIO_Register::read()+0x18>
    return -1;
    85c6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
       value |= _buffer[i];
     }
   }

   return value;
}
    85ca:	bd38      	pop	{r3, r4, r5, pc}
    return -1;
  }

  uint32_t value = 0;

   for (int i=0; i < _width; i++) {
    85cc:	7b28      	ldrb	r0, [r5, #12]
    85ce:	2800      	cmp	r0, #0
    85d0:	d0fb      	beq.n	85ca <Adafruit_BusIO_Register::read()+0x16>
    85d2:	300e      	adds	r0, #14
    85d4:	182b      	adds	r3, r5, r0
    85d6:	7baa      	ldrb	r2, [r5, #14]
    85d8:	4621      	mov	r1, r4
    85da:	350e      	adds	r5, #14
    85dc:	2000      	movs	r0, #0
    85de:	e007      	b.n	85f0 <Adafruit_BusIO_Register::read()+0x3c>
     value <<= 8;
     if (_bitorder == LSBFIRST) {
       value |= _buffer[_width-i-1];
    85e0:	781c      	ldrb	r4, [r3, #0]
    85e2:	3b01      	subs	r3, #1
    return -1;
  }

  uint32_t value = 0;

   for (int i=0; i < _width; i++) {
    85e4:	42ab      	cmp	r3, r5
     value <<= 8;
     if (_bitorder == LSBFIRST) {
       value |= _buffer[_width-i-1];
    85e6:	ea40 0004 	orr.w	r0, r0, r4
    85ea:	f101 0101 	add.w	r1, r1, #1
    return -1;
  }

  uint32_t value = 0;

   for (int i=0; i < _width; i++) {
    85ee:	d00a      	beq.n	8606 <Adafruit_BusIO_Register::read()+0x52>
     value <<= 8;
    85f0:	0200      	lsls	r0, r0, #8
     if (_bitorder == LSBFIRST) {
    85f2:	2a00      	cmp	r2, #0
    85f4:	d0f4      	beq.n	85e0 <Adafruit_BusIO_Register::read()+0x2c>
       value |= _buffer[_width-i-1];
     } else {
       value |= _buffer[i];
    85f6:	780c      	ldrb	r4, [r1, #0]
    85f8:	3b01      	subs	r3, #1
    return -1;
  }

  uint32_t value = 0;

   for (int i=0; i < _width; i++) {
    85fa:	42ab      	cmp	r3, r5
     value <<= 8;
     if (_bitorder == LSBFIRST) {
       value |= _buffer[_width-i-1];
     } else {
       value |= _buffer[i];
    85fc:	ea40 0004 	orr.w	r0, r0, r4
    8600:	f101 0101 	add.w	r1, r1, #1
    return -1;
  }

  uint32_t value = 0;

   for (int i=0; i < _width; i++) {
    8604:	d1f4      	bne.n	85f0 <Adafruit_BusIO_Register::read()+0x3c>
    8606:	bd38      	pop	{r3, r4, r5, pc}

00008608 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>:
 *    @brief  Create a slice of the register that we can address without touching other bits
 *    @param  reg The Adafruit_BusIO_Register which defines the bus/register
 *    @param  bits The number of bits wide we are slicing
 *    @param  shift The number of bits that our bit-slice is shifted from LSB
 */
Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register *reg, uint8_t bits, uint8_t shift) {
    8608:	b410      	push	{r4}
  _register = reg;
    860a:	6001      	str	r1, [r0, #0]
  _bits = bits;
    860c:	7102      	strb	r2, [r0, #4]
  _shift = shift;
    860e:	7143      	strb	r3, [r0, #5]
}
    8610:	bc10      	pop	{r4}
    8612:	4770      	bx	lr

00008614 <Adafruit_BusIO_RegisterBits::read()>:

/*!
 *    @brief  Read 4 bytes of data from the register
 *    @return  data The 4 bytes to read
 */
uint32_t Adafruit_BusIO_RegisterBits::read(void) {
    8614:	b510      	push	{r4, lr}
    8616:	4604      	mov	r4, r0
  uint32_t val = _register->read();
    8618:	6800      	ldr	r0, [r0, #0]
    861a:	f7ff ffcb 	bl	85b4 <Adafruit_BusIO_Register::read()>
  val >>= _shift;
  return val & ((1 << (_bits+1)) - 1);
    861e:	7923      	ldrb	r3, [r4, #4]
    8620:	7962      	ldrb	r2, [r4, #5]
    8622:	1c59      	adds	r1, r3, #1
    8624:	2301      	movs	r3, #1
    8626:	408b      	lsls	r3, r1
    8628:	40d0      	lsrs	r0, r2
    862a:	3b01      	subs	r3, #1
}
    862c:	4018      	ands	r0, r3
    862e:	bd10      	pop	{r4, pc}

00008630 <Adafruit_BusIO_RegisterBits::write(unsigned long)>:

/*!
 *    @brief  Write 4 bytes of data to the register
 *    @param  data The 4 bytes to write
 */
void Adafruit_BusIO_RegisterBits::write(uint32_t data) {
    8630:	b538      	push	{r3, r4, r5, lr}
    8632:	4605      	mov	r5, r0
  uint32_t val = _register->read();
    8634:	6800      	ldr	r0, [r0, #0]

/*!
 *    @brief  Write 4 bytes of data to the register
 *    @param  data The 4 bytes to write
 */
void Adafruit_BusIO_RegisterBits::write(uint32_t data) {
    8636:	460c      	mov	r4, r1
  uint32_t val = _register->read();
    8638:	f7ff ffbc 	bl	85b4 <Adafruit_BusIO_Register::read()>

  // mask off the data before writing
  uint32_t mask = (1 << (_bits+1)) - 1;
    863c:	792b      	ldrb	r3, [r5, #4]
  data &= mask;

  mask <<= _shift;
    863e:	7969      	ldrb	r1, [r5, #5]
  val &= ~mask;      // remove the current data at that spot
  val |= data << _shift; // and add in the new data
  
  _register->write(val, _register->width());
    8640:	682d      	ldr	r5, [r5, #0]
 */
void Adafruit_BusIO_RegisterBits::write(uint32_t data) {
  uint32_t val = _register->read();

  // mask off the data before writing
  uint32_t mask = (1 << (_bits+1)) - 1;
    8642:	2201      	movs	r2, #1
    8644:	3301      	adds	r3, #1
    8646:	fa02 f303 	lsl.w	r3, r2, r3
    864a:	3b01      	subs	r3, #1

  mask <<= _shift;
  val &= ~mask;      // remove the current data at that spot
  val |= data << _shift; // and add in the new data
  
  _register->write(val, _register->width());
    864c:	401c      	ands	r4, r3
  // mask off the data before writing
  uint32_t mask = (1 << (_bits+1)) - 1;
  data &= mask;

  mask <<= _shift;
  val &= ~mask;      // remove the current data at that spot
    864e:	408b      	lsls	r3, r1
    8650:	ea20 0003 	bic.w	r0, r0, r3
  val |= data << _shift; // and add in the new data
  
  _register->write(val, _register->width());
    8654:	fa04 f101 	lsl.w	r1, r4, r1
    8658:	4301      	orrs	r1, r0
    865a:	7b2a      	ldrb	r2, [r5, #12]
    865c:	4628      	mov	r0, r5
}
    865e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  mask <<= _shift;
  val &= ~mask;      // remove the current data at that spot
  val |= data << _shift; // and add in the new data
  
  _register->write(val, _register->width());
    8662:	f7ff bf59 	b.w	8518 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)>
    8666:	bf00      	nop

00008668 <Adafruit_I2CDevice::write(unsigned char*, unsigned int, bool, unsigned char*, unsigned int) [clone .part.1]>:
 *    @param  prefix_buffer Pointer to optional array of data to write before buffer. Cannot be more than 32 bytes.
 *    @param  prefix_len Number of bytes from prefix buffer to write
 *    @param  stop Whether to send an I2C STOP signal on write
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(uint8_t *buffer, size_t len, bool stop, uint8_t *prefix_buffer, size_t prefix_len) {
    8668:	b570      	push	{r4, r5, r6, lr}
    866a:	4604      	mov	r4, r0
      return false;
    }
  }

  // Write the data itself
  if (_wire->write(buffer, len) != len) {
    866c:	6840      	ldr	r0, [r0, #4]
 *    @param  prefix_buffer Pointer to optional array of data to write before buffer. Cannot be more than 32 bytes.
 *    @param  prefix_len Number of bytes from prefix buffer to write
 *    @param  stop Whether to send an I2C STOP signal on write
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(uint8_t *buffer, size_t len, bool stop, uint8_t *prefix_buffer, size_t prefix_len) {
    866e:	461e      	mov	r6, r3
      return false;
    }
  }

  // Write the data itself
  if (_wire->write(buffer, len) != len) {
    8670:	6803      	ldr	r3, [r0, #0]
    8672:	685b      	ldr	r3, [r3, #4]
 *    @param  prefix_buffer Pointer to optional array of data to write before buffer. Cannot be more than 32 bytes.
 *    @param  prefix_len Number of bytes from prefix buffer to write
 *    @param  stop Whether to send an I2C STOP signal on write
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(uint8_t *buffer, size_t len, bool stop, uint8_t *prefix_buffer, size_t prefix_len) {
    8674:	4615      	mov	r5, r2
      return false;
    }
  }

  // Write the data itself
  if (_wire->write(buffer, len) != len) {
    8676:	4798      	blx	r3
    8678:	4285      	cmp	r5, r0
    867a:	d001      	beq.n	8680 <Adafruit_I2CDevice::write(unsigned char*, unsigned int, bool, unsigned char*, unsigned int) [clone .part.1]+0x18>
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println(F("\tI2CDevice failed to write"));
#endif
    return false;
    867c:	2000      	movs	r0, #0
  DEBUG_SERIAL.println();
#endif


  return (_wire -> endTransmission(stop) == 0);
}
    867e:	bd70      	pop	{r4, r5, r6, pc}
  }
  DEBUG_SERIAL.println();
#endif


  return (_wire -> endTransmission(stop) == 0);
    8680:	4631      	mov	r1, r6
    8682:	6860      	ldr	r0, [r4, #4]
    8684:	f7ff fd6a 	bl	815c <TwoWire::endTransmission(unsigned char)>
    8688:	fab0 f080 	clz	r0, r0
    868c:	0940      	lsrs	r0, r0, #5
    868e:	bd70      	pop	{r4, r5, r6, pc}

00008690 <Adafruit_I2CDevice::Adafruit_I2CDevice(unsigned char, TwoWire*)>:
/*!
 *    @brief  Create an I2C device at a given address
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
    8690:	b410      	push	{r4}
  _addr = addr;
  _wire = theWire;
  _begun = false;
    8692:	2400      	movs	r4, #0
    8694:	7204      	strb	r4, [r0, #8]
 *    @brief  Create an I2C device at a given address
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
  _addr = addr;
    8696:	7001      	strb	r1, [r0, #0]
  _wire = theWire;
    8698:	6042      	str	r2, [r0, #4]
  _begun = false;
}
    869a:	bc10      	pop	{r4}
    869c:	4770      	bx	lr
    869e:	bf00      	nop

000086a0 <Adafruit_I2CDevice::detected()>:
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
  // Init I2C if not done yet
  if (!_begun && !begin()) {
    86a0:	7a03      	ldrb	r3, [r0, #8]
/*!
 *    @brief  Scans I2C for the address - note will give a false-positive
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
    86a2:	b510      	push	{r4, lr}
    86a4:	4604      	mov	r4, r0
  // Init I2C if not done yet
  if (!_begun && !begin()) {
    86a6:	b183      	cbz	r3, 86ca <Adafruit_I2CDevice::detected()+0x2a>
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    86a8:	7822      	ldrb	r2, [r4, #0]
    return false;
  }

  // A basic scanner, see if it ACK's
  _wire->beginTransmission(_addr);
    86aa:	6863      	ldr	r3, [r4, #4]
		transmitting = 1;
    86ac:	2101      	movs	r1, #1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    86ae:	0052      	lsls	r2, r2, #1
    86b0:	f883 203b 	strb.w	r2, [r3, #59]	; 0x3b
		transmitting = 1;
    86b4:	f883 105e 	strb.w	r1, [r3, #94]	; 0x5e
		txBufferLength = 1;
    86b8:	f883 105d 	strb.w	r1, [r3, #93]	; 0x5d
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    86bc:	6860      	ldr	r0, [r4, #4]
    86be:	f7ff fd4d 	bl	815c <TwoWire::endTransmission(unsigned char)>
  if (_wire->endTransmission () == 0) {
    86c2:	fab0 f080 	clz	r0, r0
    86c6:	0940      	lsrs	r0, r0, #5
    return true;
  }
  return false;
}
    86c8:	bd10      	pop	{r4, pc}
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
  // Init I2C if not done yet
  if (!_begun && !begin()) {
    86ca:	f000 f803 	bl	86d4 <Adafruit_I2CDevice::begin()>
    86ce:	2800      	cmp	r0, #0
    86d0:	d1ea      	bne.n	86a8 <Adafruit_I2CDevice::detected()+0x8>
  _wire->beginTransmission(_addr);
  if (_wire->endTransmission () == 0) {
    return true;
  }
  return false;
}
    86d2:	bd10      	pop	{r4, pc}

000086d4 <Adafruit_I2CDevice::begin()>:

/*!
 *    @brief  Initializes and does basic address detection
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::begin(void) {
    86d4:	b510      	push	{r4, lr}
    86d6:	4604      	mov	r4, r0
  _wire->begin();
    86d8:	6840      	ldr	r0, [r0, #4]
    86da:	f7ff fbaf 	bl	7e3c <TwoWire::begin()>
  _begun = true;
    86de:	2301      	movs	r3, #1
    86e0:	7223      	strb	r3, [r4, #8]

  return detected();
    86e2:	4620      	mov	r0, r4
}
    86e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 */
bool Adafruit_I2CDevice::begin(void) {
  _wire->begin();
  _begun = true;

  return detected();
    86e8:	f7ff bfda 	b.w	86a0 <Adafruit_I2CDevice::detected()>

000086ec <Adafruit_I2CDevice::write(unsigned char*, unsigned int, bool, unsigned char*, unsigned int)>:
 *    @param  prefix_buffer Pointer to optional array of data to write before buffer. Cannot be more than 32 bytes.
 *    @param  prefix_len Number of bytes from prefix buffer to write
 *    @param  stop Whether to send an I2C STOP signal on write
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(uint8_t *buffer, size_t len, bool stop, uint8_t *prefix_buffer, size_t prefix_len) {
    86ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    86f0:	9e07      	ldr	r6, [sp, #28]
    86f2:	f8dd e018 	ldr.w	lr, [sp, #24]
  if ((len+prefix_len) > 32) {
    86f6:	1995      	adds	r5, r2, r6
    86f8:	2d20      	cmp	r5, #32
    86fa:	d819      	bhi.n	8730 <Adafruit_I2CDevice::write(unsigned char*, unsigned int, bool, unsigned char*, unsigned int)+0x44>
    86fc:	4615      	mov	r5, r2
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    86fe:	7802      	ldrb	r2, [r0, #0]
    8700:	4698      	mov	r8, r3
    DEBUG_SERIAL.println(F("\tI2CDevice could not write such a large buffer"));
#endif
    return false;
  }

  _wire->beginTransmission(_addr);
    8702:	6843      	ldr	r3, [r0, #4]
    8704:	460f      	mov	r7, r1
    8706:	0052      	lsls	r2, r2, #1
		transmitting = 1;
    8708:	2101      	movs	r1, #1
    870a:	4604      	mov	r4, r0
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    870c:	f883 203b 	strb.w	r2, [r3, #59]	; 0x3b
		transmitting = 1;
    8710:	f883 105e 	strb.w	r1, [r3, #94]	; 0x5e
		txBufferLength = 1;
    8714:	f883 105d 	strb.w	r1, [r3, #93]	; 0x5d

  // Write the prefix data (usually an address)
  if ((prefix_len != 0) && (prefix_buffer != NULL)) {
    8718:	b16e      	cbz	r6, 8736 <Adafruit_I2CDevice::write(unsigned char*, unsigned int, bool, unsigned char*, unsigned int)+0x4a>
    871a:	f1be 0f00 	cmp.w	lr, #0
    871e:	d00a      	beq.n	8736 <Adafruit_I2CDevice::write(unsigned char*, unsigned int, bool, unsigned char*, unsigned int)+0x4a>
    if (_wire->write(prefix_buffer, prefix_len) != prefix_len) {
    8720:	6840      	ldr	r0, [r0, #4]
    8722:	6803      	ldr	r3, [r0, #0]
    8724:	4671      	mov	r1, lr
    8726:	685b      	ldr	r3, [r3, #4]
    8728:	4632      	mov	r2, r6
    872a:	4798      	blx	r3
    872c:	4286      	cmp	r6, r0
    872e:	d002      	beq.n	8736 <Adafruit_I2CDevice::write(unsigned char*, unsigned int, bool, unsigned char*, unsigned int)+0x4a>
  DEBUG_SERIAL.println();
#endif


  return (_wire -> endTransmission(stop) == 0);
}
    8730:	2000      	movs	r0, #0
    8732:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8736:	4643      	mov	r3, r8
    8738:	462a      	mov	r2, r5
    873a:	4639      	mov	r1, r7
    873c:	4620      	mov	r0, r4
    873e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    8742:	f7ff bf91 	b.w	8668 <Adafruit_I2CDevice::write(unsigned char*, unsigned int, bool, unsigned char*, unsigned int) [clone .part.1]>
    8746:	bf00      	nop

00008748 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)>:
 *    @param  len Number of bytes from buffer to read.
 *    @param  stop Whether to send an I2C STOP signal on read
 *    @return True if read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
  if (len > 32) {
    8748:	2a20      	cmp	r2, #32
    874a:	d901      	bls.n	8750 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x8>
    // we will need to find out if some platforms have larger
    // I2C buffer sizes :/
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println(F("\tI2CDevice could not read such a large buffer"));
#endif
    return false;
    874c:	2000      	movs	r0, #0
  }
  DEBUG_SERIAL.println();
#endif

  return true;
}
    874e:	4770      	bx	lr
 *    @param  buffer Pointer to buffer of data to read into
 *    @param  len Number of bytes from buffer to read.
 *    @param  stop Whether to send an I2C STOP signal on read
 *    @return True if read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
    8750:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    8754:	4616      	mov	r6, r2
    8756:	4688      	mov	r8, r1
    8758:	4607      	mov	r7, r0
    DEBUG_SERIAL.println(F("\tI2CDevice could not read such a large buffer"));
#endif
    return false;
  }

  if (_wire->requestFrom((uint8_t)_addr, (uint8_t)len, (uint8_t)stop) != len) {
    875a:	7801      	ldrb	r1, [r0, #0]
    875c:	6840      	ldr	r0, [r0, #4]
    875e:	b2d2      	uxtb	r2, r2
    8760:	f7ff fd86 	bl	8270 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>
    8764:	4286      	cmp	r6, r0
    8766:	d002      	beq.n	876e <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x26>
    // we will need to find out if some platforms have larger
    // I2C buffer sizes :/
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println(F("\tI2CDevice could not read such a large buffer"));
#endif
    return false;
    8768:	2000      	movs	r0, #0
    876a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    DEBUG_SERIAL.println(F("\tI2CDevice did not receive enough data"));
#endif
    return false;
  }

  for (uint16_t i=0; i<len; i++) {
    876e:	b336      	cbz	r6, 87be <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x76>
    8770:	2300      	movs	r3, #0
    8772:	f8df 9054 	ldr.w	r9, [pc, #84]	; 87c8 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x80>
    8776:	461c      	mov	r4, r3
    8778:	e012      	b.n	87a0 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x58>
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    877a:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
    877e:	f890 2039 	ldrb.w	r2, [r0, #57]	; 0x39
    8782:	429a      	cmp	r2, r3
		return rxBuffer[rxBufferIndex++];
    8784:	f103 0e01 	add.w	lr, r3, #1
    8788:	eb00 0103 	add.w	r1, r0, r3
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    878c:	d91a      	bls.n	87c4 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x7c>
		return rxBuffer[rxBufferIndex++];
    878e:	f880 e038 	strb.w	lr, [r0, #56]	; 0x38
    8792:	7e08      	ldrb	r0, [r1, #24]
    buffer[i] = _wire->read();
    8794:	7028      	strb	r0, [r5, #0]
    DEBUG_SERIAL.println(F("\tI2CDevice did not receive enough data"));
#endif
    return false;
  }

  for (uint16_t i=0; i<len; i++) {
    8796:	3401      	adds	r4, #1
    8798:	b2a4      	uxth	r4, r4
    879a:	42a6      	cmp	r6, r4
    879c:	4623      	mov	r3, r4
    879e:	d90e      	bls.n	87be <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x76>
    buffer[i] = _wire->read();
    87a0:	6878      	ldr	r0, [r7, #4]
    87a2:	6802      	ldr	r2, [r0, #0]
    87a4:	6952      	ldr	r2, [r2, #20]
    87a6:	454a      	cmp	r2, r9
    87a8:	eb08 0503 	add.w	r5, r8, r3
    87ac:	d0e5      	beq.n	877a <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x32>
    87ae:	4790      	blx	r2
    DEBUG_SERIAL.println(F("\tI2CDevice did not receive enough data"));
#endif
    return false;
  }

  for (uint16_t i=0; i<len; i++) {
    87b0:	3401      	adds	r4, #1
    87b2:	b2a4      	uxth	r4, r4
    87b4:	b2c0      	uxtb	r0, r0
    87b6:	42a6      	cmp	r6, r4
    buffer[i] = _wire->read();
    87b8:	7028      	strb	r0, [r5, #0]
    DEBUG_SERIAL.println(F("\tI2CDevice did not receive enough data"));
#endif
    return false;
  }

  for (uint16_t i=0; i<len; i++) {
    87ba:	4623      	mov	r3, r4
    87bc:	d8f0      	bhi.n	87a0 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x58>
    // we will need to find out if some platforms have larger
    // I2C buffer sizes :/
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println(F("\tI2CDevice could not read such a large buffer"));
#endif
    return false;
    87be:	2001      	movs	r0, #1
    87c0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    87c4:	20ff      	movs	r0, #255	; 0xff
    87c6:	e7e5      	b.n	8794 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x4c>
    87c8:	00007d9d 	.word	0x00007d9d

000087cc <Adafruit_I2CDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, bool)>:
 *    @param  read_buffer Pointer to buffer of data to read into.
 *    @param  read_len Number of bytes from buffer to read.
 *    @param  stop Whether to send an I2C STOP signal between the write and read
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(uint8_t *write_buffer, size_t write_len, uint8_t *read_buffer, size_t read_len, bool stop) {
    87cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 *    @param  prefix_len Number of bytes from prefix buffer to write
 *    @param  stop Whether to send an I2C STOP signal on write
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(uint8_t *buffer, size_t len, bool stop, uint8_t *prefix_buffer, size_t prefix_len) {
  if ((len+prefix_len) > 32) {
    87d0:	2a20      	cmp	r2, #32
 *    @param  read_buffer Pointer to buffer of data to read into.
 *    @param  read_len Number of bytes from buffer to read.
 *    @param  stop Whether to send an I2C STOP signal between the write and read
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(uint8_t *write_buffer, size_t write_len, uint8_t *read_buffer, size_t read_len, bool stop) {
    87d2:	9f06      	ldr	r7, [sp, #24]
    87d4:	f89d 501c 	ldrb.w	r5, [sp, #28]
 *    @param  prefix_len Number of bytes from prefix buffer to write
 *    @param  stop Whether to send an I2C STOP signal on write
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(uint8_t *buffer, size_t len, bool stop, uint8_t *prefix_buffer, size_t prefix_len) {
  if ((len+prefix_len) > 32) {
    87d8:	d902      	bls.n	87e0 <Adafruit_I2CDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, bool)+0x14>
  if (! write(write_buffer, write_len, stop)) {
    return false;
  }
  
  return read(read_buffer, read_len);
}
    87da:	2000      	movs	r0, #0
    87dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    87e0:	f890 c000 	ldrb.w	ip, [r0]
    DEBUG_SERIAL.println(F("\tI2CDevice could not write such a large buffer"));
#endif
    return false;
  }

  _wire->beginTransmission(_addr);
    87e4:	f8d0 e004 	ldr.w	lr, [r0, #4]
		transmitting = 1;
    87e8:	f04f 0801 	mov.w	r8, #1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    87ec:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
    87f0:	461c      	mov	r4, r3
    87f2:	f88e c03b 	strb.w	ip, [lr, #59]	; 0x3b
    87f6:	462b      	mov	r3, r5
		transmitting = 1;
    87f8:	f88e 805e 	strb.w	r8, [lr, #94]	; 0x5e
		txBufferLength = 1;
    87fc:	f88e 805d 	strb.w	r8, [lr, #93]	; 0x5d
    8800:	4606      	mov	r6, r0
    8802:	f7ff ff31 	bl	8668 <Adafruit_I2CDevice::write(unsigned char*, unsigned int, bool, unsigned char*, unsigned int) [clone .part.1]>
 *    @param  read_len Number of bytes from buffer to read.
 *    @param  stop Whether to send an I2C STOP signal between the write and read
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(uint8_t *write_buffer, size_t write_len, uint8_t *read_buffer, size_t read_len, bool stop) {
  if (! write(write_buffer, write_len, stop)) {
    8806:	2800      	cmp	r0, #0
    8808:	d0e7      	beq.n	87da <Adafruit_I2CDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, bool)+0xe>
    return false;
  }
  
  return read(read_buffer, read_len);
    880a:	4643      	mov	r3, r8
    880c:	463a      	mov	r2, r7
    880e:	4621      	mov	r1, r4
    8810:	4630      	mov	r0, r6
}
    8812:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
bool Adafruit_I2CDevice::write_then_read(uint8_t *write_buffer, size_t write_len, uint8_t *read_buffer, size_t read_len, bool stop) {
  if (! write(write_buffer, write_len, stop)) {
    return false;
  }
  
  return read(read_buffer, read_len);
    8816:	f7ff bf97 	b.w	8748 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)>
    881a:	bf00      	nop

0000881c <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>:
/*!
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  buffer The buffer to send and receive at the same time
 *    @param  len    The number of bytes to transfer
 */
void Adafruit_SPIDevice::transfer(uint8_t *buffer, size_t len) {
    881c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if (_spi) {
    8820:	6804      	ldr	r4, [r0, #0]
/*!
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  buffer The buffer to send and receive at the same time
 *    @param  len    The number of bytes to transfer
 */
void Adafruit_SPIDevice::transfer(uint8_t *buffer, size_t len) {
    8822:	4613      	mov	r3, r2
    8824:	460a      	mov	r2, r1
  if (_spi) {
    8826:	b124      	cbz	r4, 8832 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x16>
		port().PUSHR = data | SPI_PUSHR_CTAS(1);
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
	}

	void inline transfer(void *buf, size_t count) {transfer(buf, buf, count);}
    8828:	4620      	mov	r0, r4
    }

    buffer[i] = reply;
  }
  return;
}
    882a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    882e:	f7fe bae1 	b.w	6df4 <SPIClass::transfer(void const*, void*, unsigned int)>
    _spi->transfer(buffer, len);
    return;
  }

  // for softSPI we'll do it by hand
  for (size_t i=0; i<len; i++) {
    8832:	2b00      	cmp	r3, #0
    8834:	f000 8084 	beq.w	8940 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x124>
    8838:	4680      	mov	r8, r0
    883a:	460d      	mov	r5, r1
    883c:	18cf      	adds	r7, r1, r3
    }
    for (int b=7; b>=0; b--) {
      reply <<= 1;
      if (_dataMode == SPI_MODE0) {
	digitalWrite(_sck, LOW);
	digitalWrite(_mosi, send & (1<<b));
    883e:	2601      	movs	r6, #1
  for (size_t i=0; i<len; i++) {
    // software SPI
    uint8_t reply = 0;
    uint8_t send = buffer[i];

    if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    8840:	f898 300c 	ldrb.w	r3, [r8, #12]

  // for softSPI we'll do it by hand
  for (size_t i=0; i<len; i++) {
    // software SPI
    uint8_t reply = 0;
    uint8_t send = buffer[i];
    8844:	f895 9000 	ldrb.w	r9, [r5]

    if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    8848:	b983      	cbnz	r3, 886c <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x50>
    884a:	4648      	mov	r0, r9
    884c:	461a      	mov	r2, r3
    884e:	4699      	mov	r9, r3
      // LSB is rare, if it happens we'll just flip the bits around for them
      uint8_t temp = 0;
      for (uint8_t b=0; b<8; b++) {
	temp |= ((send >> b) & 0x1) << (7-b);
    8850:	fa40 f302 	asr.w	r3, r0, r2
    8854:	f1c2 0107 	rsb	r1, r2, #7
    8858:	f003 0301 	and.w	r3, r3, #1
    885c:	408b      	lsls	r3, r1
    885e:	3201      	adds	r2, #1
    8860:	ea43 0309 	orr.w	r3, r3, r9
    uint8_t send = buffer[i];

    if (_dataOrder == SPI_BITORDER_LSBFIRST) {
      // LSB is rare, if it happens we'll just flip the bits around for them
      uint8_t temp = 0;
      for (uint8_t b=0; b<8; b++) {
    8864:	2a08      	cmp	r2, #8
	temp |= ((send >> b) & 0x1) << (7-b);
    8866:	fa5f f983 	uxtb.w	r9, r3
    uint8_t send = buffer[i];

    if (_dataOrder == SPI_BITORDER_LSBFIRST) {
      // LSB is rare, if it happens we'll just flip the bits around for them
      uint8_t temp = 0;
      for (uint8_t b=0; b<8; b++) {
    886a:	d1f1      	bne.n	8850 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x34>
  }

  // for softSPI we'll do it by hand
  for (size_t i=0; i<len; i++) {
    // software SPI
    uint8_t reply = 0;
    886c:	2400      	movs	r4, #0
      for (uint8_t b=0; b<8; b++) {
	temp |= ((send >> b) & 0x1) << (7-b);
      }
      send = temp;
    }
    for (int b=7; b>=0; b--) {
    886e:	f04f 0a07 	mov.w	sl, #7
    8872:	e004      	b.n	887e <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x62>
	digitalWrite(_sck, HIGH);
	if ((_miso != -1) && digitalRead(_miso)) {
	  reply |= 1;
	}
      }
      if (_dataMode == SPI_MODE1) {
    8874:	2904      	cmp	r1, #4
    8876:	d028      	beq.n	88ca <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xae>
      for (uint8_t b=0; b<8; b++) {
	temp |= ((send >> b) & 0x1) << (7-b);
      }
      send = temp;
    }
    for (int b=7; b>=0; b--) {
    8878:	f11a 3aff 	adds.w	sl, sl, #4294967295	; 0xffffffff
    887c:	d345      	bcc.n	890a <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xee>
      reply <<= 1;
      if (_dataMode == SPI_MODE0) {
    887e:	f898 100d 	ldrb.w	r1, [r8, #13]
	temp |= ((send >> b) & 0x1) << (7-b);
      }
      send = temp;
    }
    for (int b=7; b>=0; b--) {
      reply <<= 1;
    8882:	0064      	lsls	r4, r4, #1
    8884:	b2e4      	uxtb	r4, r4
      if (_dataMode == SPI_MODE0) {
    8886:	2900      	cmp	r1, #0
    8888:	d1f4      	bne.n	8874 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x58>
	digitalWrite(_sck, LOW);
    888a:	f898 000f 	ldrb.w	r0, [r8, #15]
    888e:	f001 fc03 	bl	a098 <digitalWrite>
	digitalWrite(_mosi, send & (1<<b));
    8892:	fa06 f10a 	lsl.w	r1, r6, sl
    8896:	ea01 0109 	and.w	r1, r1, r9
    889a:	f898 0010 	ldrb.w	r0, [r8, #16]
    889e:	f001 fbfb 	bl	a098 <digitalWrite>
	digitalWrite(_sck, HIGH);
    88a2:	f898 000f 	ldrb.w	r0, [r8, #15]
    88a6:	2101      	movs	r1, #1
    88a8:	f001 fbf6 	bl	a098 <digitalWrite>
	if ((_miso != -1) && digitalRead(_miso)) {
    88ac:	f998 0011 	ldrsb.w	r0, [r8, #17]
    88b0:	1c42      	adds	r2, r0, #1
    88b2:	d042      	beq.n	893a <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x11e>
    88b4:	b2c0      	uxtb	r0, r0
    88b6:	f001 fbf5 	bl	a0a4 <digitalRead>
    88ba:	2800      	cmp	r0, #0
    88bc:	d03d      	beq.n	893a <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x11e>
    88be:	f898 100d 	ldrb.w	r1, [r8, #13]
	  reply |= 1;
	}
      }
      if (_dataMode == SPI_MODE1) {
    88c2:	2904      	cmp	r1, #4
      if (_dataMode == SPI_MODE0) {
	digitalWrite(_sck, LOW);
	digitalWrite(_mosi, send & (1<<b));
	digitalWrite(_sck, HIGH);
	if ((_miso != -1) && digitalRead(_miso)) {
	  reply |= 1;
    88c4:	f044 0401 	orr.w	r4, r4, #1
	}
      }
      if (_dataMode == SPI_MODE1) {
    88c8:	d1d6      	bne.n	8878 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x5c>
	digitalWrite(_sck, HIGH);
    88ca:	2101      	movs	r1, #1
    88cc:	f898 000f 	ldrb.w	r0, [r8, #15]
    88d0:	f001 fbe2 	bl	a098 <digitalWrite>
	digitalWrite(_mosi, send & (1<<b));
    88d4:	fa06 f10a 	lsl.w	r1, r6, sl
    88d8:	ea01 0109 	and.w	r1, r1, r9
    88dc:	f898 0010 	ldrb.w	r0, [r8, #16]
    88e0:	f001 fbda 	bl	a098 <digitalWrite>
	digitalWrite(_sck, LOW);
    88e4:	f898 000f 	ldrb.w	r0, [r8, #15]
    88e8:	2100      	movs	r1, #0
    88ea:	f001 fbd5 	bl	a098 <digitalWrite>
	if ((_miso != -1) && digitalRead(_miso)) {
    88ee:	f998 0011 	ldrsb.w	r0, [r8, #17]
    88f2:	1c43      	adds	r3, r0, #1
    88f4:	d0c0      	beq.n	8878 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x5c>
    88f6:	b2c0      	uxtb	r0, r0
    88f8:	f001 fbd4 	bl	a0a4 <digitalRead>
    88fc:	2800      	cmp	r0, #0
    88fe:	d0bb      	beq.n	8878 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x5c>
      for (uint8_t b=0; b<8; b++) {
	temp |= ((send >> b) & 0x1) << (7-b);
      }
      send = temp;
    }
    for (int b=7; b>=0; b--) {
    8900:	f11a 3aff 	adds.w	sl, sl, #4294967295	; 0xffffffff
      if (_dataMode == SPI_MODE1) {
	digitalWrite(_sck, HIGH);
	digitalWrite(_mosi, send & (1<<b));
	digitalWrite(_sck, LOW);
	if ((_miso != -1) && digitalRead(_miso)) {
	  reply |= 1;
    8904:	f044 0401 	orr.w	r4, r4, #1
      for (uint8_t b=0; b<8; b++) {
	temp |= ((send >> b) & 0x1) << (7-b);
      }
      send = temp;
    }
    for (int b=7; b>=0; b--) {
    8908:	d2b9      	bcs.n	887e <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x62>
	  reply |= 1;
	}
      }
    }

    if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    890a:	f898 300c 	ldrb.w	r3, [r8, #12]
    890e:	b973      	cbnz	r3, 892e <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x112>
    8910:	4620      	mov	r0, r4
    8912:	461a      	mov	r2, r3
    8914:	461c      	mov	r4, r3
      // LSB is rare, if it happens we'll just flip the bits around for them
      uint8_t temp = 0;
      for (uint8_t b=0; b<8; b++) {
	temp |= ((reply >> b) & 0x1) << (7-b);
    8916:	fa40 f302 	asr.w	r3, r0, r2
    891a:	f1c2 0107 	rsb	r1, r2, #7
    891e:	f003 0301 	and.w	r3, r3, #1
    8922:	408b      	lsls	r3, r1
    8924:	3201      	adds	r2, #1
    8926:	431c      	orrs	r4, r3
    }

    if (_dataOrder == SPI_BITORDER_LSBFIRST) {
      // LSB is rare, if it happens we'll just flip the bits around for them
      uint8_t temp = 0;
      for (uint8_t b=0; b<8; b++) {
    8928:	2a08      	cmp	r2, #8
	temp |= ((reply >> b) & 0x1) << (7-b);
    892a:	b2e4      	uxtb	r4, r4
    }

    if (_dataOrder == SPI_BITORDER_LSBFIRST) {
      // LSB is rare, if it happens we'll just flip the bits around for them
      uint8_t temp = 0;
      for (uint8_t b=0; b<8; b++) {
    892c:	d1f3      	bne.n	8916 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xfa>
	temp |= ((reply >> b) & 0x1) << (7-b);
      }
      reply = temp;
    }

    buffer[i] = reply;
    892e:	f805 4b01 	strb.w	r4, [r5], #1
    _spi->transfer(buffer, len);
    return;
  }

  // for softSPI we'll do it by hand
  for (size_t i=0; i<len; i++) {
    8932:	42af      	cmp	r7, r5
    8934:	d184      	bne.n	8840 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x24>
    8936:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    893a:	f898 100d 	ldrb.w	r1, [r8, #13]
    893e:	e799      	b.n	8874 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x58>
    8940:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00008944 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)>:
 *    @param  len Number of bytes from buffer to write
 *    @param  prefix_buffer Pointer to optional array of data to write before buffer.
 *    @param  prefix_len Number of bytes from prefix buffer to write
 *    @return Always returns true because there's no way to test success of SPI writes
 */
bool Adafruit_SPIDevice::write(uint8_t *buffer, size_t len, uint8_t *prefix_buffer, size_t prefix_len) {
    8944:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    8948:	460c      	mov	r4, r1
    894a:	b083      	sub	sp, #12
  if (_spi) {
    894c:	6801      	ldr	r1, [r0, #0]
 *    @param  len Number of bytes from buffer to write
 *    @param  prefix_buffer Pointer to optional array of data to write before buffer.
 *    @param  prefix_len Number of bytes from prefix buffer to write
 *    @return Always returns true because there's no way to test success of SPI writes
 */
bool Adafruit_SPIDevice::write(uint8_t *buffer, size_t len, uint8_t *prefix_buffer, size_t prefix_len) {
    894e:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    8950:	4606      	mov	r6, r0
    8952:	4690      	mov	r8, r2
    8954:	461d      	mov	r5, r3
  if (_spi) {
    8956:	b181      	cbz	r1, 897a <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x36>
    8958:	6842      	ldr	r2, [r0, #4]

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    895a:	7acb      	ldrb	r3, [r1, #11]
    895c:	6812      	ldr	r2, [r2, #0]
    895e:	2b00      	cmp	r3, #0
    8960:	d14e      	bne.n	8a00 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0xbc>
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    8962:	680b      	ldr	r3, [r1, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
    8964:	68d9      	ldr	r1, [r3, #12]
    8966:	4291      	cmp	r1, r2
    8968:	d007      	beq.n	897a <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x36>
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
    896a:	4839      	ldr	r0, [pc, #228]	; (8a50 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x10c>)
    896c:	6018      	str	r0, [r3, #0]
			port().CTAR0 = settings.ctar;
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    896e:	4939      	ldr	r1, [pc, #228]	; (8a54 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x110>)
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
			port().CTAR0 = settings.ctar;
    8970:	60da      	str	r2, [r3, #12]
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
    8972:	f042 4080 	orr.w	r0, r2, #1073741824	; 0x40000000
    8976:	6118      	str	r0, [r3, #16]
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    8978:	6019      	str	r1, [r3, #0]
    _spi->beginTransaction(*_spiSetting);
  }

  digitalWrite(_cs, LOW);
    897a:	2100      	movs	r1, #0
    897c:	7bb0      	ldrb	r0, [r6, #14]
    897e:	f001 fb8b 	bl	a098 <digitalWrite>
  // do the writing
  for (size_t i=0; i<prefix_len; i++) {
    8982:	b177      	cbz	r7, 89a2 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x5e>
    8984:	eb05 0907 	add.w	r9, r5, r7
    8988:	f10d 0707 	add.w	r7, sp, #7
    transfer(prefix_buffer[i]);
    898c:	f815 3b01 	ldrb.w	r3, [r5], #1
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    8990:	f88d 3007 	strb.w	r3, [sp, #7]
  transfer(&data, 1);
    8994:	2201      	movs	r2, #1
    8996:	4639      	mov	r1, r7
    8998:	4630      	mov	r0, r6
    899a:	f7ff ff3f 	bl	881c <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
    _spi->beginTransaction(*_spiSetting);
  }

  digitalWrite(_cs, LOW);
  // do the writing
  for (size_t i=0; i<prefix_len; i++) {
    899e:	45a9      	cmp	r9, r5
    89a0:	d1f4      	bne.n	898c <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x48>
    transfer(prefix_buffer[i]);
  }
  for (size_t i=0; i<len; i++) {
    89a2:	f1b8 0f00 	cmp.w	r8, #0
    89a6:	d00e      	beq.n	89c6 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x82>
    89a8:	eb04 0508 	add.w	r5, r4, r8
    89ac:	f10d 0707 	add.w	r7, sp, #7
    transfer(buffer[i]);
    89b0:	f814 3b01 	ldrb.w	r3, [r4], #1
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    89b4:	f88d 3007 	strb.w	r3, [sp, #7]
  transfer(&data, 1);
    89b8:	2201      	movs	r2, #1
    89ba:	4639      	mov	r1, r7
    89bc:	4630      	mov	r0, r6
    89be:	f7ff ff2d 	bl	881c <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
  digitalWrite(_cs, LOW);
  // do the writing
  for (size_t i=0; i<prefix_len; i++) {
    transfer(prefix_buffer[i]);
  }
  for (size_t i=0; i<len; i++) {
    89c2:	42a5      	cmp	r5, r4
    89c4:	d1f4      	bne.n	89b0 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x6c>
    transfer(buffer[i]);
  }
  digitalWrite(_cs, HIGH);
    89c6:	2101      	movs	r1, #1
    89c8:	7bb0      	ldrb	r0, [r6, #14]
    89ca:	f001 fb65 	bl	a098 <digitalWrite>

  if (_spi) {
    89ce:	6833      	ldr	r3, [r6, #0]
    89d0:	b193      	cbz	r3, 89f8 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0xb4>
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    89d2:	7ada      	ldrb	r2, [r3, #11]
    89d4:	b182      	cbz	r2, 89f8 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0xb4>
			if (interruptMasksUsed & 0x01) {
    89d6:	07d0      	lsls	r0, r2, #31
    89d8:	d503      	bpl.n	89e2 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x9e>
				NVIC_ISER0 = interruptSave[0];
    89da:	4a1f      	ldr	r2, [pc, #124]	; (8a58 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x114>)
    89dc:	6999      	ldr	r1, [r3, #24]
    89de:	6011      	str	r1, [r2, #0]
    89e0:	7ada      	ldrb	r2, [r3, #11]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    89e2:	0791      	lsls	r1, r2, #30
    89e4:	d503      	bpl.n	89ee <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0xaa>
				NVIC_ISER1 = interruptSave[1];
    89e6:	4a1d      	ldr	r2, [pc, #116]	; (8a5c <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x118>)
    89e8:	69d9      	ldr	r1, [r3, #28]
    89ea:	6011      	str	r1, [r2, #0]
    89ec:	7ada      	ldrb	r2, [r3, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    89ee:	0752      	lsls	r2, r2, #29
    89f0:	d502      	bpl.n	89f8 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0xb4>
				NVIC_ISER2 = interruptSave[2];
    89f2:	4a1b      	ldr	r2, [pc, #108]	; (8a60 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x11c>)
    89f4:	6a1b      	ldr	r3, [r3, #32]
    89f6:	6013      	str	r3, [r2, #0]
  }
  DEBUG_SERIAL.println();
#endif

  return true;
}
    89f8:	2001      	movs	r0, #1
    89fa:	b003      	add	sp, #12
    89fc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
			__disable_irq();
    8a00:	b672      	cpsid	i
			if (interruptMasksUsed & 0x01) {
    8a02:	7acb      	ldrb	r3, [r1, #11]
    8a04:	07d8      	lsls	r0, r3, #31
    8a06:	d509      	bpl.n	8a1c <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0xd8>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    8a08:	f8df e058 	ldr.w	lr, [pc, #88]	; 8a64 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x120>
    8a0c:	68c8      	ldr	r0, [r1, #12]
    8a0e:	f8de 3000 	ldr.w	r3, [lr]
    8a12:	4003      	ands	r3, r0
    8a14:	618b      	str	r3, [r1, #24]
				NVIC_ICER0 = interruptSave[0];
    8a16:	f8ce 3000 	str.w	r3, [lr]
    8a1a:	7acb      	ldrb	r3, [r1, #11]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    8a1c:	0798      	lsls	r0, r3, #30
    8a1e:	d509      	bpl.n	8a34 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0xf0>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    8a20:	f8df e044 	ldr.w	lr, [pc, #68]	; 8a68 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x124>
    8a24:	6908      	ldr	r0, [r1, #16]
    8a26:	f8de 3000 	ldr.w	r3, [lr]
    8a2a:	4003      	ands	r3, r0
    8a2c:	61cb      	str	r3, [r1, #28]
				NVIC_ICER1 = interruptSave[1];
    8a2e:	f8ce 3000 	str.w	r3, [lr]
    8a32:	7acb      	ldrb	r3, [r1, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    8a34:	075b      	lsls	r3, r3, #29
    8a36:	d508      	bpl.n	8a4a <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x106>
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    8a38:	f8df e030 	ldr.w	lr, [pc, #48]	; 8a6c <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x128>
    8a3c:	6948      	ldr	r0, [r1, #20]
    8a3e:	f8de 3000 	ldr.w	r3, [lr]
    8a42:	4003      	ands	r3, r0
    8a44:	620b      	str	r3, [r1, #32]
				NVIC_ICER2 = interruptSave[2];
    8a46:	f8ce 3000 	str.w	r3, [lr]
			if (interruptMasksUsed & 0x08) {
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
				NVIC_ICER3 = interruptSave[3];
			}
			#endif
			__enable_irq();
    8a4a:	b662      	cpsie	i
    8a4c:	e789      	b.n	8962 <Adafruit_SPIDevice::write(unsigned char*, unsigned int, unsigned char*, unsigned int)+0x1e>
    8a4e:	bf00      	nop
    8a50:	003f4001 	.word	0x003f4001
    8a54:	803f0000 	.word	0x803f0000
    8a58:	e000e100 	.word	0xe000e100
    8a5c:	e000e104 	.word	0xe000e104
    8a60:	e000e108 	.word	0xe000e108
    8a64:	e000e180 	.word	0xe000e180
    8a68:	e000e184 	.word	0xe000e184
    8a6c:	e000e188 	.word	0xe000e188

00008a70 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)>:
 *    @param  read_buffer Pointer to buffer of data to read into.
 *    @param  read_len Number of bytes from buffer to read.
 *    @param  sendvalue The 8-bits of data to write when doing the data read, defaults to 0xFF
 *    @return Always returns true because there's no way to test success of SPI writes
 */
bool Adafruit_SPIDevice::write_then_read(uint8_t *write_buffer, size_t write_len, uint8_t *read_buffer, size_t read_len, uint8_t sendvalue) {
    8a70:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    8a74:	460d      	mov	r5, r1
    8a76:	b082      	sub	sp, #8
  if (_spi) {
    8a78:	6801      	ldr	r1, [r0, #0]
 *    @param  read_buffer Pointer to buffer of data to read into.
 *    @param  read_len Number of bytes from buffer to read.
 *    @param  sendvalue The 8-bits of data to write when doing the data read, defaults to 0xFF
 *    @return Always returns true because there's no way to test success of SPI writes
 */
bool Adafruit_SPIDevice::write_then_read(uint8_t *write_buffer, size_t write_len, uint8_t *read_buffer, size_t read_len, uint8_t sendvalue) {
    8a7a:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
    8a7e:	f89d 802c 	ldrb.w	r8, [sp, #44]	; 0x2c
    8a82:	4606      	mov	r6, r0
    8a84:	4617      	mov	r7, r2
    8a86:	461c      	mov	r4, r3
  if (_spi) {
    8a88:	b181      	cbz	r1, 8aac <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x3c>
    8a8a:	6842      	ldr	r2, [r0, #4]

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    8a8c:	7acb      	ldrb	r3, [r1, #11]
    8a8e:	6812      	ldr	r2, [r2, #0]
    8a90:	2b00      	cmp	r3, #0
    8a92:	d14f      	bne.n	8b34 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0xc4>
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    8a94:	680b      	ldr	r3, [r1, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
    8a96:	68d9      	ldr	r1, [r3, #12]
    8a98:	4291      	cmp	r1, r2
    8a9a:	d007      	beq.n	8aac <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x3c>
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
    8a9c:	4839      	ldr	r0, [pc, #228]	; (8b84 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x114>)
    8a9e:	6018      	str	r0, [r3, #0]
			port().CTAR0 = settings.ctar;
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    8aa0:	4939      	ldr	r1, [pc, #228]	; (8b88 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x118>)
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
			port().CTAR0 = settings.ctar;
    8aa2:	60da      	str	r2, [r3, #12]
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
    8aa4:	f042 4080 	orr.w	r0, r2, #1073741824	; 0x40000000
    8aa8:	6118      	str	r0, [r3, #16]
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    8aaa:	6019      	str	r1, [r3, #0]
    _spi->beginTransaction(*_spiSetting);
  }

  digitalWrite(_cs, LOW);
    8aac:	2100      	movs	r1, #0
    8aae:	7bb0      	ldrb	r0, [r6, #14]
    8ab0:	f001 faf2 	bl	a098 <digitalWrite>
  // do the writing
  for (size_t i=0; i<write_len; i++) {
    8ab4:	b177      	cbz	r7, 8ad4 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x64>
    8ab6:	eb05 0a07 	add.w	sl, r5, r7
    8aba:	f10d 0707 	add.w	r7, sp, #7
    transfer(write_buffer[i]);
    8abe:	f815 3b01 	ldrb.w	r3, [r5], #1
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    8ac2:	f88d 3007 	strb.w	r3, [sp, #7]
  transfer(&data, 1);
    8ac6:	2201      	movs	r2, #1
    8ac8:	4639      	mov	r1, r7
    8aca:	4630      	mov	r0, r6
    8acc:	f7ff fea6 	bl	881c <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
    _spi->beginTransaction(*_spiSetting);
  }

  digitalWrite(_cs, LOW);
  // do the writing
  for (size_t i=0; i<write_len; i++) {
    8ad0:	45aa      	cmp	sl, r5
    8ad2:	d1f4      	bne.n	8abe <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x4e>
  }
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i=0; i<read_len; i++) {
    8ad4:	f1b9 0f00 	cmp.w	r9, #0
    8ad8:	d00f      	beq.n	8afa <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x8a>
    8ada:	44a1      	add	r9, r4
    8adc:	f10d 0707 	add.w	r7, sp, #7
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
    8ae0:	2201      	movs	r2, #1
    8ae2:	4639      	mov	r1, r7
    8ae4:	4630      	mov	r0, r6
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    8ae6:	f88d 8007 	strb.w	r8, [sp, #7]
  transfer(&data, 1);
    8aea:	f7ff fe97 	bl	881c <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
  return data;
    8aee:	f89d 3007 	ldrb.w	r3, [sp, #7]
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i=0; i<read_len; i++) {
    read_buffer[i] = transfer(sendvalue);
    8af2:	f804 3b01 	strb.w	r3, [r4], #1
  }
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i=0; i<read_len; i++) {
    8af6:	45a1      	cmp	r9, r4
    8af8:	d1f2      	bne.n	8ae0 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x70>
    }
  }
  DEBUG_SERIAL.println();
#endif

  digitalWrite(_cs, HIGH);
    8afa:	2101      	movs	r1, #1
    8afc:	7bb0      	ldrb	r0, [r6, #14]
    8afe:	f001 facb 	bl	a098 <digitalWrite>

  if (_spi) {
    8b02:	6833      	ldr	r3, [r6, #0]
    8b04:	b193      	cbz	r3, 8b2c <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0xbc>
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    8b06:	7ada      	ldrb	r2, [r3, #11]
    8b08:	b182      	cbz	r2, 8b2c <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0xbc>
			if (interruptMasksUsed & 0x01) {
    8b0a:	07d0      	lsls	r0, r2, #31
    8b0c:	d503      	bpl.n	8b16 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0xa6>
				NVIC_ISER0 = interruptSave[0];
    8b0e:	4a1f      	ldr	r2, [pc, #124]	; (8b8c <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x11c>)
    8b10:	6999      	ldr	r1, [r3, #24]
    8b12:	6011      	str	r1, [r2, #0]
    8b14:	7ada      	ldrb	r2, [r3, #11]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    8b16:	0791      	lsls	r1, r2, #30
    8b18:	d503      	bpl.n	8b22 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0xb2>
				NVIC_ISER1 = interruptSave[1];
    8b1a:	4a1d      	ldr	r2, [pc, #116]	; (8b90 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x120>)
    8b1c:	69d9      	ldr	r1, [r3, #28]
    8b1e:	6011      	str	r1, [r2, #0]
    8b20:	7ada      	ldrb	r2, [r3, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    8b22:	0752      	lsls	r2, r2, #29
    8b24:	d502      	bpl.n	8b2c <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0xbc>
				NVIC_ISER2 = interruptSave[2];
    8b26:	4a1b      	ldr	r2, [pc, #108]	; (8b94 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x124>)
    8b28:	6a1b      	ldr	r3, [r3, #32]
    8b2a:	6013      	str	r3, [r2, #0]
    _spi->endTransaction();
  }

  return true;
}
    8b2c:	2001      	movs	r0, #1
    8b2e:	b002      	add	sp, #8
    8b30:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
			__disable_irq();
    8b34:	b672      	cpsid	i
			if (interruptMasksUsed & 0x01) {
    8b36:	7acb      	ldrb	r3, [r1, #11]
    8b38:	07d8      	lsls	r0, r3, #31
    8b3a:	d509      	bpl.n	8b50 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0xe0>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    8b3c:	f8df e058 	ldr.w	lr, [pc, #88]	; 8b98 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x128>
    8b40:	68c8      	ldr	r0, [r1, #12]
    8b42:	f8de 3000 	ldr.w	r3, [lr]
    8b46:	4003      	ands	r3, r0
    8b48:	618b      	str	r3, [r1, #24]
				NVIC_ICER0 = interruptSave[0];
    8b4a:	f8ce 3000 	str.w	r3, [lr]
    8b4e:	7acb      	ldrb	r3, [r1, #11]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    8b50:	0798      	lsls	r0, r3, #30
    8b52:	d509      	bpl.n	8b68 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0xf8>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    8b54:	f8df e044 	ldr.w	lr, [pc, #68]	; 8b9c <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x12c>
    8b58:	6908      	ldr	r0, [r1, #16]
    8b5a:	f8de 3000 	ldr.w	r3, [lr]
    8b5e:	4003      	ands	r3, r0
    8b60:	61cb      	str	r3, [r1, #28]
				NVIC_ICER1 = interruptSave[1];
    8b62:	f8ce 3000 	str.w	r3, [lr]
    8b66:	7acb      	ldrb	r3, [r1, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    8b68:	075b      	lsls	r3, r3, #29
    8b6a:	d508      	bpl.n	8b7e <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x10e>
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    8b6c:	f8df e030 	ldr.w	lr, [pc, #48]	; 8ba0 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x130>
    8b70:	6948      	ldr	r0, [r1, #20]
    8b72:	f8de 3000 	ldr.w	r3, [lr]
    8b76:	4003      	ands	r3, r0
    8b78:	620b      	str	r3, [r1, #32]
				NVIC_ICER2 = interruptSave[2];
    8b7a:	f8ce 3000 	str.w	r3, [lr]
			if (interruptMasksUsed & 0x08) {
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
				NVIC_ICER3 = interruptSave[3];
			}
			#endif
			__enable_irq();
    8b7e:	b662      	cpsie	i
    8b80:	e788      	b.n	8a94 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x24>
    8b82:	bf00      	nop
    8b84:	003f4001 	.word	0x003f4001
    8b88:	803f0000 	.word	0x803f0000
    8b8c:	e000e100 	.word	0xe000e100
    8b90:	e000e104 	.word	0xe000e104
    8b94:	e000e108 	.word	0xe000e108
    8b98:	e000e180 	.word	0xe000e180
    8b9c:	e000e184 	.word	0xe000e184
    8ba0:	e000e188 	.word	0xe000e188

00008ba4 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)>:


// Set up the pool of audio data blocks
// placing them all onto the free list
void AudioStream::initialize_memory(audio_block_t *data, unsigned int num)
{
    8ba4:	29c0      	cmp	r1, #192	; 0xc0
    8ba6:	b4f0      	push	{r4, r5, r6, r7}
    8ba8:	bf28      	it	cs
    8baa:	21c0      	movcs	r1, #192	; 0xc0
	unsigned int maxnum = MAX_AUDIO_MEMORY / AUDIO_BLOCK_SAMPLES / 2;

	//Serial.println("AudioStream initialize_memory");
	//delay(10);
	if (num > maxnum) num = maxnum;
	__disable_irq();
    8bac:	b672      	cpsid	i
	memory_pool = data;
    8bae:	4b12      	ldr	r3, [pc, #72]	; (8bf8 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x54>)
	memory_pool_first_mask = 0;
	for (i=0; i < NUM_MASKS; i++) {
		memory_pool_available_mask[i] = 0;
    8bb0:	4e12      	ldr	r6, [pc, #72]	; (8bfc <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x58>)
	//Serial.println("AudioStream initialize_memory");
	//delay(10);
	if (num > maxnum) num = maxnum;
	__disable_irq();
	memory_pool = data;
	memory_pool_first_mask = 0;
    8bb2:	4a13      	ldr	r2, [pc, #76]	; (8c00 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x5c>)

	//Serial.println("AudioStream initialize_memory");
	//delay(10);
	if (num > maxnum) num = maxnum;
	__disable_irq();
	memory_pool = data;
    8bb4:	6018      	str	r0, [r3, #0]
	memory_pool_first_mask = 0;
    8bb6:	2300      	movs	r3, #0
    8bb8:	8013      	strh	r3, [r2, #0]
	for (i=0; i < NUM_MASKS; i++) {
		memory_pool_available_mask[i] = 0;
    8bba:	6033      	str	r3, [r6, #0]
    8bbc:	6073      	str	r3, [r6, #4]
    8bbe:	60b3      	str	r3, [r6, #8]
    8bc0:	60f3      	str	r3, [r6, #12]
    8bc2:	6133      	str	r3, [r6, #16]
    8bc4:	6173      	str	r3, [r6, #20]
	}
	for (i=0; i < num; i++) {
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
    8bc6:	2701      	movs	r7, #1
	memory_pool = data;
	memory_pool_first_mask = 0;
	for (i=0; i < NUM_MASKS; i++) {
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
    8bc8:	b199      	cbz	r1, 8bf2 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x4e>
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
    8bca:	095d      	lsrs	r5, r3, #5
    8bcc:	f003 041f 	and.w	r4, r3, #31
    8bd0:	f856 2025 	ldr.w	r2, [r6, r5, lsl #2]
    8bd4:	fa07 f404 	lsl.w	r4, r7, r4
	memory_pool = data;
	memory_pool_first_mask = 0;
	for (i=0; i < NUM_MASKS; i++) {
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
    8bd8:	3301      	adds	r3, #1
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
    8bda:	4322      	orrs	r2, r4
	memory_pool = data;
	memory_pool_first_mask = 0;
	for (i=0; i < NUM_MASKS; i++) {
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
    8bdc:	428b      	cmp	r3, r1
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
    8bde:	f846 2025 	str.w	r2, [r6, r5, lsl #2]
	memory_pool = data;
	memory_pool_first_mask = 0;
	for (i=0; i < NUM_MASKS; i++) {
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
    8be2:	d1f2      	bne.n	8bca <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x26>
    8be4:	2300      	movs	r3, #0
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
	}
	for (i=0; i < num; i++) {
		data[i].memory_pool_index = i;
    8be6:	8043      	strh	r3, [r0, #2]
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
	}
	for (i=0; i < num; i++) {
    8be8:	3301      	adds	r3, #1
    8bea:	428b      	cmp	r3, r1
    8bec:	f500 7082 	add.w	r0, r0, #260	; 0x104
    8bf0:	d1f9      	bne.n	8be6 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x42>
		data[i].memory_pool_index = i;
	}
	__enable_irq();
    8bf2:	b662      	cpsie	i

}
    8bf4:	bcf0      	pop	{r4, r5, r6, r7}
    8bf6:	4770      	bx	lr
    8bf8:	200045a0 	.word	0x200045a0
    8bfc:	200045a8 	.word	0x200045a8
    8c00:	200045c2 	.word	0x200045c2

00008c04 <AudioStream::allocate()>:

// Allocate 1 audio data block.  If successful
// the caller is the only owner of this new block
audio_block_t * AudioStream::allocate(void)
{
    8c04:	b4f0      	push	{r4, r5, r6, r7}
	audio_block_t *block;
	uint32_t used;

	p = memory_pool_available_mask;
	end = p + NUM_MASKS;
	__disable_irq();
    8c06:	b672      	cpsid	i
	index = memory_pool_first_mask;
    8c08:	4f23      	ldr	r7, [pc, #140]	; (8c98 <AudioStream::allocate()+0x94>)
	p += index;
    8c0a:	4e24      	ldr	r6, [pc, #144]	; (8c9c <AudioStream::allocate()+0x98>)
	uint32_t used;

	p = memory_pool_available_mask;
	end = p + NUM_MASKS;
	__disable_irq();
	index = memory_pool_first_mask;
    8c0c:	883c      	ldrh	r4, [r7, #0]
	p += index;
	while (1) {
		if (p >= end) {
    8c0e:	f106 0318 	add.w	r3, r6, #24

	p = memory_pool_available_mask;
	end = p + NUM_MASKS;
	__disable_irq();
	index = memory_pool_first_mask;
	p += index;
    8c12:	eb06 0084 	add.w	r0, r6, r4, lsl #2
	while (1) {
		if (p >= end) {
    8c16:	4298      	cmp	r0, r3
    8c18:	d212      	bcs.n	8c40 <AudioStream::allocate()+0x3c>
			__enable_irq();
			//Serial.println("alloc:null");
			return NULL;
		}
		avail = *p;
    8c1a:	f856 1024 	ldr.w	r1, [r6, r4, lsl #2]
		if (avail) break;
    8c1e:	b999      	cbnz	r1, 8c48 <AudioStream::allocate()+0x44>
    8c20:	1d02      	adds	r2, r0, #4
    8c22:	f106 051b 	add.w	r5, r6, #27
    8c26:	1c63      	adds	r3, r4, #1
    8c28:	1aad      	subs	r5, r5, r2
    8c2a:	eb03 0595 	add.w	r5, r3, r5, lsr #2
    8c2e:	e003      	b.n	8c38 <AudioStream::allocate()+0x34>
		if (p >= end) {
			__enable_irq();
			//Serial.println("alloc:null");
			return NULL;
		}
		avail = *p;
    8c30:	f852 1b04 	ldr.w	r1, [r2], #4
		if (avail) break;
    8c34:	b941      	cbnz	r1, 8c48 <AudioStream::allocate()+0x44>
    8c36:	3301      	adds	r3, #1
	end = p + NUM_MASKS;
	__disable_irq();
	index = memory_pool_first_mask;
	p += index;
	while (1) {
		if (p >= end) {
    8c38:	42ab      	cmp	r3, r5
			//Serial.println("alloc:null");
			return NULL;
		}
		avail = *p;
		if (avail) break;
		index++;
    8c3a:	461c      	mov	r4, r3
		p++;
    8c3c:	4610      	mov	r0, r2
	end = p + NUM_MASKS;
	__disable_irq();
	index = memory_pool_first_mask;
	p += index;
	while (1) {
		if (p >= end) {
    8c3e:	d1f7      	bne.n	8c30 <AudioStream::allocate()+0x2c>
			__enable_irq();
    8c40:	b662      	cpsie	i
			//Serial.println("alloc:null");
			return NULL;
    8c42:	2000      	movs	r0, #0
	block->ref_count = 1;
	if (used > memory_used_max) memory_used_max = used;
	//Serial.print("alloc:");
	//Serial.println((uint32_t)block, HEX);
	return block;
}
    8c44:	bcf0      	pop	{r4, r5, r6, r7}
    8c46:	4770      	bx	lr
		avail = *p;
		if (avail) break;
		index++;
		p++;
	}
	n = __builtin_clz(avail);
    8c48:	fab1 f381 	clz	r3, r1
	avail &= ~(0x80000000 >> n);
    8c4c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    8c50:	40da      	lsrs	r2, r3
    8c52:	ea21 0102 	bic.w	r1, r1, r2
	*p = avail;
    8c56:	6001      	str	r1, [r0, #0]
	if (!avail) index++;
    8c58:	b901      	cbnz	r1, 8c5c <AudioStream::allocate()+0x58>
    8c5a:	3401      	adds	r4, #1
	memory_pool_first_mask = index;
	used = memory_used + 1;
    8c5c:	4910      	ldr	r1, [pc, #64]	; (8ca0 <AudioStream::allocate()+0x9c>)
	}
	n = __builtin_clz(avail);
	avail &= ~(0x80000000 >> n);
	*p = avail;
	if (!avail) index++;
	memory_pool_first_mask = index;
    8c5e:	803c      	strh	r4, [r7, #0]
	used = memory_used + 1;
    8c60:	880a      	ldrh	r2, [r1, #0]
    8c62:	3201      	adds	r2, #1
	memory_used = used;
    8c64:	b294      	uxth	r4, r2
    8c66:	800c      	strh	r4, [r1, #0]
	__enable_irq();
    8c68:	b662      	cpsie	i
	index = p - memory_pool_available_mask;
	block = memory_pool + ((index << 5) + (31 - n));
    8c6a:	1b80      	subs	r0, r0, r6
    8c6c:	1080      	asrs	r0, r0, #2
    8c6e:	ebc3 1040 	rsb	r0, r3, r0, lsl #5
    8c72:	eb00 1080 	add.w	r0, r0, r0, lsl #6
    8c76:	0083      	lsls	r3, r0, #2
    8c78:	480a      	ldr	r0, [pc, #40]	; (8ca4 <AudioStream::allocate()+0xa0>)
	block->ref_count = 1;
	if (used > memory_used_max) memory_used_max = used;
    8c7a:	490b      	ldr	r1, [pc, #44]	; (8ca8 <AudioStream::allocate()+0xa4>)
	memory_pool_first_mask = index;
	used = memory_used + 1;
	memory_used = used;
	__enable_irq();
	index = p - memory_pool_available_mask;
	block = memory_pool + ((index << 5) + (31 - n));
    8c7c:	6800      	ldr	r0, [r0, #0]
    8c7e:	f503 53fb 	add.w	r3, r3, #8032	; 0x1f60
    8c82:	331c      	adds	r3, #28
	block->ref_count = 1;
    8c84:	2501      	movs	r5, #1
    8c86:	54c5      	strb	r5, [r0, r3]
	if (used > memory_used_max) memory_used_max = used;
    8c88:	880d      	ldrh	r5, [r1, #0]
    8c8a:	42aa      	cmp	r2, r5
	memory_pool_first_mask = index;
	used = memory_used + 1;
	memory_used = used;
	__enable_irq();
	index = p - memory_pool_available_mask;
	block = memory_pool + ((index << 5) + (31 - n));
    8c8c:	4418      	add	r0, r3
	block->ref_count = 1;
	if (used > memory_used_max) memory_used_max = used;
    8c8e:	bf88      	it	hi
    8c90:	800c      	strhhi	r4, [r1, #0]
	//Serial.print("alloc:");
	//Serial.println((uint32_t)block, HEX);
	return block;
}
    8c92:	bcf0      	pop	{r4, r5, r6, r7}
    8c94:	4770      	bx	lr
    8c96:	bf00      	nop
    8c98:	200045c2 	.word	0x200045c2
    8c9c:	200045a8 	.word	0x200045a8
    8ca0:	200045c4 	.word	0x200045c4
    8ca4:	200045a0 	.word	0x200045a0
    8ca8:	2000459c 	.word	0x2000459c

00008cac <AudioStream::release(audio_block_struct*)>:
// other streams have ownership, the block is
// returned to the free pool
void AudioStream::release(audio_block_t *block)
{
	//if (block == NULL) return;
	uint32_t mask = (0x80000000 >> (31 - (block->memory_pool_index & 0x1F)));
    8cac:	8842      	ldrh	r2, [r0, #2]
	uint32_t index = block->memory_pool_index >> 5;

	__disable_irq();
    8cae:	b672      	cpsid	i
	if (block->ref_count > 1) {
    8cb0:	7803      	ldrb	r3, [r0, #0]
    8cb2:	2b01      	cmp	r3, #1
    8cb4:	d903      	bls.n	8cbe <AudioStream::release(audio_block_struct*)+0x12>
		block->ref_count--;
    8cb6:	3b01      	subs	r3, #1
    8cb8:	7003      	strb	r3, [r0, #0]
		//Serial.println((uint32_t)block, HEX);
		memory_pool_available_mask[index] |= mask;
		if (index < memory_pool_first_mask) memory_pool_first_mask = index;
		memory_used--;
	}
	__enable_irq();
    8cba:	b662      	cpsie	i
    8cbc:	4770      	bx	lr
// returned to the free pool
void AudioStream::release(audio_block_t *block)
{
	//if (block == NULL) return;
	uint32_t mask = (0x80000000 >> (31 - (block->memory_pool_index & 0x1F)));
	uint32_t index = block->memory_pool_index >> 5;
    8cbe:	1153      	asrs	r3, r2, #5

// Release ownership of a data block.  If no
// other streams have ownership, the block is
// returned to the free pool
void AudioStream::release(audio_block_t *block)
{
    8cc0:	b470      	push	{r4, r5, r6}
	if (block->ref_count > 1) {
		block->ref_count--;
	} else {
		//Serial.print("reles:");
		//Serial.println((uint32_t)block, HEX);
		memory_pool_available_mask[index] |= mask;
    8cc2:	4c0c      	ldr	r4, [pc, #48]	; (8cf4 <AudioStream::release(audio_block_struct*)+0x48>)
		if (index < memory_pool_first_mask) memory_pool_first_mask = index;
    8cc4:	4d0c      	ldr	r5, [pc, #48]	; (8cf8 <AudioStream::release(audio_block_struct*)+0x4c>)
	if (block->ref_count > 1) {
		block->ref_count--;
	} else {
		//Serial.print("reles:");
		//Serial.println((uint32_t)block, HEX);
		memory_pool_available_mask[index] |= mask;
    8cc6:	f854 1023 	ldr.w	r1, [r4, r3, lsl #2]
		if (index < memory_pool_first_mask) memory_pool_first_mask = index;
    8cca:	882e      	ldrh	r6, [r5, #0]
	if (block->ref_count > 1) {
		block->ref_count--;
	} else {
		//Serial.print("reles:");
		//Serial.println((uint32_t)block, HEX);
		memory_pool_available_mask[index] |= mask;
    8ccc:	43d2      	mvns	r2, r2
    8cce:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    8cd2:	f002 021f 	and.w	r2, r2, #31
    8cd6:	fa20 f202 	lsr.w	r2, r0, r2
    8cda:	4311      	orrs	r1, r2
		if (index < memory_pool_first_mask) memory_pool_first_mask = index;
		memory_used--;
    8cdc:	4a07      	ldr	r2, [pc, #28]	; (8cfc <AudioStream::release(audio_block_struct*)+0x50>)
	if (block->ref_count > 1) {
		block->ref_count--;
	} else {
		//Serial.print("reles:");
		//Serial.println((uint32_t)block, HEX);
		memory_pool_available_mask[index] |= mask;
    8cde:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
		if (index < memory_pool_first_mask) memory_pool_first_mask = index;
    8ce2:	42b3      	cmp	r3, r6
    8ce4:	bf38      	it	cc
    8ce6:	802b      	strhcc	r3, [r5, #0]
		memory_used--;
    8ce8:	8813      	ldrh	r3, [r2, #0]
    8cea:	3b01      	subs	r3, #1
    8cec:	8013      	strh	r3, [r2, #0]
	}
	__enable_irq();
    8cee:	b662      	cpsie	i
}
    8cf0:	bc70      	pop	{r4, r5, r6}
    8cf2:	4770      	bx	lr
    8cf4:	200045a8 	.word	0x200045a8
    8cf8:	200045c2 	.word	0x200045c2
    8cfc:	200045c4 	.word	0x200045c4

00008d00 <AudioStream::transmit(audio_block_struct*, unsigned char)>:
// by the caller after it's transmitted.  This allows the
// caller to transmit to same block to more than 1 output,
// and then release it once after all transmit calls.
void AudioStream::transmit(audio_block_t *block, unsigned char index)
{
	for (AudioConnection *c = destination_list; c != NULL; c = c->next_dest) {
    8d00:	68c3      	ldr	r3, [r0, #12]
    8d02:	b1b3      	cbz	r3, 8d32 <AudioStream::transmit(audio_block_struct*, unsigned char)+0x32>
// owned by this object.  Normally, a block must be released
// by the caller after it's transmitted.  This allows the
// caller to transmit to same block to more than 1 output,
// and then release it once after all transmit calls.
void AudioStream::transmit(audio_block_t *block, unsigned char index)
{
    8d04:	b430      	push	{r4, r5}
    8d06:	e001      	b.n	8d0c <AudioStream::transmit(audio_block_struct*, unsigned char)+0xc>
	for (AudioConnection *c = destination_list; c != NULL; c = c->next_dest) {
    8d08:	68db      	ldr	r3, [r3, #12]
    8d0a:	b18b      	cbz	r3, 8d30 <AudioStream::transmit(audio_block_struct*, unsigned char)+0x30>
		if (c->src_index == index) {
    8d0c:	7a18      	ldrb	r0, [r3, #8]
    8d0e:	4290      	cmp	r0, r2
    8d10:	d1fa      	bne.n	8d08 <AudioStream::transmit(audio_block_struct*, unsigned char)+0x8>
			if (c->dst.inputQueue[c->dest_index] == NULL) {
    8d12:	6858      	ldr	r0, [r3, #4]
    8d14:	7a5c      	ldrb	r4, [r3, #9]
    8d16:	6900      	ldr	r0, [r0, #16]
    8d18:	f850 5024 	ldr.w	r5, [r0, r4, lsl #2]
    8d1c:	2d00      	cmp	r5, #0
    8d1e:	d1f3      	bne.n	8d08 <AudioStream::transmit(audio_block_struct*, unsigned char)+0x8>
				c->dst.inputQueue[c->dest_index] = block;
    8d20:	f840 1024 	str.w	r1, [r0, r4, lsl #2]
				block->ref_count++;
    8d24:	7808      	ldrb	r0, [r1, #0]
    8d26:	3001      	adds	r0, #1
    8d28:	7008      	strb	r0, [r1, #0]
// by the caller after it's transmitted.  This allows the
// caller to transmit to same block to more than 1 output,
// and then release it once after all transmit calls.
void AudioStream::transmit(audio_block_t *block, unsigned char index)
{
	for (AudioConnection *c = destination_list; c != NULL; c = c->next_dest) {
    8d2a:	68db      	ldr	r3, [r3, #12]
    8d2c:	2b00      	cmp	r3, #0
    8d2e:	d1ed      	bne.n	8d0c <AudioStream::transmit(audio_block_struct*, unsigned char)+0xc>
				c->dst.inputQueue[c->dest_index] = block;
				block->ref_count++;
			}
		}
	}
}
    8d30:	bc30      	pop	{r4, r5}
    8d32:	4770      	bx	lr

00008d34 <AudioStream::receiveReadOnly(unsigned int)>:
// may be shared with other streams, so it must not be written
audio_block_t * AudioStream::receiveReadOnly(unsigned int index)
{
	audio_block_t *in;

	if (index >= num_inputs) return NULL;
    8d34:	7a43      	ldrb	r3, [r0, #9]
    8d36:	428b      	cmp	r3, r1
    8d38:	d906      	bls.n	8d48 <AudioStream::receiveReadOnly(unsigned int)+0x14>
	in = inputQueue[index];
    8d3a:	6903      	ldr	r3, [r0, #16]
	inputQueue[index] = NULL;
    8d3c:	2200      	movs	r2, #0
audio_block_t * AudioStream::receiveReadOnly(unsigned int index)
{
	audio_block_t *in;

	if (index >= num_inputs) return NULL;
	in = inputQueue[index];
    8d3e:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
	inputQueue[index] = NULL;
    8d42:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
	return in;
    8d46:	4770      	bx	lr
// may be shared with other streams, so it must not be written
audio_block_t * AudioStream::receiveReadOnly(unsigned int index)
{
	audio_block_t *in;

	if (index >= num_inputs) return NULL;
    8d48:	2000      	movs	r0, #0
	in = inputQueue[index];
	inputQueue[index] = NULL;
	return in;
}
    8d4a:	4770      	bx	lr

00008d4c <AudioStream::receiveWritable(unsigned int)>:

// Receive block from an input.  The block will not
// be shared, so its contents may be changed.
audio_block_t * AudioStream::receiveWritable(unsigned int index)
{
    8d4c:	b538      	push	{r3, r4, r5, lr}
	audio_block_t *in, *p;

	if (index >= num_inputs) return NULL;
    8d4e:	7a43      	ldrb	r3, [r0, #9]
    8d50:	428b      	cmp	r3, r1
    8d52:	d91a      	bls.n	8d8a <AudioStream::receiveWritable(unsigned int)+0x3e>
	in = inputQueue[index];
    8d54:	6903      	ldr	r3, [r0, #16]
    8d56:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
	inputQueue[index] = NULL;
    8d5a:	2200      	movs	r2, #0
    8d5c:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
	if (in && in->ref_count > 1) {
    8d60:	b19c      	cbz	r4, 8d8a <AudioStream::receiveWritable(unsigned int)+0x3e>
    8d62:	7823      	ldrb	r3, [r4, #0]
    8d64:	2b01      	cmp	r3, #1
    8d66:	d90e      	bls.n	8d86 <AudioStream::receiveWritable(unsigned int)+0x3a>
		p = allocate();
    8d68:	f7ff ff4c 	bl	8c04 <AudioStream::allocate()>
		if (p) memcpy(p->data, in->data, sizeof(p->data));
    8d6c:	4605      	mov	r5, r0
    8d6e:	b128      	cbz	r0, 8d7c <AudioStream::receiveWritable(unsigned int)+0x30>
    8d70:	f44f 7280 	mov.w	r2, #256	; 0x100
    8d74:	1d21      	adds	r1, r4, #4
    8d76:	3004      	adds	r0, #4
    8d78:	f000 fd9a 	bl	98b0 <memcpy>
		in->ref_count--;
    8d7c:	7823      	ldrb	r3, [r4, #0]
    8d7e:	3b01      	subs	r3, #1
    8d80:	7023      	strb	r3, [r4, #0]

	if (index >= num_inputs) return NULL;
	in = inputQueue[index];
	inputQueue[index] = NULL;
	if (in && in->ref_count > 1) {
		p = allocate();
    8d82:	4628      	mov	r0, r5
    8d84:	bd38      	pop	{r3, r4, r5, pc}
    8d86:	4620      	mov	r0, r4
		if (p) memcpy(p->data, in->data, sizeof(p->data));
		in->ref_count--;
		in = p;
	}
	return in;
}
    8d88:	bd38      	pop	{r3, r4, r5, pc}
// be shared, so its contents may be changed.
audio_block_t * AudioStream::receiveWritable(unsigned int index)
{
	audio_block_t *in, *p;

	if (index >= num_inputs) return NULL;
    8d8a:	2000      	movs	r0, #0
    8d8c:	bd38      	pop	{r3, r4, r5, pc}
    8d8e:	bf00      	nop

00008d90 <AudioConnection::connect()>:

void AudioConnection::connect(void)
{
	AudioConnection *p;

	if (isConnected) return;
    8d90:	7c03      	ldrb	r3, [r0, #16]
    8d92:	bb23      	cbnz	r3, 8dde <AudioConnection::connect()+0x4e>
	if (dest_index > dst.num_inputs) return;
    8d94:	6843      	ldr	r3, [r0, #4]
    8d96:	7a42      	ldrb	r2, [r0, #9]
    8d98:	7a5b      	ldrb	r3, [r3, #9]
    8d9a:	429a      	cmp	r2, r3
    8d9c:	d81f      	bhi.n	8dde <AudioConnection::connect()+0x4e>
	return in;
}


void AudioConnection::connect(void)
{
    8d9e:	b430      	push	{r4, r5}
	AudioConnection *p;

	if (isConnected) return;
	if (dest_index > dst.num_inputs) return;
	__disable_irq();
    8da0:	b672      	cpsid	i
	p = src.destination_list;
    8da2:	6804      	ldr	r4, [r0, #0]
    8da4:	68e3      	ldr	r3, [r4, #12]
	if (p == NULL) {
    8da6:	b32b      	cbz	r3, 8df4 <AudioConnection::connect()+0x64>
		src.destination_list = this;
	} else {
		while (p->next_dest) {
    8da8:	68da      	ldr	r2, [r3, #12]
    8daa:	b132      	cbz	r2, 8dba <AudioConnection::connect()+0x2a>
			if (&p->src == &this->src && &p->dst == &this->dst
    8dac:	6819      	ldr	r1, [r3, #0]
    8dae:	428c      	cmp	r4, r1
    8db0:	d016      	beq.n	8de0 <AudioConnection::connect()+0x50>
	return in;
}


void AudioConnection::connect(void)
{
    8db2:	4613      	mov	r3, r2
	__disable_irq();
	p = src.destination_list;
	if (p == NULL) {
		src.destination_list = this;
	} else {
		while (p->next_dest) {
    8db4:	68da      	ldr	r2, [r3, #12]
    8db6:	2a00      	cmp	r2, #0
    8db8:	d1f8      	bne.n	8dac <AudioConnection::connect()+0x1c>
				__enable_irq();
				return;
			}
			p = p->next_dest;
		}
		p->next_dest = this;
    8dba:	60d8      	str	r0, [r3, #12]
	}
	this->next_dest = NULL;
    8dbc:	2300      	movs	r3, #0
    8dbe:	60c3      	str	r3, [r0, #12]
	src.numConnections++;
    8dc0:	7aa3      	ldrb	r3, [r4, #10]
    8dc2:	3301      	adds	r3, #1
    8dc4:	72a3      	strb	r3, [r4, #10]
	src.active = true;
    8dc6:	6802      	ldr	r2, [r0, #0]

	dst.numConnections++;
    8dc8:	6841      	ldr	r1, [r0, #4]
		}
		p->next_dest = this;
	}
	this->next_dest = NULL;
	src.numConnections++;
	src.active = true;
    8dca:	2301      	movs	r3, #1
    8dcc:	7213      	strb	r3, [r2, #8]

	dst.numConnections++;
    8dce:	7a8a      	ldrb	r2, [r1, #10]
    8dd0:	441a      	add	r2, r3
    8dd2:	728a      	strb	r2, [r1, #10]
	dst.active = true;
    8dd4:	6842      	ldr	r2, [r0, #4]
    8dd6:	7213      	strb	r3, [r2, #8]

	isConnected = true;
    8dd8:	7403      	strb	r3, [r0, #16]

	__enable_irq();
    8dda:	b662      	cpsie	i
}
    8ddc:	bc30      	pop	{r4, r5}
    8dde:	4770      	bx	lr
	p = src.destination_list;
	if (p == NULL) {
		src.destination_list = this;
	} else {
		while (p->next_dest) {
			if (&p->src == &this->src && &p->dst == &this->dst
    8de0:	685d      	ldr	r5, [r3, #4]
    8de2:	6841      	ldr	r1, [r0, #4]
    8de4:	428d      	cmp	r5, r1
    8de6:	d1e4      	bne.n	8db2 <AudioConnection::connect()+0x22>
				&& p->src_index == this->src_index && p->dest_index == this->dest_index) {
    8de8:	8919      	ldrh	r1, [r3, #8]
    8dea:	8903      	ldrh	r3, [r0, #8]
    8dec:	4299      	cmp	r1, r3
    8dee:	d0f4      	beq.n	8dda <AudioConnection::connect()+0x4a>
	return in;
}


void AudioConnection::connect(void)
{
    8df0:	4613      	mov	r3, r2
    8df2:	e7df      	b.n	8db4 <AudioConnection::connect()+0x24>
	if (isConnected) return;
	if (dest_index > dst.num_inputs) return;
	__disable_irq();
	p = src.destination_list;
	if (p == NULL) {
		src.destination_list = this;
    8df4:	60e0      	str	r0, [r4, #12]
    8df6:	e7e1      	b.n	8dbc <AudioConnection::connect()+0x2c>

00008df8 <AudioConnection::disconnect()>:

void AudioConnection::disconnect(void)
{
	AudioConnection *p;

	if (!isConnected) return;
    8df8:	7c03      	ldrb	r3, [r0, #16]

	__enable_irq();
}

void AudioConnection::disconnect(void)
{
    8dfa:	b510      	push	{r4, lr}
	AudioConnection *p;

	if (!isConnected) return;
    8dfc:	2b00      	cmp	r3, #0
    8dfe:	d032      	beq.n	8e66 <AudioConnection::disconnect()+0x6e>
	if (dest_index > dst.num_inputs) return;
    8e00:	6843      	ldr	r3, [r0, #4]
    8e02:	7a42      	ldrb	r2, [r0, #9]
    8e04:	7a5b      	ldrb	r3, [r3, #9]
    8e06:	429a      	cmp	r2, r3
    8e08:	d82d      	bhi.n	8e66 <AudioConnection::disconnect()+0x6e>
	__disable_irq();
    8e0a:	b672      	cpsid	i
	// Remove destination from source list
	p = src.destination_list;
    8e0c:	6802      	ldr	r2, [r0, #0]
    8e0e:	68d3      	ldr	r3, [r2, #12]
	if (p == NULL) {
    8e10:	b343      	cbz	r3, 8e64 <AudioConnection::disconnect()+0x6c>
//>>> PAH re-enable the IRQ
		__enable_irq();
		return;
	} else if (p == this) {
    8e12:	4298      	cmp	r0, r3
    8e14:	d102      	bne.n	8e1c <AudioConnection::disconnect()+0x24>
    8e16:	e029      	b.n	8e6c <AudioConnection::disconnect()+0x74>
		} else {
			src.destination_list = NULL;
		}
	} else {
		while (p) {
			if (p == this) {
    8e18:	4298      	cmp	r0, r3
    8e1a:	d002      	beq.n	8e22 <AudioConnection::disconnect()+0x2a>
				} else {
					p = NULL;
					break;
				}
			}
			p = p->next_dest;
    8e1c:	68db      	ldr	r3, [r3, #12]
			src.destination_list = next_dest;
		} else {
			src.destination_list = NULL;
		}
	} else {
		while (p) {
    8e1e:	2b00      	cmp	r3, #0
    8e20:	d1fa      	bne.n	8e18 <AudioConnection::disconnect()+0x20>
			p = p->next_dest;
		}
	}
//>>> PAH release the audio buffer properly
	//Remove possible pending src block from destination
	if(dst.inputQueue[dest_index] != NULL) {
    8e22:	6843      	ldr	r3, [r0, #4]
    8e24:	7a41      	ldrb	r1, [r0, #9]
    8e26:	691b      	ldr	r3, [r3, #16]
    8e28:	4604      	mov	r4, r0
    8e2a:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
    8e2e:	b148      	cbz	r0, 8e44 <AudioConnection::disconnect()+0x4c>
		AudioStream::release(dst.inputQueue[dest_index]);
    8e30:	f7ff ff3c 	bl	8cac <AudioStream::release(audio_block_struct*)>
		// release() re-enables the IRQ. Need it to be disabled a little longer
		__disable_irq();
    8e34:	b672      	cpsid	i
		dst.inputQueue[dest_index] = NULL;
    8e36:	6863      	ldr	r3, [r4, #4]
    8e38:	7a62      	ldrb	r2, [r4, #9]
    8e3a:	691b      	ldr	r3, [r3, #16]
    8e3c:	2100      	movs	r1, #0
    8e3e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    8e42:	6822      	ldr	r2, [r4, #0]
	}

	//Check if the disconnected AudioStream objects should still be active
	src.numConnections--;
    8e44:	7a93      	ldrb	r3, [r2, #10]
    8e46:	3b01      	subs	r3, #1
    8e48:	7293      	strb	r3, [r2, #10]
	if (src.numConnections == 0) {
    8e4a:	6823      	ldr	r3, [r4, #0]
    8e4c:	7a9a      	ldrb	r2, [r3, #10]
    8e4e:	b902      	cbnz	r2, 8e52 <AudioConnection::disconnect()+0x5a>
		src.active = false;
    8e50:	721a      	strb	r2, [r3, #8]
	}

	dst.numConnections--;
    8e52:	6862      	ldr	r2, [r4, #4]
    8e54:	7a93      	ldrb	r3, [r2, #10]
    8e56:	3b01      	subs	r3, #1
    8e58:	7293      	strb	r3, [r2, #10]
	if (dst.numConnections == 0) {
    8e5a:	6863      	ldr	r3, [r4, #4]
    8e5c:	7a9a      	ldrb	r2, [r3, #10]
    8e5e:	b11a      	cbz	r2, 8e68 <AudioConnection::disconnect()+0x70>
		dst.active = false;
	}

	isConnected = false;
    8e60:	2300      	movs	r3, #0
    8e62:	7423      	strb	r3, [r4, #16]

	__enable_irq();
    8e64:	b662      	cpsie	i
    8e66:	bd10      	pop	{r4, pc}
		src.active = false;
	}

	dst.numConnections--;
	if (dst.numConnections == 0) {
		dst.active = false;
    8e68:	721a      	strb	r2, [r3, #8]
    8e6a:	e7f9      	b.n	8e60 <AudioConnection::disconnect()+0x68>
	if (p == NULL) {
//>>> PAH re-enable the IRQ
		__enable_irq();
		return;
	} else if (p == this) {
		if (p->next_dest) {
    8e6c:	68c3      	ldr	r3, [r0, #12]
			src.destination_list = next_dest;
		} else {
			src.destination_list = NULL;
    8e6e:	60d3      	str	r3, [r2, #12]
    8e70:	e7d7      	b.n	8e22 <AudioConnection::disconnect()+0x2a>
    8e72:	bf00      	nop

00008e74 <AudioStream::update_setup()>:
// their constructors.
bool AudioStream::update_scheduled = false;

bool AudioStream::update_setup(void)
{
	if (update_scheduled) return false;
    8e74:	4b08      	ldr	r3, [pc, #32]	; (8e98 <AudioStream::update_setup()+0x24>)
    8e76:	781a      	ldrb	r2, [r3, #0]
    8e78:	b962      	cbnz	r2, 8e94 <AudioStream::update_setup()+0x20>
// input and output based on interrupts, must check this variable in
// their constructors.
bool AudioStream::update_scheduled = false;

bool AudioStream::update_setup(void)
{
    8e7a:	b430      	push	{r4, r5}
	if (update_scheduled) return false;
	NVIC_SET_PRIORITY(IRQ_SOFTWARE, 208); // 255 = lowest priority
    8e7c:	4807      	ldr	r0, [pc, #28]	; (8e9c <AudioStream::update_setup()+0x28>)
	NVIC_ENABLE_IRQ(IRQ_SOFTWARE);
    8e7e:	4908      	ldr	r1, [pc, #32]	; (8ea0 <AudioStream::update_setup()+0x2c>)
bool AudioStream::update_scheduled = false;

bool AudioStream::update_setup(void)
{
	if (update_scheduled) return false;
	NVIC_SET_PRIORITY(IRQ_SOFTWARE, 208); // 255 = lowest priority
    8e80:	25d0      	movs	r5, #208	; 0xd0
    8e82:	7005      	strb	r5, [r0, #0]
	NVIC_ENABLE_IRQ(IRQ_SOFTWARE);
    8e84:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
	update_scheduled = true;
    8e88:	2201      	movs	r2, #1

bool AudioStream::update_setup(void)
{
	if (update_scheduled) return false;
	NVIC_SET_PRIORITY(IRQ_SOFTWARE, 208); // 255 = lowest priority
	NVIC_ENABLE_IRQ(IRQ_SOFTWARE);
    8e8a:	600c      	str	r4, [r1, #0]
	update_scheduled = true;
	return true;
    8e8c:	4610      	mov	r0, r2
bool AudioStream::update_setup(void)
{
	if (update_scheduled) return false;
	NVIC_SET_PRIORITY(IRQ_SOFTWARE, 208); // 255 = lowest priority
	NVIC_ENABLE_IRQ(IRQ_SOFTWARE);
	update_scheduled = true;
    8e8e:	701a      	strb	r2, [r3, #0]
	return true;
}
    8e90:	bc30      	pop	{r4, r5}
    8e92:	4770      	bx	lr
// their constructors.
bool AudioStream::update_scheduled = false;

bool AudioStream::update_setup(void)
{
	if (update_scheduled) return false;
    8e94:	2000      	movs	r0, #0
    8e96:	4770      	bx	lr
    8e98:	200045a4 	.word	0x200045a4
    8e9c:	e000e45e 	.word	0xe000e45e
    8ea0:	e000e108 	.word	0xe000e108

00008ea4 <software_isr>:

void software_isr(void) // AudioStream::update_all()
{
	AudioStream *p;

	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    8ea4:	491a      	ldr	r1, [pc, #104]	; (8f10 <software_isr+0x6c>)
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
    8ea6:	4a1b      	ldr	r2, [pc, #108]	; (8f14 <software_isr+0x70>)
	uint32_t totalcycles = ARM_DWT_CYCCNT;
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    8ea8:	481b      	ldr	r0, [pc, #108]	; (8f18 <software_isr+0x74>)
}

AudioStream * AudioStream::first_update = NULL;

void software_isr(void) // AudioStream::update_all()
{
    8eaa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	AudioStream *p;

	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    8eac:	680b      	ldr	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
	uint32_t totalcycles = ARM_DWT_CYCCNT;
    8eae:	4d1b      	ldr	r5, [pc, #108]	; (8f1c <software_isr+0x78>)
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    8eb0:	6804      	ldr	r4, [r0, #0]

void software_isr(void) // AudioStream::update_all()
{
	AudioStream *p;

	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    8eb2:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    8eb6:	600b      	str	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
    8eb8:	6813      	ldr	r3, [r2, #0]
    8eba:	f043 0301 	orr.w	r3, r3, #1
    8ebe:	6013      	str	r3, [r2, #0]
	uint32_t totalcycles = ARM_DWT_CYCCNT;
    8ec0:	682e      	ldr	r6, [r5, #0]
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    8ec2:	b914      	cbnz	r4, 8eca <software_isr+0x26>
    8ec4:	e015      	b.n	8ef2 <software_isr+0x4e>
    8ec6:	6964      	ldr	r4, [r4, #20]
    8ec8:	b19c      	cbz	r4, 8ef2 <software_isr+0x4e>
		if (p->active) {
    8eca:	7a23      	ldrb	r3, [r4, #8]
    8ecc:	2b00      	cmp	r3, #0
    8ece:	d0fa      	beq.n	8ec6 <software_isr+0x22>
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
    8ed0:	6823      	ldr	r3, [r4, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
	uint32_t totalcycles = ARM_DWT_CYCCNT;
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
		if (p->active) {
			uint32_t cycles = ARM_DWT_CYCCNT;
    8ed2:	682f      	ldr	r7, [r5, #0]
			p->update();
    8ed4:	681b      	ldr	r3, [r3, #0]
    8ed6:	4620      	mov	r0, r4
    8ed8:	4798      	blx	r3
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 4;
    8eda:	682b      	ldr	r3, [r5, #0]
			p->cpu_cycles = cycles;
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
    8edc:	88e1      	ldrh	r1, [r4, #6]
		if (p->active) {
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 4;
    8ede:	1bdb      	subs	r3, r3, r7
    8ee0:	091b      	lsrs	r3, r3, #4
			p->cpu_cycles = cycles;
    8ee2:	b29a      	uxth	r2, r3
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
    8ee4:	428b      	cmp	r3, r1
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 4;
			p->cpu_cycles = cycles;
    8ee6:	80a2      	strh	r2, [r4, #4]
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
    8ee8:	bf88      	it	hi
    8eea:	80e2      	strhhi	r2, [r4, #6]

	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
	uint32_t totalcycles = ARM_DWT_CYCCNT;
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    8eec:	6964      	ldr	r4, [r4, #20]
    8eee:	2c00      	cmp	r4, #0
    8ef0:	d1eb      	bne.n	8eca <software_isr+0x26>
			p->cpu_cycles = cycles;
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;;
    8ef2:	4b0a      	ldr	r3, [pc, #40]	; (8f1c <software_isr+0x78>)
	AudioStream::cpu_cycles_total = totalcycles;
	if (totalcycles > AudioStream::cpu_cycles_total_max)
    8ef4:	4a0a      	ldr	r2, [pc, #40]	; (8f20 <software_isr+0x7c>)
			p->cpu_cycles = cycles;
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;;
    8ef6:	681b      	ldr	r3, [r3, #0]
	AudioStream::cpu_cycles_total = totalcycles;
	if (totalcycles > AudioStream::cpu_cycles_total_max)
    8ef8:	8810      	ldrh	r0, [r2, #0]
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;;
	AudioStream::cpu_cycles_total = totalcycles;
    8efa:	4c0a      	ldr	r4, [pc, #40]	; (8f24 <software_isr+0x80>)
			p->cpu_cycles = cycles;
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;;
    8efc:	1b9b      	subs	r3, r3, r6
    8efe:	091b      	lsrs	r3, r3, #4
	AudioStream::cpu_cycles_total = totalcycles;
    8f00:	b299      	uxth	r1, r3
	if (totalcycles > AudioStream::cpu_cycles_total_max)
    8f02:	4283      	cmp	r3, r0
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;;
	AudioStream::cpu_cycles_total = totalcycles;
    8f04:	8021      	strh	r1, [r4, #0]
	if (totalcycles > AudioStream::cpu_cycles_total_max)
    8f06:	d901      	bls.n	8f0c <software_isr+0x68>
		AudioStream::cpu_cycles_total_max = totalcycles;
    8f08:	8011      	strh	r1, [r2, #0]
    8f0a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8f0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8f0e:	bf00      	nop
    8f10:	e000edfc 	.word	0xe000edfc
    8f14:	e0001000 	.word	0xe0001000
    8f18:	20004598 	.word	0x20004598
    8f1c:	e0001004 	.word	0xe0001004
    8f20:	200045c0 	.word	0x200045c0
    8f24:	200045c6 	.word	0x200045c6

00008f28 <DMAChannel::begin(bool)>:
/**                     Teensy 3.0 & 3.1                       **/
/****************************************************************/
#if defined(KINETISK)

void DMAChannel::begin(bool force_initialization)
{
    8f28:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t ch = 0;

	__disable_irq();
    8f2a:	b672      	cpsid	i
	if (!force_initialization && TCD && channel < DMA_MAX_CHANNELS
    8f2c:	b999      	cbnz	r1, 8f56 <DMAChannel::begin(bool)+0x2e>
    8f2e:	6802      	ldr	r2, [r0, #0]
    8f30:	b18a      	cbz	r2, 8f56 <DMAChannel::begin(bool)+0x2e>
    8f32:	7903      	ldrb	r3, [r0, #4]
    8f34:	2b0f      	cmp	r3, #15
    8f36:	d80e      	bhi.n	8f56 <DMAChannel::begin(bool)+0x2e>
	  && (dma_channel_allocated_mask & (1 << channel))
    8f38:	4c27      	ldr	r4, [pc, #156]	; (8fd8 <DMAChannel::begin(bool)+0xb0>)
    8f3a:	8821      	ldrh	r1, [r4, #0]
    8f3c:	fa41 f503 	asr.w	r5, r1, r3
    8f40:	07ed      	lsls	r5, r5, #31
    8f42:	d50a      	bpl.n	8f5a <DMAChannel::begin(bool)+0x32>
	  && (uint32_t)TCD == (uint32_t)(0x40009000 + channel * 32)) {
    8f44:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
    8f48:	f503 6390 	add.w	r3, r3, #1152	; 0x480
    8f4c:	ebb2 1f43 	cmp.w	r2, r3, lsl #5
    8f50:	d103      	bne.n	8f5a <DMAChannel::begin(bool)+0x32>
		// DMA channel already allocated
		__enable_irq();
    8f52:	b662      	cpsie	i
		return;
    8f54:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8f56:	4c20      	ldr	r4, [pc, #128]	; (8fd8 <DMAChannel::begin(bool)+0xb0>)
    8f58:	8821      	ldrh	r1, [r4, #0]
/**                     Teensy 3.0 & 3.1                       **/
/****************************************************************/
#if defined(KINETISK)

void DMAChannel::begin(bool force_initialization)
{
    8f5a:	2300      	movs	r3, #0
		// DMA channel already allocated
		__enable_irq();
		return;
	}
	while (1) {
		if (!(dma_channel_allocated_mask & (1 << ch))) {
    8f5c:	fa41 f203 	asr.w	r2, r1, r3
    8f60:	f012 0201 	ands.w	r2, r2, #1
    8f64:	d007      	beq.n	8f76 <DMAChannel::begin(bool)+0x4e>
			dma_channel_allocated_mask |= (1 << ch);
			__enable_irq();
			break;
		}
		if (++ch >= DMA_MAX_CHANNELS) {
    8f66:	3301      	adds	r3, #1
    8f68:	2b10      	cmp	r3, #16
    8f6a:	d1f7      	bne.n	8f5c <DMAChannel::begin(bool)+0x34>
			__enable_irq();
    8f6c:	b662      	cpsie	i
			TCD = (TCD_t *)0;
    8f6e:	2200      	movs	r2, #0
			channel = DMA_MAX_CHANNELS;
    8f70:	7103      	strb	r3, [r0, #4]
			__enable_irq();
			break;
		}
		if (++ch >= DMA_MAX_CHANNELS) {
			__enable_irq();
			TCD = (TCD_t *)0;
    8f72:	6002      	str	r2, [r0, #0]
    8f74:	bdf0      	pop	{r4, r5, r6, r7, pc}
		__enable_irq();
		return;
	}
	while (1) {
		if (!(dma_channel_allocated_mask & (1 << ch))) {
			dma_channel_allocated_mask |= (1 << ch);
    8f76:	2501      	movs	r5, #1
    8f78:	409d      	lsls	r5, r3
    8f7a:	4329      	orrs	r1, r5
    8f7c:	8021      	strh	r1, [r4, #0]
			__enable_irq();
    8f7e:	b662      	cpsie	i
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    8f80:	4e16      	ldr	r6, [pc, #88]	; (8fdc <DMAChannel::begin(bool)+0xb4>)
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    8f82:	4d17      	ldr	r5, [pc, #92]	; (8fe0 <DMAChannel::begin(bool)+0xb8>)
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
    8f84:	4f17      	ldr	r7, [pc, #92]	; (8fe4 <DMAChannel::begin(bool)+0xbc>)
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
    8f86:	f8df e064 	ldr.w	lr, [pc, #100]	; 8fec <DMAChannel::begin(bool)+0xc4>
			channel = DMA_MAX_CHANNELS;
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
    8f8a:	b2d9      	uxtb	r1, r3
    8f8c:	7101      	strb	r1, [r0, #4]
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    8f8e:	6834      	ldr	r4, [r6, #0]
    8f90:	f044 0402 	orr.w	r4, r4, #2
    8f94:	6034      	str	r4, [r6, #0]
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    8f96:	682c      	ldr	r4, [r5, #0]
    8f98:	f044 0402 	orr.w	r4, r4, #2
    8f9c:	602c      	str	r4, [r5, #0]
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
    8f9e:	f5a6 2680 	sub.w	r6, r6, #262144	; 0x40000
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
    8fa2:	2482      	movs	r4, #130	; 0x82
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
    8fa4:	f5a5 2580 	sub.w	r5, r5, #262144	; 0x40000
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    8fa8:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
    8fac:	603c      	str	r4, [r7, #0]
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    8fae:	f503 6390 	add.w	r3, r3, #1152	; 0x480
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
    8fb2:	3e22      	subs	r6, #34	; 0x22
	DMA_CEEI = ch;
    8fb4:	3d24      	subs	r5, #36	; 0x24
	DMA_CINT = ch;
    8fb6:	4c0c      	ldr	r4, [pc, #48]	; (8fe8 <DMAChannel::begin(bool)+0xc0>)
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
    8fb8:	f88e 1000 	strb.w	r1, [lr]
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    8fbc:	015b      	lsls	r3, r3, #5
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
    8fbe:	7031      	strb	r1, [r6, #0]
	DMA_CEEI = ch;
    8fc0:	7029      	strb	r1, [r5, #0]
	DMA_CINT = ch;
    8fc2:	7021      	strb	r1, [r4, #0]
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    8fc4:	6003      	str	r3, [r0, #0]
	uint32_t *p = (uint32_t *)TCD;
	*p++ = 0;
    8fc6:	601a      	str	r2, [r3, #0]
	*p++ = 0;
    8fc8:	605a      	str	r2, [r3, #4]
	*p++ = 0;
    8fca:	609a      	str	r2, [r3, #8]
	*p++ = 0;
    8fcc:	60da      	str	r2, [r3, #12]
	*p++ = 0;
    8fce:	611a      	str	r2, [r3, #16]
	*p++ = 0;
    8fd0:	615a      	str	r2, [r3, #20]
	*p++ = 0;
    8fd2:	619a      	str	r2, [r3, #24]
	*p++ = 0;
    8fd4:	61da      	str	r2, [r3, #28]
    8fd6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8fd8:	200045c8 	.word	0x200045c8
    8fdc:	40048040 	.word	0x40048040
    8fe0:	4004803c 	.word	0x4004803c
    8fe4:	40008000 	.word	0x40008000
    8fe8:	4000801f 	.word	0x4000801f
    8fec:	4000801a 	.word	0x4000801a

00008ff0 <DMAChannel::release()>:
}

void DMAChannel::release(void)
{
	if (channel >= DMA_MAX_CHANNELS) return;
    8ff0:	7903      	ldrb	r3, [r0, #4]
    8ff2:	2b0f      	cmp	r3, #15
    8ff4:	d811      	bhi.n	901a <DMAChannel::release()+0x2a>
	DMA_CERQ = channel;
    8ff6:	4a09      	ldr	r2, [pc, #36]	; (901c <DMAChannel::release()+0x2c>)
	*p++ = 0;
	*p++ = 0;
}

void DMAChannel::release(void)
{
    8ff8:	b410      	push	{r4}
	if (channel >= DMA_MAX_CHANNELS) return;
	DMA_CERQ = channel;
    8ffa:	7013      	strb	r3, [r2, #0]
	__disable_irq();
    8ffc:	b672      	cpsid	i
	dma_channel_allocated_mask &= ~(1 << channel);
    8ffe:	4908      	ldr	r1, [pc, #32]	; (9020 <DMAChannel::release()+0x30>)
    9000:	7904      	ldrb	r4, [r0, #4]
    9002:	880a      	ldrh	r2, [r1, #0]
    9004:	2301      	movs	r3, #1
    9006:	40a3      	lsls	r3, r4
    9008:	ea22 0303 	bic.w	r3, r2, r3
    900c:	800b      	strh	r3, [r1, #0]
	__enable_irq();
    900e:	b662      	cpsie	i
	channel = DMA_MAX_CHANNELS;
    9010:	2210      	movs	r2, #16
	TCD = (TCD_t *)0;
    9012:	2300      	movs	r3, #0
}
    9014:	bc10      	pop	{r4}
	if (channel >= DMA_MAX_CHANNELS) return;
	DMA_CERQ = channel;
	__disable_irq();
	dma_channel_allocated_mask &= ~(1 << channel);
	__enable_irq();
	channel = DMA_MAX_CHANNELS;
    9016:	7102      	strb	r2, [r0, #4]
	TCD = (TCD_t *)0;
    9018:	6003      	str	r3, [r0, #0]
}
    901a:	4770      	bx	lr
    901c:	4000801a 	.word	0x4000801a
    9020:	200045c8 	.word	0x200045c8

00009024 <EventResponder::triggerEventNotImmediate()>:
bool EventResponder::runningFromYield = false;

// TODO: interrupt disable/enable needed in many places!!!

void EventResponder::triggerEventNotImmediate()
{
    9024:	b410      	push	{r4}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    9026:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    902a:	b672      	cpsid	i
	bool irq = disableInterrupts();
	if (_triggered == false) {
    902c:	7f43      	ldrb	r3, [r0, #29]
    902e:	b933      	cbnz	r3, 903e <EventResponder::triggerEventNotImmediate()+0x1a>
		// not already triggered
		if (_type == EventTypeYield) {
    9030:	7f01      	ldrb	r1, [r0, #28]
    9032:	2901      	cmp	r1, #1
    9034:	d007      	beq.n	9046 <EventResponder::triggerEventNotImmediate()+0x22>
				_next = nullptr;
				_prev = lastYield;
				_prev->_next = this;
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
    9036:	2903      	cmp	r1, #3
    9038:	d00f      	beq.n	905a <EventResponder::triggerEventNotImmediate()+0x36>
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
		} else {
			// detached, easy :-)
		}
		_triggered = true;
    903a:	2301      	movs	r3, #1
    903c:	7743      	strb	r3, [r0, #29]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    903e:	b902      	cbnz	r2, 9042 <EventResponder::triggerEventNotImmediate()+0x1e>
    9040:	b662      	cpsie	i
	}
	enableInterrupts(irq);
}
    9042:	bc10      	pop	{r4}
    9044:	4770      	bx	lr
	bool irq = disableInterrupts();
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
    9046:	4c12      	ldr	r4, [pc, #72]	; (9090 <EventResponder::triggerEventNotImmediate()+0x6c>)
    9048:	6821      	ldr	r1, [r4, #0]
    904a:	b1a1      	cbz	r1, 9076 <EventResponder::triggerEventNotImmediate()+0x52>
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
				_prev = lastYield;
    904c:	4911      	ldr	r1, [pc, #68]	; (9094 <EventResponder::triggerEventNotImmediate()+0x70>)
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
    904e:	6143      	str	r3, [r0, #20]
				_prev = lastYield;
    9050:	680b      	ldr	r3, [r1, #0]
    9052:	6183      	str	r3, [r0, #24]
				_prev->_next = this;
				lastYield = this;
    9054:	6008      	str	r0, [r1, #0]
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
				_prev = lastYield;
				_prev->_next = this;
    9056:	6158      	str	r0, [r3, #20]
    9058:	e7ef      	b.n	903a <EventResponder::triggerEventNotImmediate()+0x16>
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
    905a:	4c0f      	ldr	r4, [pc, #60]	; (9098 <EventResponder::triggerEventNotImmediate()+0x74>)
    905c:	6821      	ldr	r1, [r4, #0]
    905e:	b181      	cbz	r1, 9082 <EventResponder::triggerEventNotImmediate()+0x5e>
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
				_prev = lastInterrupt;
    9060:	490e      	ldr	r1, [pc, #56]	; (909c <EventResponder::triggerEventNotImmediate()+0x78>)
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
    9062:	6143      	str	r3, [r0, #20]
				_prev = lastInterrupt;
    9064:	680b      	ldr	r3, [r1, #0]
    9066:	6183      	str	r3, [r0, #24]
				_prev->_next = this;
				lastInterrupt = this;
    9068:	6008      	str	r0, [r1, #0]
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
				_prev = lastInterrupt;
				_prev->_next = this;
    906a:	6158      	str	r0, [r3, #20]
				lastInterrupt = this;
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
    906c:	4b0c      	ldr	r3, [pc, #48]	; (90a0 <EventResponder::triggerEventNotImmediate()+0x7c>)
    906e:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
    9072:	6019      	str	r1, [r3, #0]
    9074:	e7e1      	b.n	903a <EventResponder::triggerEventNotImmediate()+0x16>
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
    9076:	4b07      	ldr	r3, [pc, #28]	; (9094 <EventResponder::triggerEventNotImmediate()+0x70>)
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
    9078:	6141      	str	r1, [r0, #20]
				_prev = nullptr;
    907a:	6181      	str	r1, [r0, #24]
				firstYield = this;
    907c:	6020      	str	r0, [r4, #0]
				lastYield = this;
    907e:	6018      	str	r0, [r3, #0]
    9080:	e7db      	b.n	903a <EventResponder::triggerEventNotImmediate()+0x16>
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
    9082:	4b06      	ldr	r3, [pc, #24]	; (909c <EventResponder::triggerEventNotImmediate()+0x78>)
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
    9084:	6141      	str	r1, [r0, #20]
				_prev = nullptr;
    9086:	6181      	str	r1, [r0, #24]
				firstInterrupt = this;
    9088:	6020      	str	r0, [r4, #0]
				lastInterrupt = this;
    908a:	6018      	str	r0, [r3, #0]
    908c:	e7ee      	b.n	906c <EventResponder::triggerEventNotImmediate()+0x48>
    908e:	bf00      	nop
    9090:	200045dc 	.word	0x200045dc
    9094:	200045d8 	.word	0x200045d8
    9098:	200045cc 	.word	0x200045cc
    909c:	200045d0 	.word	0x200045d0
    90a0:	e000ed04 	.word	0xe000ed04

000090a4 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    90a4:	b570      	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    90a6:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    90aa:	b672      	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    90ac:	4c0c      	ldr	r4, [pc, #48]	; (90e0 <EventResponder::runFromInterrupt()+0x3c>)
    90ae:	6820      	ldr	r0, [r4, #0]
		if (first) {
    90b0:	b180      	cbz	r0, 90d4 <EventResponder::runFromInterrupt()+0x30>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    90b2:	4e0c      	ldr	r6, [pc, #48]	; (90e4 <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    90b4:	2500      	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
    90b6:	6943      	ldr	r3, [r0, #20]
    90b8:	6023      	str	r3, [r4, #0]
			if (firstInterrupt) {
    90ba:	b173      	cbz	r3, 90da <EventResponder::runFromInterrupt()+0x36>
				firstInterrupt->_prev = nullptr;
    90bc:	619d      	str	r5, [r3, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    90be:	b902      	cbnz	r2, 90c2 <EventResponder::runFromInterrupt()+0x1e>
    90c0:	b662      	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    90c2:	7745      	strb	r5, [r0, #29]
			(*(first->_function))(*first);
    90c4:	6883      	ldr	r3, [r0, #8]
    90c6:	4798      	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    90c8:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    90cc:	b672      	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    90ce:	6820      	ldr	r0, [r4, #0]
		if (first) {
    90d0:	2800      	cmp	r0, #0
    90d2:	d1f0      	bne.n	90b6 <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    90d4:	b902      	cbnz	r2, 90d8 <EventResponder::runFromInterrupt()+0x34>
    90d6:	b662      	cpsie	i
    90d8:	bd70      	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    90da:	6033      	str	r3, [r6, #0]
    90dc:	e7ef      	b.n	90be <EventResponder::runFromInterrupt()+0x1a>
    90de:	bf00      	nop
    90e0:	200045cc 	.word	0x200045cc
    90e4:	200045d0 	.word	0x200045d0

000090e8 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    90e8:	f7ff bfdc 	b.w	90a4 <EventResponder::runFromInterrupt()>

000090ec <MillisTimer::addToActiveList()>:
	enableTimerInterrupt(irq);
}

void MillisTimer::addToActiveList() // only called by runFromTimer()
{
	if (listActive == nullptr) {
    90ec:	4a18      	ldr	r2, [pc, #96]	; (9150 <MillisTimer::addToActiveList()+0x64>)
	_state = TimerWaiting;
	enableTimerInterrupt(irq);
}

void MillisTimer::addToActiveList() // only called by runFromTimer()
{
    90ee:	b430      	push	{r4, r5}
	if (listActive == nullptr) {
    90f0:	6814      	ldr	r4, [r2, #0]
    90f2:	2c00      	cmp	r4, #0
    90f4:	d027      	beq.n	9146 <MillisTimer::addToActiveList()+0x5a>
		// list is empty, easy case
		_next = nullptr;
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
    90f6:	6803      	ldr	r3, [r0, #0]
    90f8:	6821      	ldr	r1, [r4, #0]
    90fa:	428b      	cmp	r3, r1
    90fc:	d20e      	bcs.n	911c <MillisTimer::addToActiveList()+0x30>
		// this timer triggers before any on the list
		_next = listActive;
		_prev = nullptr;
		listActive->_prev = this;
		// Decrement the next items wait time be our wait time as to properly handle waits for all other items...
		listActive->_ms -= _ms;	
    90fe:	1acb      	subs	r3, r1, r3
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
		// this timer triggers before any on the list
		_next = listActive;
		_prev = nullptr;
    9100:	2100      	movs	r1, #0
		_next = nullptr;
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
		// this timer triggers before any on the list
		_next = listActive;
    9102:	6084      	str	r4, [r0, #8]
		_prev = nullptr;
    9104:	60c1      	str	r1, [r0, #12]
		listActive->_prev = this;
		// Decrement the next items wait time be our wait time as to properly handle waits for all other items...
		listActive->_ms -= _ms;	
    9106:	6023      	str	r3, [r4, #0]
		listActive = this;
	} else if (_ms < listActive->_ms) {
		// this timer triggers before any on the list
		_next = listActive;
		_prev = nullptr;
		listActive->_prev = this;
    9108:	60e0      	str	r0, [r4, #12]
		// Decrement the next items wait time be our wait time as to properly handle waits for all other items...
		listActive->_ms -= _ms;	
		listActive = this;
    910a:	6010      	str	r0, [r2, #0]
		_ms -= timer->_ms;
		_next = nullptr;
		_prev = timer;
		timer->_next = this;
	}
	_state = TimerActive;
    910c:	2302      	movs	r3, #2
    910e:	7503      	strb	r3, [r0, #20]
}
    9110:	bc30      	pop	{r4, r5}
    9112:	4770      	bx	lr
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
    9114:	6811      	ldr	r1, [r2, #0]
    9116:	428b      	cmp	r3, r1
    9118:	4614      	mov	r4, r2
    911a:	d308      	bcc.n	912e <MillisTimer::addToActiveList()+0x42>
		listActive->_ms -= _ms;	
		listActive = this;
	} else {
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
    911c:	68a2      	ldr	r2, [r4, #8]
				_state = TimerActive;
				return;
			}
		}
		// add this time at the end of the list
		_ms -= timer->_ms;
    911e:	1a5b      	subs	r3, r3, r1
    9120:	6003      	str	r3, [r0, #0]
		listActive->_ms -= _ms;	
		listActive = this;
	} else {
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
    9122:	2a00      	cmp	r2, #0
    9124:	d1f6      	bne.n	9114 <MillisTimer::addToActiveList()+0x28>
				return;
			}
		}
		// add this time at the end of the list
		_ms -= timer->_ms;
		_next = nullptr;
    9126:	6082      	str	r2, [r0, #8]
		_prev = timer;
    9128:	60c4      	str	r4, [r0, #12]
		timer->_next = this;
    912a:	60a0      	str	r0, [r4, #8]
    912c:	e7ee      	b.n	910c <MillisTimer::addToActiveList()+0x20>
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
				// found the right place in the middle of list
				_next = timer;
				_prev = timer->_prev;
    912e:	68d2      	ldr	r2, [r2, #12]
    9130:	60c2      	str	r2, [r0, #12]
		while (timer->_next) {
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
				// found the right place in the middle of list
				_next = timer;
    9132:	6084      	str	r4, [r0, #8]
				_prev = timer->_prev;
				timer->_prev = this;
    9134:	60e0      	str	r0, [r4, #12]
				_prev->_next = this;
    9136:	68c5      	ldr	r5, [r0, #12]
				timer->_ms -= _ms;
    9138:	1acb      	subs	r3, r1, r3
				_state = TimerActive;
    913a:	2202      	movs	r2, #2
			if (_ms < timer->_ms) {
				// found the right place in the middle of list
				_next = timer;
				_prev = timer->_prev;
				timer->_prev = this;
				_prev->_next = this;
    913c:	60a8      	str	r0, [r5, #8]
				timer->_ms -= _ms;
    913e:	6023      	str	r3, [r4, #0]
				_state = TimerActive;
    9140:	7502      	strb	r2, [r0, #20]
		_next = nullptr;
		_prev = timer;
		timer->_next = this;
	}
	_state = TimerActive;
}
    9142:	bc30      	pop	{r4, r5}
    9144:	4770      	bx	lr

void MillisTimer::addToActiveList() // only called by runFromTimer()
{
	if (listActive == nullptr) {
		// list is empty, easy case
		_next = nullptr;
    9146:	6084      	str	r4, [r0, #8]
		_prev = nullptr;
    9148:	60c4      	str	r4, [r0, #12]
		listActive = this;
    914a:	6010      	str	r0, [r2, #0]
    914c:	e7de      	b.n	910c <MillisTimer::addToActiveList()+0x20>
    914e:	bf00      	nop
    9150:	200045d4 	.word	0x200045d4

00009154 <MillisTimer::runFromTimer()>:
	}
	enableTimerInterrupt(irq);
}

void MillisTimer::runFromTimer()
{
    9154:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	MillisTimer *timer = listActive;
    9156:	4e22      	ldr	r6, [pc, #136]	; (91e0 <MillisTimer::runFromTimer()+0x8c>)
    9158:	6834      	ldr	r4, [r6, #0]
	while (timer) {
    915a:	b32c      	cbz	r4, 91a8 <MillisTimer::runFromTimer()+0x54>
		if (timer->_ms > 0) {
    915c:	6823      	ldr	r3, [r4, #0]
    915e:	2b00      	cmp	r3, #0
    9160:	d13a      	bne.n	91d8 <MillisTimer::runFromTimer()+0x84>
    9162:	4f20      	ldr	r7, [pc, #128]	; (91e4 <MillisTimer::runFromTimer()+0x90>)
			timer->_ms--;
			break;
		} else {
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
    9164:	461d      	mov	r5, r3
    9166:	e004      	b.n	9172 <MillisTimer::runFromTimer()+0x1e>
			event.triggerEvent(0, timer);
			if (timer->_reload) {
				timer->_ms = timer->_reload;
				timer->addToActiveList();
			}
			timer = listActive;
    9168:	6834      	ldr	r4, [r6, #0]
}

void MillisTimer::runFromTimer()
{
	MillisTimer *timer = listActive;
	while (timer) {
    916a:	b1ec      	cbz	r4, 91a8 <MillisTimer::runFromTimer()+0x54>
		if (timer->_ms > 0) {
    916c:	6823      	ldr	r3, [r4, #0]
    916e:	2b00      	cmp	r3, #0
    9170:	d132      	bne.n	91d8 <MillisTimer::runFromTimer()+0x84>
			timer->_ms--;
			break;
		} else {
			MillisTimer *next = timer->_next;
    9172:	68a3      	ldr	r3, [r4, #8]
			if (next) next->_prev = nullptr;
    9174:	b103      	cbz	r3, 9178 <MillisTimer::runFromTimer()+0x24>
    9176:	60dd      	str	r5, [r3, #12]
			listActive = next;
			timer->_state = TimerOff;
			EventResponderRef event = *(timer->_event);
    9178:	6920      	ldr	r0, [r4, #16]
			timer->_ms--;
			break;
		} else {
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
			listActive = next;
    917a:	6033      	str	r3, [r6, #0]
			timer->_state = TimerOff;
			EventResponderRef event = *(timer->_event);
			event.triggerEvent(0, timer);
    917c:	6803      	ldr	r3, [r0, #0]
			break;
		} else {
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
			listActive = next;
			timer->_state = TimerOff;
    917e:	7525      	strb	r5, [r4, #20]
			EventResponderRef event = *(timer->_event);
			event.triggerEvent(0, timer);
    9180:	681b      	ldr	r3, [r3, #0]
    9182:	42bb      	cmp	r3, r7
    9184:	d121      	bne.n	91ca <MillisTimer::runFromTimer()+0x76>
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    9186:	7f03      	ldrb	r3, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
    9188:	6045      	str	r5, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
    918a:	2b02      	cmp	r3, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
    918c:	60c4      	str	r4, [r0, #12]
		if (_type == EventTypeImmediate) {
    918e:	d020      	beq.n	91d2 <MillisTimer::runFromTimer()+0x7e>
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
    9190:	f7ff ff48 	bl	9024 <EventResponder::triggerEventNotImmediate()>
			if (timer->_reload) {
    9194:	6863      	ldr	r3, [r4, #4]
    9196:	2b00      	cmp	r3, #0
    9198:	d0e6      	beq.n	9168 <MillisTimer::runFromTimer()+0x14>
				timer->_ms = timer->_reload;
    919a:	6023      	str	r3, [r4, #0]
				timer->addToActiveList();
    919c:	4620      	mov	r0, r4
    919e:	f7ff ffa5 	bl	90ec <MillisTimer::addToActiveList()>
			}
			timer = listActive;
    91a2:	6834      	ldr	r4, [r6, #0]
}

void MillisTimer::runFromTimer()
{
	MillisTimer *timer = listActive;
	while (timer) {
    91a4:	2c00      	cmp	r4, #0
    91a6:	d1e1      	bne.n	916c <MillisTimer::runFromTimer()+0x18>
	volatile TimerStateType _state = TimerOff;
	static MillisTimer *listWaiting; // single linked list of waiting to start timers
	static MillisTimer *listActive;  // double linked list of running timers
	static bool disableTimerInterrupt() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    91a8:	f3ef 8310 	mrs	r3, PRIMASK
		__disable_irq();
    91ac:	b672      	cpsid	i
			}
			timer = listActive;
		}
	}
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
    91ae:	4a0e      	ldr	r2, [pc, #56]	; (91e8 <MillisTimer::runFromTimer()+0x94>)
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
    91b0:	2100      	movs	r1, #0
			}
			timer = listActive;
		}
	}
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
    91b2:	6810      	ldr	r0, [r2, #0]
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
    91b4:	6011      	str	r1, [r2, #0]
		return (primask == 0) ? true : false;
	}
	static void enableTimerInterrupt(bool doit) {
		if (doit) __enable_irq();
    91b6:	b903      	cbnz	r3, 91ba <MillisTimer::runFromTimer()+0x66>
    91b8:	b662      	cpsie	i
	enableTimerInterrupt(irq);
	while (waiting) {
    91ba:	b128      	cbz	r0, 91c8 <MillisTimer::runFromTimer()+0x74>
		MillisTimer *next = waiting->_next;
    91bc:	6884      	ldr	r4, [r0, #8]
		waiting->addToActiveList();
    91be:	f7ff ff95 	bl	90ec <MillisTimer::addToActiveList()>
	}
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
	enableTimerInterrupt(irq);
	while (waiting) {
    91c2:	4620      	mov	r0, r4
    91c4:	2800      	cmp	r0, #0
    91c6:	d1f9      	bne.n	91bc <MillisTimer::runFromTimer()+0x68>
    91c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
			listActive = next;
			timer->_state = TimerOff;
			EventResponderRef event = *(timer->_event);
			event.triggerEvent(0, timer);
    91ca:	4622      	mov	r2, r4
    91cc:	2100      	movs	r1, #0
    91ce:	4798      	blx	r3
    91d0:	e7e0      	b.n	9194 <MillisTimer::runFromTimer()+0x40>
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    91d2:	6883      	ldr	r3, [r0, #8]
    91d4:	4798      	blx	r3
    91d6:	e7dd      	b.n	9194 <MillisTimer::runFromTimer()+0x40>
void MillisTimer::runFromTimer()
{
	MillisTimer *timer = listActive;
	while (timer) {
		if (timer->_ms > 0) {
			timer->_ms--;
    91d8:	3b01      	subs	r3, #1
    91da:	6023      	str	r3, [r4, #0]
			break;
    91dc:	e7e4      	b.n	91a8 <MillisTimer::runFromTimer()+0x54>
    91de:	bf00      	nop
    91e0:	200045d4 	.word	0x200045d4
    91e4:	00006ab1 	.word	0x00006ab1
    91e8:	200045e4 	.word	0x200045e4

000091ec <systick_isr>:
// with libraries using mid-to-high priority interrupts.

extern "C" volatile uint32_t systick_millis_count;
void systick_isr(void)
{
	systick_millis_count++;
    91ec:	4a02      	ldr	r2, [pc, #8]	; (91f8 <systick_isr+0xc>)
    91ee:	6813      	ldr	r3, [r2, #0]
    91f0:	3301      	adds	r3, #1
    91f2:	6013      	str	r3, [r2, #0]
	MillisTimer::runFromTimer();
    91f4:	f7ff bfae 	b.w	9154 <MillisTimer::runFromTimer()>
    91f8:	200045ec 	.word	0x200045ec

000091fc <Print::write(unsigned char const*, unsigned int)>:

#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
    91fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (buffer == nullptr) return 0;
    91fe:	460e      	mov	r6, r1
    9200:	b171      	cbz	r1, 9220 <Print::write(unsigned char const*, unsigned int)+0x24>
	size_t count = 0;
	while (size--) count += write(*buffer++);
    9202:	b17a      	cbz	r2, 9224 <Print::write(unsigned char const*, unsigned int)+0x28>
    9204:	4607      	mov	r7, r0
    9206:	4614      	mov	r4, r2
    9208:	2500      	movs	r5, #0
    920a:	683b      	ldr	r3, [r7, #0]
    920c:	f816 1b01 	ldrb.w	r1, [r6], #1
    9210:	681b      	ldr	r3, [r3, #0]
    9212:	4638      	mov	r0, r7
    9214:	4798      	blx	r3
    9216:	3c01      	subs	r4, #1
    9218:	4405      	add	r5, r0
    921a:	d1f6      	bne.n	920a <Print::write(unsigned char const*, unsigned int)+0xe>
    921c:	4628      	mov	r0, r5
    921e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
	if (buffer == nullptr) return 0;
    9220:	4608      	mov	r0, r1
    9222:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9224:	4610      	mov	r0, r2
	size_t count = 0;
	while (size--) count += write(*buffer++);
	return count;
}
    9226:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00009228 <Print::print(String const&)>:


size_t Print::print(const String &s)
{
    9228:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    922c:	688c      	ldr	r4, [r1, #8]
    922e:	b08b      	sub	sp, #44	; 0x2c
	uint8_t buffer[33];
	size_t count = 0;
	unsigned int index = 0;
	unsigned int len = s.length();
	while (len > 0) {
    9230:	b1ec      	cbz	r4, 926e <Print::print(String const&)+0x46>
    9232:	2500      	movs	r5, #0
    9234:	4606      	mov	r6, r0
    9236:	4689      	mov	r9, r1
    9238:	462f      	mov	r7, r5
		s.getBytes(buffer, sizeof(buffer), index);
    923a:	462b      	mov	r3, r5
    923c:	2221      	movs	r2, #33	; 0x21
    923e:	a901      	add	r1, sp, #4
    9240:	4648      	mov	r0, r9
    9242:	f000 fa19 	bl	9678 <String::getBytes(unsigned char*, unsigned int, unsigned int) const>
		unsigned int nbytes = len;
		if (nbytes > sizeof(buffer)-1) nbytes = sizeof(buffer)-1;
		index += nbytes;
		len -= nbytes;
		count += write(buffer, nbytes);
    9246:	6832      	ldr	r2, [r6, #0]
    9248:	2c20      	cmp	r4, #32
    924a:	4623      	mov	r3, r4
    924c:	bf28      	it	cs
    924e:	2320      	movcs	r3, #32
    9250:	f8d2 8004 	ldr.w	r8, [r2, #4]
    9254:	a901      	add	r1, sp, #4
    9256:	461a      	mov	r2, r3
    9258:	4630      	mov	r0, r6
	unsigned int len = s.length();
	while (len > 0) {
		s.getBytes(buffer, sizeof(buffer), index);
		unsigned int nbytes = len;
		if (nbytes > sizeof(buffer)-1) nbytes = sizeof(buffer)-1;
		index += nbytes;
    925a:	441d      	add	r5, r3
		len -= nbytes;
    925c:	1ae4      	subs	r4, r4, r3
		count += write(buffer, nbytes);
    925e:	47c0      	blx	r8
    9260:	4407      	add	r7, r0
{
	uint8_t buffer[33];
	size_t count = 0;
	unsigned int index = 0;
	unsigned int len = s.length();
	while (len > 0) {
    9262:	2c00      	cmp	r4, #0
    9264:	d1e9      	bne.n	923a <Print::print(String const&)+0x12>
		index += nbytes;
		len -= nbytes;
		count += write(buffer, nbytes);
	}
	return count;
}
    9266:	4638      	mov	r0, r7
    9268:	b00b      	add	sp, #44	; 0x2c
    926a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}


size_t Print::print(const String &s)
{
	uint8_t buffer[33];
	size_t count = 0;
    926e:	4627      	mov	r7, r4
    9270:	e7f9      	b.n	9266 <Print::print(String const&)+0x3e>
    9272:	bf00      	nop

00009274 <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    9274:	b500      	push	{lr}
	uint8_t buf[2]={'\r', '\n'};
    9276:	4a06      	ldr	r2, [pc, #24]	; (9290 <Print::println()+0x1c>)
	return write(buf, 2);
    9278:	6803      	ldr	r3, [r0, #0]
}


size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    927a:	8812      	ldrh	r2, [r2, #0]
	return write(buf, 2);
    927c:	685b      	ldr	r3, [r3, #4]
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    927e:	b083      	sub	sp, #12
	uint8_t buf[2]={'\r', '\n'};
	return write(buf, 2);
    9280:	a901      	add	r1, sp, #4
}


size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    9282:	f8ad 2004 	strh.w	r2, [sp, #4]
	return write(buf, 2);
    9286:	2202      	movs	r2, #2
    9288:	4798      	blx	r3
}
    928a:	b003      	add	sp, #12
    928c:	f85d fb04 	ldr.w	pc, [sp], #4
    9290:	000123a4 	.word	0x000123a4

00009294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
}

#else

size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
{
    9294:	b5f0      	push	{r4, r5, r6, r7, lr}
    9296:	4607      	mov	r7, r0
    9298:	b08b      	sub	sp, #44	; 0x2c
	uint8_t digit, i;

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
    929a:	2a00      	cmp	r2, #0
    929c:	d033      	beq.n	9306 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x72>
		return write((uint8_t)n);
	} else if (base == 1) {
		base = 10;
    929e:	2a01      	cmp	r2, #1
    92a0:	bf08      	it	eq
    92a2:	220a      	moveq	r2, #10
	}


	if (n == 0) {
    92a4:	b351      	cbz	r1, 92fc <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x68>
    92a6:	2421      	movs	r4, #33	; 0x21
    92a8:	e000      	b.n	92ac <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x18>
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
			i--;
    92aa:	b2f4      	uxtb	r4, r6
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    92ac:	fbb1 f5f2 	udiv	r5, r1, r2
    92b0:	fb02 1115 	mls	r1, r2, r5, r1
    92b4:	b2c8      	uxtb	r0, r1
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    92b6:	2909      	cmp	r1, #9
    92b8:	f100 0130 	add.w	r1, r0, #48	; 0x30
    92bc:	bf98      	it	ls
    92be:	b2c8      	uxtbls	r0, r1
    92c0:	a90a      	add	r1, sp, #40	; 0x28
    92c2:	bf88      	it	hi
    92c4:	3037      	addhi	r0, #55	; 0x37
    92c6:	4421      	add	r1, r4
    92c8:	bf88      	it	hi
    92ca:	b2c0      	uxtbhi	r0, r0
    92cc:	f801 0c24 	strb.w	r0, [r1, #-36]
			n /= base;
			if (n == 0) break;
			i--;
    92d0:	1e66      	subs	r6, r4, #1
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
    92d2:	4629      	mov	r1, r5
    92d4:	2d00      	cmp	r5, #0
    92d6:	d1e8      	bne.n	92aa <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x16>
			i--;
		}
	}
	if (sign) {
    92d8:	b133      	cbz	r3, 92e8 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x54>
		i--;
    92da:	3c01      	subs	r4, #1
    92dc:	b2e4      	uxtb	r4, r4
		buf[i] = '-';
    92de:	ab0a      	add	r3, sp, #40	; 0x28
    92e0:	4423      	add	r3, r4
    92e2:	222d      	movs	r2, #45	; 0x2d
    92e4:	f803 2c24 	strb.w	r2, [r3, #-36]
	}
	return write(buf + i, sizeof(buf) - i);
    92e8:	683b      	ldr	r3, [r7, #0]
    92ea:	aa01      	add	r2, sp, #4
    92ec:	1911      	adds	r1, r2, r4
    92ee:	685b      	ldr	r3, [r3, #4]
    92f0:	4638      	mov	r0, r7
    92f2:	f1c4 0222 	rsb	r2, r4, #34	; 0x22
    92f6:	4798      	blx	r3
}
    92f8:	b00b      	add	sp, #44	; 0x2c
    92fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
		base = 10;
	}


	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
    92fc:	2230      	movs	r2, #48	; 0x30
    92fe:	f88d 2025 	strb.w	r2, [sp, #37]	; 0x25
		i = sizeof(buf) - 1;
    9302:	2421      	movs	r4, #33	; 0x21
    9304:	e7e8      	b.n	92d8 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x44>

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
		return write((uint8_t)n);
    9306:	6803      	ldr	r3, [r0, #0]
    9308:	b2c9      	uxtb	r1, r1
    930a:	681b      	ldr	r3, [r3, #0]
    930c:	4798      	blx	r3
	if (sign) {
		i--;
		buf[i] = '-';
	}
	return write(buf + i, sizeof(buf) - i);
}
    930e:	b00b      	add	sp, #44	; 0x2c
    9310:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9312:	bf00      	nop

00009314 <Print::print(long)>:

size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
    9314:	2900      	cmp	r1, #0
		sign = '-';
		n = -n;
    9316:	bfba      	itte	lt
    9318:	4249      	neglt	r1, r1
size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
		sign = '-';
    931a:	232d      	movlt	r3, #45	; 0x2d
}


size_t Print::print(long n)
{
	uint8_t sign=0;
    931c:	2300      	movge	r3, #0

	if (n < 0) {
		sign = '-';
		n = -n;
	}
	return printNumber(n, 10, sign);
    931e:	220a      	movs	r2, #10
    9320:	f7ff bfb8 	b.w	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    9324:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

00009328 <Print::printFloat(double, unsigned char)>:
}

#endif

size_t Print::printFloat(double number, uint8_t digits) 
{
    9328:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    932c:	b085      	sub	sp, #20
    932e:	4680      	mov	r8, r0
	uint8_t sign=0;
	size_t count=0;

	if (isnan(number)) return print("nan");
    9330:	4619      	mov	r1, r3
    9332:	4610      	mov	r0, r2
}

#endif

size_t Print::printFloat(double number, uint8_t digits) 
{
    9334:	4616      	mov	r6, r2
    9336:	461f      	mov	r7, r3
    9338:	f89d 5030 	ldrb.w	r5, [sp, #48]	; 0x30
	uint8_t sign=0;
	size_t count=0;

	if (isnan(number)) return print("nan");
    933c:	f003 fe52 	bl	cfe4 <__aeabi_dcmpun>
    9340:	2800      	cmp	r0, #0
    9342:	f040 80b1 	bne.w	94a8 <Print::printFloat(double, unsigned char)+0x180>
    	if (isinf(number)) return print("inf");
    9346:	f027 4400 	bic.w	r4, r7, #2147483648	; 0x80000000
    934a:	4630      	mov	r0, r6
    934c:	4621      	mov	r1, r4
    934e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    9352:	4b59      	ldr	r3, [pc, #356]	; (94b8 <Print::printFloat(double, unsigned char)+0x190>)
    9354:	f003 fe46 	bl	cfe4 <__aeabi_dcmpun>
    9358:	b998      	cbnz	r0, 9382 <Print::printFloat(double, unsigned char)+0x5a>
    935a:	4630      	mov	r0, r6
    935c:	4621      	mov	r1, r4
    935e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    9362:	4b55      	ldr	r3, [pc, #340]	; (94b8 <Print::printFloat(double, unsigned char)+0x190>)
    9364:	f003 fe20 	bl	cfa8 <__aeabi_dcmple>
    9368:	b958      	cbnz	r0, 9382 <Print::printFloat(double, unsigned char)+0x5a>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    936a:	f8d8 3000 	ldr.w	r3, [r8]
    936e:	4953      	ldr	r1, [pc, #332]	; (94bc <Print::printFloat(double, unsigned char)+0x194>)
    9370:	685b      	ldr	r3, [r3, #4]
    9372:	4640      	mov	r0, r8
    9374:	2203      	movs	r2, #3
    9376:	4798      	blx	r3
    9378:	4681      	mov	r9, r0
			remainder -= n; 
		}
		count += write(buf, count);
	}
	return count;
}
    937a:	4648      	mov	r0, r9
    937c:	b005      	add	sp, #20
    937e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	uint8_t sign=0;
	size_t count=0;

	if (isnan(number)) return print("nan");
    	if (isinf(number)) return print("inf");
    	if (number > 4294967040.0f) return print("ovf");  // constant determined empirically
    9382:	4630      	mov	r0, r6
    9384:	4639      	mov	r1, r7
    9386:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
    938a:	4b4d      	ldr	r3, [pc, #308]	; (94c0 <Print::printFloat(double, unsigned char)+0x198>)
    938c:	f003 fe20 	bl	cfd0 <__aeabi_dcmpgt>
    9390:	2800      	cmp	r0, #0
    9392:	d170      	bne.n	9476 <Print::printFloat(double, unsigned char)+0x14e>
    	if (number <-4294967040.0f) return print("ovf");  // constant determined empirically
    9394:	4630      	mov	r0, r6
    9396:	4639      	mov	r1, r7
    9398:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
    939c:	4b49      	ldr	r3, [pc, #292]	; (94c4 <Print::printFloat(double, unsigned char)+0x19c>)
    939e:	f003 fdf9 	bl	cf94 <__aeabi_dcmplt>
    93a2:	2800      	cmp	r0, #0
    93a4:	d167      	bne.n	9476 <Print::printFloat(double, unsigned char)+0x14e>
	
	// Handle negative numbers
	if (number < 0.0) {
    93a6:	4630      	mov	r0, r6
    93a8:	4639      	mov	r1, r7
    93aa:	2200      	movs	r2, #0
    93ac:	2300      	movs	r3, #0
    93ae:	f003 fdf1 	bl	cf94 <__aeabi_dcmplt>
    93b2:	2800      	cmp	r0, #0
    93b4:	d163      	bne.n	947e <Print::printFloat(double, unsigned char)+0x156>

#endif

size_t Print::printFloat(double number, uint8_t digits) 
{
	uint8_t sign=0;
    93b6:	4681      	mov	r9, r0
		number = -number;
	}

	// Round correctly so that print(1.999, 2) prints as "2.00"
	double rounding = 0.5;
	for (uint8_t i=0; i<digits; ++i) {
    93b8:	2d00      	cmp	r5, #0
    93ba:	d065      	beq.n	9488 <Print::printFloat(double, unsigned char)+0x160>
    93bc:	4b42      	ldr	r3, [pc, #264]	; (94c8 <Print::printFloat(double, unsigned char)+0x1a0>)
    93be:	2400      	movs	r4, #0
    93c0:	2200      	movs	r2, #0
		rounding *= 0.1;
    93c2:	4610      	mov	r0, r2
    93c4:	4619      	mov	r1, r3
    93c6:	a33a      	add	r3, pc, #232	; (adr r3, 94b0 <Print::printFloat(double, unsigned char)+0x188>)
    93c8:	e9d3 2300 	ldrd	r2, r3, [r3]
    93cc:	f003 fb70 	bl	cab0 <__aeabi_dmul>
    93d0:	3401      	adds	r4, #1
    93d2:	460b      	mov	r3, r1
		number = -number;
	}

	// Round correctly so that print(1.999, 2) prints as "2.00"
	double rounding = 0.5;
	for (uint8_t i=0; i<digits; ++i) {
    93d4:	b2e1      	uxtb	r1, r4
    93d6:	428d      	cmp	r5, r1
		rounding *= 0.1;
    93d8:	4602      	mov	r2, r0
		number = -number;
	}

	// Round correctly so that print(1.999, 2) prints as "2.00"
	double rounding = 0.5;
	for (uint8_t i=0; i<digits; ++i) {
    93da:	d8f2      	bhi.n	93c2 <Print::printFloat(double, unsigned char)+0x9a>
		rounding *= 0.1;
	}
	number += rounding;
    93dc:	4630      	mov	r0, r6
    93de:	4639      	mov	r1, r7
    93e0:	f003 f9b4 	bl	c74c <__adddf3>
    93e4:	460f      	mov	r7, r1
    93e6:	4606      	mov	r6, r0

	// Extract the integer part of the number and print it
	unsigned long int_part = (unsigned long)number;
    93e8:	f003 fe3a 	bl	d060 <__aeabi_d2uiz>
    93ec:	4604      	mov	r4, r0
	double remainder = number - (double)int_part;
    93ee:	f003 fae9 	bl	c9c4 <__aeabi_ui2d>
    93f2:	4602      	mov	r2, r0
    93f4:	460b      	mov	r3, r1
    93f6:	4630      	mov	r0, r6
    93f8:	4639      	mov	r1, r7
    93fa:	f003 f9a5 	bl	c748 <__aeabi_dsub>
	count += printNumber(int_part, 10, sign);
    93fe:	464b      	mov	r3, r9
	}
	number += rounding;

	// Extract the integer part of the number and print it
	unsigned long int_part = (unsigned long)number;
	double remainder = number - (double)int_part;
    9400:	4606      	mov	r6, r0
    9402:	460f      	mov	r7, r1
	count += printNumber(int_part, 10, sign);
    9404:	220a      	movs	r2, #10
    9406:	4621      	mov	r1, r4
    9408:	4640      	mov	r0, r8
    940a:	f7ff ff43 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    940e:	2d0f      	cmp	r5, #15
    9410:	bf28      	it	cs
    9412:	250f      	movcs	r5, #15
    9414:	3501      	adds	r5, #1

	// Print the decimal point, but only if there are digits beyond
	if (digits > 0) {
		uint8_t n, buf[16], count=1;
		buf[0] = '.';
    9416:	232e      	movs	r3, #46	; 0x2e
	number += rounding;

	// Extract the integer part of the number and print it
	unsigned long int_part = (unsigned long)number;
	double remainder = number - (double)int_part;
	count += printNumber(int_part, 10, sign);
    9418:	4681      	mov	r9, r0
    941a:	b2ed      	uxtb	r5, r5

	// Print the decimal point, but only if there are digits beyond
	if (digits > 0) {
		uint8_t n, buf[16], count=1;
		buf[0] = '.';
    941c:	f88d 3000 	strb.w	r3, [sp]
    9420:	2401      	movs	r4, #1

		// Extract digits from the remainder one at a time
		if (digits > sizeof(buf) - 1) digits = sizeof(buf) - 1;

		while (digits-- > 0) {
			remainder *= 10.0;
    9422:	2200      	movs	r2, #0
    9424:	4b29      	ldr	r3, [pc, #164]	; (94cc <Print::printFloat(double, unsigned char)+0x1a4>)
    9426:	4630      	mov	r0, r6
    9428:	4639      	mov	r1, r7
    942a:	f003 fb41 	bl	cab0 <__aeabi_dmul>
    942e:	460f      	mov	r7, r1
    9430:	4606      	mov	r6, r0
			n = (uint8_t)(remainder);
    9432:	f003 fe15 	bl	d060 <__aeabi_d2uiz>
			buf[count++] = '0' + n;
    9436:	ab04      	add	r3, sp, #16
    9438:	4423      	add	r3, r4
		// Extract digits from the remainder one at a time
		if (digits > sizeof(buf) - 1) digits = sizeof(buf) - 1;

		while (digits-- > 0) {
			remainder *= 10.0;
			n = (uint8_t)(remainder);
    943a:	b2c0      	uxtb	r0, r0
			buf[count++] = '0' + n;
    943c:	f100 0230 	add.w	r2, r0, #48	; 0x30
    9440:	f803 2c10 	strb.w	r2, [r3, #-16]
			remainder -= n; 
    9444:	f003 face 	bl	c9e4 <__aeabi_i2d>
    9448:	4602      	mov	r2, r0
    944a:	460b      	mov	r3, r1
    944c:	4630      	mov	r0, r6
    944e:	4639      	mov	r1, r7
    9450:	f003 f97a 	bl	c748 <__aeabi_dsub>
		if (digits > sizeof(buf) - 1) digits = sizeof(buf) - 1;

		while (digits-- > 0) {
			remainder *= 10.0;
			n = (uint8_t)(remainder);
			buf[count++] = '0' + n;
    9454:	3401      	adds	r4, #1
    9456:	b2e4      	uxtb	r4, r4
		buf[0] = '.';

		// Extract digits from the remainder one at a time
		if (digits > sizeof(buf) - 1) digits = sizeof(buf) - 1;

		while (digits-- > 0) {
    9458:	42ac      	cmp	r4, r5
			remainder *= 10.0;
			n = (uint8_t)(remainder);
			buf[count++] = '0' + n;
			remainder -= n; 
    945a:	4606      	mov	r6, r0
    945c:	460f      	mov	r7, r1
		buf[0] = '.';

		// Extract digits from the remainder one at a time
		if (digits > sizeof(buf) - 1) digits = sizeof(buf) - 1;

		while (digits-- > 0) {
    945e:	d1e0      	bne.n	9422 <Print::printFloat(double, unsigned char)+0xfa>
			remainder *= 10.0;
			n = (uint8_t)(remainder);
			buf[count++] = '0' + n;
			remainder -= n; 
		}
		count += write(buf, count);
    9460:	f8d8 3000 	ldr.w	r3, [r8]
    9464:	4622      	mov	r2, r4
    9466:	685b      	ldr	r3, [r3, #4]
    9468:	4640      	mov	r0, r8
    946a:	4669      	mov	r1, sp
    946c:	4798      	blx	r3
	}
	return count;
}
    946e:	4648      	mov	r0, r9
    9470:	b005      	add	sp, #20
    9472:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    9476:	f8d8 3000 	ldr.w	r3, [r8]
    947a:	4915      	ldr	r1, [pc, #84]	; (94d0 <Print::printFloat(double, unsigned char)+0x1a8>)
    947c:	e778      	b.n	9370 <Print::printFloat(double, unsigned char)+0x48>
    	if (number <-4294967040.0f) return print("ovf");  // constant determined empirically
	
	// Handle negative numbers
	if (number < 0.0) {
		sign = 1;
		number = -number;
    947e:	f107 4700 	add.w	r7, r7, #2147483648	; 0x80000000
    	if (number > 4294967040.0f) return print("ovf");  // constant determined empirically
    	if (number <-4294967040.0f) return print("ovf");  // constant determined empirically
	
	// Handle negative numbers
	if (number < 0.0) {
		sign = 1;
    9482:	f04f 0901 	mov.w	r9, #1
    9486:	e797      	b.n	93b8 <Print::printFloat(double, unsigned char)+0x90>
	number += rounding;

	// Extract the integer part of the number and print it
	unsigned long int_part = (unsigned long)number;
	double remainder = number - (double)int_part;
	count += printNumber(int_part, 10, sign);
    9488:	2200      	movs	r2, #0
    948a:	4b0f      	ldr	r3, [pc, #60]	; (94c8 <Print::printFloat(double, unsigned char)+0x1a0>)
    948c:	4630      	mov	r0, r6
    948e:	4639      	mov	r1, r7
    9490:	f003 f95c 	bl	c74c <__adddf3>
    9494:	f003 fde4 	bl	d060 <__aeabi_d2uiz>
    9498:	464b      	mov	r3, r9
    949a:	4601      	mov	r1, r0
    949c:	220a      	movs	r2, #10
    949e:	4640      	mov	r0, r8
    94a0:	f7ff fef8 	bl	9294 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    94a4:	4681      	mov	r9, r0
    94a6:	e768      	b.n	937a <Print::printFloat(double, unsigned char)+0x52>
    94a8:	f8d8 3000 	ldr.w	r3, [r8]
    94ac:	4909      	ldr	r1, [pc, #36]	; (94d4 <Print::printFloat(double, unsigned char)+0x1ac>)
    94ae:	e75f      	b.n	9370 <Print::printFloat(double, unsigned char)+0x48>
    94b0:	a0000000 	.word	0xa0000000
    94b4:	3fb99999 	.word	0x3fb99999
    94b8:	7fefffff 	.word	0x7fefffff
    94bc:	000123b0 	.word	0x000123b0
    94c0:	41efffff 	.word	0x41efffff
    94c4:	c1efffff 	.word	0xc1efffff
    94c8:	3fe00000 	.word	0x3fe00000
    94cc:	40240000 	.word	0x40240000
    94d0:	000123ac 	.word	0x000123ac
    94d4:	000123a8 	.word	0x000123a8

000094d8 <String::~String()>:
	init();
	char buf[40];
	*this = dtostrf(num, digits + 2, digits, buf);
}

String::~String()
    94d8:	b510      	push	{r4, lr}
    94da:	4604      	mov	r4, r0
{
	free(buffer);
    94dc:	6800      	ldr	r0, [r0, #0]
    94de:	f004 fb55 	bl	db8c <free>
}
    94e2:	4620      	mov	r0, r4
    94e4:	bd10      	pop	{r4, pc}
    94e6:	bf00      	nop

000094e8 <String::reserve(unsigned int)>:
	len = 0;
	flags = 0;
}

unsigned char String::reserve(unsigned int size)
{
    94e8:	b538      	push	{r3, r4, r5, lr}
	if (capacity >= size) return 1;
    94ea:	6843      	ldr	r3, [r0, #4]
    94ec:	428b      	cmp	r3, r1
    94ee:	d301      	bcc.n	94f4 <String::reserve(unsigned int)+0xc>
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    94f0:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
    94f2:	bd38      	pop	{r3, r4, r5, pc}
    94f4:	460d      	mov	r5, r1
    94f6:	4604      	mov	r4, r0

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
    94f8:	3101      	adds	r1, #1
    94fa:	6800      	ldr	r0, [r0, #0]
    94fc:	f004 febc 	bl	e278 <realloc>
	if (newbuffer) {
    9500:	2800      	cmp	r0, #0
    9502:	d0f6      	beq.n	94f2 <String::reserve(unsigned int)+0xa>

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    9504:	68a3      	ldr	r3, [r4, #8]
unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
	if (newbuffer) {
		buffer = newbuffer;
		capacity = maxStrLen;
    9506:	e884 0021 	stmia.w	r4, {r0, r5}

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    950a:	2b00      	cmp	r3, #0
    950c:	d1f0      	bne.n	94f0 <String::reserve(unsigned int)+0x8>
    950e:	7003      	strb	r3, [r0, #0]
    9510:	e7ee      	b.n	94f0 <String::reserve(unsigned int)+0x8>
    9512:	bf00      	nop

00009514 <String::copy(char const*, unsigned int)>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
    9514:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9516:	4604      	mov	r4, r0
	if (length == 0) {
    9518:	4615      	mov	r5, r2
    951a:	b932      	cbnz	r2, 952a <String::copy(char const*, unsigned int)+0x16>
		if (buffer) buffer[0] = 0;
    951c:	6803      	ldr	r3, [r0, #0]
    951e:	b103      	cbz	r3, 9522 <String::copy(char const*, unsigned int)+0xe>
    9520:	701a      	strb	r2, [r3, #0]
		len = 0;
    9522:	2300      	movs	r3, #0
    9524:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    9526:	4620      	mov	r0, r4
    9528:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    952a:	460e      	mov	r6, r1
	if (length == 0) {
		if (buffer) buffer[0] = 0;
		len = 0;
		return *this;
	}
	if (!reserve(length)) {
    952c:	4611      	mov	r1, r2
    952e:	f7ff ffdb 	bl	94e8 <String::reserve(unsigned int)>
    9532:	4607      	mov	r7, r0
    9534:	b948      	cbnz	r0, 954a <String::copy(char const*, unsigned int)+0x36>
		if (buffer) {
    9536:	6820      	ldr	r0, [r4, #0]
    9538:	b110      	cbz	r0, 9540 <String::copy(char const*, unsigned int)+0x2c>
			free(buffer);
    953a:	f004 fb27 	bl	db8c <free>
			buffer = NULL;
    953e:	6027      	str	r7, [r4, #0]
		}
		len = capacity = 0;
    9540:	2300      	movs	r3, #0
    9542:	6063      	str	r3, [r4, #4]
    9544:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    9546:	4620      	mov	r0, r4
    9548:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			buffer = NULL;
		}
		len = capacity = 0;
		return *this;
	}
	len = length;
    954a:	60a5      	str	r5, [r4, #8]
	strcpy(buffer, cstr);
    954c:	4631      	mov	r1, r6
    954e:	6820      	ldr	r0, [r4, #0]
    9550:	f005 fa14 	bl	e97c <strcpy>
	return *this;
    9554:	e7e7      	b.n	9526 <String::copy(char const*, unsigned int)+0x12>
    9556:	bf00      	nop

00009558 <String::String(char const*)>:

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    9558:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    955a:	2300      	movs	r3, #0

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    955c:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    955e:	6003      	str	r3, [r0, #0]
	capacity = 0;
    9560:	6043      	str	r3, [r0, #4]
	len = 0;
    9562:	6083      	str	r3, [r0, #8]
	flags = 0;
    9564:	7303      	strb	r3, [r0, #12]
/*********************************************/

String::String(const char *cstr)
{
	init();
	if (cstr) copy(cstr, strlen(cstr));
    9566:	b141      	cbz	r1, 957a <String::String(char const*)+0x22>
    9568:	4608      	mov	r0, r1
    956a:	460d      	mov	r5, r1
    956c:	f005 fa68 	bl	ea40 <strlen>
    9570:	4629      	mov	r1, r5
    9572:	4602      	mov	r2, r0
    9574:	4620      	mov	r0, r4
    9576:	f7ff ffcd 	bl	9514 <String::copy(char const*, unsigned int)>
}
    957a:	4620      	mov	r0, r4
    957c:	bd38      	pop	{r3, r4, r5, pc}
    957e:	bf00      	nop

00009580 <String::String(String const&)>:
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    9580:	2300      	movs	r3, #0
	rhs.len = 0;
}

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
    9582:	4288      	cmp	r0, r1
{
	init();
	*this = pgmstr;
}

String::String(const String &value)
    9584:	b510      	push	{r4, lr}
    9586:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    9588:	6003      	str	r3, [r0, #0]
	capacity = 0;
    958a:	6043      	str	r3, [r0, #4]
	len = 0;
    958c:	6083      	str	r3, [r0, #8]
	flags = 0;
    958e:	7303      	strb	r3, [r0, #12]
	rhs.len = 0;
}

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
    9590:	d003      	beq.n	959a <String::String(String const&)+0x1a>
	return copy(rhs.buffer, rhs.len);
    9592:	688a      	ldr	r2, [r1, #8]
    9594:	6809      	ldr	r1, [r1, #0]
    9596:	f7ff ffbd 	bl	9514 <String::copy(char const*, unsigned int)>

String::String(const String &value)
{
	init();
	*this = value;
}
    959a:	4620      	mov	r0, r4
    959c:	bd10      	pop	{r4, pc}
    959e:	bf00      	nop

000095a0 <String::operator=(char const*) [clone .part.3]>:
	if (this != &rval) move(rval);
	return *this;
}
#endif

String & String::operator = (const char *cstr)
    95a0:	b538      	push	{r3, r4, r5, lr}
    95a2:	4605      	mov	r5, r0
{
	if (cstr) {
		copy(cstr, strlen(cstr));
    95a4:	4608      	mov	r0, r1
	if (this != &rval) move(rval);
	return *this;
}
#endif

String & String::operator = (const char *cstr)
    95a6:	460c      	mov	r4, r1
{
	if (cstr) {
		copy(cstr, strlen(cstr));
    95a8:	f005 fa4a 	bl	ea40 <strlen>
    95ac:	4621      	mov	r1, r4
    95ae:	4602      	mov	r2, r0
    95b0:	4628      	mov	r0, r5
	} else {
		len = 0;
	}
	return *this;
}
    95b2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif

String & String::operator = (const char *cstr)
{
	if (cstr) {
		copy(cstr, strlen(cstr));
    95b6:	f7ff bfad 	b.w	9514 <String::copy(char const*, unsigned int)>
    95ba:	bf00      	nop

000095bc <String::String(float, unsigned char)>:
	char buf[33];
	ultoa(value, buf, base);
	*this = buf;
}

String::String(float num, unsigned char digits)
    95bc:	b510      	push	{r4, lr}
    95be:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    95c0:	2300      	movs	r3, #0
	char buf[33];
	ultoa(value, buf, base);
	*this = buf;
}

String::String(float num, unsigned char digits)
    95c2:	b08a      	sub	sp, #40	; 0x28
{
	init();
	char buf[40];
	*this = dtostrf(num, digits + 2, digits, buf);
    95c4:	4608      	mov	r0, r1
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    95c6:	6023      	str	r3, [r4, #0]
	capacity = 0;
    95c8:	6063      	str	r3, [r4, #4]
	len = 0;
    95ca:	60a3      	str	r3, [r4, #8]
	flags = 0;
    95cc:	7323      	strb	r3, [r4, #12]

String::String(float num, unsigned char digits)
{
	init();
	char buf[40];
	*this = dtostrf(num, digits + 2, digits, buf);
    95ce:	1c91      	adds	r1, r2, #2
    95d0:	466b      	mov	r3, sp
    95d2:	f000 fa77 	bl	9ac4 <dtostrf>
}
#endif

String & String::operator = (const char *cstr)
{
	if (cstr) {
    95d6:	b130      	cbz	r0, 95e6 <String::String(float, unsigned char)+0x2a>
    95d8:	4601      	mov	r1, r0
    95da:	4620      	mov	r0, r4
    95dc:	f7ff ffe0 	bl	95a0 <String::operator=(char const*) [clone .part.3]>
String::String(float num, unsigned char digits)
{
	init();
	char buf[40];
	*this = dtostrf(num, digits + 2, digits, buf);
}
    95e0:	4620      	mov	r0, r4
    95e2:	b00a      	add	sp, #40	; 0x28
    95e4:	bd10      	pop	{r4, pc}
String & String::operator = (const char *cstr)
{
	if (cstr) {
		copy(cstr, strlen(cstr));
	} else {
		len = 0;
    95e6:	60a0      	str	r0, [r4, #8]
String::String(float num, unsigned char digits)
{
	init();
	char buf[40];
	*this = dtostrf(num, digits + 2, digits, buf);
}
    95e8:	4620      	mov	r0, r4
    95ea:	b00a      	add	sp, #40	; 0x28
    95ec:	bd10      	pop	{r4, pc}
    95ee:	bf00      	nop

000095f0 <String::move(String&)>:
	strcpy(buffer, cstr);
	return *this;
}

void String::move(String &rhs)
{
    95f0:	b538      	push	{r3, r4, r5, lr}
    95f2:	4605      	mov	r5, r0
	if (buffer) {
    95f4:	6800      	ldr	r0, [r0, #0]
	strcpy(buffer, cstr);
	return *this;
}

void String::move(String &rhs)
{
    95f6:	460c      	mov	r4, r1
	if (buffer) {
    95f8:	b128      	cbz	r0, 9606 <String::move(String&)+0x16>
		if (capacity >= rhs.len) {
    95fa:	686a      	ldr	r2, [r5, #4]
    95fc:	688b      	ldr	r3, [r1, #8]
    95fe:	429a      	cmp	r2, r3
    9600:	d20c      	bcs.n	961c <String::move(String&)+0x2c>
			strcpy(buffer, rhs.buffer);
			len = rhs.len;
			rhs.len = 0;
			return;
		} else {
			free(buffer);
    9602:	f004 fac3 	bl	db8c <free>
		}
	}
	buffer = rhs.buffer;
    9606:	6823      	ldr	r3, [r4, #0]
	capacity = rhs.capacity;
    9608:	6861      	ldr	r1, [r4, #4]
	len = rhs.len;
    960a:	68a2      	ldr	r2, [r4, #8]
			return;
		} else {
			free(buffer);
		}
	}
	buffer = rhs.buffer;
    960c:	602b      	str	r3, [r5, #0]
	capacity = rhs.capacity;
	len = rhs.len;
	rhs.buffer = NULL;
    960e:	2300      	movs	r3, #0
		} else {
			free(buffer);
		}
	}
	buffer = rhs.buffer;
	capacity = rhs.capacity;
    9610:	6069      	str	r1, [r5, #4]
	len = rhs.len;
    9612:	60aa      	str	r2, [r5, #8]
	rhs.buffer = NULL;
    9614:	6023      	str	r3, [r4, #0]
	rhs.capacity = 0;
    9616:	6063      	str	r3, [r4, #4]
	rhs.len = 0;
    9618:	60a3      	str	r3, [r4, #8]
    961a:	bd38      	pop	{r3, r4, r5, pc}

void String::move(String &rhs)
{
	if (buffer) {
		if (capacity >= rhs.len) {
			strcpy(buffer, rhs.buffer);
    961c:	6809      	ldr	r1, [r1, #0]
    961e:	f005 f9ad 	bl	e97c <strcpy>
			len = rhs.len;
    9622:	68a3      	ldr	r3, [r4, #8]
    9624:	60ab      	str	r3, [r5, #8]
			rhs.len = 0;
    9626:	2300      	movs	r3, #0
    9628:	60a3      	str	r3, [r4, #8]
			return;
    962a:	bd38      	pop	{r3, r4, r5, pc}

0000962c <String::operator=(String const&)>:
	rhs.len = 0;
}

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
    962c:	4281      	cmp	r1, r0
    962e:	d003      	beq.n	9638 <String::operator=(String const&)+0xc>
	return copy(rhs.buffer, rhs.len);
    9630:	688a      	ldr	r2, [r1, #8]
    9632:	6809      	ldr	r1, [r1, #0]
    9634:	f7ff bf6e 	b.w	9514 <String::copy(char const*, unsigned int)>
}
    9638:	4770      	bx	lr
    963a:	bf00      	nop

0000963c <String::operator=(String&&)>:

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
String & String::operator = (String &&rval)
{
	if (this != &rval) move(rval);
    963c:	4288      	cmp	r0, r1
	return copy(rhs.buffer, rhs.len);
}

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
String & String::operator = (String &&rval)
{
    963e:	b510      	push	{r4, lr}
    9640:	4604      	mov	r4, r0
	if (this != &rval) move(rval);
    9642:	d001      	beq.n	9648 <String::operator=(String&&)+0xc>
    9644:	f7ff ffd4 	bl	95f0 <String::move(String&)>
	return *this;
}
    9648:	4620      	mov	r0, r4
    964a:	bd10      	pop	{r4, pc}

0000964c <String::equals(char const*) const>:
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    964c:	6882      	ldr	r2, [r0, #8]
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
    964e:	b508      	push	{r3, lr}
    9650:	460b      	mov	r3, r1
	if (len == 0) return (cstr == NULL || *cstr == 0);
    9652:	b92a      	cbnz	r2, 9660 <String::equals(char const*) const+0x14>
    9654:	b171      	cbz	r1, 9674 <String::equals(char const*) const+0x28>
	if (cstr == NULL) return buffer[0] == 0;
    9656:	7818      	ldrb	r0, [r3, #0]
    9658:	fab0 f080 	clz	r0, r0
    965c:	0940      	lsrs	r0, r0, #5
    965e:	bd08      	pop	{r3, pc}
    9660:	b131      	cbz	r1, 9670 <String::equals(char const*) const+0x24>
	return strcmp(buffer, cstr) == 0;
    9662:	6800      	ldr	r0, [r0, #0]
    9664:	f005 f820 	bl	e6a8 <strcmp>
    9668:	fab0 f080 	clz	r0, r0
    966c:	0940      	lsrs	r0, r0, #5
}
    966e:	bd08      	pop	{r3, pc}
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
	if (cstr == NULL) return buffer[0] == 0;
    9670:	6803      	ldr	r3, [r0, #0]
    9672:	e7f0      	b.n	9656 <String::equals(char const*) const+0xa>
    9674:	2001      	movs	r0, #1
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    9676:	bd08      	pop	{r3, pc}

00009678 <String::getBytes(unsigned char*, unsigned int, unsigned int) const>:
	return buffer[index];
}

void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
{
	if (!bufsize || !buf) return;
    9678:	b1b2      	cbz	r2, 96a8 <String::getBytes(unsigned char*, unsigned int, unsigned int) const+0x30>
    967a:	b1a9      	cbz	r1, 96a8 <String::getBytes(unsigned char*, unsigned int, unsigned int) const+0x30>
	if (index >= len || !buffer) return 0;
	return buffer[index];
}

void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
{
    967c:	b538      	push	{r3, r4, r5, lr}
	if (!bufsize || !buf) return;
	if (index >= len) {
    967e:	6884      	ldr	r4, [r0, #8]
    9680:	429c      	cmp	r4, r3
    9682:	d90e      	bls.n	96a2 <String::getBytes(unsigned char*, unsigned int, unsigned int) const+0x2a>
		buf[0] = 0;
		return;
	}
	unsigned int n = bufsize - 1;
	if (n > len - index) n = len - index;
    9684:	1ae4      	subs	r4, r4, r3
	if (!bufsize || !buf) return;
	if (index >= len) {
		buf[0] = 0;
		return;
	}
	unsigned int n = bufsize - 1;
    9686:	3a01      	subs	r2, #1
    9688:	460d      	mov	r5, r1
    968a:	4294      	cmp	r4, r2
	if (n > len - index) n = len - index;
	strncpy((char *)buf, buffer + index, n);
    968c:	6801      	ldr	r1, [r0, #0]
    968e:	bf28      	it	cs
    9690:	4614      	movcs	r4, r2
    9692:	4419      	add	r1, r3
    9694:	4622      	mov	r2, r4
    9696:	4628      	mov	r0, r5
    9698:	f005 fa40 	bl	eb1c <strncpy>
	buf[n] = 0;
    969c:	2300      	movs	r3, #0
    969e:	552b      	strb	r3, [r5, r4]
    96a0:	bd38      	pop	{r3, r4, r5, pc}

void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
{
	if (!bufsize || !buf) return;
	if (index >= len) {
		buf[0] = 0;
    96a2:	2300      	movs	r3, #0
    96a4:	700b      	strb	r3, [r1, #0]
		return;
    96a6:	bd38      	pop	{r3, r4, r5, pc}
    96a8:	4770      	bx	lr
    96aa:	bf00      	nop

000096ac <analog_init>:
#else
#error "F_BUS must be 128, 120, 108, 96, 90, 80, 72, 64, 60, 56, 54, 48, 40, 36, 24, 4 or 2 MHz"
#endif

void analog_init(void)
{
    96ac:	b430      	push	{r4, r5}
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    96ae:	4829      	ldr	r0, [pc, #164]	; (9754 <analog_init+0xa8>)
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    96b0:	4a29      	ldr	r2, [pc, #164]	; (9758 <analog_init+0xac>)
	#endif

	if (analog_config_bits == 8) {
    96b2:	4b2a      	ldr	r3, [pc, #168]	; (975c <analog_init+0xb0>)
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    96b4:	4d2a      	ldr	r5, [pc, #168]	; (9760 <analog_init+0xb4>)
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    96b6:	2460      	movs	r4, #96	; 0x60
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    96b8:	21e1      	movs	r1, #225	; 0xe1
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    96ba:	7004      	strb	r4, [r0, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    96bc:	7011      	strb	r1, [r2, #0]
	#endif

	if (analog_config_bits == 8) {
    96be:	781b      	ldrb	r3, [r3, #0]
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    96c0:	4c28      	ldr	r4, [pc, #160]	; (9764 <analog_init+0xb8>)
	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
    96c2:	2b08      	cmp	r3, #8
    96c4:	d030      	beq.n	9728 <analog_init+0x7c>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    96c6:	2b0a      	cmp	r3, #10
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    96c8:	4827      	ldr	r0, [pc, #156]	; (9768 <analog_init+0xbc>)
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    96ca:	4928      	ldr	r1, [pc, #160]	; (976c <analog_init+0xc0>)
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    96cc:	d037      	beq.n	973e <analog_init+0x92>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    96ce:	2b0c      	cmp	r3, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    96d0:	bf0c      	ite	eq
    96d2:	2235      	moveq	r2, #53	; 0x35
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    96d4:	225d      	movne	r2, #93	; 0x5d
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    96d6:	2312      	movs	r3, #18
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    96d8:	602a      	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    96da:	6023      	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    96dc:	6002      	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    96de:	600b      	str	r3, [r1, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    96e0:	4b23      	ldr	r3, [pc, #140]	; (9770 <analog_init+0xc4>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    96e2:	4924      	ldr	r1, [pc, #144]	; (9774 <analog_init+0xc8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    96e4:	781b      	ldrb	r3, [r3, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    96e6:	4a24      	ldr	r2, [pc, #144]	; (9778 <analog_init+0xcc>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    96e8:	b1bb      	cbz	r3, 971a <analog_init+0x6e>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    96ea:	2301      	movs	r3, #1
    96ec:	600b      	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    96ee:	6013      	str	r3, [r2, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    96f0:	4b22      	ldr	r3, [pc, #136]	; (977c <analog_init+0xd0>)
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    96f2:	4923      	ldr	r1, [pc, #140]	; (9780 <analog_init+0xd4>)
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    96f4:	781b      	ldrb	r3, [r3, #0]
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    96f6:	4a23      	ldr	r2, [pc, #140]	; (9784 <analog_init+0xd8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
    96f8:	2b01      	cmp	r3, #1
    96fa:	d926      	bls.n	974a <analog_init+0x9e>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    96fc:	2b04      	cmp	r3, #4
    96fe:	d90f      	bls.n	9720 <analog_init+0x74>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
    9700:	2b08      	cmp	r3, #8
    9702:	d91e      	bls.n	9742 <analog_init+0x96>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
    9704:	2b10      	cmp	r3, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    9706:	bf94      	ite	ls
    9708:	2386      	movls	r3, #134	; 0x86
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    970a:	2387      	movhi	r3, #135	; 0x87
    970c:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    970e:	6013      	str	r3, [r2, #0]
		#endif
	}
	calibrating = 1;
    9710:	4b1d      	ldr	r3, [pc, #116]	; (9788 <analog_init+0xdc>)
    9712:	2201      	movs	r2, #1
    9714:	701a      	strb	r2, [r3, #0]
}
    9716:	bc30      	pop	{r4, r5}
    9718:	4770      	bx	lr
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    971a:	600b      	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    971c:	6013      	str	r3, [r2, #0]
    971e:	e7e7      	b.n	96f0 <analog_init+0x44>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    9720:	2384      	movs	r3, #132	; 0x84
    9722:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    9724:	6013      	str	r3, [r2, #0]
    9726:	e7f3      	b.n	9710 <analog_init+0x64>

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    9728:	f500 208e 	add.w	r0, r0, #290816	; 0x47000
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    972c:	490f      	ldr	r1, [pc, #60]	; (976c <analog_init+0xc0>)

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    972e:	3008      	adds	r0, #8
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    9730:	2221      	movs	r2, #33	; 0x21
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    9732:	2313      	movs	r3, #19
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    9734:	602a      	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    9736:	6023      	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    9738:	6002      	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    973a:	600b      	str	r3, [r1, #0]
    973c:	e7d0      	b.n	96e0 <analog_init+0x34>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    973e:	2239      	movs	r2, #57	; 0x39
    9740:	e7f7      	b.n	9732 <analog_init+0x86>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    9742:	2385      	movs	r3, #133	; 0x85
    9744:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    9746:	6013      	str	r3, [r2, #0]
    9748:	e7e2      	b.n	9710 <analog_init+0x64>
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    974a:	2380      	movs	r3, #128	; 0x80
    974c:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    974e:	6013      	str	r3, [r2, #0]
    9750:	e7de      	b.n	9710 <analog_init+0x64>
    9752:	bf00      	nop
    9754:	40074000 	.word	0x40074000
    9758:	40074001 	.word	0x40074001
    975c:	1fffb9fc 	.word	0x1fffb9fc
    9760:	4003b008 	.word	0x4003b008
    9764:	4003b00c 	.word	0x4003b00c
    9768:	400bb008 	.word	0x400bb008
    976c:	400bb00c 	.word	0x400bb00c
    9770:	200045e9 	.word	0x200045e9
    9774:	4003b020 	.word	0x4003b020
    9778:	400bb020 	.word	0x400bb020
    977c:	1fffb9fd 	.word	0x1fffb9fd
    9780:	4003b024 	.word	0x4003b024
    9784:	400bb024 	.word	0x400bb024
    9788:	200045e8 	.word	0x200045e8

0000978c <eeprom_initialize>:
//
#define HANDLE_UNALIGNED_WRITES


void eeprom_initialize(void)
{
    978c:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t count=0;
	uint16_t do_flash_cmd[] = {
    978e:	4b1b      	ldr	r3, [pc, #108]	; (97fc <eeprom_initialize+0x70>)
		0xf06f, 0x037f, 0x7003, 0x7803,
		0xf013, 0x0f80, 0xd0fb, 0x4770};
	uint8_t status;

	if (FTFL_FCNFG & FTFL_FCNFG_RAMRDY) {
    9790:	4e1b      	ldr	r6, [pc, #108]	; (9800 <eeprom_initialize+0x74>)


void eeprom_initialize(void)
{
	uint32_t count=0;
	uint16_t do_flash_cmd[] = {
    9792:	6859      	ldr	r1, [r3, #4]
    9794:	6818      	ldr	r0, [r3, #0]
    9796:	689a      	ldr	r2, [r3, #8]
    9798:	68db      	ldr	r3, [r3, #12]
//
#define HANDLE_UNALIGNED_WRITES


void eeprom_initialize(void)
{
    979a:	b085      	sub	sp, #20
	uint32_t count=0;
	uint16_t do_flash_cmd[] = {
    979c:	466c      	mov	r4, sp
    979e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
		0xf06f, 0x037f, 0x7003, 0x7803,
		0xf013, 0x0f80, 0xd0fb, 0x4770};
	uint8_t status;

	if (FTFL_FCNFG & FTFL_FCNFG_RAMRDY) {
    97a0:	7833      	ldrb	r3, [r6, #0]
    97a2:	0799      	lsls	r1, r3, #30
    97a4:	d51d      	bpl.n	97e2 <eeprom_initialize+0x56>
		uint8_t stat = FTFL_FSTAT & 0x70;
    97a6:	4a17      	ldr	r2, [pc, #92]	; (9804 <eeprom_initialize+0x78>)
		if (stat) FTFL_FSTAT = stat;
		// FlexRAM is configured as traditional RAM
		// We need to reconfigure for EEPROM usage
		kinetis_hsrun_disable();
		FTFL_FCCOB0 = 0x80; // PGMPART = Program Partition Command
		FTFL_FCCOB3 = 0;
    97a8:	4c17      	ldr	r4, [pc, #92]	; (9808 <eeprom_initialize+0x7c>)
		0xf06f, 0x037f, 0x7003, 0x7803,
		0xf013, 0x0f80, 0xd0fb, 0x4770};
	uint8_t status;

	if (FTFL_FCNFG & FTFL_FCNFG_RAMRDY) {
		uint8_t stat = FTFL_FSTAT & 0x70;
    97aa:	7813      	ldrb	r3, [r2, #0]
		// FlexRAM is configured as traditional RAM
		// We need to reconfigure for EEPROM usage
		kinetis_hsrun_disable();
		FTFL_FCCOB0 = 0x80; // PGMPART = Program Partition Command
		FTFL_FCCOB3 = 0;
		FTFL_FCCOB4 = EEESPLIT | EEESIZE;
    97ac:	4917      	ldr	r1, [pc, #92]	; (980c <eeprom_initialize+0x80>)
		0xf013, 0x0f80, 0xd0fb, 0x4770};
	uint8_t status;

	if (FTFL_FCNFG & FTFL_FCNFG_RAMRDY) {
		uint8_t stat = FTFL_FSTAT & 0x70;
		if (stat) FTFL_FSTAT = stat;
    97ae:	f013 0370 	ands.w	r3, r3, #112	; 0x70
    97b2:	bf18      	it	ne
    97b4:	7013      	strbne	r3, [r2, #0]
		// FlexRAM is configured as traditional RAM
		// We need to reconfigure for EEPROM usage
		kinetis_hsrun_disable();
		FTFL_FCCOB0 = 0x80; // PGMPART = Program Partition Command
    97b6:	4a16      	ldr	r2, [pc, #88]	; (9810 <eeprom_initialize+0x84>)
		FTFL_FCCOB3 = 0;
		FTFL_FCCOB4 = EEESPLIT | EEESIZE;
		FTFL_FCCOB5 = EEPARTITION;
    97b8:	4b16      	ldr	r3, [pc, #88]	; (9814 <eeprom_initialize+0x88>)
		uint8_t stat = FTFL_FSTAT & 0x70;
		if (stat) FTFL_FSTAT = stat;
		// FlexRAM is configured as traditional RAM
		// We need to reconfigure for EEPROM usage
		kinetis_hsrun_disable();
		FTFL_FCCOB0 = 0x80; // PGMPART = Program Partition Command
    97ba:	2780      	movs	r7, #128	; 0x80
    97bc:	7017      	strb	r7, [r2, #0]
		FTFL_FCCOB3 = 0;
    97be:	2600      	movs	r6, #0
		FTFL_FCCOB4 = EEESPLIT | EEESIZE;
    97c0:	2033      	movs	r0, #51	; 0x33
		FTFL_FCCOB5 = EEPARTITION;
    97c2:	2203      	movs	r2, #3
		if (stat) FTFL_FSTAT = stat;
		// FlexRAM is configured as traditional RAM
		// We need to reconfigure for EEPROM usage
		kinetis_hsrun_disable();
		FTFL_FCCOB0 = 0x80; // PGMPART = Program Partition Command
		FTFL_FCCOB3 = 0;
    97c4:	7026      	strb	r6, [r4, #0]
    97c6:	466d      	mov	r5, sp
		FTFL_FCCOB4 = EEESPLIT | EEESIZE;
    97c8:	7008      	strb	r0, [r1, #0]
		FTFL_FCCOB5 = EEPARTITION;
    97ca:	701a      	strb	r2, [r3, #0]
		__disable_irq();
    97cc:	b672      	cpsid	i
		// do_flash_cmd() must execute from RAM.  Luckily the C syntax is simple...
		(*((void (*)(volatile uint8_t *))((uint32_t)do_flash_cmd | 1)))(&FTFL_FSTAT);
    97ce:	3c04      	subs	r4, #4
    97d0:	f045 0501 	orr.w	r5, r5, #1
    97d4:	4620      	mov	r0, r4
    97d6:	47a8      	blx	r5
		__enable_irq();
    97d8:	b662      	cpsie	i
		kinetis_hsrun_enable();
		status = FTFL_FSTAT;
    97da:	7823      	ldrb	r3, [r4, #0]
		if (status & 0x70) {
    97dc:	f013 0370 	ands.w	r3, r3, #112	; 0x70
    97e0:	d109      	bne.n	97f6 <eeprom_initialize+0x6a>
//
#define HANDLE_UNALIGNED_WRITES


void eeprom_initialize(void)
{
    97e2:	4b0d      	ldr	r3, [pc, #52]	; (9818 <eeprom_initialize+0x8c>)
			FTFL_FSTAT = (status & 0x70);
			return; // error
		}
	}
	// wait for eeprom to become ready (is this really necessary?)
	while (!(FTFL_FCNFG & FTFL_FCNFG_EEERDY)) {
    97e4:	4906      	ldr	r1, [pc, #24]	; (9800 <eeprom_initialize+0x74>)
    97e6:	e001      	b.n	97ec <eeprom_initialize+0x60>
		if (++count > 200000) break;
    97e8:	3b01      	subs	r3, #1
    97ea:	d002      	beq.n	97f2 <eeprom_initialize+0x66>
			FTFL_FSTAT = (status & 0x70);
			return; // error
		}
	}
	// wait for eeprom to become ready (is this really necessary?)
	while (!(FTFL_FCNFG & FTFL_FCNFG_EEERDY)) {
    97ec:	780a      	ldrb	r2, [r1, #0]
    97ee:	07d2      	lsls	r2, r2, #31
    97f0:	d5fa      	bpl.n	97e8 <eeprom_initialize+0x5c>
		if (++count > 200000) break;
	}
}
    97f2:	b005      	add	sp, #20
    97f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		(*((void (*)(volatile uint8_t *))((uint32_t)do_flash_cmd | 1)))(&FTFL_FSTAT);
		__enable_irq();
		kinetis_hsrun_enable();
		status = FTFL_FSTAT;
		if (status & 0x70) {
			FTFL_FSTAT = (status & 0x70);
    97f6:	7023      	strb	r3, [r4, #0]
	}
	// wait for eeprom to become ready (is this really necessary?)
	while (!(FTFL_FCNFG & FTFL_FCNFG_EEERDY)) {
		if (++count > 200000) break;
	}
}
    97f8:	b005      	add	sp, #20
    97fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    97fc:	000123b4 	.word	0x000123b4
    9800:	40020001 	.word	0x40020001
    9804:	40020000 	.word	0x40020000
    9808:	40020004 	.word	0x40020004
    980c:	4002000b 	.word	0x4002000b
    9810:	40020007 	.word	0x40020007
    9814:	4002000a 	.word	0x4002000a
    9818:	00030d41 	.word	0x00030d41

0000981c <eeprom_read_byte>:
#define FlexRAM ((volatile uint8_t *)0x14000000)

uint8_t eeprom_read_byte(const uint8_t *addr)
{
	uint32_t offset = (uint32_t)addr;
	if (offset >= EEPROM_SIZE) return 0;
    981c:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
    9820:	d20a      	bcs.n	9838 <eeprom_read_byte+0x1c>
}

#define FlexRAM ((volatile uint8_t *)0x14000000)

uint8_t eeprom_read_byte(const uint8_t *addr)
{
    9822:	b510      	push	{r4, lr}
	uint32_t offset = (uint32_t)addr;
	if (offset >= EEPROM_SIZE) return 0;
	if (!(FTFL_FCNFG & FTFL_FCNFG_EEERDY)) eeprom_initialize();
    9824:	4b09      	ldr	r3, [pc, #36]	; (984c <eeprom_read_byte+0x30>)
    9826:	781b      	ldrb	r3, [r3, #0]
    9828:	07db      	lsls	r3, r3, #31
    982a:	4604      	mov	r4, r0
    982c:	d506      	bpl.n	983c <eeprom_read_byte+0x20>
	return FlexRAM[offset];
    982e:	f104 50a0 	add.w	r0, r4, #335544320	; 0x14000000
    9832:	7800      	ldrb	r0, [r0, #0]
    9834:	b2c0      	uxtb	r0, r0
    9836:	bd10      	pop	{r4, pc}
#define FlexRAM ((volatile uint8_t *)0x14000000)

uint8_t eeprom_read_byte(const uint8_t *addr)
{
	uint32_t offset = (uint32_t)addr;
	if (offset >= EEPROM_SIZE) return 0;
    9838:	2000      	movs	r0, #0
    983a:	4770      	bx	lr
	if (!(FTFL_FCNFG & FTFL_FCNFG_EEERDY)) eeprom_initialize();
    983c:	f7ff ffa6 	bl	978c <eeprom_initialize>
	return FlexRAM[offset];
    9840:	f104 50a0 	add.w	r0, r4, #335544320	; 0x14000000
    9844:	7800      	ldrb	r0, [r0, #0]
    9846:	b2c0      	uxtb	r0, r0
    9848:	bd10      	pop	{r4, pc}
    984a:	bf00      	nop
    984c:	40020001 	.word	0x40020001

00009850 <eeprom_write_byte>:

void eeprom_write_byte(uint8_t *addr, uint8_t value)
{
	uint32_t offset = (uint32_t)addr;

	if (offset >= EEPROM_SIZE) return;
    9850:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
    9854:	d217      	bcs.n	9886 <eeprom_write_byte+0x36>
		// TODO: timeout
	}
}

void eeprom_write_byte(uint8_t *addr, uint8_t value)
{
    9856:	b538      	push	{r3, r4, r5, lr}
	uint32_t offset = (uint32_t)addr;

	if (offset >= EEPROM_SIZE) return;
	if (!(FTFL_FCNFG & FTFL_FCNFG_EEERDY)) eeprom_initialize();
    9858:	4b0f      	ldr	r3, [pc, #60]	; (9898 <eeprom_write_byte+0x48>)
    985a:	781b      	ldrb	r3, [r3, #0]
    985c:	07da      	lsls	r2, r3, #31
    985e:	460d      	mov	r5, r1
    9860:	4604      	mov	r4, r0
    9862:	d511      	bpl.n	9888 <eeprom_write_byte+0x38>
	if (FlexRAM[offset] != value) {
    9864:	f104 50a0 	add.w	r0, r4, #335544320	; 0x14000000
    9868:	7803      	ldrb	r3, [r0, #0]
    986a:	42ab      	cmp	r3, r5
    986c:	d00a      	beq.n	9884 <eeprom_write_byte+0x34>
		kinetis_hsrun_disable();
		uint8_t stat = FTFL_FSTAT & 0x70;
    986e:	4a0b      	ldr	r2, [pc, #44]	; (989c <eeprom_write_byte+0x4c>)
    9870:	7813      	ldrb	r3, [r2, #0]
		if (stat) FTFL_FSTAT = stat;
    9872:	f013 0370 	ands.w	r3, r3, #112	; 0x70
    9876:	bf18      	it	ne
    9878:	7013      	strbne	r3, [r2, #0]
	return (FTFL_FCNFG & FTFL_FCNFG_EEERDY) ? 1 : 0;
}

static void flexram_wait(void)
{
	while (!(FTFL_FCNFG & FTFL_FCNFG_EEERDY)) {
    987a:	4a07      	ldr	r2, [pc, #28]	; (9898 <eeprom_write_byte+0x48>)
	if (!(FTFL_FCNFG & FTFL_FCNFG_EEERDY)) eeprom_initialize();
	if (FlexRAM[offset] != value) {
		kinetis_hsrun_disable();
		uint8_t stat = FTFL_FSTAT & 0x70;
		if (stat) FTFL_FSTAT = stat;
		FlexRAM[offset] = value;
    987c:	7005      	strb	r5, [r0, #0]
	return (FTFL_FCNFG & FTFL_FCNFG_EEERDY) ? 1 : 0;
}

static void flexram_wait(void)
{
	while (!(FTFL_FCNFG & FTFL_FCNFG_EEERDY)) {
    987e:	7813      	ldrb	r3, [r2, #0]
    9880:	07db      	lsls	r3, r3, #31
    9882:	d5fc      	bpl.n	987e <eeprom_write_byte+0x2e>
    9884:	bd38      	pop	{r3, r4, r5, pc}
    9886:	4770      	bx	lr
void eeprom_write_byte(uint8_t *addr, uint8_t value)
{
	uint32_t offset = (uint32_t)addr;

	if (offset >= EEPROM_SIZE) return;
	if (!(FTFL_FCNFG & FTFL_FCNFG_EEERDY)) eeprom_initialize();
    9888:	f7ff ff80 	bl	978c <eeprom_initialize>
	if (FlexRAM[offset] != value) {
    988c:	f104 50a0 	add.w	r0, r4, #335544320	; 0x14000000
    9890:	7803      	ldrb	r3, [r0, #0]
    9892:	42ab      	cmp	r3, r5
    9894:	d1eb      	bne.n	986e <eeprom_write_byte+0x1e>
    9896:	e7f5      	b.n	9884 <eeprom_write_byte+0x34>
    9898:	40020001 	.word	0x40020001
    989c:	40020000 	.word	0x40020000

000098a0 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    98a0:	b508      	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    98a2:	f7fc fabb 	bl	5e1c <setup>
	while (1) {
		loop();
    98a6:	f7fc fc85 	bl	61b4 <loop>
		yield();
    98aa:	f001 ffad 	bl	b808 <yield>
    98ae:	e7fa      	b.n	98a6 <main+0x6>

000098b0 <memcpy>:
	@ r1: src
	@ r2: len
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
    98b0:	4684      	mov	ip, r0
#else
	push	{r0}
#endif
	orr	r3, r1, r0
    98b2:	ea41 0300 	orr.w	r3, r1, r0
	ands	r3, r3, #3
    98b6:	f013 0303 	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    98ba:	d16d      	bne.n	9998 <memcpy+0xe8>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    98bc:	3a40      	subs	r2, #64	; 0x40
	blo	.Lmid_block
    98be:	d341      	bcc.n	9944 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    98c0:	f851 3b04 	ldr.w	r3, [r1], #4
    98c4:	f840 3b04 	str.w	r3, [r0], #4
    98c8:	f851 3b04 	ldr.w	r3, [r1], #4
    98cc:	f840 3b04 	str.w	r3, [r0], #4
    98d0:	f851 3b04 	ldr.w	r3, [r1], #4
    98d4:	f840 3b04 	str.w	r3, [r0], #4
    98d8:	f851 3b04 	ldr.w	r3, [r1], #4
    98dc:	f840 3b04 	str.w	r3, [r0], #4
    98e0:	f851 3b04 	ldr.w	r3, [r1], #4
    98e4:	f840 3b04 	str.w	r3, [r0], #4
    98e8:	f851 3b04 	ldr.w	r3, [r1], #4
    98ec:	f840 3b04 	str.w	r3, [r0], #4
    98f0:	f851 3b04 	ldr.w	r3, [r1], #4
    98f4:	f840 3b04 	str.w	r3, [r0], #4
    98f8:	f851 3b04 	ldr.w	r3, [r1], #4
    98fc:	f840 3b04 	str.w	r3, [r0], #4
    9900:	f851 3b04 	ldr.w	r3, [r1], #4
    9904:	f840 3b04 	str.w	r3, [r0], #4
    9908:	f851 3b04 	ldr.w	r3, [r1], #4
    990c:	f840 3b04 	str.w	r3, [r0], #4
    9910:	f851 3b04 	ldr.w	r3, [r1], #4
    9914:	f840 3b04 	str.w	r3, [r0], #4
    9918:	f851 3b04 	ldr.w	r3, [r1], #4
    991c:	f840 3b04 	str.w	r3, [r0], #4
    9920:	f851 3b04 	ldr.w	r3, [r1], #4
    9924:	f840 3b04 	str.w	r3, [r0], #4
    9928:	f851 3b04 	ldr.w	r3, [r1], #4
    992c:	f840 3b04 	str.w	r3, [r0], #4
    9930:	f851 3b04 	ldr.w	r3, [r1], #4
    9934:	f840 3b04 	str.w	r3, [r0], #4
    9938:	f851 3b04 	ldr.w	r3, [r1], #4
    993c:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    9940:	3a40      	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    9942:	d2bd      	bcs.n	98c0 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    9944:	3230      	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    9946:	d311      	bcc.n	996c <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    9948:	f851 3b04 	ldr.w	r3, [r1], #4
    994c:	f840 3b04 	str.w	r3, [r0], #4
    9950:	f851 3b04 	ldr.w	r3, [r1], #4
    9954:	f840 3b04 	str.w	r3, [r0], #4
    9958:	f851 3b04 	ldr.w	r3, [r1], #4
    995c:	f840 3b04 	str.w	r3, [r0], #4
    9960:	f851 3b04 	ldr.w	r3, [r1], #4
    9964:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    9968:	3a10      	subs	r2, #16
	bhs	.Lmid_block_loop
    996a:	d2ed      	bcs.n	9948 <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    996c:	320c      	adds	r2, #12
	blo	.Lcopy_less_than_4
    996e:	d305      	bcc.n	997c <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    9970:	f851 3b04 	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    9974:	f840 3b04 	str.w	r3, [r0], #4
	subs	r2, #4
    9978:	3a04      	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    997a:	d2f9      	bcs.n	9970 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    997c:	3204      	adds	r2, #4
	beq	.Ldone
    997e:	d008      	beq.n	9992 <memcpy+0xe2>

	lsls	r2, r2, #31
    9980:	07d2      	lsls	r2, r2, #31
	itt ne
    9982:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    9984:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    9988:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc	.Ldone
    998c:	d301      	bcc.n	9992 <memcpy+0xe2>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
    998e:	880b      	ldrh	r3, [r1, #0]
	strh	r3, [r0]
    9990:	8003      	strh	r3, [r0, #0]
	strb	r3, [r0, #1]
#endif /* __ARM_FEATURE_UNALIGNED */

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
    9992:	4660      	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
    9994:	4770      	bx	lr
    9996:	bf00      	nop
#define Ldst_aligned Lbig_block

	/* Copy word by word using LDR when alignment can be done in hardware,
	i.e., SCTLR.A is set, supporting unaligned access in LDR and STR.  */

	cmp	r2, #8
    9998:	2a08      	cmp	r2, #8
	blo	.Lbyte_copy
    999a:	d313      	bcc.n	99c4 <memcpy+0x114>

	/* if src is aligned, just go to the big block loop.  */
	lsls	r3, r1, #30
    999c:	078b      	lsls	r3, r1, #30
	beq	.Ldst_aligned
    999e:	d08d      	beq.n	98bc <memcpy+0xc>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    99a0:	f010 0303 	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    99a4:	d08a      	beq.n	98bc <memcpy+0xc>

	rsb	r3, #4
    99a6:	f1c3 0304 	rsb	r3, r3, #4
	subs	r2, r3
    99aa:	1ad2      	subs	r2, r2, r3

	lsls    r3, r3, #31
    99ac:	07db      	lsls	r3, r3, #31
	itt ne
    99ae:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    99b0:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    99b4:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    99b8:	d380      	bcc.n	98bc <memcpy+0xc>

#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
    99ba:	f831 3b02 	ldrh.w	r3, [r1], #2
	strh    r3, [r0], #2
    99be:	f820 3b02 	strh.w	r3, [r0], #2
	b	.Ldst_aligned
    99c2:	e77b      	b.n	98bc <memcpy+0xc>
	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    99c4:	3a04      	subs	r2, #4
	blo	.Lcopy_less_than_4
    99c6:	d3d9      	bcc.n	997c <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    99c8:	3a01      	subs	r2, #1
	ldrb    r3, [r1], #1
    99ca:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    99ce:	f800 3b01 	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    99d2:	d2f9      	bcs.n	99c8 <memcpy+0x118>

	ldrb	r3, [r1]
    99d4:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    99d6:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    99d8:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    99da:	7043      	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    99dc:	788b      	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    99de:	7083      	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
    99e0:	4660      	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
    99e2:	4770      	bx	lr

000099e4 <fault_isr>:
void _init_Teensyduino_internal_(void) __attribute__((noinline));
void __libc_init_array(void);


void fault_isr(void)
{
    99e4:	b508      	push	{r3, lr}
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    99e6:	4c10      	ldr	r4, [pc, #64]	; (9a28 <fault_isr+0x44>)
    99e8:	e008      	b.n	99fc <fault_isr+0x18>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    99ea:	6823      	ldr	r3, [r4, #0]
    99ec:	0559      	lsls	r1, r3, #21
    99ee:	d40d      	bmi.n	9a0c <fault_isr+0x28>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    99f0:	6823      	ldr	r3, [r4, #0]
    99f2:	051a      	lsls	r2, r3, #20
    99f4:	d40f      	bmi.n	9a16 <fault_isr+0x32>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    99f6:	6823      	ldr	r3, [r4, #0]
    99f8:	04db      	lsls	r3, r3, #19
    99fa:	d411      	bmi.n	9a20 <fault_isr+0x3c>
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    99fc:	6823      	ldr	r3, [r4, #0]
    99fe:	0358      	lsls	r0, r3, #13
    9a00:	d5f3      	bpl.n	99ea <fault_isr+0x6>
    9a02:	f000 ff57 	bl	a8b4 <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    9a06:	6823      	ldr	r3, [r4, #0]
    9a08:	0559      	lsls	r1, r3, #21
    9a0a:	d5f1      	bpl.n	99f0 <fault_isr+0xc>
    9a0c:	f001 ff60 	bl	b8d0 <uart0_status_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    9a10:	6823      	ldr	r3, [r4, #0]
    9a12:	051a      	lsls	r2, r3, #20
    9a14:	d5ef      	bpl.n	99f6 <fault_isr+0x12>
    9a16:	f001 fff1 	bl	b9fc <uart1_status_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    9a1a:	6823      	ldr	r3, [r4, #0]
    9a1c:	04db      	lsls	r3, r3, #19
    9a1e:	d5ed      	bpl.n	99fc <fault_isr+0x18>
    9a20:	f002 f882 	bl	bb28 <uart2_status_isr>
    9a24:	e7ea      	b.n	99fc <fault_isr+0x18>
    9a26:	bf00      	nop
    9a28:	40048034 	.word	0x40048034

00009a2c <unused_isr>:
	}
}

void unused_isr(void)
{
    9a2c:	b508      	push	{r3, lr}
	fault_isr();
    9a2e:	f7ff ffd9 	bl	99e4 <fault_isr>
    9a32:	bf00      	nop

00009a34 <startup_early_hook>:
extern void rtc_set(unsigned long t);


static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    9a34:	4b01      	ldr	r3, [pc, #4]	; (9a3c <startup_early_hook+0x8>)
    9a36:	2210      	movs	r2, #16
    9a38:	801a      	strh	r2, [r3, #0]
    9a3a:	4770      	bx	lr
    9a3c:	40052000 	.word	0x40052000

00009a40 <startup_late_hook>:
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
#endif
}
static void startup_default_late_hook(void) {}
    9a40:	4770      	bx	lr
    9a42:	bf00      	nop

00009a44 <_sbrk>:

void * _sbrk(int incr)
{
	char *prev, *stack;

	prev = __brkval;
    9a44:	4909      	ldr	r1, [pc, #36]	; (9a6c <_sbrk+0x28>)

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void * _sbrk(int incr)
{
    9a46:	b508      	push	{r3, lr}
	char *prev, *stack;

	prev = __brkval;
    9a48:	680b      	ldr	r3, [r1, #0]
	if (incr != 0) {
    9a4a:	b130      	cbz	r0, 9a5a <_sbrk+0x16>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
    9a4c:	466a      	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
    9a4e:	4418      	add	r0, r3
    9a50:	f5a2 5280 	sub.w	r2, r2, #4096	; 0x1000
    9a54:	4290      	cmp	r0, r2
    9a56:	d202      	bcs.n	9a5e <_sbrk+0x1a>
			errno = ENOMEM;
			return (void *)-1;
		}
		__brkval = prev + incr;
    9a58:	6008      	str	r0, [r1, #0]
	}
	return prev;
    9a5a:	4618      	mov	r0, r3
}
    9a5c:	bd08      	pop	{r3, pc}

	prev = __brkval;
	if (incr != 0) {
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
		if (prev + incr >= stack - STACK_MARGIN) {
			errno = ENOMEM;
    9a5e:	f004 f85f 	bl	db20 <__errno>
    9a62:	230c      	movs	r3, #12
    9a64:	6003      	str	r3, [r0, #0]
			return (void *)-1;
    9a66:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    9a6a:	bd08      	pop	{r3, pc}
    9a6c:	1fffba00 	.word	0x1fffba00

00009a70 <__cxa_pure_virtual>:
	while (1);
}

__attribute__((weak)) 
void __cxa_pure_virtual()
{
    9a70:	e7fe      	b.n	9a70 <__cxa_pure_virtual>
    9a72:	bf00      	nop

00009a74 <operator new(unsigned int)>:
    9a74:	f004 b882 	b.w	db7c <malloc>

00009a78 <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    9a78:	b4f0      	push	{r4, r5, r6, r7}
    9a7a:	1e4d      	subs	r5, r1, #1
    9a7c:	462e      	mov	r6, r5
	unsigned digit;
	int i=0, j;
    9a7e:	2400      	movs	r4, #0
    9a80:	e000      	b.n	9a84 <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    9a82:	3401      	adds	r4, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
    9a84:	fbb0 f3f2 	udiv	r3, r0, r2
    9a88:	fb02 0013 	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    9a8c:	2809      	cmp	r0, #9
    9a8e:	f100 0730 	add.w	r7, r0, #48	; 0x30
    9a92:	bf8a      	itet	hi
    9a94:	3037      	addhi	r0, #55	; 0x37
    9a96:	b2f8      	uxtbls	r0, r7
    9a98:	b2c0      	uxtbhi	r0, r0
    9a9a:	f806 0f01 	strb.w	r0, [r6, #1]!
		val /= radix;
		if (val == 0) break;
    9a9e:	4618      	mov	r0, r3
    9aa0:	2b00      	cmp	r3, #0
    9aa2:	d1ee      	bne.n	9a82 <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
    9aa4:	190a      	adds	r2, r1, r4
    9aa6:	7053      	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
    9aa8:	b14c      	cbz	r4, 9abe <ultoa+0x46>
		t = buf[j];
		buf[j] = buf[i];
    9aaa:	7810      	ldrb	r0, [r2, #0]
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
		t = buf[j];
    9aac:	f815 6f01 	ldrb.w	r6, [r5, #1]!
		buf[j] = buf[i];
    9ab0:	7028      	strb	r0, [r5, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    9ab2:	3301      	adds	r3, #1
    9ab4:	1ae0      	subs	r0, r4, r3
    9ab6:	4283      	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
    9ab8:	f802 6901 	strb.w	r6, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    9abc:	dbf5      	blt.n	9aaa <ultoa+0x32>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    9abe:	4608      	mov	r0, r1
    9ac0:	bcf0      	pop	{r4, r5, r6, r7}
    9ac2:	4770      	bx	lr

00009ac4 <dtostrf>:
char * fcvtf(float, int, int *, int *);
int isnanf (float x);
int isinff (float x);

char * dtostrf(float val, int width, unsigned int precision, char *buf)
{
    9ac4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9ac8:	460d      	mov	r5, r1
    9aca:	b085      	sub	sp, #20
	int decpt, sign, reqd, pad;
	const char *s, *e;
	char *p;

	int awidth = abs(width);
    9acc:	ea85 79e5 	eor.w	r9, r5, r5, asr #31
	if (isnanf(val)) {
    9ad0:	4601      	mov	r1, r0
char * fcvtf(float, int, int *, int *);
int isnanf (float x);
int isinff (float x);

char * dtostrf(float val, int width, unsigned int precision, char *buf)
{
    9ad2:	4682      	mov	sl, r0
    9ad4:	4617      	mov	r7, r2
    9ad6:	461c      	mov	r4, r3
	int decpt, sign, reqd, pad;
	const char *s, *e;
	char *p;

	int awidth = abs(width);
    9ad8:	eba9 79e5 	sub.w	r9, r9, r5, asr #31
	if (isnanf(val)) {
    9adc:	f003 fe04 	bl	d6e8 <__aeabi_fcmpun>
    9ae0:	2800      	cmp	r0, #0
    9ae2:	f040 812f 	bne.w	9d44 <dtostrf+0x280>
			awidth--;
		}
		*buf = 0;
		return buf;
	}
	if (isinff(val)) {
    9ae6:	f02a 4800 	bic.w	r8, sl, #2147483648	; 0x80000000
    9aea:	4640      	mov	r0, r8
    9aec:	49c7      	ldr	r1, [pc, #796]	; (9e0c <dtostrf+0x348>)
    9aee:	f003 fdfb 	bl	d6e8 <__aeabi_fcmpun>
    9af2:	2800      	cmp	r0, #0
    9af4:	d147      	bne.n	9b86 <dtostrf+0xc2>
    9af6:	4640      	mov	r0, r8
    9af8:	49c4      	ldr	r1, [pc, #784]	; (9e0c <dtostrf+0x348>)
    9afa:	f003 fdd7 	bl	d6ac <__aeabi_fcmple>
    9afe:	4606      	mov	r6, r0
    9b00:	2800      	cmp	r0, #0
    9b02:	d140      	bne.n	9b86 <dtostrf+0xc2>
		int ndigs = (val<0) ? 4 : 3;
    9b04:	2100      	movs	r1, #0
    9b06:	4650      	mov	r0, sl
    9b08:	f003 fdc6 	bl	d698 <__aeabi_fcmplt>
    9b0c:	2800      	cmp	r0, #0
    9b0e:	bf14      	ite	ne
    9b10:	2004      	movne	r0, #4
    9b12:	2003      	moveq	r0, #3
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    9b14:	4548      	cmp	r0, r9
    9b16:	db1d      	blt.n	9b54 <dtostrf+0x90>
		if (width<0) {
    9b18:	2d00      	cmp	r5, #0
    9b1a:	f2c0 8174 	blt.w	9e06 <dtostrf+0x342>
			while (awidth) {
				*buf++ = ' ';
				awidth--;
			}
		}
		if (val<0) *buf++ = '-';
    9b1e:	4650      	mov	r0, sl
    9b20:	2100      	movs	r1, #0
    9b22:	f003 fdb9 	bl	d698 <__aeabi_fcmplt>
    9b26:	4625      	mov	r5, r4
    9b28:	bb48      	cbnz	r0, 9b7e <dtostrf+0xba>
		if (DTOA_UPPER) {
			*buf++ = 'I';  *buf++ = 'N';  *buf++ = 'F';
    9b2a:	2149      	movs	r1, #73	; 0x49
    9b2c:	224e      	movs	r2, #78	; 0x4e
    9b2e:	2346      	movs	r3, #70	; 0x46
    9b30:	7021      	strb	r1, [r4, #0]
    9b32:	7062      	strb	r2, [r4, #1]
    9b34:	70a3      	strb	r3, [r4, #2]
    9b36:	3403      	adds	r4, #3
		} else {
			*buf++ = 'i';  *buf++ = 'n';  *buf++ = 'f';
		}
		while (awidth) {
    9b38:	2e00      	cmp	r6, #0
    9b3a:	f000 8176 	beq.w	9e2a <dtostrf+0x366>
    9b3e:	19a0      	adds	r0, r4, r6
			*buf++ = ' ';
    9b40:	2320      	movs	r3, #32
    9b42:	f804 3b01 	strb.w	r3, [r4], #1
		if (DTOA_UPPER) {
			*buf++ = 'I';  *buf++ = 'N';  *buf++ = 'F';
		} else {
			*buf++ = 'i';  *buf++ = 'n';  *buf++ = 'f';
		}
		while (awidth) {
    9b46:	42a0      	cmp	r0, r4
    9b48:	d1fb      	bne.n	9b42 <dtostrf+0x7e>
			*buf++ = ' ';
			awidth--;
		}
		*buf = 0;
    9b4a:	2300      	movs	r3, #0
    9b4c:	7003      	strb	r3, [r0, #0]

	//char format[20];
	//sprintf(format, "%%%d.%df", width, precision);
	//sprintf(buf, format, val);
	return buf;
}
    9b4e:	b005      	add	sp, #20
    9b50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return buf;
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
    9b54:	2d00      	cmp	r5, #0
		*buf = 0;
		return buf;
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    9b56:	ebc0 0609 	rsb	r6, r0, r9
		if (width<0) {
    9b5a:	dae0      	bge.n	9b1e <dtostrf+0x5a>
			while (awidth) {
    9b5c:	2e00      	cmp	r6, #0
    9b5e:	f000 8152 	beq.w	9e06 <dtostrf+0x342>
    9b62:	19a5      	adds	r5, r4, r6
				*buf++ = ' ';
    9b64:	2320      	movs	r3, #32
    9b66:	f804 3b01 	strb.w	r3, [r4], #1
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
			while (awidth) {
    9b6a:	42ac      	cmp	r4, r5
    9b6c:	d1fb      	bne.n	9b66 <dtostrf+0xa2>
				*buf++ = ' ';
				awidth--;
			}
		}
		if (val<0) *buf++ = '-';
    9b6e:	4650      	mov	r0, sl
    9b70:	2100      	movs	r1, #0
    9b72:	f003 fd91 	bl	d698 <__aeabi_fcmplt>
    9b76:	2800      	cmp	r0, #0
    9b78:	f000 8122 	beq.w	9dc0 <dtostrf+0x2fc>
    9b7c:	2600      	movs	r6, #0
    9b7e:	232d      	movs	r3, #45	; 0x2d
    9b80:	702b      	strb	r3, [r5, #0]
    9b82:	1c6c      	adds	r4, r5, #1
    9b84:	e7d1      	b.n	9b2a <dtostrf+0x66>
		}
		*buf = 0;
		return buf;
	}

	s = fcvtf(val, precision, &decpt, &sign);
    9b86:	ab02      	add	r3, sp, #8
    9b88:	aa01      	add	r2, sp, #4
    9b8a:	4639      	mov	r1, r7
    9b8c:	4650      	mov	r0, sl
    9b8e:	f003 ffb7 	bl	db00 <fcvtf>
    9b92:	46bb      	mov	fp, r7
    9b94:	4680      	mov	r8, r0

	// if only 1 digit in output
	if (precision == 0 && decpt == 0) {
    9b96:	f8dd 9004 	ldr.w	r9, [sp, #4]
    9b9a:	2f00      	cmp	r7, #0
    9b9c:	d057      	beq.n	9c4e <dtostrf+0x18a>
    9b9e:	f1c9 0300 	rsb	r3, r9, #0
		s = (*s < '5') ? "0" : "1";
		decpt++;
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
    9ba2:	42bb      	cmp	r3, r7
    9ba4:	f300 8094 	bgt.w	9cd0 <dtostrf+0x20c>
    9ba8:	4640      	mov	r0, r8
    9baa:	f004 ff49 	bl	ea40 <strlen>
    9bae:	4606      	mov	r6, r0
	}

	reqd = strlen(s);

	// add 1 for decimal point
	if (reqd > decpt) reqd++;
    9bb0:	45b1      	cmp	r9, r6
    9bb2:	bfb8      	it	lt
    9bb4:	3601      	addlt	r6, #1

	// add 1 for zero in front of decimal point
	if (decpt == 0) reqd++;
    9bb6:	f1b9 0f00 	cmp.w	r9, #0
    9bba:	f040 8098 	bne.w	9cee <dtostrf+0x22a>
    9bbe:	3601      	adds	r6, #1
			if (newDecimalPoint - decpt == precision + 1) decpt++;
		}
	}

	// add 1 for sign if negative
	if (sign) reqd++;
    9bc0:	f8dd e008 	ldr.w	lr, [sp, #8]
    9bc4:	f1be 0f00 	cmp.w	lr, #0
    9bc8:	d053      	beq.n	9c72 <dtostrf+0x1ae>
    9bca:	3601      	adds	r6, #1

	p = buf;
	e = p + reqd;
	pad = width - reqd;
    9bcc:	1ba8      	subs	r0, r5, r6
	if (pad > 0) {
    9bce:	2800      	cmp	r0, #0

	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
	e = p + reqd;
    9bd0:	eb04 0106 	add.w	r1, r4, r6
	pad = width - reqd;
	if (pad > 0) {
    9bd4:	dc53      	bgt.n	9c7e <dtostrf+0x1ba>
	}

	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
    9bd6:	4623      	mov	r3, r4
	pad = width - reqd;
	if (pad > 0) {
		e += pad;
		while (pad-- > 0) *p++ = ' ';
	}
	if (sign) *p++ = '-';
    9bd8:	222d      	movs	r2, #45	; 0x2d
    9bda:	701a      	strb	r2, [r3, #0]
    9bdc:	3301      	adds	r3, #1
	if (decpt == 0 && precision > 0) {
    9bde:	f1b9 0f00 	cmp.w	r9, #0
    9be2:	d163      	bne.n	9cac <dtostrf+0x1e8>
    9be4:	b137      	cbz	r7, 9bf4 <dtostrf+0x130>
		*p++ = '0';
    9be6:	461a      	mov	r2, r3
    9be8:	2030      	movs	r0, #48	; 0x30
    9bea:	f802 0b02 	strb.w	r0, [r2], #2
		*p++ = '.';
    9bee:	202e      	movs	r0, #46	; 0x2e
    9bf0:	7058      	strb	r0, [r3, #1]
    9bf2:	4613      	mov	r3, r2
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    9bf4:	428b      	cmp	r3, r1
    9bf6:	d220      	bcs.n	9c3a <dtostrf+0x176>
		*p++ = *s++;
    9bf8:	1c5f      	adds	r7, r3, #1
    9bfa:	f898 2000 	ldrb.w	r2, [r8]
    9bfe:	701a      	strb	r2, [r3, #0]
		if (p == e) break;
    9c00:	428f      	cmp	r7, r1
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
		*p++ = *s++;
    9c02:	f108 0801 	add.w	r8, r8, #1
		if (p == e) break;
    9c06:	d019      	beq.n	9c3c <dtostrf+0x178>
    9c08:	9a01      	ldr	r2, [sp, #4]
		if (--decpt == 0) *p++ = '.';
    9c0a:	f04f 0e2e 	mov.w	lr, #46	; 0x2e
    9c0e:	e00b      	b.n	9c28 <dtostrf+0x164>
    9c10:	f883 e001 	strb.w	lr, [r3, #1]
    9c14:	3302      	adds	r3, #2
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    9c16:	428b      	cmp	r3, r1
		*p++ = *s++;
    9c18:	f103 0701 	add.w	r7, r3, #1
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    9c1c:	d20d      	bcs.n	9c3a <dtostrf+0x176>
		*p++ = *s++;
    9c1e:	f818 0b01 	ldrb.w	r0, [r8], #1
    9c22:	7018      	strb	r0, [r3, #0]
		if (p == e) break;
    9c24:	428f      	cmp	r7, r1
    9c26:	d009      	beq.n	9c3c <dtostrf+0x178>
		if (--decpt == 0) *p++ = '.';
    9c28:	3a01      	subs	r2, #1
    9c2a:	9201      	str	r2, [sp, #4]
    9c2c:	2a00      	cmp	r2, #0
    9c2e:	d0ef      	beq.n	9c10 <dtostrf+0x14c>
    9c30:	463b      	mov	r3, r7
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    9c32:	428b      	cmp	r3, r1
		*p++ = *s++;
    9c34:	f103 0701 	add.w	r7, r3, #1
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    9c38:	d3f1      	bcc.n	9c1e <dtostrf+0x15a>
    9c3a:	4619      	mov	r1, r3
		*p++ = *s++;
		if (p == e) break;
		if (--decpt == 0) *p++ = '.';
	}
	if (width < 0) {
    9c3c:	2d00      	cmp	r5, #0
    9c3e:	f2c0 80a9 	blt.w	9d94 <dtostrf+0x2d0>
		pad = (reqd + width) * -1;
		while (pad-- > 0) *p++ = ' ';
	}
	*p = 0;
    9c42:	2300      	movs	r3, #0

	//char format[20];
	//sprintf(format, "%%%d.%df", width, precision);
	//sprintf(buf, format, val);
	return buf;
    9c44:	4620      	mov	r0, r4
	}
	if (width < 0) {
		pad = (reqd + width) * -1;
		while (pad-- > 0) *p++ = ' ';
	}
	*p = 0;
    9c46:	700b      	strb	r3, [r1, #0]

	//char format[20];
	//sprintf(format, "%%%d.%df", width, precision);
	//sprintf(buf, format, val);
	return buf;
}
    9c48:	b005      	add	sp, #20
    9c4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}

	s = fcvtf(val, precision, &decpt, &sign);

	// if only 1 digit in output
	if (precision == 0 && decpt == 0) {
    9c4e:	f1b9 0f00 	cmp.w	r9, #0
    9c52:	d1a4      	bne.n	9b9e <dtostrf+0xda>
		// round and move decimal point
		s = (*s < '5') ? "0" : "1";
    9c54:	f890 8000 	ldrb.w	r8, [r0]
    9c58:	496d      	ldr	r1, [pc, #436]	; (9e10 <dtostrf+0x34c>)
    9c5a:	4a6e      	ldr	r2, [pc, #440]	; (9e14 <dtostrf+0x350>)
		decpt++;
    9c5c:	2301      	movs	r3, #1
    9c5e:	9301      	str	r3, [sp, #4]
    9c60:	4699      	mov	r9, r3
	s = fcvtf(val, precision, &decpt, &sign);

	// if only 1 digit in output
	if (precision == 0 && decpt == 0) {
		// round and move decimal point
		s = (*s < '5') ? "0" : "1";
    9c62:	f1b8 0f34 	cmp.w	r8, #52	; 0x34
    9c66:	bf8c      	ite	hi
    9c68:	4688      	movhi	r8, r1
    9c6a:	4690      	movls	r8, r2
		decpt++;
    9c6c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    9c70:	e797      	b.n	9ba2 <dtostrf+0xde>
	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
	e = p + reqd;
	pad = width - reqd;
    9c72:	1ba8      	subs	r0, r5, r6
	if (pad > 0) {
    9c74:	2800      	cmp	r0, #0

	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
	e = p + reqd;
    9c76:	eb04 0106 	add.w	r1, r4, r6
	pad = width - reqd;
	if (pad > 0) {
    9c7a:	f340 80d8 	ble.w	9e2e <dtostrf+0x36a>
		e += pad;
    9c7e:	4401      	add	r1, r0
		decpt++;
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
		s = "0";
    9c80:	4622      	mov	r2, r4
	p = buf;
	e = p + reqd;
	pad = width - reqd;
	if (pad > 0) {
		e += pad;
		while (pad-- > 0) *p++ = ' ';
    9c82:	3801      	subs	r0, #1
    9c84:	f04f 0c20 	mov.w	ip, #32
    9c88:	f802 cb01 	strb.w	ip, [r2], #1
    9c8c:	f1c2 0301 	rsb	r3, r2, #1
    9c90:	4403      	add	r3, r0
    9c92:	4423      	add	r3, r4
    9c94:	2b00      	cmp	r3, #0
    9c96:	dcf7      	bgt.n	9c88 <dtostrf+0x1c4>
    9c98:	ea20 73e0 	bic.w	r3, r0, r0, asr #31
    9c9c:	3301      	adds	r3, #1
    9c9e:	4423      	add	r3, r4
	}
	if (sign) *p++ = '-';
    9ca0:	f1be 0f00 	cmp.w	lr, #0
    9ca4:	d198      	bne.n	9bd8 <dtostrf+0x114>
	if (decpt == 0 && precision > 0) {
    9ca6:	f1b9 0f00 	cmp.w	r9, #0
    9caa:	d09b      	beq.n	9be4 <dtostrf+0x120>
		*p++ = '0';
		*p++ = '.';
	}
	else if (decpt < 0 && precision > 0) {
    9cac:	daa2      	bge.n	9bf4 <dtostrf+0x130>
    9cae:	2f00      	cmp	r7, #0
    9cb0:	d0a0      	beq.n	9bf4 <dtostrf+0x130>
		*p++ = '0';
    9cb2:	461a      	mov	r2, r3
    9cb4:	2030      	movs	r0, #48	; 0x30
    9cb6:	f802 0b02 	strb.w	r0, [r2], #2
		*p++ = '.';
    9cba:	272e      	movs	r7, #46	; 0x2e
    9cbc:	705f      	strb	r7, [r3, #1]
    9cbe:	ebc9 0302 	rsb	r3, r9, r2
		// print leading zeros
		while ( decpt < 0 ) {
			decpt++;
			*p++ = '0';
    9cc2:	f802 0b01 	strb.w	r0, [r2], #1
	}
	else if (decpt < 0 && precision > 0) {
		*p++ = '0';
		*p++ = '.';
		// print leading zeros
		while ( decpt < 0 ) {
    9cc6:	4293      	cmp	r3, r2
    9cc8:	d1fb      	bne.n	9cc2 <dtostrf+0x1fe>
    9cca:	2200      	movs	r2, #0
    9ccc:	9201      	str	r2, [sp, #4]
    9cce:	e791      	b.n	9bf4 <dtostrf+0x130>
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
		s = "0";
		decpt = -precision;
    9cd0:	f1c7 0900 	rsb	r9, r7, #0
    9cd4:	2601      	movs	r6, #1
	}

	reqd = strlen(s);

	// add 1 for decimal point
	if (reqd > decpt) reqd++;
    9cd6:	45b1      	cmp	r9, r6
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
		s = "0";
		decpt = -precision;
    9cd8:	4630      	mov	r0, r6
	}

	reqd = strlen(s);

	// add 1 for decimal point
	if (reqd > decpt) reqd++;
    9cda:	bfb8      	it	lt
    9cdc:	3601      	addlt	r6, #1

	// add 1 for zero in front of decimal point
	if (decpt == 0) reqd++;
    9cde:	f1b9 0f00 	cmp.w	r9, #0
		decpt++;
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
		s = "0";
    9ce2:	f8df 8130 	ldr.w	r8, [pc, #304]	; 9e14 <dtostrf+0x350>
		decpt = -precision;
    9ce6:	f8cd 9004 	str.w	r9, [sp, #4]

	// add 1 for decimal point
	if (reqd > decpt) reqd++;

	// add 1 for zero in front of decimal point
	if (decpt == 0) reqd++;
    9cea:	f43f af68 	beq.w	9bbe <dtostrf+0xfa>

	// if leading zeros after decimal point
	if (decpt < 0 && precision > 0) {
    9cee:	f6bf af67 	bge.w	9bc0 <dtostrf+0xfc>
    9cf2:	2f00      	cmp	r7, #0
    9cf4:	f43f af64 	beq.w	9bc0 <dtostrf+0xfc>
		// ensure enough trailing zeros, add 2 for '0.'
		reqd = precision + 2;

		if (strlen(s) > precision + decpt) {
    9cf8:	eb09 0307 	add.w	r3, r9, r7
    9cfc:	4298      	cmp	r0, r3
	if (decpt == 0) reqd++;

	// if leading zeros after decimal point
	if (decpt < 0 && precision > 0) {
		// ensure enough trailing zeros, add 2 for '0.'
		reqd = precision + 2;
    9cfe:	f107 0602 	add.w	r6, r7, #2

		if (strlen(s) > precision + decpt) {
    9d02:	f67f af5d 	bls.w	9bc0 <dtostrf+0xfc>

			int newPrecision = precision;
			int newDecimalPoint;

			// shift decimal point
			while (newPrecision > 0) {
    9d06:	2f00      	cmp	r7, #0
    9d08:	dd07      	ble.n	9d1a <dtostrf+0x256>
				val *= 10.0;
    9d0a:	4650      	mov	r0, sl
    9d0c:	4942      	ldr	r1, [pc, #264]	; (9e18 <dtostrf+0x354>)
    9d0e:	f003 fb25 	bl	d35c <__aeabi_fmul>

			int newPrecision = precision;
			int newDecimalPoint;

			// shift decimal point
			while (newPrecision > 0) {
    9d12:	f1bb 0b01 	subs.w	fp, fp, #1
				val *= 10.0;
    9d16:	4682      	mov	sl, r0

			int newPrecision = precision;
			int newDecimalPoint;

			// shift decimal point
			while (newPrecision > 0) {
    9d18:	d1f7      	bne.n	9d0a <dtostrf+0x246>
				val *= 10.0;
				newPrecision--;
			}

			// round after accounting for leading 0's
			s = fcvtf(val, newPrecision, &newDecimalPoint, &sign);
    9d1a:	ab02      	add	r3, sp, #8
    9d1c:	aa03      	add	r2, sp, #12
    9d1e:	4659      	mov	r1, fp
    9d20:	4650      	mov	r0, sl
    9d22:	f003 feed 	bl	db00 <fcvtf>

			// if rounded up to new digit (e.g. 0.09 to 0.1), move decimal point
			if (newDecimalPoint - decpt == precision + 1) decpt++;
    9d26:	f8dd 9004 	ldr.w	r9, [sp, #4]
    9d2a:	9a03      	ldr	r2, [sp, #12]
    9d2c:	1c7b      	adds	r3, r7, #1
    9d2e:	ebc9 0202 	rsb	r2, r9, r2
    9d32:	429a      	cmp	r2, r3
    9d34:	bf08      	it	eq
    9d36:	f109 0901 	addeq.w	r9, r9, #1
				val *= 10.0;
				newPrecision--;
			}

			// round after accounting for leading 0's
			s = fcvtf(val, newPrecision, &newDecimalPoint, &sign);
    9d3a:	4680      	mov	r8, r0

			// if rounded up to new digit (e.g. 0.09 to 0.1), move decimal point
			if (newDecimalPoint - decpt == precision + 1) decpt++;
    9d3c:	bf08      	it	eq
    9d3e:	f8cd 9004 	streq.w	r9, [sp, #4]
    9d42:	e73d      	b.n	9bc0 <dtostrf+0xfc>
	const char *s, *e;
	char *p;

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
    9d44:	2100      	movs	r1, #0
    9d46:	4650      	mov	r0, sl
    9d48:	f003 fca6 	bl	d698 <__aeabi_fcmplt>
    9d4c:	2800      	cmp	r0, #0
    9d4e:	bf14      	ite	ne
    9d50:	2004      	movne	r0, #4
    9d52:	2003      	moveq	r0, #3
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    9d54:	4548      	cmp	r0, r9
    9d56:	da3b      	bge.n	9dd0 <dtostrf+0x30c>
		if (width<0) {
    9d58:	2d00      	cmp	r5, #0
	char *p;

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    9d5a:	ebc0 0609 	rsb	r6, r0, r9
		if (width<0) {
    9d5e:	db3b      	blt.n	9dd8 <dtostrf+0x314>
			while (awidth) {
				*buf++ = ' ';
				awidth--;
			}
		}
		if (copysignf(1.0f, val)<0) *buf++ = '-';
    9d60:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
    9d64:	4650      	mov	r0, sl
    9d66:	2100      	movs	r1, #0
    9d68:	f363 001e 	bfi	r0, r3, #0, #31
    9d6c:	f003 fc94 	bl	d698 <__aeabi_fcmplt>
    9d70:	4625      	mov	r5, r4
    9d72:	2800      	cmp	r0, #0
    9d74:	d141      	bne.n	9dfa <dtostrf+0x336>
		if (DTOA_UPPER) {
			*buf++ = 'N';  *buf++ = 'A';  *buf++ = 'N';
    9d76:	234e      	movs	r3, #78	; 0x4e
    9d78:	2241      	movs	r2, #65	; 0x41
    9d7a:	7023      	strb	r3, [r4, #0]
    9d7c:	70a3      	strb	r3, [r4, #2]
    9d7e:	7062      	strb	r2, [r4, #1]
    9d80:	3403      	adds	r4, #3
		} else {
			*buf++ = 'n';  *buf++ = 'a';  *buf++ = 'n';
		}
		while (awidth) {
    9d82:	2e00      	cmp	r6, #0
    9d84:	d051      	beq.n	9e2a <dtostrf+0x366>
    9d86:	19a0      	adds	r0, r4, r6
			*buf++ = ' ';
    9d88:	2320      	movs	r3, #32
    9d8a:	f804 3b01 	strb.w	r3, [r4], #1
		if (DTOA_UPPER) {
			*buf++ = 'N';  *buf++ = 'A';  *buf++ = 'N';
		} else {
			*buf++ = 'n';  *buf++ = 'a';  *buf++ = 'n';
		}
		while (awidth) {
    9d8e:	4284      	cmp	r4, r0
    9d90:	d1fb      	bne.n	9d8a <dtostrf+0x2c6>
    9d92:	e6da      	b.n	9b4a <dtostrf+0x86>
		*p++ = *s++;
		if (p == e) break;
		if (--decpt == 0) *p++ = '.';
	}
	if (width < 0) {
		pad = (reqd + width) * -1;
    9d94:	19a8      	adds	r0, r5, r6
		while (pad-- > 0) *p++ = ' ';
    9d96:	4243      	negs	r3, r0
    9d98:	2b00      	cmp	r3, #0
    9d9a:	ea6f 0000 	mvn.w	r0, r0
    9d9e:	f77f af50 	ble.w	9c42 <dtostrf+0x17e>
    9da2:	460a      	mov	r2, r1
    9da4:	2520      	movs	r5, #32
    9da6:	f802 5b01 	strb.w	r5, [r2], #1
    9daa:	f1c2 0301 	rsb	r3, r2, #1
    9dae:	4403      	add	r3, r0
    9db0:	440b      	add	r3, r1
    9db2:	2b00      	cmp	r3, #0
    9db4:	dcf7      	bgt.n	9da6 <dtostrf+0x2e2>
    9db6:	ea20 73e0 	bic.w	r3, r0, r0, asr #31
    9dba:	3301      	adds	r3, #1
    9dbc:	4419      	add	r1, r3
    9dbe:	e740      	b.n	9c42 <dtostrf+0x17e>
				awidth--;
			}
		}
		if (val<0) *buf++ = '-';
		if (DTOA_UPPER) {
			*buf++ = 'I';  *buf++ = 'N';  *buf++ = 'F';
    9dc0:	2149      	movs	r1, #73	; 0x49
    9dc2:	224e      	movs	r2, #78	; 0x4e
    9dc4:	2346      	movs	r3, #70	; 0x46
    9dc6:	7029      	strb	r1, [r5, #0]
    9dc8:	706a      	strb	r2, [r5, #1]
    9dca:	70ab      	strb	r3, [r5, #2]
    9dcc:	1ce8      	adds	r0, r5, #3
    9dce:	e6bc      	b.n	9b4a <dtostrf+0x86>

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
    9dd0:	2d00      	cmp	r5, #0
    9dd2:	db16      	blt.n	9e02 <dtostrf+0x33e>
	char *p;

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    9dd4:	2600      	movs	r6, #0
    9dd6:	e7c3      	b.n	9d60 <dtostrf+0x29c>
		if (width<0) {
			while (awidth) {
    9dd8:	b19e      	cbz	r6, 9e02 <dtostrf+0x33e>
    9dda:	19a5      	adds	r5, r4, r6
				*buf++ = ' ';
    9ddc:	2320      	movs	r3, #32
    9dde:	f804 3b01 	strb.w	r3, [r4], #1
	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
			while (awidth) {
    9de2:	42ac      	cmp	r4, r5
    9de4:	d1fb      	bne.n	9dde <dtostrf+0x31a>
				*buf++ = ' ';
				awidth--;
			}
		}
		if (copysignf(1.0f, val)<0) *buf++ = '-';
    9de6:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
    9dea:	4650      	mov	r0, sl
    9dec:	2100      	movs	r1, #0
    9dee:	f363 001e 	bfi	r0, r3, #0, #31
    9df2:	f003 fc51 	bl	d698 <__aeabi_fcmplt>
    9df6:	b188      	cbz	r0, 9e1c <dtostrf+0x358>
    9df8:	2600      	movs	r6, #0
    9dfa:	232d      	movs	r3, #45	; 0x2d
    9dfc:	702b      	strb	r3, [r5, #0]
    9dfe:	1c6c      	adds	r4, r5, #1
    9e00:	e7b9      	b.n	9d76 <dtostrf+0x2b2>

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
    9e02:	4625      	mov	r5, r4
    9e04:	e7ef      	b.n	9de6 <dtostrf+0x322>
		return buf;
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
    9e06:	4625      	mov	r5, r4
    9e08:	e6b1      	b.n	9b6e <dtostrf+0xaa>
    9e0a:	bf00      	nop
    9e0c:	7f7fffff 	.word	0x7f7fffff
    9e10:	000123c4 	.word	0x000123c4
    9e14:	00010fa8 	.word	0x00010fa8
    9e18:	41200000 	.word	0x41200000
				awidth--;
			}
		}
		if (copysignf(1.0f, val)<0) *buf++ = '-';
		if (DTOA_UPPER) {
			*buf++ = 'N';  *buf++ = 'A';  *buf++ = 'N';
    9e1c:	234e      	movs	r3, #78	; 0x4e
    9e1e:	2241      	movs	r2, #65	; 0x41
    9e20:	702b      	strb	r3, [r5, #0]
    9e22:	70ab      	strb	r3, [r5, #2]
    9e24:	706a      	strb	r2, [r5, #1]
    9e26:	1ce8      	adds	r0, r5, #3
    9e28:	e68f      	b.n	9b4a <dtostrf+0x86>
				awidth--;
			}
		}
		if (val<0) *buf++ = '-';
		if (DTOA_UPPER) {
			*buf++ = 'I';  *buf++ = 'N';  *buf++ = 'F';
    9e2a:	4620      	mov	r0, r4
    9e2c:	e68d      	b.n	9b4a <dtostrf+0x86>
	}

	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
    9e2e:	4623      	mov	r3, r4
    9e30:	e6d5      	b.n	9bde <dtostrf+0x11a>
    9e32:	bf00      	nop

00009e34 <dummy_isr>:
	{((volatile uint8_t *)&CORE_PIN26_PORTREG + (CORE_PIN26_BIT >> 3)), &CORE_PIN26_CONFIG, (1<<(CORE_PIN26_BIT & 7))}
};

#endif

static void dummy_isr() {};
    9e34:	4770      	bx	lr
    9e36:	bf00      	nop

00009e38 <digitalWrite.part.1>:



// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
    9e38:	b410      	push	{r4}
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
    9e3a:	4b0f      	ldr	r3, [pc, #60]	; (9e78 <digitalWrite.part.1+0x40>)
    9e3c:	f853 2030 	ldr.w	r2, [r3, r0, lsl #3]
    9e40:	f892 4280 	ldrb.w	r4, [r2, #640]	; 0x280
    9e44:	b12c      	cbz	r4, 9e52 <digitalWrite.part.1+0x1a>
		if (val) {
			*portSetRegister(pin) = 1;
    9e46:	2301      	movs	r3, #1
void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
    9e48:	b169      	cbz	r1, 9e66 <digitalWrite.part.1+0x2e>
			*portSetRegister(pin) = 1;
    9e4a:	f882 3080 	strb.w	r3, [r2, #128]	; 0x80
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    9e4e:	bc10      	pop	{r4}
    9e50:	4770      	bx	lr
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
    9e52:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
    9e56:	685b      	ldr	r3, [r3, #4]
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    9e58:	681a      	ldr	r2, [r3, #0]
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
    9e5a:	b941      	cbnz	r1, 9e6e <digitalWrite.part.1+0x36>
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
			//*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else {
			// TODO use bitband for atomic read-mod-write
			*config &= ~(PORT_PCR_PE);
    9e5c:	f022 0202 	bic.w	r2, r2, #2
    9e60:	601a      	str	r2, [r3, #0]
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    9e62:	bc10      	pop	{r4}
    9e64:	4770      	bx	lr
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
			*portSetRegister(pin) = 1;
		} else {
			*portClearRegister(pin) = 1;
    9e66:	f882 3100 	strb.w	r3, [r2, #256]	; 0x100
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    9e6a:	bc10      	pop	{r4}
    9e6c:	4770      	bx	lr
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    9e6e:	f042 0203 	orr.w	r2, r2, #3
    9e72:	601a      	str	r2, [r3, #0]
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    9e74:	bc10      	pop	{r4}
    9e76:	4770      	bx	lr
    9e78:	000123c8 	.word	0x000123c8

00009e7c <pinMode.part.2>:
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    9e7c:	4a1c      	ldr	r2, [pc, #112]	; (9ef0 <pinMode.part.2+0x74>)
    9e7e:	eb02 03c0 	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    9e82:	2901      	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    9e84:	685b      	ldr	r3, [r3, #4]

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    9e86:	d011      	beq.n	9eac <pinMode.part.2+0x30>
    9e88:	2904      	cmp	r1, #4
    9e8a:	d01b      	beq.n	9ec4 <pinMode.part.2+0x48>
		} else {
		    *config &= ~PORT_PCR_ODE;
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    9e8c:	f852 0030 	ldr.w	r0, [r2, r0, lsl #3]
    9e90:	2200      	movs	r2, #0
    9e92:	f880 2280 	strb.w	r2, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    9e96:	b129      	cbz	r1, 9ea4 <pinMode.part.2+0x28>
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
    9e98:	2902      	cmp	r1, #2
    9e9a:	d020      	beq.n	9ede <pinMode.part.2+0x62>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else if (mode == INPUT_PULLDOWN) {
    9e9c:	2903      	cmp	r1, #3
    9e9e:	d022      	beq.n	9ee6 <pinMode.part.2+0x6a>
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    9ea0:	601a      	str	r2, [r3, #0]
    9ea2:	4770      	bx	lr
		*portModeRegister(pin) = 0;
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
    9ea4:	f44f 7280 	mov.w	r2, #256	; 0x100
    9ea8:	601a      	str	r2, [r3, #0]
    9eaa:	4770      	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    9eac:	f852 0030 	ldr.w	r0, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    9eb0:	f44f 72a2 	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    9eb4:	f880 1280 	strb.w	r1, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    9eb8:	601a      	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    9eba:	681a      	ldr	r2, [r3, #0]
    9ebc:	f022 0220 	bic.w	r2, r2, #32
    9ec0:	601a      	str	r2, [r3, #0]
    9ec2:	4770      	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    9ec4:	f852 1030 	ldr.w	r1, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    9ec8:	f44f 72a2 	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    9ecc:	2001      	movs	r0, #1
    9ece:	f881 0280 	strb.w	r0, [r1, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    9ed2:	601a      	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
    9ed4:	681a      	ldr	r2, [r3, #0]
    9ed6:	f042 0220 	orr.w	r2, r2, #32
    9eda:	601a      	str	r2, [r3, #0]
    9edc:	4770      	bx	lr
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    9ede:	f240 1203 	movw	r2, #259	; 0x103
    9ee2:	601a      	str	r2, [r3, #0]
    9ee4:	4770      	bx	lr
		} else if (mode == INPUT_PULLDOWN) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    9ee6:	f44f 7281 	mov.w	r2, #258	; 0x102
    9eea:	601a      	str	r2, [r3, #0]
    9eec:	4770      	bx	lr
    9eee:	bf00      	nop
    9ef0:	000123c8 	.word	0x000123c8

00009ef4 <attachInterrupt>:
void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
    9ef4:	2821      	cmp	r0, #33	; 0x21
    9ef6:	d848      	bhi.n	9f8a <attachInterrupt+0x96>
{
	_VectorsRam[irq + 16] = function;
}

void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
    9ef8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    9efa:	2a04      	cmp	r2, #4
    9efc:	d844      	bhi.n	9f88 <attachInterrupt+0x94>
    9efe:	e8df f002 	tbb	[pc, r2]
    9f02:	4b48      	.short	0x4b48
    9f04:	034e      	.short	0x034e
    9f06:	45          	.byte	0x45
    9f07:	00          	.byte	0x00
    9f08:	f44f 2610 	mov.w	r6, #589824	; 0x90000
	  case LOW:	mask = 0x08; break;
	  case HIGH:	mask = 0x0C; break;
	  default: return;
	}
	mask = (mask << 16) | 0x01000000;
	config = portConfigRegister(pin);
    9f0c:	4b2b      	ldr	r3, [pc, #172]	; (9fbc <attachInterrupt+0xc8>)
    9f0e:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
    9f12:	460d      	mov	r5, r1
    9f14:	685c      	ldr	r4, [r3, #4]
	if ((*config & 0x00000700) == 0) {
    9f16:	6821      	ldr	r1, [r4, #0]
    9f18:	f411 61e0 	ands.w	r1, r1, #1792	; 0x700
    9f1c:	d048      	beq.n	9fb0 <attachInterrupt+0xbc>
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    9f1e:	4b28      	ldr	r3, [pc, #160]	; (9fc0 <attachInterrupt+0xcc>)
    9f20:	4a28      	ldr	r2, [pc, #160]	; (9fc4 <attachInterrupt+0xd0>)
    9f22:	4929      	ldr	r1, [pc, #164]	; (9fc8 <attachInterrupt+0xd4>)
    9f24:	f8c3 219c 	str.w	r2, [r3, #412]	; 0x19c

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    9f28:	f104 4240 	add.w	r2, r4, #3221225472	; 0xc0000000
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    9f2c:	4827      	ldr	r0, [pc, #156]	; (9fcc <attachInterrupt+0xd8>)
    9f2e:	f8c3 11a4 	str.w	r1, [r3, #420]	; 0x1a4

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    9f32:	f5a2 2192 	sub.w	r1, r2, #299008	; 0x49000
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    9f36:	4f26      	ldr	r7, [pc, #152]	; (9fd0 <attachInterrupt+0xdc>)
    9f38:	f8c3 01a0 	str.w	r0, [r3, #416]	; 0x1a0

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    9f3c:	297c      	cmp	r1, #124	; 0x7c
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    9f3e:	4825      	ldr	r0, [pc, #148]	; (9fd4 <attachInterrupt+0xe0>)
    9f40:	f8c3 71a8 	str.w	r7, [r3, #424]	; 0x1a8
    9f44:	f8c3 01ac 	str.w	r0, [r3, #428]	; 0x1ac

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    9f48:	d92c      	bls.n	9fa4 <attachInterrupt+0xb0>
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
    9f4a:	f5a2 2394 	sub.w	r3, r2, #303104	; 0x4a000
    9f4e:	2b7c      	cmp	r3, #124	; 0x7c
    9f50:	d92a      	bls.n	9fa8 <attachInterrupt+0xb4>
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
    9f52:	f5a2 2396 	sub.w	r3, r2, #307200	; 0x4b000
    9f56:	2b7c      	cmp	r3, #124	; 0x7c
    9f58:	d928      	bls.n	9fac <attachInterrupt+0xb8>
	else if(&PORTD_PCR0 <= config && config <= &PORTD_PCR31) isr_table = isr_table_portD;
    9f5a:	f5a2 2398 	sub.w	r3, r2, #311296	; 0x4c000
    9f5e:	2b7c      	cmp	r3, #124	; 0x7c
    9f60:	d929      	bls.n	9fb6 <attachInterrupt+0xc2>
	else if(&PORTE_PCR0 <= config && config <= &PORTE_PCR31) isr_table = isr_table_portE;
    9f62:	f5a2 229a 	sub.w	r2, r2, #315392	; 0x4d000
    9f66:	2a7c      	cmp	r2, #124	; 0x7c
    9f68:	d827      	bhi.n	9fba <attachInterrupt+0xc6>
    9f6a:	481b      	ldr	r0, [pc, #108]	; (9fd8 <attachInterrupt+0xe4>)
	attachInterruptVector(IRQ_PORTD, port_D_isr);
	attachInterruptVector(IRQ_PORTE, port_E_isr);
	voidFuncPtr* isr_table = getIsrTable(config);
	if(!isr_table) return;
	uint32_t pin_index = getPinIndex(config);
	__disable_irq();
    9f6c:	b672      	cpsid	i
	cfg = *config;
    9f6e:	6823      	ldr	r3, [r4, #0]
	cfg &= ~0x000F0000;		// disable any previous interrupt
    9f70:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    9f74:	f043 7280 	orr.w	r2, r3, #16777216	; 0x1000000
	*config = cfg;
	isr_table[pin_index] = function;	// set the function pointer
    9f78:	f3c4 0184 	ubfx	r1, r4, #2, #5
	cfg |= mask;
    9f7c:	4316      	orrs	r6, r2
	if(!isr_table) return;
	uint32_t pin_index = getPinIndex(config);
	__disable_irq();
	cfg = *config;
	cfg &= ~0x000F0000;		// disable any previous interrupt
	*config = cfg;
    9f7e:	6023      	str	r3, [r4, #0]
	isr_table[pin_index] = function;	// set the function pointer
    9f80:	f840 5021 	str.w	r5, [r0, r1, lsl #2]
	cfg |= mask;
	*config = cfg;			// enable the new interrupt
    9f84:	6026      	str	r6, [r4, #0]
	__enable_irq();
    9f86:	b662      	cpsie	i
    9f88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9f8a:	4770      	bx	lr
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    9f8c:	f44f 2630 	mov.w	r6, #720896	; 0xb0000
    9f90:	e7bc      	b.n	9f0c <attachInterrupt+0x18>
	  case CHANGE:	mask = 0x0B; break;
	  case RISING:	mask = 0x09; break;
	  case FALLING:	mask = 0x0A; break;
	  case LOW:	mask = 0x08; break;
    9f92:	f44f 2600 	mov.w	r6, #524288	; 0x80000
    9f96:	e7b9      	b.n	9f0c <attachInterrupt+0x18>
	  case HIGH:	mask = 0x0C; break;
    9f98:	f44f 2640 	mov.w	r6, #786432	; 0xc0000
    9f9c:	e7b6      	b.n	9f0c <attachInterrupt+0x18>
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    9f9e:	f44f 2620 	mov.w	r6, #655360	; 0xa0000
    9fa2:	e7b3      	b.n	9f0c <attachInterrupt+0x18>

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    9fa4:	480d      	ldr	r0, [pc, #52]	; (9fdc <attachInterrupt+0xe8>)
    9fa6:	e7e1      	b.n	9f6c <attachInterrupt+0x78>
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
    9fa8:	480d      	ldr	r0, [pc, #52]	; (9fe0 <attachInterrupt+0xec>)
    9faa:	e7df      	b.n	9f6c <attachInterrupt+0x78>
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
    9fac:	480d      	ldr	r0, [pc, #52]	; (9fe4 <attachInterrupt+0xf0>)
    9fae:	e7dd      	b.n	9f6c <attachInterrupt+0x78>
    9fb0:	f7ff ff64 	bl	9e7c <pinMode.part.2>
    9fb4:	e7b3      	b.n	9f1e <attachInterrupt+0x2a>
	else if(&PORTD_PCR0 <= config && config <= &PORTD_PCR31) isr_table = isr_table_portD;
    9fb6:	480c      	ldr	r0, [pc, #48]	; (9fe8 <attachInterrupt+0xf4>)
    9fb8:	e7d8      	b.n	9f6c <attachInterrupt+0x78>
    9fba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9fbc:	000123c8 	.word	0x000123c8
    9fc0:	1fffac00 	.word	0x1fffac00
    9fc4:	1fffb849 	.word	0x1fffb849
    9fc8:	1fffb7f1 	.word	0x1fffb7f1
    9fcc:	1fffb81d 	.word	0x1fffb81d
    9fd0:	1fffb7c5 	.word	0x1fffb7c5
    9fd4:	1fffb799 	.word	0x1fffb799
    9fd8:	1fffbadc 	.word	0x1fffbadc
    9fdc:	1fffba04 	.word	0x1fffba04
    9fe0:	1fffba3c 	.word	0x1fffba3c
    9fe4:	1fffba8c 	.word	0x1fffba8c
    9fe8:	1fffbabc 	.word	0x1fffbabc

00009fec <detachInterrupt>:

void detachInterrupt(uint8_t pin)
{
	volatile uint32_t *config;

	config = portConfigRegister(pin);
    9fec:	4b1a      	ldr	r3, [pc, #104]	; (a058 <detachInterrupt+0x6c>)
    9fee:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
	__enable_irq();
#endif
}

void detachInterrupt(uint8_t pin)
{
    9ff2:	b410      	push	{r4}
	volatile uint32_t *config;

	config = portConfigRegister(pin);
    9ff4:	6842      	ldr	r2, [r0, #4]

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    9ff6:	f102 4340 	add.w	r3, r2, #3221225472	; 0xc0000000
    9ffa:	f5a3 2192 	sub.w	r1, r3, #299008	; 0x49000
    9ffe:	297c      	cmp	r1, #124	; 0x7c
    a000:	d923      	bls.n	a04a <detachInterrupt+0x5e>
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
    a002:	f5a3 2194 	sub.w	r1, r3, #303104	; 0x4a000
    a006:	297c      	cmp	r1, #124	; 0x7c
    a008:	d90d      	bls.n	a026 <detachInterrupt+0x3a>
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
    a00a:	f5a3 2196 	sub.w	r1, r3, #307200	; 0x4b000
    a00e:	297c      	cmp	r1, #124	; 0x7c
    a010:	d91f      	bls.n	a052 <detachInterrupt+0x66>
	else if(&PORTD_PCR0 <= config && config <= &PORTD_PCR31) isr_table = isr_table_portD;
    a012:	f5a3 2198 	sub.w	r1, r3, #311296	; 0x4c000
    a016:	297c      	cmp	r1, #124	; 0x7c
    a018:	d919      	bls.n	a04e <detachInterrupt+0x62>
	else if(&PORTE_PCR0 <= config && config <= &PORTE_PCR31) isr_table = isr_table_portE;
    a01a:	f5a3 239a 	sub.w	r3, r3, #315392	; 0x4d000
    a01e:	2b7c      	cmp	r3, #124	; 0x7c
    a020:	d811      	bhi.n	a046 <detachInterrupt+0x5a>
    a022:	4c0e      	ldr	r4, [pc, #56]	; (a05c <detachInterrupt+0x70>)
    a024:	e000      	b.n	a028 <detachInterrupt+0x3c>
// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
    a026:	4c0e      	ldr	r4, [pc, #56]	; (a060 <detachInterrupt+0x74>)
	config = portConfigRegister(pin);
#if defined(KINETISK)
	voidFuncPtr* isr_table = getIsrTable(config);
	if(!isr_table) return;
	uint32_t pin_index = getPinIndex(config);
	__disable_irq();
    a028:	b672      	cpsid	i
	*config = ((*config & ~0x000F0000) | 0x01000000);
    a02a:	6813      	ldr	r3, [r2, #0]
	isr_table[pin_index] = dummy_isr;
    a02c:	480d      	ldr	r0, [pc, #52]	; (a064 <detachInterrupt+0x78>)
#if defined(KINETISK)
	voidFuncPtr* isr_table = getIsrTable(config);
	if(!isr_table) return;
	uint32_t pin_index = getPinIndex(config);
	__disable_irq();
	*config = ((*config & ~0x000F0000) | 0x01000000);
    a02e:	f023 7387 	bic.w	r3, r3, #17694720	; 0x10e0000
	isr_table[pin_index] = dummy_isr;
    a032:	f3c2 0184 	ubfx	r1, r2, #2, #5
#if defined(KINETISK)
	voidFuncPtr* isr_table = getIsrTable(config);
	if(!isr_table) return;
	uint32_t pin_index = getPinIndex(config);
	__disable_irq();
	*config = ((*config & ~0x000F0000) | 0x01000000);
    a036:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    a03a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    a03e:	6013      	str	r3, [r2, #0]
	isr_table[pin_index] = dummy_isr;
    a040:	f844 0021 	str.w	r0, [r4, r1, lsl #2]
	__enable_irq();
    a044:	b662      	cpsie	i
	__disable_irq();
	*config = ((*config & ~0x000F0000) | 0x01000000);
	intFunc[pin] = dummy_isr;
	__enable_irq();
#endif
}
    a046:	bc10      	pop	{r4}
    a048:	4770      	bx	lr

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    a04a:	4c07      	ldr	r4, [pc, #28]	; (a068 <detachInterrupt+0x7c>)
    a04c:	e7ec      	b.n	a028 <detachInterrupt+0x3c>
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
	else if(&PORTD_PCR0 <= config && config <= &PORTD_PCR31) isr_table = isr_table_portD;
    a04e:	4c07      	ldr	r4, [pc, #28]	; (a06c <detachInterrupt+0x80>)
    a050:	e7ea      	b.n	a028 <detachInterrupt+0x3c>
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
    a052:	4c07      	ldr	r4, [pc, #28]	; (a070 <detachInterrupt+0x84>)
    a054:	e7e8      	b.n	a028 <detachInterrupt+0x3c>
    a056:	bf00      	nop
    a058:	000123c8 	.word	0x000123c8
    a05c:	1fffbadc 	.word	0x1fffbadc
    a060:	1fffba3c 	.word	0x1fffba3c
    a064:	00009e35 	.word	0x00009e35
    a068:	1fffba04 	.word	0x1fffba04
    a06c:	1fffbabc 	.word	0x1fffbabc
    a070:	1fffba8c 	.word	0x1fffba8c

0000a074 <rtc_set>:
{
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
    a074:	b430      	push	{r4, r5}
	RTC_SR = 0;
    a076:	4b05      	ldr	r3, [pc, #20]	; (a08c <rtc_set+0x18>)
	RTC_TPR = 0;
    a078:	4d05      	ldr	r5, [pc, #20]	; (a090 <rtc_set+0x1c>)
	RTC_TSR = t;
    a07a:	4c06      	ldr	r4, [pc, #24]	; (a094 <rtc_set+0x20>)
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    a07c:	2200      	movs	r2, #0
	RTC_TPR = 0;
	RTC_TSR = t;
	RTC_SR = RTC_SR_TCE;
    a07e:	2110      	movs	r1, #16
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    a080:	601a      	str	r2, [r3, #0]
	RTC_TPR = 0;
    a082:	602a      	str	r2, [r5, #0]
	RTC_TSR = t;
    a084:	6020      	str	r0, [r4, #0]
	RTC_SR = RTC_SR_TCE;
    a086:	6019      	str	r1, [r3, #0]
}
    a088:	bc30      	pop	{r4, r5}
    a08a:	4770      	bx	lr
    a08c:	4003d014 	.word	0x4003d014
    a090:	4003d004 	.word	0x4003d004
    a094:	4003d000 	.word	0x4003d000

0000a098 <digitalWrite>:

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    a098:	2821      	cmp	r0, #33	; 0x21
    a09a:	d801      	bhi.n	a0a0 <digitalWrite+0x8>
    a09c:	f7ff becc 	b.w	9e38 <digitalWrite.part.1>
    a0a0:	4770      	bx	lr
    a0a2:	bf00      	nop

0000a0a4 <digitalRead>:

}

uint8_t digitalRead(uint8_t pin)
{
	if (pin >= CORE_NUM_DIGITAL) return 0;
    a0a4:	2821      	cmp	r0, #33	; 0x21
    a0a6:	d806      	bhi.n	a0b6 <digitalRead+0x12>
#ifdef KINETISK
	return *portInputRegister(pin);
    a0a8:	4b04      	ldr	r3, [pc, #16]	; (a0bc <digitalRead+0x18>)
    a0aa:	f853 3030 	ldr.w	r3, [r3, r0, lsl #3]
    a0ae:	f893 0200 	ldrb.w	r0, [r3, #512]	; 0x200
    a0b2:	b2c0      	uxtb	r0, r0
    a0b4:	4770      	bx	lr

}

uint8_t digitalRead(uint8_t pin)
{
	if (pin >= CORE_NUM_DIGITAL) return 0;
    a0b6:	2000      	movs	r0, #0
#ifdef KINETISK
	return *portInputRegister(pin);
#else
	return (*portInputRegister(pin) & digitalPinToBitMask(pin)) ? 1 : 0;
#endif
}
    a0b8:	4770      	bx	lr
    a0ba:	bf00      	nop
    a0bc:	000123c8 	.word	0x000123c8

0000a0c0 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    a0c0:	2821      	cmp	r0, #33	; 0x21
    a0c2:	d801      	bhi.n	a0c8 <pinMode+0x8>
    a0c4:	f7ff beda 	b.w	9e7c <pinMode.part.2>
    a0c8:	4770      	bx	lr
    a0ca:	bf00      	nop

0000a0cc <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    a0cc:	b672      	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    a0ce:	490c      	ldr	r1, [pc, #48]	; (a100 <micros+0x34>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    a0d0:	4b0c      	ldr	r3, [pc, #48]	; (a104 <micros+0x38>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    a0d2:	4a0d      	ldr	r2, [pc, #52]	; (a108 <micros+0x3c>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    a0d4:	681b      	ldr	r3, [r3, #0]
	count = systick_millis_count;
    a0d6:	6808      	ldr	r0, [r1, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    a0d8:	6812      	ldr	r2, [r2, #0]
	__enable_irq();
    a0da:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    a0dc:	0152      	lsls	r2, r2, #5
    a0de:	d502      	bpl.n	a0e6 <micros+0x1a>
    a0e0:	2b32      	cmp	r3, #50	; 0x32
    a0e2:	bf88      	it	hi
    a0e4:	3001      	addhi	r0, #1
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    a0e6:	4909      	ldr	r1, [pc, #36]	; (a10c <micros+0x40>)
    a0e8:	f5c3 33ea 	rsb	r3, r3, #119808	; 0x1d400
    a0ec:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    a0f0:	33bf      	adds	r3, #191	; 0xbf
    a0f2:	fba1 1303 	umull	r1, r3, r1, r3
    a0f6:	fb02 f000 	mul.w	r0, r2, r0
}
    a0fa:	eb00 1093 	add.w	r0, r0, r3, lsr #6
    a0fe:	4770      	bx	lr
    a100:	200045ec 	.word	0x200045ec
    a104:	e000e018 	.word	0xe000e018
    a108:	e000ed04 	.word	0xe000ed04
    a10c:	88888889 	.word	0x88888889

0000a110 <delay>:

void delay(uint32_t ms)
{
    a110:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    a114:	4605      	mov	r5, r0

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    a116:	b672      	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    a118:	4f20      	ldr	r7, [pc, #128]	; (a19c <delay+0x8c>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    a11a:	4b21      	ldr	r3, [pc, #132]	; (a1a0 <delay+0x90>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    a11c:	4a21      	ldr	r2, [pc, #132]	; (a1a4 <delay+0x94>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    a11e:	681b      	ldr	r3, [r3, #0]
	count = systick_millis_count;
    a120:	683c      	ldr	r4, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    a122:	6812      	ldr	r2, [r2, #0]
	__enable_irq();
    a124:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    a126:	0152      	lsls	r2, r2, #5
    a128:	d502      	bpl.n	a130 <delay+0x20>
    a12a:	2b32      	cmp	r3, #50	; 0x32
    a12c:	bf88      	it	hi
    a12e:	3401      	addhi	r4, #1

void delay(uint32_t ms)
{
	uint32_t start = micros();

	if (ms > 0) {
    a130:	b395      	cbz	r5, a198 <delay+0x88>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    a132:	f5c3 33ea 	rsb	r3, r3, #119808	; 0x1d400
    a136:	4e1c      	ldr	r6, [pc, #112]	; (a1a8 <delay+0x98>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    a138:	f8df 9064 	ldr.w	r9, [pc, #100]	; a1a0 <delay+0x90>
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    a13c:	f8df 8064 	ldr.w	r8, [pc, #100]	; a1a4 <delay+0x94>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    a140:	33bf      	adds	r3, #191	; 0xbf
    a142:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    a146:	fba6 1303 	umull	r1, r3, r6, r3
    a14a:	fb02 f404 	mul.w	r4, r2, r4
    a14e:	eb04 1493 	add.w	r4, r4, r3, lsr #6

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    a152:	b672      	cpsid	i
	current = SYST_CVR;
    a154:	f8d9 1000 	ldr.w	r1, [r9]
	count = systick_millis_count;
    a158:	683a      	ldr	r2, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    a15a:	f8d8 e000 	ldr.w	lr, [r8]
	__enable_irq();
    a15e:	b662      	cpsie	i
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    a160:	f5c1 33ea 	rsb	r3, r1, #119808	; 0x1d400
    a164:	33bf      	adds	r3, #191	; 0xbf
    a166:	fba6 0303 	umull	r0, r3, r6, r3
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    a16a:	f01e 6f80 	tst.w	lr, #67108864	; 0x4000000
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    a16e:	ebc4 1393 	rsb	r3, r4, r3, lsr #6
    a172:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    a176:	d002      	beq.n	a17e <delay+0x6e>
    a178:	2932      	cmp	r1, #50	; 0x32
    a17a:	bf88      	it	hi
    a17c:	3201      	addhi	r2, #1
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    a17e:	fb00 3302 	mla	r3, r0, r2, r3
    a182:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    a186:	d304      	bcc.n	a192 <delay+0x82>
				ms--;
				if (ms == 0) return;
    a188:	3d01      	subs	r5, #1
    a18a:	d005      	beq.n	a198 <delay+0x88>
				start += 1000;
    a18c:	f504 747a 	add.w	r4, r4, #1000	; 0x3e8
    a190:	e7df      	b.n	a152 <delay+0x42>
			}
			yield();
    a192:	f001 fb39 	bl	b808 <yield>
		}
    a196:	e7dc      	b.n	a152 <delay+0x42>
    a198:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    a19c:	200045ec 	.word	0x200045ec
    a1a0:	e000e018 	.word	0xe000e018
    a1a4:	e000ed04 	.word	0xe000ed04
    a1a8:	88888889 	.word	0x88888889

0000a1ac <_init_Teensyduino_internal_>:
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
    a1ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    a1ae:	4b2d      	ldr	r3, [pc, #180]	; (a264 <_init_Teensyduino_internal_+0xb8>)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    a1b0:	492d      	ldr	r1, [pc, #180]	; (a268 <_init_Teensyduino_internal_+0xbc>)
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    a1b2:	f8df e0d0 	ldr.w	lr, [pc, #208]	; a284 <_init_Teensyduino_internal_+0xd8>
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
    a1b6:	f8df c0d0 	ldr.w	ip, [pc, #208]	; a288 <_init_Teensyduino_internal_+0xdc>
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
    a1ba:	4e2c      	ldr	r6, [pc, #176]	; (a26c <_init_Teensyduino_internal_+0xc0>)
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
    a1bc:	4d2c      	ldr	r5, [pc, #176]	; (a270 <_init_Teensyduino_internal_+0xc4>)
	FTM0_C4SC = 0x28;
    a1be:	4c2d      	ldr	r4, [pc, #180]	; (a274 <_init_Teensyduino_internal_+0xc8>)
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
    a1c0:	4a2d      	ldr	r2, [pc, #180]	; (a278 <_init_Teensyduino_internal_+0xcc>)
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
    a1c2:	4f2e      	ldr	r7, [pc, #184]	; (a27c <_init_Teensyduino_internal_+0xd0>)
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    a1c4:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
    a1c8:	6018      	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    a1ca:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
    a1ce:	6018      	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    a1d0:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
    a1d4:	6018      	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    a1d6:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
    a1da:	6018      	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    a1dc:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
    a1e0:	6018      	str	r0, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    a1e2:	2000      	movs	r0, #0
    a1e4:	6008      	str	r0, [r1, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    a1e6:	2328      	movs	r3, #40	; 0x28
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
    a1e8:	f64e 71ff 	movw	r1, #61439	; 0xefff
    a1ec:	f8cc 1000 	str.w	r1, [ip]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    a1f0:	f8ce 3000 	str.w	r3, [lr]
	FTM0_C1SC = 0x28;
    a1f4:	6033      	str	r3, [r6, #0]
	FTM0_C2SC = 0x28;
    a1f6:	6013      	str	r3, [r2, #0]
	FTM0_C3SC = 0x28;
    a1f8:	602b      	str	r3, [r5, #0]
	FTM0_C4SC = 0x28;
    a1fa:	6023      	str	r3, [r4, #0]
	FTM0_C5SC = 0x28;
    a1fc:	603b      	str	r3, [r7, #0]
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
    a1fe:	62b3      	str	r3, [r6, #40]	; 0x28
	FTM0_C7SC = 0x28;
    a200:	6293      	str	r3, [r2, #40]	; 0x28
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    a202:	2209      	movs	r2, #9
    a204:	f845 2c24 	str.w	r2, [r5, #-36]
	FTM1_CNT = 0;
    a208:	f8c4 0fd8 	str.w	r0, [r4, #4056]	; 0xfd8
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
    a20c:	f505 657f 	add.w	r5, r5, #4080	; 0xff0
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
	FTM1_MOD = DEFAULT_FTM_MOD;
    a210:	f8c7 1fd4 	str.w	r1, [r7, #4052]	; 0xfd4
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    a214:	f507 27ff 	add.w	r7, r7, #522240	; 0x7f800
    a218:	f507 67fa 	add.w	r7, r7, #2000	; 0x7d0
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
    a21c:	f8c6 3ff8 	str.w	r3, [r6, #4088]	; 0xff8
	FTM1_C1SC = 0x28;
    a220:	602b      	str	r3, [r5, #0]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
    a222:	f506 26ff 	add.w	r6, r6, #522240	; 0x7f800
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    a226:	f8c4 2fd4 	str.w	r2, [r4, #4052]	; 0xfd4
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
	FTM2_C0SC = 0x28;
    a22a:	f505 25fd 	add.w	r5, r5, #518144	; 0x7e800
	FTM2_C1SC = 0x28;
    a22e:	f504 24ff 	add.w	r4, r4, #522240	; 0x7f800
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    a232:	6038      	str	r0, [r7, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
    a234:	f206 76f4 	addw	r6, r6, #2036	; 0x7f4
	FTM2_C0SC = 0x28;
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    a238:	4811      	ldr	r0, [pc, #68]	; (a280 <_init_Teensyduino_internal_+0xd4>)
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
    a23a:	6031      	str	r1, [r6, #0]
	FTM2_C0SC = 0x28;
    a23c:	f505 65ff 	add.w	r5, r5, #2040	; 0x7f8
	FTM2_C1SC = 0x28;
    a240:	f504 64fd 	add.w	r4, r4, #2024	; 0x7e8
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
	FTM2_C0SC = 0x28;
    a244:	602b      	str	r3, [r5, #0]
	FTM2_C1SC = 0x28;
    a246:	6023      	str	r3, [r4, #0]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    a248:	6002      	str	r2, [r0, #0]
	TPM1_MOD = 32767;
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
#endif
	analog_init();
    a24a:	f7ff fa2f 	bl	96ac <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
    a24e:	2019      	movs	r0, #25
    a250:	f7ff ff5e 	bl	a110 <delay>
	usb_init();
    a254:	f001 f8a0 	bl	b398 <usb_init>
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    a258:	f240 1013 	movw	r0, #275	; 0x113
}
    a25c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    a260:	f7ff bf56 	b.w	a110 <delay>
    a264:	e000e108 	.word	0xe000e108
    a268:	40038004 	.word	0x40038004
    a26c:	40038014 	.word	0x40038014
    a270:	40038024 	.word	0x40038024
    a274:	4003802c 	.word	0x4003802c
    a278:	4003801c 	.word	0x4003801c
    a27c:	40038034 	.word	0x40038034
    a280:	400b8000 	.word	0x400b8000
    a284:	4003800c 	.word	0x4003800c
    a288:	40038008 	.word	0x40038008

0000a28c <copy_to_buffers(unsigned long const*, short*, short*, unsigned int)>:
	usb_audio_sync_feedback = feedback_accumulator >> 8;
}

static void copy_to_buffers(const uint32_t *src, int16_t *left, int16_t *right, unsigned int len)
{
	uint32_t *target = (uint32_t*) src + len; 
    a28c:	eb00 0383 	add.w	r3, r0, r3, lsl #2
	while ((src < target) && (((uintptr_t) left & 0x02) != 0)) {
    a290:	4298      	cmp	r0, r3
	update_responsibility = false;
	usb_audio_sync_feedback = feedback_accumulator >> 8;
}

static void copy_to_buffers(const uint32_t *src, int16_t *left, int16_t *right, unsigned int len)
{
    a292:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t *target = (uint32_t*) src + len; 
	while ((src < target) && (((uintptr_t) left & 0x02) != 0)) {
    a294:	d30a      	bcc.n	a2ac <copy_to_buffers(unsigned long const*, short*, short*, unsigned int)+0x20>
    a296:	e02d      	b.n	a2f4 <copy_to_buffers(unsigned long const*, short*, short*, unsigned int)+0x68>
		uint32_t n = *src++;
    a298:	f850 4b04 	ldr.w	r4, [r0], #4
		*left++ = n & 0xFFFF;
    a29c:	f821 4b02 	strh.w	r4, [r1], #2
}

static void copy_to_buffers(const uint32_t *src, int16_t *left, int16_t *right, unsigned int len)
{
	uint32_t *target = (uint32_t*) src + len; 
	while ((src < target) && (((uintptr_t) left & 0x02) != 0)) {
    a2a0:	4283      	cmp	r3, r0
		uint32_t n = *src++;
		*left++ = n & 0xFFFF;
		*right++ = n >> 16;
    a2a2:	ea4f 4414 	mov.w	r4, r4, lsr #16
    a2a6:	f822 4b02 	strh.w	r4, [r2], #2
}

static void copy_to_buffers(const uint32_t *src, int16_t *left, int16_t *right, unsigned int len)
{
	uint32_t *target = (uint32_t*) src + len; 
	while ((src < target) && (((uintptr_t) left & 0x02) != 0)) {
    a2aa:	d923      	bls.n	a2f4 <copy_to_buffers(unsigned long const*, short*, short*, unsigned int)+0x68>
    a2ac:	078c      	lsls	r4, r1, #30
    a2ae:	d4f3      	bmi.n	a298 <copy_to_buffers(unsigned long const*, short*, short*, unsigned int)+0xc>
		uint32_t n = *src++;
		*left++ = n & 0xFFFF;
		*right++ = n >> 16;
	}

	while ((src < target - 2)) {
    a2b0:	f1a3 0e08 	sub.w	lr, r3, #8
    a2b4:	4570      	cmp	r0, lr
    a2b6:	d212      	bcs.n	a2de <copy_to_buffers(unsigned long const*, short*, short*, unsigned int)+0x52>
		uint32_t n1 = *src++;
    a2b8:	f850 7b08 	ldr.w	r7, [r0], #8
		uint32_t n = *src++;
    a2bc:	f850 6c04 	ldr.w	r6, [r0, #-4]
		*(uint32_t *)left = (n1 & 0xFFFF) | ((n & 0xFFFF) << 16);
		left+=2;
		*(uint32_t *)right = (n1 >> 16) | ((n & 0xFFFF0000)) ;
    a2c0:	0c34      	lsrs	r4, r6, #16
    a2c2:	0424      	lsls	r4, r4, #16
	}

	while ((src < target - 2)) {
		uint32_t n1 = *src++;
		uint32_t n = *src++;
		*(uint32_t *)left = (n1 & 0xFFFF) | ((n & 0xFFFF) << 16);
    a2c4:	b2bd      	uxth	r5, r7
		left+=2;
		*(uint32_t *)right = (n1 >> 16) | ((n & 0xFFFF0000)) ;
    a2c6:	ea44 4417 	orr.w	r4, r4, r7, lsr #16
	}

	while ((src < target - 2)) {
		uint32_t n1 = *src++;
		uint32_t n = *src++;
		*(uint32_t *)left = (n1 & 0xFFFF) | ((n & 0xFFFF) << 16);
    a2ca:	ea45 4506 	orr.w	r5, r5, r6, lsl #16
		uint32_t n = *src++;
		*left++ = n & 0xFFFF;
		*right++ = n >> 16;
	}

	while ((src < target - 2)) {
    a2ce:	4570      	cmp	r0, lr
		uint32_t n1 = *src++;
		uint32_t n = *src++;
		*(uint32_t *)left = (n1 & 0xFFFF) | ((n & 0xFFFF) << 16);
    a2d0:	f841 5b04 	str.w	r5, [r1], #4
		left+=2;
		*(uint32_t *)right = (n1 >> 16) | ((n & 0xFFFF0000)) ;
    a2d4:	f842 4b04 	str.w	r4, [r2], #4
		uint32_t n = *src++;
		*left++ = n & 0xFFFF;
		*right++ = n >> 16;
	}

	while ((src < target - 2)) {
    a2d8:	d3ee      	bcc.n	a2b8 <copy_to_buffers(unsigned long const*, short*, short*, unsigned int)+0x2c>
		left+=2;
		*(uint32_t *)right = (n1 >> 16) | ((n & 0xFFFF0000)) ;
		right+=2;
	}

	while ((src < target)) {
    a2da:	4283      	cmp	r3, r0
    a2dc:	d90f      	bls.n	a2fe <copy_to_buffers(unsigned long const*, short*, short*, unsigned int)+0x72>
		uint32_t n = *src++;
    a2de:	f850 4b04 	ldr.w	r4, [r0], #4
		*left++ = n & 0xFFFF;
    a2e2:	f821 4b02 	strh.w	r4, [r1], #2
		left+=2;
		*(uint32_t *)right = (n1 >> 16) | ((n & 0xFFFF0000)) ;
		right+=2;
	}

	while ((src < target)) {
    a2e6:	4283      	cmp	r3, r0
		uint32_t n = *src++;
		*left++ = n & 0xFFFF;
		*right++ = n >> 16;
    a2e8:	ea4f 4414 	mov.w	r4, r4, lsr #16
    a2ec:	f822 4b02 	strh.w	r4, [r2], #2
		left+=2;
		*(uint32_t *)right = (n1 >> 16) | ((n & 0xFFFF0000)) ;
		right+=2;
	}

	while ((src < target)) {
    a2f0:	d8f5      	bhi.n	a2de <copy_to_buffers(unsigned long const*, short*, short*, unsigned int)+0x52>
    a2f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uint32_t n = *src++;
		*left++ = n & 0xFFFF;
		*right++ = n >> 16;
	}

	while ((src < target - 2)) {
    a2f4:	f1a3 0e08 	sub.w	lr, r3, #8
    a2f8:	4570      	cmp	r0, lr
    a2fa:	d3dd      	bcc.n	a2b8 <copy_to_buffers(unsigned long const*, short*, short*, unsigned int)+0x2c>
    a2fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a2fe:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000a300 <AudioOutputUSB::update()>:
		len--;
	}
}

void AudioOutputUSB::update(void)
{
    a300:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	audio_block_t *left, *right;

	// TODO: we shouldn't be writing to these......
	//left = receiveReadOnly(0); // input 0 = left channel
	//right = receiveReadOnly(1); // input 1 = right channel
	left = receiveWritable(0); // input 0 = left channel
    a304:	2100      	movs	r1, #0
		len--;
	}
}

void AudioOutputUSB::update(void)
{
    a306:	4604      	mov	r4, r0
	audio_block_t *left, *right;

	// TODO: we shouldn't be writing to these......
	//left = receiveReadOnly(0); // input 0 = left channel
	//right = receiveReadOnly(1); // input 1 = right channel
	left = receiveWritable(0); // input 0 = left channel
    a308:	f7fe fd20 	bl	8d4c <AudioStream::receiveWritable(unsigned int)>
	right = receiveWritable(1); // input 1 = right channel
    a30c:	2101      	movs	r1, #1
	audio_block_t *left, *right;

	// TODO: we shouldn't be writing to these......
	//left = receiveReadOnly(0); // input 0 = left channel
	//right = receiveReadOnly(1); // input 1 = right channel
	left = receiveWritable(0); // input 0 = left channel
    a30e:	4605      	mov	r5, r0
	right = receiveWritable(1); // input 1 = right channel
    a310:	4620      	mov	r0, r4
    a312:	f7fe fd1b 	bl	8d4c <AudioStream::receiveWritable(unsigned int)>
	if (usb_audio_transmit_setting == 0) {
    a316:	4b3b      	ldr	r3, [pc, #236]	; (a404 <AudioOutputUSB::update()+0x104>)
    a318:	781b      	ldrb	r3, [r3, #0]

	// TODO: we shouldn't be writing to these......
	//left = receiveReadOnly(0); // input 0 = left channel
	//right = receiveReadOnly(1); // input 1 = right channel
	left = receiveWritable(0); // input 0 = left channel
	right = receiveWritable(1); // input 1 = right channel
    a31a:	4604      	mov	r4, r0
	if (usb_audio_transmit_setting == 0) {
    a31c:	bb43      	cbnz	r3, a370 <AudioOutputUSB::update()+0x70>
		if (left) release(left);
    a31e:	b115      	cbz	r5, a326 <AudioOutputUSB::update()+0x26>
    a320:	4628      	mov	r0, r5
    a322:	f7fe fcc3 	bl	8cac <AudioStream::release(audio_block_struct*)>
		if (right) release(right);
    a326:	b114      	cbz	r4, a32e <AudioOutputUSB::update()+0x2e>
    a328:	4620      	mov	r0, r4
    a32a:	f7fe fcbf 	bl	8cac <AudioStream::release(audio_block_struct*)>
		if (left_1st) { release(left_1st); left_1st = NULL; }
    a32e:	4c36      	ldr	r4, [pc, #216]	; (a408 <AudioOutputUSB::update()+0x108>)
    a330:	6820      	ldr	r0, [r4, #0]
    a332:	b118      	cbz	r0, a33c <AudioOutputUSB::update()+0x3c>
    a334:	f7fe fcba 	bl	8cac <AudioStream::release(audio_block_struct*)>
    a338:	2300      	movs	r3, #0
    a33a:	6023      	str	r3, [r4, #0]
		if (left_2nd) { release(left_2nd); left_2nd = NULL; }
    a33c:	4c33      	ldr	r4, [pc, #204]	; (a40c <AudioOutputUSB::update()+0x10c>)
    a33e:	6820      	ldr	r0, [r4, #0]
    a340:	b118      	cbz	r0, a34a <AudioOutputUSB::update()+0x4a>
    a342:	f7fe fcb3 	bl	8cac <AudioStream::release(audio_block_struct*)>
    a346:	2300      	movs	r3, #0
    a348:	6023      	str	r3, [r4, #0]
		if (right_1st) { release(right_1st); right_1st = NULL; }
    a34a:	4c31      	ldr	r4, [pc, #196]	; (a410 <AudioOutputUSB::update()+0x110>)
    a34c:	6820      	ldr	r0, [r4, #0]
    a34e:	b118      	cbz	r0, a358 <AudioOutputUSB::update()+0x58>
    a350:	f7fe fcac 	bl	8cac <AudioStream::release(audio_block_struct*)>
    a354:	2300      	movs	r3, #0
    a356:	6023      	str	r3, [r4, #0]
		if (right_2nd) { release(right_2nd); right_2nd = NULL; }
    a358:	4c2e      	ldr	r4, [pc, #184]	; (a414 <AudioOutputUSB::update()+0x114>)
    a35a:	6820      	ldr	r0, [r4, #0]
    a35c:	b118      	cbz	r0, a366 <AudioOutputUSB::update()+0x66>
    a35e:	f7fe fca5 	bl	8cac <AudioStream::release(audio_block_struct*)>
    a362:	2300      	movs	r3, #0
    a364:	6023      	str	r3, [r4, #0]
		offset_1st = 0;
    a366:	4b2c      	ldr	r3, [pc, #176]	; (a418 <AudioOutputUSB::update()+0x118>)
    a368:	2200      	movs	r2, #0
    a36a:	801a      	strh	r2, [r3, #0]
		return;
    a36c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}
	if (left == NULL) {
    a370:	b335      	cbz	r5, a3c0 <AudioOutputUSB::update()+0xc0>
			if (right) release(right);
			return;
		}
		memset(left->data, 0, sizeof(left->data));
	}
	if (right == NULL) {
    a372:	2c00      	cmp	r4, #0
    a374:	d02f      	beq.n	a3d6 <AudioOutputUSB::update()+0xd6>
			release(left);
			return;
		}
		memset(right->data, 0, sizeof(right->data));
	}
	__disable_irq();
    a376:	b672      	cpsid	i
	if (left_1st == NULL) {
    a378:	4b23      	ldr	r3, [pc, #140]	; (a408 <AudioOutputUSB::update()+0x108>)
    a37a:	6818      	ldr	r0, [r3, #0]
    a37c:	b1d0      	cbz	r0, a3b4 <AudioOutputUSB::update()+0xb4>
		left_1st = left;
		right_1st = right;
		offset_1st = 0;
	} else if (left_2nd == NULL) {
    a37e:	4a23      	ldr	r2, [pc, #140]	; (a40c <AudioOutputUSB::update()+0x10c>)
    a380:	6811      	ldr	r1, [r2, #0]
    a382:	b199      	cbz	r1, a3ac <AudioOutputUSB::update()+0xac>
	} else {
		// buffer overrun - PC is consuming too slowly
		audio_block_t *discard1 = left_1st;
		left_1st = left_2nd;
		left_2nd = left;
		audio_block_t *discard2 = right_1st;
    a384:	4f22      	ldr	r7, [pc, #136]	; (a410 <AudioOutputUSB::update()+0x110>)
		right_1st = right_2nd;
    a386:	4e23      	ldr	r6, [pc, #140]	; (a414 <AudioOutputUSB::update()+0x114>)
		left_2nd = left;
		right_2nd = right;
	} else {
		// buffer overrun - PC is consuming too slowly
		audio_block_t *discard1 = left_1st;
		left_1st = left_2nd;
    a388:	6019      	str	r1, [r3, #0]
		left_2nd = left;
		audio_block_t *discard2 = right_1st;
    a38a:	f8d7 8000 	ldr.w	r8, [r7]
		right_1st = right_2nd;
		right_2nd = right;
		offset_1st = 0; // TODO: discard part of this data?
    a38e:	4b22      	ldr	r3, [pc, #136]	; (a418 <AudioOutputUSB::update()+0x118>)
		right_2nd = right;
	} else {
		// buffer overrun - PC is consuming too slowly
		audio_block_t *discard1 = left_1st;
		left_1st = left_2nd;
		left_2nd = left;
    a390:	6015      	str	r5, [r2, #0]
		audio_block_t *discard2 = right_1st;
		right_1st = right_2nd;
    a392:	6832      	ldr	r2, [r6, #0]
    a394:	603a      	str	r2, [r7, #0]
		right_2nd = right;
		offset_1st = 0; // TODO: discard part of this data?
    a396:	2200      	movs	r2, #0
		audio_block_t *discard1 = left_1st;
		left_1st = left_2nd;
		left_2nd = left;
		audio_block_t *discard2 = right_1st;
		right_1st = right_2nd;
		right_2nd = right;
    a398:	6034      	str	r4, [r6, #0]
		offset_1st = 0; // TODO: discard part of this data?
    a39a:	801a      	strh	r2, [r3, #0]
		//serial_print("*");
		release(discard1);
    a39c:	f7fe fc86 	bl	8cac <AudioStream::release(audio_block_struct*)>
		release(discard2);
    a3a0:	4640      	mov	r0, r8
    a3a2:	f7fe fc83 	bl	8cac <AudioStream::release(audio_block_struct*)>
	}
	__enable_irq();
    a3a6:	b662      	cpsie	i
    a3a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		left_1st = left;
		right_1st = right;
		offset_1st = 0;
	} else if (left_2nd == NULL) {
		left_2nd = left;
		right_2nd = right;
    a3ac:	4b19      	ldr	r3, [pc, #100]	; (a414 <AudioOutputUSB::update()+0x114>)
	if (left_1st == NULL) {
		left_1st = left;
		right_1st = right;
		offset_1st = 0;
	} else if (left_2nd == NULL) {
		left_2nd = left;
    a3ae:	6015      	str	r5, [r2, #0]
		right_2nd = right;
    a3b0:	601c      	str	r4, [r3, #0]
    a3b2:	e7f8      	b.n	a3a6 <AudioOutputUSB::update()+0xa6>
		memset(right->data, 0, sizeof(right->data));
	}
	__disable_irq();
	if (left_1st == NULL) {
		left_1st = left;
		right_1st = right;
    a3b4:	4916      	ldr	r1, [pc, #88]	; (a410 <AudioOutputUSB::update()+0x110>)
		offset_1st = 0;
    a3b6:	4a18      	ldr	r2, [pc, #96]	; (a418 <AudioOutputUSB::update()+0x118>)
		}
		memset(right->data, 0, sizeof(right->data));
	}
	__disable_irq();
	if (left_1st == NULL) {
		left_1st = left;
    a3b8:	601d      	str	r5, [r3, #0]
		right_1st = right;
    a3ba:	600c      	str	r4, [r1, #0]
		offset_1st = 0;
    a3bc:	8010      	strh	r0, [r2, #0]
    a3be:	e7f2      	b.n	a3a6 <AudioOutputUSB::update()+0xa6>
		if (right_2nd) { release(right_2nd); right_2nd = NULL; }
		offset_1st = 0;
		return;
	}
	if (left == NULL) {
		left = allocate();
    a3c0:	f7fe fc20 	bl	8c04 <AudioStream::allocate()>
		if (left == NULL) {
    a3c4:	4605      	mov	r5, r0
    a3c6:	b188      	cbz	r0, a3ec <AudioOutputUSB::update()+0xec>
			if (right) release(right);
			return;
		}
		memset(left->data, 0, sizeof(left->data));
    a3c8:	f44f 7280 	mov.w	r2, #256	; 0x100
    a3cc:	2100      	movs	r1, #0
    a3ce:	3004      	adds	r0, #4
    a3d0:	f003 ff00 	bl	e1d4 <memset>
    a3d4:	e7cd      	b.n	a372 <AudioOutputUSB::update()+0x72>
	}
	if (right == NULL) {
		right = allocate();
    a3d6:	f7fe fc15 	bl	8c04 <AudioStream::allocate()>
		if (right == NULL) {
    a3da:	4604      	mov	r4, r0
    a3dc:	b168      	cbz	r0, a3fa <AudioOutputUSB::update()+0xfa>
			release(left);
			return;
		}
		memset(right->data, 0, sizeof(right->data));
    a3de:	f44f 7280 	mov.w	r2, #256	; 0x100
    a3e2:	2100      	movs	r1, #0
    a3e4:	3004      	adds	r0, #4
    a3e6:	f003 fef5 	bl	e1d4 <memset>
    a3ea:	e7c4      	b.n	a376 <AudioOutputUSB::update()+0x76>
		return;
	}
	if (left == NULL) {
		left = allocate();
		if (left == NULL) {
			if (right) release(right);
    a3ec:	2c00      	cmp	r4, #0
    a3ee:	d0db      	beq.n	a3a8 <AudioOutputUSB::update()+0xa8>
    a3f0:	4620      	mov	r0, r4
		//serial_print("*");
		release(discard1);
		release(discard2);
	}
	__enable_irq();
}
    a3f2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		return;
	}
	if (left == NULL) {
		left = allocate();
		if (left == NULL) {
			if (right) release(right);
    a3f6:	f7fe bc59 	b.w	8cac <AudioStream::release(audio_block_struct*)>
		memset(left->data, 0, sizeof(left->data));
	}
	if (right == NULL) {
		right = allocate();
		if (right == NULL) {
			release(left);
    a3fa:	4628      	mov	r0, r5
		//serial_print("*");
		release(discard1);
		release(discard2);
	}
	__enable_irq();
}
    a3fc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		memset(left->data, 0, sizeof(left->data));
	}
	if (right == NULL) {
		right = allocate();
		if (right == NULL) {
			release(left);
    a400:	f7fe bc54 	b.w	8cac <AudioStream::release(audio_block_struct*)>
    a404:	200045f6 	.word	0x200045f6
    a408:	200045fc 	.word	0x200045fc
    a40c:	20004618 	.word	0x20004618
    a410:	20004610 	.word	0x20004610
    a414:	20004600 	.word	0x20004600
    a418:	200045f4 	.word	0x200045f4

0000a41c <usb_audio_receive_callback>:

	AudioInputUSB::receive_flag = 1;
	len >>= 2; // 1 sample = 4 bytes: 2 left, 2 right
	data = (const uint32_t *)usb_audio_receive_buffer;

	count = AudioInputUSB::incoming_count;
    a41c:	4b51      	ldr	r3, [pc, #324]	; (a564 <usb_audio_receive_callback+0x148>)

// Called from the USB interrupt when an isochronous packet arrives
// we must completely remove it from the receive buffer before returning
//
void usb_audio_receive_callback(unsigned int len)
{
    a41e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	AudioInputUSB::receive_flag = 1;
	len >>= 2; // 1 sample = 4 bytes: 2 left, 2 right
	data = (const uint32_t *)usb_audio_receive_buffer;

	count = AudioInputUSB::incoming_count;
    a422:	f8b3 8000 	ldrh.w	r8, [r3]
	left = AudioInputUSB::incoming_left;
    a426:	f8df b150 	ldr.w	fp, [pc, #336]	; a578 <usb_audio_receive_callback+0x15c>
{
	unsigned int count, avail;
	audio_block_t *left, *right;
	const uint32_t *data;

	AudioInputUSB::receive_flag = 1;
    a42a:	4b4f      	ldr	r3, [pc, #316]	; (a568 <usb_audio_receive_callback+0x14c>)
	len >>= 2; // 1 sample = 4 bytes: 2 left, 2 right
	data = (const uint32_t *)usb_audio_receive_buffer;

	count = AudioInputUSB::incoming_count;
	left = AudioInputUSB::incoming_left;
    a42c:	f8db 4000 	ldr.w	r4, [fp]
{
	unsigned int count, avail;
	audio_block_t *left, *right;
	const uint32_t *data;

	AudioInputUSB::receive_flag = 1;
    a430:	2201      	movs	r2, #1
    a432:	701a      	strb	r2, [r3, #0]
	len >>= 2; // 1 sample = 4 bytes: 2 left, 2 right
	data = (const uint32_t *)usb_audio_receive_buffer;

	count = AudioInputUSB::incoming_count;
	left = AudioInputUSB::incoming_left;
	right = AudioInputUSB::incoming_right;
    a434:	4b4d      	ldr	r3, [pc, #308]	; (a56c <usb_audio_receive_callback+0x150>)

// Called from the USB interrupt when an isochronous packet arrives
// we must completely remove it from the receive buffer before returning
//
void usb_audio_receive_callback(unsigned int len)
{
    a436:	b083      	sub	sp, #12
	unsigned int count, avail;
	audio_block_t *left, *right;
	const uint32_t *data;

	AudioInputUSB::receive_flag = 1;
	len >>= 2; // 1 sample = 4 bytes: 2 left, 2 right
    a438:	0886      	lsrs	r6, r0, #2
	data = (const uint32_t *)usb_audio_receive_buffer;

	count = AudioInputUSB::incoming_count;
    a43a:	46c2      	mov	sl, r8
	left = AudioInputUSB::incoming_left;
	right = AudioInputUSB::incoming_right;
    a43c:	681d      	ldr	r5, [r3, #0]
	if (left == NULL) {
    a43e:	2c00      	cmp	r4, #0
    a440:	d04e      	beq.n	a4e0 <usb_audio_receive_callback+0xc4>
		left = AudioStream::allocate();
		if (left == NULL) return;
		AudioInputUSB::incoming_left = left;
	}
	if (right == NULL) {
    a442:	2d00      	cmp	r5, #0
    a444:	d055      	beq.n	a4f2 <usb_audio_receive_callback+0xd6>
		right = AudioStream::allocate();
		if (right == NULL) return;
		AudioInputUSB::incoming_right = right;
	}
	while (len > 0) {
    a446:	2e00      	cmp	r6, #0
    a448:	d05c      	beq.n	a504 <usb_audio_receive_callback+0xe8>
		avail = AUDIO_BLOCK_SAMPLES - count;
    a44a:	f1c8 0780 	rsb	r7, r8, #128	; 0x80
		if (len < avail) {
    a44e:	42be      	cmp	r6, r7
    a450:	f0c0 8083 	bcc.w	a55a <usb_audio_receive_callback+0x13e>
    a454:	4b46      	ldr	r3, [pc, #280]	; (a570 <usb_audio_receive_callback+0x154>)
    a456:	9301      	str	r3, [sp, #4]
    a458:	f8df 8120 	ldr.w	r8, [pc, #288]	; a57c <usb_audio_receive_callback+0x160>
			}
			AudioInputUSB::incoming_left = left;
			AudioInputUSB::incoming_right = right;
			count = 0;
		} else {
			if (AudioInputUSB::ready_left || AudioInputUSB::ready_right) return;
    a45c:	f8df 9114 	ldr.w	r9, [pc, #276]	; a574 <usb_audio_receive_callback+0x158>
		avail = AUDIO_BLOCK_SAMPLES - count;
		if (len < avail) {
			copy_to_buffers(data, left->data + count, right->data + count, len);
			AudioInputUSB::incoming_count = count + len;
			return;
		} else if (avail > 0) {
    a460:	bb0f      	cbnz	r7, a4a6 <usb_audio_receive_callback+0x8a>
			}
			AudioInputUSB::incoming_left = left;
			AudioInputUSB::incoming_right = right;
			count = 0;
		} else {
			if (AudioInputUSB::ready_left || AudioInputUSB::ready_right) return;
    a462:	f8d8 3000 	ldr.w	r3, [r8]
    a466:	2b00      	cmp	r3, #0
    a468:	d137      	bne.n	a4da <usb_audio_receive_callback+0xbe>
    a46a:	f8d9 2000 	ldr.w	r2, [r9]
    a46e:	464b      	mov	r3, r9
    a470:	2a00      	cmp	r2, #0
    a472:	d132      	bne.n	a4da <usb_audio_receive_callback+0xbe>
					//serial_phex(len);
				//}
				return;
			}
			send:
			AudioInputUSB::ready_left = left;
    a474:	f8c8 4000 	str.w	r4, [r8]
			AudioInputUSB::ready_right = right;
    a478:	601d      	str	r5, [r3, #0]
			//if (AudioInputUSB::update_responsibility) AudioStream::update_all();
			left = AudioStream::allocate();
    a47a:	f7fe fbc3 	bl	8c04 <AudioStream::allocate()>
			if (left == NULL) {
    a47e:	4604      	mov	r4, r0
    a480:	2800      	cmp	r0, #0
    a482:	d045      	beq.n	a510 <usb_audio_receive_callback+0xf4>
				AudioInputUSB::incoming_left = NULL;
				AudioInputUSB::incoming_right = NULL;
				AudioInputUSB::incoming_count = 0;
				return;
			}
			right = AudioStream::allocate();
    a484:	f7fe fbbe 	bl	8c04 <AudioStream::allocate()>
			if (right == NULL) {
    a488:	4605      	mov	r5, r0
    a48a:	2800      	cmp	r0, #0
    a48c:	d049      	beq.n	a522 <usb_audio_receive_callback+0x106>
				AudioInputUSB::incoming_right = NULL;
				AudioInputUSB::incoming_count = 0;
				return;
			}
			AudioInputUSB::incoming_left = left;
			AudioInputUSB::incoming_right = right;
    a48e:	4b37      	ldr	r3, [pc, #220]	; (a56c <usb_audio_receive_callback+0x150>)
				AudioInputUSB::incoming_left = NULL;
				AudioInputUSB::incoming_right = NULL;
				AudioInputUSB::incoming_count = 0;
				return;
			}
			AudioInputUSB::incoming_left = left;
    a490:	f8cb 4000 	str.w	r4, [fp]
			AudioInputUSB::incoming_right = right;
    a494:	6018      	str	r0, [r3, #0]
	if (right == NULL) {
		right = AudioStream::allocate();
		if (right == NULL) return;
		AudioInputUSB::incoming_right = right;
	}
	while (len > 0) {
    a496:	2e00      	cmp	r6, #0
    a498:	d033      	beq.n	a502 <usb_audio_receive_callback+0xe6>
		avail = AUDIO_BLOCK_SAMPLES - count;
		if (len < avail) {
    a49a:	2e7f      	cmp	r6, #127	; 0x7f
				AudioInputUSB::incoming_count = 0;
				return;
			}
			AudioInputUSB::incoming_left = left;
			AudioInputUSB::incoming_right = right;
			count = 0;
    a49c:	f04f 0a00 	mov.w	sl, #0
		right = AudioStream::allocate();
		if (right == NULL) return;
		AudioInputUSB::incoming_right = right;
	}
	while (len > 0) {
		avail = AUDIO_BLOCK_SAMPLES - count;
    a4a0:	f04f 0780 	mov.w	r7, #128	; 0x80
		if (len < avail) {
    a4a4:	d949      	bls.n	a53a <usb_audio_receive_callback+0x11e>
			copy_to_buffers(data, left->data + count, right->data + count, len);
			AudioInputUSB::incoming_count = count + len;
			return;
		} else if (avail > 0) {
			copy_to_buffers(data, left->data + count, right->data + count, avail);
    a4a6:	ea4f 034a 	mov.w	r3, sl, lsl #1
    a4aa:	1d2a      	adds	r2, r5, #4
    a4ac:	1d21      	adds	r1, r4, #4
    a4ae:	441a      	add	r2, r3
    a4b0:	4419      	add	r1, r3
    a4b2:	9801      	ldr	r0, [sp, #4]
    a4b4:	463b      	mov	r3, r7
    a4b6:	f7ff fee9 	bl	a28c <copy_to_buffers(unsigned long const*, short*, short*, unsigned int)>
			data += avail;
    a4ba:	9a01      	ldr	r2, [sp, #4]
			len -= avail;
			if (AudioInputUSB::ready_left || AudioInputUSB::ready_right) {
    a4bc:	f8d8 3000 	ldr.w	r3, [r8]
			copy_to_buffers(data, left->data + count, right->data + count, len);
			AudioInputUSB::incoming_count = count + len;
			return;
		} else if (avail > 0) {
			copy_to_buffers(data, left->data + count, right->data + count, avail);
			data += avail;
    a4c0:	eb02 0287 	add.w	r2, r2, r7, lsl #2
			len -= avail;
    a4c4:	1bf6      	subs	r6, r6, r7
			copy_to_buffers(data, left->data + count, right->data + count, len);
			AudioInputUSB::incoming_count = count + len;
			return;
		} else if (avail > 0) {
			copy_to_buffers(data, left->data + count, right->data + count, avail);
			data += avail;
    a4c6:	9201      	str	r2, [sp, #4]
			len -= avail;
			if (AudioInputUSB::ready_left || AudioInputUSB::ready_right) {
    a4c8:	b923      	cbnz	r3, a4d4 <usb_audio_receive_callback+0xb8>
    a4ca:	f8d9 2000 	ldr.w	r2, [r9]
    a4ce:	4b29      	ldr	r3, [pc, #164]	; (a574 <usb_audio_receive_callback+0x158>)
    a4d0:	2a00      	cmp	r2, #0
    a4d2:	d0cf      	beq.n	a474 <usb_audio_receive_callback+0x58>
				// buffer overrun, PC sending too fast
				AudioInputUSB::incoming_count = count + avail;
    a4d4:	4b23      	ldr	r3, [pc, #140]	; (a564 <usb_audio_receive_callback+0x148>)
    a4d6:	4457      	add	r7, sl
    a4d8:	801f      	strh	r7, [r3, #0]
			if (AudioInputUSB::ready_left || AudioInputUSB::ready_right) return;
			goto send; // recover from buffer overrun
		}
	}
	AudioInputUSB::incoming_count = count;
}
    a4da:	b003      	add	sp, #12
    a4dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

	count = AudioInputUSB::incoming_count;
	left = AudioInputUSB::incoming_left;
	right = AudioInputUSB::incoming_right;
	if (left == NULL) {
		left = AudioStream::allocate();
    a4e0:	f7fe fb90 	bl	8c04 <AudioStream::allocate()>
		if (left == NULL) return;
    a4e4:	4604      	mov	r4, r0
    a4e6:	2800      	cmp	r0, #0
    a4e8:	d0f7      	beq.n	a4da <usb_audio_receive_callback+0xbe>
		AudioInputUSB::incoming_left = left;
    a4ea:	f8cb 0000 	str.w	r0, [fp]
	}
	if (right == NULL) {
    a4ee:	2d00      	cmp	r5, #0
    a4f0:	d1a9      	bne.n	a446 <usb_audio_receive_callback+0x2a>
		right = AudioStream::allocate();
    a4f2:	f7fe fb87 	bl	8c04 <AudioStream::allocate()>
		if (right == NULL) return;
    a4f6:	4605      	mov	r5, r0
    a4f8:	2800      	cmp	r0, #0
    a4fa:	d0ee      	beq.n	a4da <usb_audio_receive_callback+0xbe>
		AudioInputUSB::incoming_right = right;
    a4fc:	4b1b      	ldr	r3, [pc, #108]	; (a56c <usb_audio_receive_callback+0x150>)
    a4fe:	6018      	str	r0, [r3, #0]
    a500:	e7a1      	b.n	a446 <usb_audio_receive_callback+0x2a>
    a502:	46b0      	mov	r8, r6
		} else {
			if (AudioInputUSB::ready_left || AudioInputUSB::ready_right) return;
			goto send; // recover from buffer overrun
		}
	}
	AudioInputUSB::incoming_count = count;
    a504:	4b17      	ldr	r3, [pc, #92]	; (a564 <usb_audio_receive_callback+0x148>)
    a506:	f8a3 8000 	strh.w	r8, [r3]
}
    a50a:	b003      	add	sp, #12
    a50c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			AudioInputUSB::ready_right = right;
			//if (AudioInputUSB::update_responsibility) AudioStream::update_all();
			left = AudioStream::allocate();
			if (left == NULL) {
				AudioInputUSB::incoming_left = NULL;
				AudioInputUSB::incoming_right = NULL;
    a510:	4b16      	ldr	r3, [pc, #88]	; (a56c <usb_audio_receive_callback+0x150>)
			AudioInputUSB::ready_left = left;
			AudioInputUSB::ready_right = right;
			//if (AudioInputUSB::update_responsibility) AudioStream::update_all();
			left = AudioStream::allocate();
			if (left == NULL) {
				AudioInputUSB::incoming_left = NULL;
    a512:	f8cb 0000 	str.w	r0, [fp]
				AudioInputUSB::incoming_right = NULL;
    a516:	6018      	str	r0, [r3, #0]
				AudioInputUSB::incoming_count = 0;
    a518:	4b12      	ldr	r3, [pc, #72]	; (a564 <usb_audio_receive_callback+0x148>)
    a51a:	8018      	strh	r0, [r3, #0]
			if (AudioInputUSB::ready_left || AudioInputUSB::ready_right) return;
			goto send; // recover from buffer overrun
		}
	}
	AudioInputUSB::incoming_count = count;
}
    a51c:	b003      	add	sp, #12
    a51e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				AudioInputUSB::incoming_count = 0;
				return;
			}
			right = AudioStream::allocate();
			if (right == NULL) {
				AudioStream::release(left);
    a522:	4620      	mov	r0, r4
    a524:	f7fe fbc2 	bl	8cac <AudioStream::release(audio_block_struct*)>
				AudioInputUSB::incoming_left = NULL;
				AudioInputUSB::incoming_right = NULL;
    a528:	4b10      	ldr	r3, [pc, #64]	; (a56c <usb_audio_receive_callback+0x150>)
				return;
			}
			right = AudioStream::allocate();
			if (right == NULL) {
				AudioStream::release(left);
				AudioInputUSB::incoming_left = NULL;
    a52a:	f8cb 5000 	str.w	r5, [fp]
				AudioInputUSB::incoming_right = NULL;
    a52e:	601d      	str	r5, [r3, #0]
				AudioInputUSB::incoming_count = 0;
    a530:	4b0c      	ldr	r3, [pc, #48]	; (a564 <usb_audio_receive_callback+0x148>)
    a532:	801d      	strh	r5, [r3, #0]
			if (AudioInputUSB::ready_left || AudioInputUSB::ready_right) return;
			goto send; // recover from buffer overrun
		}
	}
	AudioInputUSB::incoming_count = count;
}
    a534:	b003      	add	sp, #12
    a536:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a53a:	46d0      	mov	r8, sl
    a53c:	4653      	mov	r3, sl
		AudioInputUSB::incoming_right = right;
	}
	while (len > 0) {
		avail = AUDIO_BLOCK_SAMPLES - count;
		if (len < avail) {
			copy_to_buffers(data, left->data + count, right->data + count, len);
    a53e:	1d2a      	adds	r2, r5, #4
    a540:	1d21      	adds	r1, r4, #4
    a542:	441a      	add	r2, r3
    a544:	4419      	add	r1, r3
    a546:	9801      	ldr	r0, [sp, #4]
    a548:	4633      	mov	r3, r6
    a54a:	f7ff fe9f 	bl	a28c <copy_to_buffers(unsigned long const*, short*, short*, unsigned int)>
			AudioInputUSB::incoming_count = count + len;
    a54e:	4b05      	ldr	r3, [pc, #20]	; (a564 <usb_audio_receive_callback+0x148>)
    a550:	4446      	add	r6, r8
    a552:	801e      	strh	r6, [r3, #0]
			if (AudioInputUSB::ready_left || AudioInputUSB::ready_right) return;
			goto send; // recover from buffer overrun
		}
	}
	AudioInputUSB::incoming_count = count;
}
    a554:	b003      	add	sp, #12
    a556:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (right == NULL) return;
		AudioInputUSB::incoming_right = right;
	}
	while (len > 0) {
		avail = AUDIO_BLOCK_SAMPLES - count;
		if (len < avail) {
    a55a:	4a05      	ldr	r2, [pc, #20]	; (a570 <usb_audio_receive_callback+0x154>)
    a55c:	9201      	str	r2, [sp, #4]
    a55e:	ea4f 0348 	mov.w	r3, r8, lsl #1
    a562:	e7ec      	b.n	a53e <usb_audio_receive_callback+0x122>
    a564:	2000461c 	.word	0x2000461c
    a568:	20004608 	.word	0x20004608
    a56c:	200045f0 	.word	0x200045f0
    a570:	1fffadc0 	.word	0x1fffadc0
    a574:	200045f8 	.word	0x200045f8
    a578:	20004604 	.word	0x20004604
    a57c:	2000460c 	.word	0x2000460c

0000a580 <AudioOutputUSB::begin()>:
uint16_t usb_audio_transmit_buffer[AUDIO_TX_SIZE/2] DMABUFATTR;
uint8_t usb_audio_transmit_setting=0;

void AudioOutputUSB::begin(void)
{
	update_responsibility = false;
    a580:	4803      	ldr	r0, [pc, #12]	; (a590 <AudioOutputUSB::begin()+0x10>)
	left_1st = NULL;
    a582:	4904      	ldr	r1, [pc, #16]	; (a594 <AudioOutputUSB::begin()+0x14>)
	right_1st = NULL;
    a584:	4a04      	ldr	r2, [pc, #16]	; (a598 <AudioOutputUSB::begin()+0x18>)
uint16_t usb_audio_transmit_buffer[AUDIO_TX_SIZE/2] DMABUFATTR;
uint8_t usb_audio_transmit_setting=0;

void AudioOutputUSB::begin(void)
{
	update_responsibility = false;
    a586:	2300      	movs	r3, #0
    a588:	7003      	strb	r3, [r0, #0]
	left_1st = NULL;
    a58a:	600b      	str	r3, [r1, #0]
	right_1st = NULL;
    a58c:	6013      	str	r3, [r2, #0]
    a58e:	4770      	bx	lr
    a590:	20004614 	.word	0x20004614
    a594:	200045fc 	.word	0x200045fc
    a598:	20004610 	.word	0x20004610

0000a59c <usb_audio_transmit_callback>:
{
	static uint32_t count=5;
	uint32_t avail, num, target, offset, len=0;
	audio_block_t *left, *right;

	if (++count < 9) {   // TODO: dynamic adjust to match USB rate
    a59c:	4a35      	ldr	r2, [pc, #212]	; (a674 <usb_audio_transmit_callback+0xd8>)
// Called from the USB interrupt when ready to transmit another
// isochronous packet.  If we place data into the transmit buffer,
// the return is the number of bytes.  Otherwise, return 0 means
// no data to transmit
unsigned int usb_audio_transmit_callback(void)
{
    a59e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	static uint32_t count=5;
	uint32_t avail, num, target, offset, len=0;
	audio_block_t *left, *right;

	if (++count < 9) {   // TODO: dynamic adjust to match USB rate
    a5a2:	6813      	ldr	r3, [r2, #0]
    a5a4:	3301      	adds	r3, #1
    a5a6:	2b08      	cmp	r3, #8
// Called from the USB interrupt when ready to transmit another
// isochronous packet.  If we place data into the transmit buffer,
// the return is the number of bytes.  Otherwise, return 0 means
// no data to transmit
unsigned int usb_audio_transmit_callback(void)
{
    a5a8:	b083      	sub	sp, #12
	static uint32_t count=5;
	uint32_t avail, num, target, offset, len=0;
	audio_block_t *left, *right;

	if (++count < 9) {   // TODO: dynamic adjust to match USB rate
    a5aa:	d851      	bhi.n	a650 <usb_audio_transmit_callback+0xb4>
    a5ac:	6013      	str	r3, [r2, #0]
    a5ae:	23b0      	movs	r3, #176	; 0xb0
    a5b0:	9301      	str	r3, [sp, #4]
		target = 44;
    a5b2:	f04f 0a2c 	mov.w	sl, #44	; 0x2c
    a5b6:	4930      	ldr	r1, [pc, #192]	; (a678 <usb_audio_transmit_callback+0xdc>)
			memset(usb_audio_transmit_buffer + len, 0, num * 4);
			//serial_print("%");
			break;
		}
		right = AudioOutputUSB::right_1st;
		offset = AudioOutputUSB::offset_1st;
    a5b8:	f8df b0d0 	ldr.w	fp, [pc, #208]	; a68c <usb_audio_transmit_callback+0xf0>
	static uint32_t count=5;
	uint32_t avail, num, target, offset, len=0;
	audio_block_t *left, *right;

	if (++count < 9) {   // TODO: dynamic adjust to match USB rate
		target = 44;
    a5bc:	f04f 0800 	mov.w	r8, #0
		count = 0;
		target = 45;
	}
	while (len < target) {
		num = target - len;
		left = AudioOutputUSB::left_1st;
    a5c0:	6808      	ldr	r0, [r1, #0]
	} else {
		count = 0;
		target = 45;
	}
	while (len < target) {
		num = target - len;
    a5c2:	ebc8 030a 	rsb	r3, r8, sl
		left = AudioOutputUSB::left_1st;
		if (left == NULL) {
    a5c6:	2800      	cmp	r0, #0
    a5c8:	d049      	beq.n	a65e <usb_audio_transmit_callback+0xc2>
			memset(usb_audio_transmit_buffer + len, 0, num * 4);
			//serial_print("%");
			break;
		}
		right = AudioOutputUSB::right_1st;
		offset = AudioOutputUSB::offset_1st;
    a5ca:	f8bb e000 	ldrh.w	lr, [fp]
			// buffer underrun - PC is consuming too quickly
			memset(usb_audio_transmit_buffer + len, 0, num * 4);
			//serial_print("%");
			break;
		}
		right = AudioOutputUSB::right_1st;
    a5ce:	4a2b      	ldr	r2, [pc, #172]	; (a67c <usb_audio_transmit_callback+0xe0>)
    a5d0:	f8d2 9000 	ldr.w	r9, [r2]
		offset = AudioOutputUSB::offset_1st;

		avail = AUDIO_BLOCK_SAMPLES - offset;
    a5d4:	f1ce 0280 	rsb	r2, lr, #128	; 0x80
    a5d8:	4293      	cmp	r3, r2
    a5da:	bf28      	it	cs
    a5dc:	4613      	movcs	r3, r2
		if (num > avail) num = avail;

		copy_from_buffers((uint32_t *)usb_audio_transmit_buffer + len,
    a5de:	1d05      	adds	r5, r0, #4
    a5e0:	ea4f 024e 	mov.w	r2, lr, lsl #1
    a5e4:	f109 0704 	add.w	r7, r9, #4
    a5e8:	4415      	add	r5, r2
    a5ea:	4417      	add	r7, r2
    a5ec:	ea4f 0688 	mov.w	r6, r8, lsl #2
}

static void copy_from_buffers(uint32_t *dst, int16_t *left, int16_t *right, unsigned int len)
{
	// TODO: optimize...
	while (len > 0) {
    a5f0:	b16b      	cbz	r3, a60e <usb_audio_transmit_callback+0x72>
    a5f2:	4a23      	ldr	r2, [pc, #140]	; (a680 <usb_audio_transmit_callback+0xe4>)
    a5f4:	3e04      	subs	r6, #4
    a5f6:	4416      	add	r6, r2
    a5f8:	461c      	mov	r4, r3
		*dst++ = (*right++ << 16) | (*left++ & 0xFFFF);
    a5fa:	f937 cb02 	ldrsh.w	ip, [r7], #2
    a5fe:	f835 2b02 	ldrh.w	r2, [r5], #2
}

static void copy_from_buffers(uint32_t *dst, int16_t *left, int16_t *right, unsigned int len)
{
	// TODO: optimize...
	while (len > 0) {
    a602:	3c01      	subs	r4, #1
		*dst++ = (*right++ << 16) | (*left++ & 0xFFFF);
    a604:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
    a608:	f846 2f04 	str.w	r2, [r6, #4]!
}

static void copy_from_buffers(uint32_t *dst, int16_t *left, int16_t *right, unsigned int len)
{
	// TODO: optimize...
	while (len > 0) {
    a60c:	d1f5      	bne.n	a5fa <usb_audio_transmit_callback+0x5e>
		if (num > avail) num = avail;

		copy_from_buffers((uint32_t *)usb_audio_transmit_buffer + len,
			left->data + offset, right->data + offset, num);
		len += num;
		offset += num;
    a60e:	449e      	add	lr, r3
		if (offset >= AUDIO_BLOCK_SAMPLES) {
    a610:	f1be 0f7f 	cmp.w	lr, #127	; 0x7f
		avail = AUDIO_BLOCK_SAMPLES - offset;
		if (num > avail) num = avail;

		copy_from_buffers((uint32_t *)usb_audio_transmit_buffer + len,
			left->data + offset, right->data + offset, num);
		len += num;
    a614:	4498      	add	r8, r3
		offset += num;
		if (offset >= AUDIO_BLOCK_SAMPLES) {
    a616:	d807      	bhi.n	a628 <usb_audio_transmit_callback+0x8c>
			AudioOutputUSB::left_2nd = NULL;
			AudioOutputUSB::right_1st = AudioOutputUSB::right_2nd;
			AudioOutputUSB::right_2nd = NULL;
			AudioOutputUSB::offset_1st = 0;
		} else {
			AudioOutputUSB::offset_1st = offset;
    a618:	f8ab e000 	strh.w	lr, [fp]
		target = 44;
	} else {
		count = 0;
		target = 45;
	}
	while (len < target) {
    a61c:	45c2      	cmp	sl, r8
    a61e:	d8cf      	bhi.n	a5c0 <usb_audio_transmit_callback+0x24>
		} else {
			AudioOutputUSB::offset_1st = offset;
		}
	}
	return target * 4;
}
    a620:	9801      	ldr	r0, [sp, #4]
    a622:	b003      	add	sp, #12
    a624:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a628:	9100      	str	r1, [sp, #0]
		copy_from_buffers((uint32_t *)usb_audio_transmit_buffer + len,
			left->data + offset, right->data + offset, num);
		len += num;
		offset += num;
		if (offset >= AUDIO_BLOCK_SAMPLES) {
			AudioStream::release(left);
    a62a:	f7fe fb3f 	bl	8cac <AudioStream::release(audio_block_struct*)>
			AudioStream::release(right);
    a62e:	4648      	mov	r0, r9
    a630:	f7fe fb3c 	bl	8cac <AudioStream::release(audio_block_struct*)>
			AudioOutputUSB::left_1st = AudioOutputUSB::left_2nd;
    a634:	4813      	ldr	r0, [pc, #76]	; (a684 <usb_audio_transmit_callback+0xe8>)
    a636:	9900      	ldr	r1, [sp, #0]
    a638:	6803      	ldr	r3, [r0, #0]
			AudioOutputUSB::left_2nd = NULL;
			AudioOutputUSB::right_1st = AudioOutputUSB::right_2nd;
    a63a:	4a13      	ldr	r2, [pc, #76]	; (a688 <usb_audio_transmit_callback+0xec>)
		len += num;
		offset += num;
		if (offset >= AUDIO_BLOCK_SAMPLES) {
			AudioStream::release(left);
			AudioStream::release(right);
			AudioOutputUSB::left_1st = AudioOutputUSB::left_2nd;
    a63c:	600b      	str	r3, [r1, #0]
			AudioOutputUSB::left_2nd = NULL;
    a63e:	2300      	movs	r3, #0
			AudioOutputUSB::right_1st = AudioOutputUSB::right_2nd;
    a640:	6814      	ldr	r4, [r2, #0]
		offset += num;
		if (offset >= AUDIO_BLOCK_SAMPLES) {
			AudioStream::release(left);
			AudioStream::release(right);
			AudioOutputUSB::left_1st = AudioOutputUSB::left_2nd;
			AudioOutputUSB::left_2nd = NULL;
    a642:	6003      	str	r3, [r0, #0]
			AudioOutputUSB::right_1st = AudioOutputUSB::right_2nd;
			AudioOutputUSB::right_2nd = NULL;
			AudioOutputUSB::offset_1st = 0;
    a644:	f8ab 3000 	strh.w	r3, [fp]
			AudioStream::release(left);
			AudioStream::release(right);
			AudioOutputUSB::left_1st = AudioOutputUSB::left_2nd;
			AudioOutputUSB::left_2nd = NULL;
			AudioOutputUSB::right_1st = AudioOutputUSB::right_2nd;
			AudioOutputUSB::right_2nd = NULL;
    a648:	6013      	str	r3, [r2, #0]
		if (offset >= AUDIO_BLOCK_SAMPLES) {
			AudioStream::release(left);
			AudioStream::release(right);
			AudioOutputUSB::left_1st = AudioOutputUSB::left_2nd;
			AudioOutputUSB::left_2nd = NULL;
			AudioOutputUSB::right_1st = AudioOutputUSB::right_2nd;
    a64a:	4b0c      	ldr	r3, [pc, #48]	; (a67c <usb_audio_transmit_callback+0xe0>)
    a64c:	601c      	str	r4, [r3, #0]
    a64e:	e7e5      	b.n	a61c <usb_audio_transmit_callback+0x80>
	audio_block_t *left, *right;

	if (++count < 9) {   // TODO: dynamic adjust to match USB rate
		target = 44;
	} else {
		count = 0;
    a650:	2300      	movs	r3, #0
    a652:	6013      	str	r3, [r2, #0]
    a654:	23b4      	movs	r3, #180	; 0xb4
    a656:	9301      	str	r3, [sp, #4]
		target = 45;
    a658:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
    a65c:	e7ab      	b.n	a5b6 <usb_audio_transmit_callback+0x1a>
	while (len < target) {
		num = target - len;
		left = AudioOutputUSB::left_1st;
		if (left == NULL) {
			// buffer underrun - PC is consuming too quickly
			memset(usb_audio_transmit_buffer + len, 0, num * 4);
    a65e:	4c08      	ldr	r4, [pc, #32]	; (a680 <usb_audio_transmit_callback+0xe4>)
    a660:	4601      	mov	r1, r0
    a662:	009a      	lsls	r2, r3, #2
    a664:	eb04 0048 	add.w	r0, r4, r8, lsl #1
    a668:	f003 fdb4 	bl	e1d4 <memset>
		} else {
			AudioOutputUSB::offset_1st = offset;
		}
	}
	return target * 4;
}
    a66c:	9801      	ldr	r0, [sp, #4]
    a66e:	b003      	add	sp, #12
    a670:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a674:	1fffbaf0 	.word	0x1fffbaf0
    a678:	200045fc 	.word	0x200045fc
    a67c:	20004610 	.word	0x20004610
    a680:	1fffae74 	.word	0x1fffae74
    a684:	20004618 	.word	0x20004618
    a688:	20004600 	.word	0x20004600
    a68c:	200045f4 	.word	0x200045f4

0000a690 <usb_audio_get_feature>:
};

int usb_audio_get_feature(void *stp, uint8_t *data, uint32_t *datalen)
{
	struct setup_struct setup = *((struct setup_struct *)stp);
	if (setup.bmRequestType==0xA1) { // should check bRequest, bChannel, and UnitID
    a690:	7803      	ldrb	r3, [r0, #0]
    a692:	2ba1      	cmp	r3, #161	; 0xa1
    a694:	d001      	beq.n	a69a <usb_audio_get_feature+0xa>
				}
				*datalen = 2;
				return 1;
			}
	}
	return 0;
    a696:	2000      	movs	r0, #0
}
    a698:	4770      	bx	lr
  };
};

int usb_audio_get_feature(void *stp, uint8_t *data, uint32_t *datalen)
{
	struct setup_struct setup = *((struct setup_struct *)stp);
    a69a:	78c3      	ldrb	r3, [r0, #3]
	if (setup.bmRequestType==0xA1) { // should check bRequest, bChannel, and UnitID
			if (setup.bCS==0x01) { // mute
    a69c:	2b01      	cmp	r3, #1
    a69e:	d012      	beq.n	a6c6 <usb_audio_get_feature+0x36>
				data[0] = AudioInputUSB::features.mute;  // 1=mute, 0=unmute
				*datalen = 1;
				return 1;
			}
			else if (setup.bCS==0x02) { // volume
    a6a0:	2b02      	cmp	r3, #2
    a6a2:	d1f8      	bne.n	a696 <usb_audio_get_feature+0x6>
  };
};

int usb_audio_get_feature(void *stp, uint8_t *data, uint32_t *datalen)
{
	struct setup_struct setup = *((struct setup_struct *)stp);
    a6a4:	7843      	ldrb	r3, [r0, #1]
				data[0] = AudioInputUSB::features.mute;  // 1=mute, 0=unmute
				*datalen = 1;
				return 1;
			}
			else if (setup.bCS==0x02) { // volume
				if (setup.bRequest==0x81) { // GET_CURR
    a6a6:	2b81      	cmp	r3, #129	; 0x81
    a6a8:	d018      	beq.n	a6dc <usb_audio_get_feature+0x4c>
					data[0] = AudioInputUSB::features.volume & 0xFF;
					data[1] = (AudioInputUSB::features.volume>>8) & 0xFF;
				}
				else if (setup.bRequest==0x82) { // GET_MIN
    a6aa:	2b82      	cmp	r3, #130	; 0x82
    a6ac:	d01d      	beq.n	a6ea <usb_audio_get_feature+0x5a>
					//serial_print("vol get_min\n");
					data[0] = 0;     // min level is 0
					data[1] = 0;
				}
				else if (setup.bRequest==0x83) { // GET_MAX
    a6ae:	2b83      	cmp	r3, #131	; 0x83
    a6b0:	d00f      	beq.n	a6d2 <usb_audio_get_feature+0x42>
					data[0] = FEATURE_MAX_VOLUME & 0xFF;  // max level, for range of 0 to MAX
					data[1] = (FEATURE_MAX_VOLUME>>8) & 0x0F;
				}
				else if (setup.bRequest==0x84) { // GET_RES
    a6b2:	2b84      	cmp	r3, #132	; 0x84
    a6b4:	d1ef      	bne.n	a696 <usb_audio_get_feature+0x6>
					data[0] = 1; // increment vol by by 1
    a6b6:	2001      	movs	r0, #1
					data[1] = 0;
    a6b8:	2300      	movs	r3, #0
				else if (setup.bRequest==0x83) { // GET_MAX
					data[0] = FEATURE_MAX_VOLUME & 0xFF;  // max level, for range of 0 to MAX
					data[1] = (FEATURE_MAX_VOLUME>>8) & 0x0F;
				}
				else if (setup.bRequest==0x84) { // GET_RES
					data[0] = 1; // increment vol by by 1
    a6ba:	7008      	strb	r0, [r1, #0]
					data[1] = 0;
    a6bc:	704b      	strb	r3, [r1, #1]
				}
				else { // pass over SET_MEM, etc.
					return 0;
				}
				*datalen = 2;
    a6be:	2302      	movs	r3, #2
    a6c0:	6013      	str	r3, [r2, #0]
				return 1;
    a6c2:	2001      	movs	r0, #1
    a6c4:	4770      	bx	lr
int usb_audio_get_feature(void *stp, uint8_t *data, uint32_t *datalen)
{
	struct setup_struct setup = *((struct setup_struct *)stp);
	if (setup.bmRequestType==0xA1) { // should check bRequest, bChannel, and UnitID
			if (setup.bCS==0x01) { // mute
				data[0] = AudioInputUSB::features.mute;  // 1=mute, 0=unmute
    a6c6:	480b      	ldr	r0, [pc, #44]	; (a6f4 <usb_audio_get_feature+0x64>)
    a6c8:	6840      	ldr	r0, [r0, #4]
    a6ca:	7008      	strb	r0, [r1, #0]
				*datalen = 1;
				return 1;
    a6cc:	4618      	mov	r0, r3
{
	struct setup_struct setup = *((struct setup_struct *)stp);
	if (setup.bmRequestType==0xA1) { // should check bRequest, bChannel, and UnitID
			if (setup.bCS==0x01) { // mute
				data[0] = AudioInputUSB::features.mute;  // 1=mute, 0=unmute
				*datalen = 1;
    a6ce:	6013      	str	r3, [r2, #0]
				return 1;
    a6d0:	4770      	bx	lr
					//serial_print("vol get_min\n");
					data[0] = 0;     // min level is 0
					data[1] = 0;
				}
				else if (setup.bRequest==0x83) { // GET_MAX
					data[0] = FEATURE_MAX_VOLUME & 0xFF;  // max level, for range of 0 to MAX
    a6d2:	20ff      	movs	r0, #255	; 0xff
					data[1] = (FEATURE_MAX_VOLUME>>8) & 0x0F;
    a6d4:	230f      	movs	r3, #15
					//serial_print("vol get_min\n");
					data[0] = 0;     // min level is 0
					data[1] = 0;
				}
				else if (setup.bRequest==0x83) { // GET_MAX
					data[0] = FEATURE_MAX_VOLUME & 0xFF;  // max level, for range of 0 to MAX
    a6d6:	7008      	strb	r0, [r1, #0]
					data[1] = (FEATURE_MAX_VOLUME>>8) & 0x0F;
    a6d8:	704b      	strb	r3, [r1, #1]
    a6da:	e7f0      	b.n	a6be <usb_audio_get_feature+0x2e>
				*datalen = 1;
				return 1;
			}
			else if (setup.bCS==0x02) { // volume
				if (setup.bRequest==0x81) { // GET_CURR
					data[0] = AudioInputUSB::features.volume & 0xFF;
    a6dc:	4b05      	ldr	r3, [pc, #20]	; (a6f4 <usb_audio_get_feature+0x64>)
    a6de:	6898      	ldr	r0, [r3, #8]
    a6e0:	7008      	strb	r0, [r1, #0]
					data[1] = (AudioInputUSB::features.volume>>8) & 0xFF;
    a6e2:	689b      	ldr	r3, [r3, #8]
    a6e4:	121b      	asrs	r3, r3, #8
    a6e6:	704b      	strb	r3, [r1, #1]
    a6e8:	e7e9      	b.n	a6be <usb_audio_get_feature+0x2e>
				}
				else if (setup.bRequest==0x82) { // GET_MIN
					//serial_print("vol get_min\n");
					data[0] = 0;     // min level is 0
    a6ea:	2300      	movs	r3, #0
    a6ec:	700b      	strb	r3, [r1, #0]
					data[1] = 0;
    a6ee:	704b      	strb	r3, [r1, #1]
    a6f0:	e7e5      	b.n	a6be <usb_audio_get_feature+0x2e>
    a6f2:	bf00      	nop
    a6f4:	1fffbae4 	.word	0x1fffbae4

0000a6f8 <usb_audio_set_feature>:
}

int usb_audio_set_feature(void *stp, uint8_t *buf) 
{
	struct setup_struct setup = *((struct setup_struct *)stp);
	if (setup.bmRequestType==0x21) { // should check bRequest, bChannel and UnitID
    a6f8:	7803      	ldrb	r3, [r0, #0]
    a6fa:	2b21      	cmp	r3, #33	; 0x21
    a6fc:	d001      	beq.n	a702 <usb_audio_set_feature+0xa>
					AudioInputUSB::features.change = 1;
					return 1;
				}
			}
	}
	return 0;
    a6fe:	2000      	movs	r0, #0
    a700:	4770      	bx	lr
	return 0;
}

int usb_audio_set_feature(void *stp, uint8_t *buf) 
{
	struct setup_struct setup = *((struct setup_struct *)stp);
    a702:	78c3      	ldrb	r3, [r0, #3]
    a704:	7840      	ldrb	r0, [r0, #1]
	if (setup.bmRequestType==0x21) { // should check bRequest, bChannel and UnitID
			if (setup.bCS==0x01) { // mute
    a706:	2b01      	cmp	r3, #1
    a708:	d00d      	beq.n	a726 <usb_audio_set_feature+0x2e>
					AudioInputUSB::features.mute = buf[0]; // 1=mute,0=unmute
					AudioInputUSB::features.change = 1;
					return 1;
				}
			}
			else if (setup.bCS==0x02) { // volume
    a70a:	2b02      	cmp	r3, #2
    a70c:	d1f7      	bne.n	a6fe <usb_audio_set_feature+0x6>
				if (setup.bRequest==0x01) { // SET_CUR
    a70e:	2801      	cmp	r0, #1
    a710:	d1f5      	bne.n	a6fe <usb_audio_set_feature+0x6>
	}
	return 0;
}

int usb_audio_set_feature(void *stp, uint8_t *buf) 
{
    a712:	b410      	push	{r4}
					return 1;
				}
			}
			else if (setup.bCS==0x02) { // volume
				if (setup.bRequest==0x01) { // SET_CUR
					AudioInputUSB::features.volume = buf[0] + (buf[1]<<8);
    a714:	780b      	ldrb	r3, [r1, #0]
    a716:	784c      	ldrb	r4, [r1, #1]
    a718:	4a06      	ldr	r2, [pc, #24]	; (a734 <usb_audio_set_feature+0x3c>)
    a71a:	eb03 2304 	add.w	r3, r3, r4, lsl #8
    a71e:	6093      	str	r3, [r2, #8]
					AudioInputUSB::features.change = 1;
    a720:	6010      	str	r0, [r2, #0]
					return 1;
				}
			}
	}
	return 0;
}
    a722:	bc10      	pop	{r4}
    a724:	4770      	bx	lr
int usb_audio_set_feature(void *stp, uint8_t *buf) 
{
	struct setup_struct setup = *((struct setup_struct *)stp);
	if (setup.bmRequestType==0x21) { // should check bRequest, bChannel and UnitID
			if (setup.bCS==0x01) { // mute
				if (setup.bRequest==0x01) { // SET_CUR
    a726:	2801      	cmp	r0, #1
    a728:	d1e9      	bne.n	a6fe <usb_audio_set_feature+0x6>
					AudioInputUSB::features.mute = buf[0]; // 1=mute,0=unmute
    a72a:	4b02      	ldr	r3, [pc, #8]	; (a734 <usb_audio_set_feature+0x3c>)
    a72c:	780a      	ldrb	r2, [r1, #0]
					AudioInputUSB::features.change = 1;
    a72e:	e883 0005 	stmia.w	r3, {r0, r2}
					return 1;
    a732:	4770      	bx	lr
    a734:	1fffbae4 	.word	0x1fffbae4

0000a738 <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    a738:	1e43      	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    a73a:	2b07      	cmp	r3, #7
    a73c:	d814      	bhi.n	a768 <usb_rx+0x30>
	__disable_irq();
    a73e:	b672      	cpsid	i
	ret = rx_first[endpoint];
    a740:	490a      	ldr	r1, [pc, #40]	; (a76c <usb_rx+0x34>)
    a742:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
	if (ret) {
    a746:	b168      	cbz	r0, a764 <usb_rx+0x2c>




usb_packet_t *usb_rx(uint32_t endpoint)
{
    a748:	b470      	push	{r4, r5, r6}
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
    a74a:	4c09      	ldr	r4, [pc, #36]	; (a770 <usb_rx+0x38>)
    a74c:	8805      	ldrh	r5, [r0, #0]
    a74e:	f834 2013 	ldrh.w	r2, [r4, r3, lsl #1]
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
    a752:	6846      	ldr	r6, [r0, #4]
    a754:	f841 6023 	str.w	r6, [r1, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    a758:	1b52      	subs	r2, r2, r5
    a75a:	f824 2013 	strh.w	r2, [r4, r3, lsl #1]
	}
	__enable_irq();
    a75e:	b662      	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    a760:	bc70      	pop	{r4, r5, r6}
    a762:	4770      	bx	lr
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
	}
	__enable_irq();
    a764:	b662      	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    a766:	4770      	bx	lr

usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    a768:	2000      	movs	r0, #0
    a76a:	4770      	bx	lr
    a76c:	20004688 	.word	0x20004688
    a770:	20004928 	.word	0x20004928

0000a774 <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    a774:	3801      	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    a776:	2807      	cmp	r0, #7
    a778:	d80b      	bhi.n	a792 <usb_tx_packet_count+0x1e>
	__disable_irq();
    a77a:	b672      	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    a77c:	4b07      	ldr	r3, [pc, #28]	; (a79c <usb_tx_packet_count+0x28>)
    a77e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    a782:	b143      	cbz	r3, a796 <usb_tx_packet_count+0x22>
    a784:	2000      	movs	r0, #0
    a786:	685b      	ldr	r3, [r3, #4]
    a788:	3001      	adds	r0, #1
    a78a:	2b00      	cmp	r3, #0
    a78c:	d1fb      	bne.n	a786 <usb_tx_packet_count+0x12>
	__enable_irq();
    a78e:	b662      	cpsie	i
	return count;
    a790:	4770      	bx	lr
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
    a792:	2000      	movs	r0, #0
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
	__enable_irq();
	return count;
}
    a794:	4770      	bx	lr
}

uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;
    a796:	4618      	mov	r0, r3
    a798:	e7f9      	b.n	a78e <usb_tx_packet_count+0x1a>
    a79a:	bf00      	nop
    a79c:	200046ec 	.word	0x200046ec

0000a7a0 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    a7a0:	b5f0      	push	{r4, r5, r6, r7, lr}
    a7a2:	4686      	mov	lr, r0
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    a7a4:	b672      	cpsid	i
    a7a6:	2202      	movs	r2, #2
    a7a8:	2301      	movs	r3, #1
void usb_rx_memory(usb_packet_t *packet)
{
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
    a7aa:	491c      	ldr	r1, [pc, #112]	; (a81c <usb_rx_memory+0x7c>)
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
    a7ac:	4f1c      	ldr	r7, [pc, #112]	; (a820 <usb_rx_memory+0x80>)
    a7ae:	e002      	b.n	a7b6 <usb_rx_memory+0x16>
    a7b0:	4629      	mov	r1, r5
    a7b2:	3301      	adds	r3, #1
    a7b4:	3201      	adds	r2, #1
	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
    a7b6:	2b07      	cmp	r3, #7
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    a7b8:	f101 0501 	add.w	r5, r1, #1
	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
    a7bc:	d0f9      	beq.n	a7b2 <usb_rx_memory+0x12>
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    a7be:	7809      	ldrb	r1, [r1, #0]
			if (table[index(i, RX, EVEN)].desc == 0) {
    a7c0:	4817      	ldr	r0, [pc, #92]	; (a820 <usb_rx_memory+0x80>)
    a7c2:	009c      	lsls	r4, r3, #2
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    a7c4:	0709      	lsls	r1, r1, #28
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    a7c6:	f044 0601 	orr.w	r6, r4, #1
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    a7ca:	d505      	bpl.n	a7d8 <usb_rx_memory+0x38>
			if (table[index(i, RX, EVEN)].desc == 0) {
    a7cc:	f857 1034 	ldr.w	r1, [r7, r4, lsl #3]
    a7d0:	b169      	cbz	r1, a7ee <usb_rx_memory+0x4e>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    a7d2:	f857 1036 	ldr.w	r1, [r7, r6, lsl #3]
    a7d6:	b1c1      	cbz	r1, a80a <usb_rx_memory+0x6a>
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    a7d8:	2a09      	cmp	r2, #9
    a7da:	d1e9      	bne.n	a7b0 <usb_rx_memory+0x10>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    a7dc:	b662      	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    a7de:	4b11      	ldr	r3, [pc, #68]	; (a824 <usb_rx_memory+0x84>)
    a7e0:	2200      	movs	r2, #0
    a7e2:	701a      	strb	r2, [r3, #0]
	usb_free(packet);
    a7e4:	4670      	mov	r0, lr
	return;
}
    a7e6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
    a7ea:	f000 be67 	b.w	b4bc <usb_free>
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    a7ee:	490d      	ldr	r1, [pc, #52]	; (a824 <usb_rx_memory+0x84>)
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    a7f0:	4d0d      	ldr	r5, [pc, #52]	; (a828 <usb_rx_memory+0x88>)
				usb_rx_memory_needed--;
    a7f2:	780a      	ldrb	r2, [r1, #0]
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    a7f4:	f840 5034 	str.w	r5, [r0, r4, lsl #3]
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    a7f8:	eb00 1343 	add.w	r3, r0, r3, lsl #5
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    a7fc:	f10e 0008 	add.w	r0, lr, #8
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    a800:	3a01      	subs	r2, #1
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    a802:	6058      	str	r0, [r3, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    a804:	700a      	strb	r2, [r1, #0]
				__enable_irq();
    a806:	b662      	cpsie	i
				//serial_phex(i);
				//serial_print(",odd\n");
				return;
    a808:	bdf0      	pop	{r4, r5, r6, r7, pc}
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    a80a:	4906      	ldr	r1, [pc, #24]	; (a824 <usb_rx_memory+0x84>)
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    a80c:	4b07      	ldr	r3, [pc, #28]	; (a82c <usb_rx_memory+0x8c>)
    a80e:	f840 3036 	str.w	r3, [r0, r6, lsl #3]
				usb_rx_memory_needed--;
    a812:	780a      	ldrb	r2, [r1, #0]
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    a814:	eb00 03c6 	add.w	r3, r0, r6, lsl #3
    a818:	e7f0      	b.n	a7fc <usb_rx_memory+0x5c>
    a81a:	bf00      	nop
    a81c:	0001250c 	.word	0x0001250c
    a820:	1fff8000 	.word	0x1fff8000
    a824:	20004735 	.word	0x20004735
    a828:	00400088 	.word	0x00400088
    a82c:	004000c8 	.word	0x004000c8

0000a830 <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    a830:	1e43      	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    a832:	2b07      	cmp	r3, #7
    a834:	d81d      	bhi.n	a872 <usb_tx+0x42>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    a836:	4a1b      	ldr	r2, [pc, #108]	; (a8a4 <usb_tx+0x74>)
    a838:	0140      	lsls	r0, r0, #5
    a83a:	f040 0010 	orr.w	r0, r0, #16

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
    a83e:	b430      	push	{r4, r5}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    a840:	4410      	add	r0, r2
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
	__disable_irq();
    a842:	b672      	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    a844:	4c18      	ldr	r4, [pc, #96]	; (a8a8 <usb_tx+0x78>)
    a846:	5ce2      	ldrb	r2, [r4, r3]
    a848:	2a03      	cmp	r2, #3
    a84a:	d81b      	bhi.n	a884 <usb_tx+0x54>
    a84c:	e8df f002 	tbb	[pc, r2]
    a850:	17151202 	.word	0x17151202
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    a854:	2203      	movs	r2, #3
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    a856:	880d      	ldrh	r5, [r1, #0]
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    a858:	54e2      	strb	r2, [r4, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    a85a:	f010 0f08 	tst.w	r0, #8
    a85e:	bf14      	ite	ne
    a860:	23c8      	movne	r3, #200	; 0xc8
    a862:	2388      	moveq	r3, #136	; 0x88
    a864:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    a868:	3108      	adds	r1, #8
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    a86a:	6003      	str	r3, [r0, #0]
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    a86c:	6041      	str	r1, [r0, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
	__enable_irq();
    a86e:	b662      	cpsie	i
}
    a870:	bc30      	pop	{r4, r5}
    a872:	4770      	bx	lr
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    a874:	3008      	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    a876:	2202      	movs	r2, #2
		break;
    a878:	e7ed      	b.n	a856 <usb_tx+0x26>
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    a87a:	2205      	movs	r2, #5
    a87c:	e7eb      	b.n	a856 <usb_tx+0x26>
		break;
	  case TX_STATE_ODD_FREE:
		b++;
    a87e:	3008      	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    a880:	2204      	movs	r2, #4
		break;
    a882:	e7e8      	b.n	a856 <usb_tx+0x26>
	  default:
		if (tx_first[endpoint] == NULL) {
    a884:	4a09      	ldr	r2, [pc, #36]	; (a8ac <usb_tx+0x7c>)
    a886:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    a88a:	b138      	cbz	r0, a89c <usb_tx+0x6c>
			tx_first[endpoint] = packet;
		} else {
			tx_last[endpoint]->next = packet;
    a88c:	4a08      	ldr	r2, [pc, #32]	; (a8b0 <usb_tx+0x80>)
    a88e:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    a892:	6041      	str	r1, [r0, #4]
		}
		tx_last[endpoint] = packet;
    a894:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		__enable_irq();
    a898:	b662      	cpsie	i
		return;
    a89a:	e7e9      	b.n	a870 <usb_tx+0x40>
		b++;
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
		break;
	  default:
		if (tx_first[endpoint] == NULL) {
			tx_first[endpoint] = packet;
    a89c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    a8a0:	4a03      	ldr	r2, [pc, #12]	; (a8b0 <usb_tx+0x80>)
    a8a2:	e7f7      	b.n	a894 <usb_tx+0x64>
    a8a4:	1fff8000 	.word	0x1fff8000
    a8a8:	20004744 	.word	0x20004744
    a8ac:	200046ec 	.word	0x200046ec
    a8b0:	2000470c 	.word	0x2000470c

0000a8b4 <usb_isr>:
}



void usb_isr(void)
{
    a8b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    a8b8:	f8df a344 	ldr.w	sl, [pc, #836]	; ac00 <usb_isr+0x34c>
		USB0_ISTAT = USB_ISTAT_SOFTOK;
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
		uint8_t endpoint;
		stat = USB0_STAT;
    a8bc:	f8df b344 	ldr.w	fp, [pc, #836]	; ac04 <usb_isr+0x350>
}



void usb_isr(void)
{
    a8c0:	b089      	sub	sp, #36	; 0x24
    a8c2:	e049      	b.n	a958 <usb_isr+0xa4>
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    a8c4:	f8df 8340 	ldr.w	r8, [pc, #832]	; ac08 <usb_isr+0x354>
    a8c8:	ea4f 0993 	mov.w	r9, r3, lsr #2
    a8cc:	eb08 07c9 	add.w	r7, r8, r9, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    a8d0:	3c01      	subs	r4, #1
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    a8d2:	687a      	ldr	r2, [r7, #4]
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    a8d4:	b2e4      	uxtb	r4, r4

#ifdef AUDIO_INTERFACE
			if ((endpoint == AUDIO_TX_ENDPOINT-1) && (stat & 0x08)) {
    a8d6:	2c05      	cmp	r4, #5
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    a8d8:	f1a2 0008 	sub.w	r0, r2, #8
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays

#ifdef AUDIO_INTERFACE
			if ((endpoint == AUDIO_TX_ENDPOINT-1) && (stat & 0x08)) {
    a8dc:	f000 8120 	beq.w	ab20 <usb_isr+0x26c>
					b = (bdt_t *)((uint32_t)b ^ 8);
					b->addr = usb_audio_transmit_buffer;
					b->desc = (len << 16) | BDT_OWN;
					tx_state[endpoint] ^= 1;
				}
			} else if ((endpoint == AUDIO_RX_ENDPOINT-1) && !(stat & 0x08)) {
    a8e0:	2c06      	cmp	r4, #6
    a8e2:	f000 813c 	beq.w	ab5e <usb_isr+0x2aa>
				usb_audio_receive_callback(b->desc >> 16);
				b->addr = usb_audio_receive_buffer;
				b->desc = (AUDIO_RX_SIZE << 16) | BDT_OWN;
			} else if ((endpoint == AUDIO_SYNC_ENDPOINT-1) && (stat & 0x08)) {
    a8e6:	2c07      	cmp	r4, #7
    a8e8:	f000 8151 	beq.w	ab8e <usb_isr+0x2da>
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    a8ec:	071e      	lsls	r6, r3, #28
    a8ee:	f100 8138 	bmi.w	ab62 <usb_isr+0x2ae>
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    a8f2:	f858 3039 	ldr.w	r3, [r8, r9, lsl #3]
    a8f6:	0c1b      	lsrs	r3, r3, #16
    a8f8:	b299      	uxth	r1, r3
    a8fa:	f822 1c08 	strh.w	r1, [r2, #-8]
				if (packet->len > 0) {
    a8fe:	2b00      	cmp	r3, #0
    a900:	f000 8124 	beq.w	ab4c <usb_isr+0x298>
					packet->index = 0;
					packet->next = NULL;
					if (rx_first[endpoint] == NULL) {
    a904:	4da9      	ldr	r5, [pc, #676]	; (abac <usb_isr+0x2f8>)
    a906:	f855 6024 	ldr.w	r6, [r5, r4, lsl #2]
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
				if (packet->len > 0) {
					packet->index = 0;
    a90a:	2300      	movs	r3, #0
    a90c:	f822 3c06 	strh.w	r3, [r2, #-6]
					packet->next = NULL;
    a910:	f842 3c04 	str.w	r3, [r2, #-4]
					if (rx_first[endpoint] == NULL) {
    a914:	2e00      	cmp	r6, #0
    a916:	f000 821b 	beq.w	ad50 <usb_isr+0x49c>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    a91a:	4ea5      	ldr	r6, [pc, #660]	; (abb0 <usb_isr+0x2fc>)
    a91c:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
    a920:	6058      	str	r0, [r3, #4]
					}
					rx_last[endpoint] = packet;
					usb_rx_byte_count_data[endpoint] += packet->len;
    a922:	4da4      	ldr	r5, [pc, #656]	; (abb4 <usb_isr+0x300>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
					}
					rx_last[endpoint] = packet;
    a924:	f846 0024 	str.w	r0, [r6, r4, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    a928:	f835 3014 	ldrh.w	r3, [r5, r4, lsl #1]
    a92c:	4419      	add	r1, r3
    a92e:	f825 1014 	strh.w	r1, [r5, r4, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    a932:	f000 fda3 	bl	b47c <usb_malloc>
					if (packet) {
    a936:	2800      	cmp	r0, #0
    a938:	f000 8203 	beq.w	ad42 <usb_isr+0x48e>
						b->addr = packet->buf;
						b->desc = BDT_DESC(64,
    a93c:	4a9e      	ldr	r2, [pc, #632]	; (abb8 <usb_isr+0x304>)
    a93e:	4b9f      	ldr	r3, [pc, #636]	; (abbc <usb_isr+0x308>)
    a940:	f017 0f08 	tst.w	r7, #8
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    a944:	f100 0008 	add.w	r0, r0, #8
						b->desc = BDT_DESC(64,
    a948:	bf18      	it	ne
    a94a:	4613      	movne	r3, r2
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    a94c:	6078      	str	r0, [r7, #4]
						b->desc = BDT_DESC(64,
    a94e:	f848 3039 	str.w	r3, [r8, r9, lsl #3]
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    a952:	2308      	movs	r3, #8
    a954:	f88a 3000 	strb.w	r3, [sl]
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    a958:	f89a 4000 	ldrb.w	r4, [sl]
    a95c:	b2e4      	uxtb	r4, r4

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    a95e:	0763      	lsls	r3, r4, #29
    a960:	d51c      	bpl.n	a99c <usb_isr+0xe8>
		if (usb_configuration) {
    a962:	4b97      	ldr	r3, [pc, #604]	; (abc0 <usb_isr+0x30c>)
    a964:	781b      	ldrb	r3, [r3, #0]
    a966:	b1b3      	cbz	r3, a996 <usb_isr+0xe2>
			t = usb_reboot_timer;
    a968:	4996      	ldr	r1, [pc, #600]	; (abc4 <usb_isr+0x310>)
    a96a:	780a      	ldrb	r2, [r1, #0]
			if (t) {
    a96c:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    a970:	b122      	cbz	r2, a97c <usb_isr+0xc8>
				usb_reboot_timer = --t;
    a972:	3b01      	subs	r3, #1
    a974:	b2db      	uxtb	r3, r3
    a976:	700b      	strb	r3, [r1, #0]
				if (!t) _reboot_Teensyduino_();
    a978:	b903      	cbnz	r3, a97c <usb_isr+0xc8>


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    a97a:	be00      	bkpt	0x0000
			if (t) {
				usb_reboot_timer = --t;
				if (!t) _reboot_Teensyduino_();
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    a97c:	4992      	ldr	r1, [pc, #584]	; (abc8 <usb_isr+0x314>)
    a97e:	780a      	ldrb	r2, [r1, #0]
			if (t) {
    a980:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    a984:	b12a      	cbz	r2, a992 <usb_isr+0xde>
				usb_cdc_transmit_flush_timer = --t;
    a986:	3b01      	subs	r3, #1
    a988:	b2db      	uxtb	r3, r3
    a98a:	700b      	strb	r3, [r1, #0]
				if (t == 0) usb_serial_flush_callback();
    a98c:	2b00      	cmp	r3, #0
    a98e:	f000 81ae 	beq.w	acee <usb_isr+0x43a>
				usb_seremu_transmit_flush_timer = --t;
				if (t == 0) usb_seremu_flush_callback();
			}
#endif
#ifdef MIDI_INTERFACE
                        usb_midi_flush_output();
    a992:	f000 fdb9 	bl	b508 <usb_midi_flush_output>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    a996:	2304      	movs	r3, #4
    a998:	f88a 3000 	strb.w	r3, [sl]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    a99c:	f004 0308 	and.w	r3, r4, #8
    a9a0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    a9a4:	2b00      	cmp	r3, #0
    a9a6:	f000 813e 	beq.w	ac26 <usb_isr+0x372>
		uint8_t endpoint;
		stat = USB0_STAT;
    a9aa:	f89b 3000 	ldrb.w	r3, [fp]
    a9ae:	b2db      	uxtb	r3, r3
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
    a9b0:	091c      	lsrs	r4, r3, #4
    a9b2:	d187      	bne.n	a8c4 <usb_isr+0x10>
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    a9b4:	089d      	lsrs	r5, r3, #2
    a9b6:	f8df 9250 	ldr.w	r9, [pc, #592]	; ac08 <usb_isr+0x354>
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    a9ba:	f859 2035 	ldr.w	r2, [r9, r5, lsl #3]
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    a9be:	eb09 01c5 	add.w	r1, r9, r5, lsl #3
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    a9c2:	f3c2 0283 	ubfx	r2, r2, #2, #4
    a9c6:	3a01      	subs	r2, #1
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
	//count = b->desc >> 16;
	buf = b->addr;
    a9c8:	6849      	ldr	r1, [r1, #4]
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    a9ca:	2a0c      	cmp	r2, #12
    a9cc:	d87c      	bhi.n	aac8 <usb_isr+0x214>
    a9ce:	e8df f002 	tbb	[pc, r2]
    a9d2:	7f7f      	.short	0x7f7f
    a9d4:	7b7b7b7b 	.word	0x7b7b7b7b
    a9d8:	7b4a7b7b 	.word	0x7b4a7b7b
    a9dc:	7b7b      	.short	0x7b7b
    a9de:	07          	.byte	0x07
    a9df:	00          	.byte	0x00
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    a9e0:	680a      	ldr	r2, [r1, #0]
		setup.word2 = *(uint32_t *)(buf + 4);
    a9e2:	4e7a      	ldr	r6, [pc, #488]	; (abcc <usb_isr+0x318>)
    a9e4:	6849      	ldr	r1, [r1, #4]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    a9e6:	4b7a      	ldr	r3, [pc, #488]	; (abd0 <usb_isr+0x31c>)
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    a9e8:	4873      	ldr	r0, [pc, #460]	; (abb8 <usb_isr+0x304>)
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    a9ea:	4c7a      	ldr	r4, [pc, #488]	; (abd4 <usb_isr+0x320>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    a9ec:	6071      	str	r1, [r6, #4]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    a9ee:	b291      	uxth	r1, r2
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    a9f0:	f849 0035 	str.w	r0, [r9, r5, lsl #3]
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    a9f4:	6032      	str	r2, [r6, #0]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    a9f6:	2001      	movs	r0, #1
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    a9f8:	2200      	movs	r2, #0
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    a9fa:	f5b1 6f08 	cmp.w	r1, #2176	; 0x880
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    a9fe:	9301      	str	r3, [sp, #4]
    aa00:	601a      	str	r2, [r3, #0]
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    aa02:	f8c9 2010 	str.w	r2, [r9, #16]
		table[index(0, TX, ODD)].desc = 0;
    aa06:	f8c9 2018 	str.w	r2, [r9, #24]
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    aa0a:	9207      	str	r2, [sp, #28]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    aa0c:	7020      	strb	r0, [r4, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    aa0e:	f000 834e 	beq.w	b0ae <usb_isr+0x7fa>
    aa12:	f240 8129 	bls.w	ac68 <usb_isr+0x3b4>
    aa16:	f242 3521 	movw	r5, #8993	; 0x2321
    aa1a:	42a9      	cmp	r1, r5
    aa1c:	f000 82fa 	beq.w	b014 <usb_isr+0x760>
    aa20:	f200 8248 	bhi.w	aeb4 <usb_isr+0x600>
    aa24:	f640 3201 	movw	r2, #2817	; 0xb01
    aa28:	4291      	cmp	r1, r2
    aa2a:	f000 82ca 	beq.w	afc2 <usb_isr+0x70e>
    aa2e:	f200 829f 	bhi.w	af70 <usb_isr+0x6bc>
    aa32:	f5b1 6f10 	cmp.w	r1, #2304	; 0x900
    aa36:	f000 835d 	beq.w	b0f4 <usb_isr+0x840>
    aa3a:	f640 2281 	movw	r2, #2689	; 0xa81
    aa3e:	4291      	cmp	r1, r2
    aa40:	f040 8204 	bne.w	ae4c <usb_isr+0x598>
		}
		break;
	  case 0x0A81: // GET_INTERFACE (alternate setting)
		datalen = 1;
		data = reply_buffer;
		if (setup.wIndex == AUDIO_INTERFACE+1) {
    aa44:	4b61      	ldr	r3, [pc, #388]	; (abcc <usb_isr+0x318>)
			endpoint0_stall();
			return;
		}
		break;
	  case 0x0A81: // GET_INTERFACE (alternate setting)
		datalen = 1;
    aa46:	9007      	str	r0, [sp, #28]
		data = reply_buffer;
		if (setup.wIndex == AUDIO_INTERFACE+1) {
    aa48:	889a      	ldrh	r2, [r3, #4]
    aa4a:	2a04      	cmp	r2, #4
    aa4c:	f000 8439 	beq.w	b2c2 <usb_isr+0xa0e>
			reply_buffer[0] = usb_audio_transmit_setting;
		} else if (setup.wIndex == AUDIO_INTERFACE+2) {
    aa50:	2a05      	cmp	r2, #5
    aa52:	f040 81fb 	bne.w	ae4c <usb_isr+0x598>
			reply_buffer[0] = usb_audio_receive_setting;
    aa56:	4a60      	ldr	r2, [pc, #384]	; (abd8 <usb_isr+0x324>)
    aa58:	4960      	ldr	r1, [pc, #384]	; (abdc <usb_isr+0x328>)
    aa5a:	4b5c      	ldr	r3, [pc, #368]	; (abcc <usb_isr+0x318>)
    aa5c:	7812      	ldrb	r2, [r2, #0]
    aa5e:	88df      	ldrh	r7, [r3, #6]
    aa60:	700a      	strb	r2, [r1, #0]
    aa62:	2001      	movs	r0, #1
    aa64:	e242      	b.n	aeec <usb_isr+0x638>
		//serial_print("PID=IN:");
		//serial_phex(stat);
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
    aa66:	4b5a      	ldr	r3, [pc, #360]	; (abd0 <usb_isr+0x31c>)
    aa68:	9301      	str	r3, [sp, #4]
    aa6a:	6819      	ldr	r1, [r3, #0]
		if (data) {
    aa6c:	b331      	cbz	r1, aabc <usb_isr+0x208>
			size = ep0_tx_len;
    aa6e:	4b5c      	ldr	r3, [pc, #368]	; (abe0 <usb_isr+0x32c>)
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    aa70:	4c58      	ldr	r4, [pc, #352]	; (abd4 <usb_isr+0x320>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    aa72:	4a5c      	ldr	r2, [pc, #368]	; (abe4 <usb_isr+0x330>)
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
    aa74:	8818      	ldrh	r0, [r3, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    aa76:	7825      	ldrb	r5, [r4, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    aa78:	7816      	ldrb	r6, [r2, #0]
    aa7a:	2840      	cmp	r0, #64	; 0x40
    aa7c:	4607      	mov	r7, r0
    aa7e:	f046 0c02 	orr.w	ip, r6, #2
    aa82:	bf28      	it	cs
    aa84:	2740      	movcs	r7, #64	; 0x40
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    aa86:	2d00      	cmp	r5, #0
	ep0_tx_data_toggle ^= 1;
    aa88:	f085 0501 	eor.w	r5, r5, #1
    aa8c:	7025      	strb	r5, [r4, #0]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    aa8e:	eba0 0007 	sub.w	r0, r0, r7
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    aa92:	bf0c      	ite	eq
    aa94:	2488      	moveq	r4, #136	; 0x88
    aa96:	24c8      	movne	r4, #200	; 0xc8
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    aa98:	eb09 05cc 	add.w	r5, r9, ip, lsl #3
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    aa9c:	b280      	uxth	r0, r0
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    aa9e:	f086 0601 	eor.w	r6, r6, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    aaa2:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    aaa6:	6069      	str	r1, [r5, #4]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    aaa8:	8018      	strh	r0, [r3, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    aaaa:	f849 403c 	str.w	r4, [r9, ip, lsl #3]
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    aaae:	4439      	add	r1, r7
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    aab0:	7016      	strb	r6, [r2, #0]
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    aab2:	2800      	cmp	r0, #0
    aab4:	f000 810e 	beq.w	acd4 <usb_isr+0x420>
    aab8:	9b01      	ldr	r3, [sp, #4]
    aaba:	6019      	str	r1, [r3, #0]
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    aabc:	4b43      	ldr	r3, [pc, #268]	; (abcc <usb_isr+0x318>)
    aabe:	881a      	ldrh	r2, [r3, #0]
    aac0:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
    aac4:	f000 810a 	beq.w	acdc <usb_isr+0x428>
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    aac8:	4a47      	ldr	r2, [pc, #284]	; (abe8 <usb_isr+0x334>)
    aaca:	2301      	movs	r3, #1
    aacc:	7013      	strb	r3, [r2, #0]
    aace:	e740      	b.n	a952 <usb_isr+0x9e>
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
#ifdef CDC_STATUS_INTERFACE
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    aad0:	4a3e      	ldr	r2, [pc, #248]	; (abcc <usb_isr+0x318>)
    aad2:	8810      	ldrh	r0, [r2, #0]
    aad4:	f242 0221 	movw	r2, #8225	; 0x2021
    aad8:	4290      	cmp	r0, r2
    aada:	f000 814d 	beq.w	ad78 <usb_isr+0x4c4>
			usb_reboot_timer = 5;
			endpoint0_transmit(NULL, 0);
		}
#endif
#ifdef AUDIO_INTERFACE
		if (usb_audio_set_feature(&setup, buf)) {
    aade:	483b      	ldr	r0, [pc, #236]	; (abcc <usb_isr+0x318>)
    aae0:	f7ff fe0a 	bl	a6f8 <usb_audio_set_feature>
    aae4:	b1a8      	cbz	r0, ab12 <usb_isr+0x25e>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    aae6:	4a3f      	ldr	r2, [pc, #252]	; (abe4 <usb_isr+0x330>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    aae8:	4c3a      	ldr	r4, [pc, #232]	; (abd4 <usb_isr+0x320>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    aaea:	7811      	ldrb	r1, [r2, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    aaec:	7820      	ldrb	r0, [r4, #0]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    aaee:	f081 0601 	eor.w	r6, r1, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    aaf2:	2800      	cmp	r0, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    aaf4:	f041 0102 	orr.w	r1, r1, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    aaf8:	7016      	strb	r6, [r2, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    aafa:	bf0c      	ite	eq
    aafc:	2288      	moveq	r2, #136	; 0x88
    aafe:	22c8      	movne	r2, #200	; 0xc8
    ab00:	f849 2031 	str.w	r2, [r9, r1, lsl #3]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    ab04:	eb09 01c1 	add.w	r1, r9, r1, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    ab08:	f080 0001 	eor.w	r0, r0, #1
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    ab0c:	2200      	movs	r2, #0
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    ab0e:	7020      	strb	r0, [r4, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    ab10:	604a      	str	r2, [r1, #4]
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    ab12:	4a29      	ldr	r2, [pc, #164]	; (abb8 <usb_isr+0x304>)
    ab14:	f849 2035 	str.w	r2, [r9, r5, lsl #3]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    ab18:	4a33      	ldr	r2, [pc, #204]	; (abe8 <usb_isr+0x334>)
    ab1a:	2301      	movs	r3, #1
    ab1c:	7013      	strb	r3, [r2, #0]
    ab1e:	e718      	b.n	a952 <usb_isr+0x9e>
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays

#ifdef AUDIO_INTERFACE
			if ((endpoint == AUDIO_TX_ENDPOINT-1) && (stat & 0x08)) {
    ab20:	0719      	lsls	r1, r3, #28
    ab22:	f57f aee6 	bpl.w	a8f2 <usb_isr+0x3e>
				unsigned int len;
				len = usb_audio_transmit_callback();
    ab26:	f7ff fd39 	bl	a59c <usb_audio_transmit_callback>
				if (len > 0) {
    ab2a:	2800      	cmp	r0, #0
    ab2c:	f43f af11 	beq.w	a952 <usb_isr+0x9e>
					b = (bdt_t *)((uint32_t)b ^ 8);
    ab30:	f087 0708 	eor.w	r7, r7, #8
					b->addr = usb_audio_transmit_buffer;
					b->desc = (len << 16) | BDT_OWN;
    ab34:	0400      	lsls	r0, r0, #16
			if ((endpoint == AUDIO_TX_ENDPOINT-1) && (stat & 0x08)) {
				unsigned int len;
				len = usb_audio_transmit_callback();
				if (len > 0) {
					b = (bdt_t *)((uint32_t)b ^ 8);
					b->addr = usb_audio_transmit_buffer;
    ab36:	4b2d      	ldr	r3, [pc, #180]	; (abec <usb_isr+0x338>)
					b->desc = (len << 16) | BDT_OWN;
					tx_state[endpoint] ^= 1;
    ab38:	4a2d      	ldr	r2, [pc, #180]	; (abf0 <usb_isr+0x33c>)
			if ((endpoint == AUDIO_TX_ENDPOINT-1) && (stat & 0x08)) {
				unsigned int len;
				len = usb_audio_transmit_callback();
				if (len > 0) {
					b = (bdt_t *)((uint32_t)b ^ 8);
					b->addr = usb_audio_transmit_buffer;
    ab3a:	607b      	str	r3, [r7, #4]
					b->desc = (len << 16) | BDT_OWN;
    ab3c:	f040 0080 	orr.w	r0, r0, #128	; 0x80
    ab40:	6038      	str	r0, [r7, #0]
					tx_state[endpoint] ^= 1;
    ab42:	7953      	ldrb	r3, [r2, #5]
    ab44:	f083 0301 	eor.w	r3, r3, #1
    ab48:	7153      	strb	r3, [r2, #5]
    ab4a:	e702      	b.n	a952 <usb_isr+0x9e>
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    ab4c:	4a1a      	ldr	r2, [pc, #104]	; (abb8 <usb_isr+0x304>)
    ab4e:	4b1b      	ldr	r3, [pc, #108]	; (abbc <usb_isr+0x308>)
    ab50:	f017 0f08 	tst.w	r7, #8
    ab54:	bf18      	it	ne
    ab56:	4613      	movne	r3, r2
    ab58:	f848 3039 	str.w	r3, [r8, r9, lsl #3]
    ab5c:	e6f9      	b.n	a952 <usb_isr+0x9e>
					b = (bdt_t *)((uint32_t)b ^ 8);
					b->addr = usb_audio_transmit_buffer;
					b->desc = (len << 16) | BDT_OWN;
					tx_state[endpoint] ^= 1;
				}
			} else if ((endpoint == AUDIO_RX_ENDPOINT-1) && !(stat & 0x08)) {
    ab5e:	071b      	lsls	r3, r3, #28
    ab60:	d577      	bpl.n	ac52 <usb_isr+0x39e>
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
    ab62:	f000 fcab 	bl	b4bc <usb_free>
				packet = tx_first[endpoint];
    ab66:	4a23      	ldr	r2, [pc, #140]	; (abf4 <usb_isr+0x340>)
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    ab68:	4d21      	ldr	r5, [pc, #132]	; (abf0 <usb_isr+0x33c>)
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
    ab6a:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
				if (packet) {
    ab6e:	2b00      	cmp	r3, #0
    ab70:	f000 80f2 	beq.w	ad58 <usb_isr+0x4a4>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    ab74:	6859      	ldr	r1, [r3, #4]
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    ab76:	5d28      	ldrb	r0, [r5, r4]
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    ab78:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
					b->addr = packet->buf;
    ab7c:	f103 0208 	add.w	r2, r3, #8
    ab80:	607a      	str	r2, [r7, #4]
					switch (tx_state[endpoint]) {
    ab82:	2803      	cmp	r0, #3
    ab84:	d844      	bhi.n	ac10 <usb_isr+0x35c>
    ab86:	e8df f000 	tbb	[pc, r0]
    ab8a:	41a2      	.short	0x41a2
    ab8c:	9c9f      	.short	0x9c9f
				}
			} else if ((endpoint == AUDIO_RX_ENDPOINT-1) && !(stat & 0x08)) {
				usb_audio_receive_callback(b->desc >> 16);
				b->addr = usb_audio_receive_buffer;
				b->desc = (AUDIO_RX_SIZE << 16) | BDT_OWN;
			} else if ((endpoint == AUDIO_SYNC_ENDPOINT-1) && (stat & 0x08)) {
    ab8e:	071d      	lsls	r5, r3, #28
    ab90:	f57f aeaf 	bpl.w	a8f2 <usb_isr+0x3e>
				b = (bdt_t *)((uint32_t)b ^ 8);
    ab94:	f087 0708 	eor.w	r7, r7, #8
				b->addr = &usb_audio_sync_feedback;
    ab98:	4a17      	ldr	r2, [pc, #92]	; (abf8 <usb_isr+0x344>)
    ab9a:	607a      	str	r2, [r7, #4]
				b->desc = (3 << 16) | BDT_OWN;
    ab9c:	4b17      	ldr	r3, [pc, #92]	; (abfc <usb_isr+0x348>)
				tx_state[endpoint] ^= 1;
    ab9e:	4a14      	ldr	r2, [pc, #80]	; (abf0 <usb_isr+0x33c>)
				b->addr = usb_audio_receive_buffer;
				b->desc = (AUDIO_RX_SIZE << 16) | BDT_OWN;
			} else if ((endpoint == AUDIO_SYNC_ENDPOINT-1) && (stat & 0x08)) {
				b = (bdt_t *)((uint32_t)b ^ 8);
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
    aba0:	603b      	str	r3, [r7, #0]
				tx_state[endpoint] ^= 1;
    aba2:	79d3      	ldrb	r3, [r2, #7]
    aba4:	f083 0301 	eor.w	r3, r3, #1
    aba8:	71d3      	strb	r3, [r2, #7]
    abaa:	e6d2      	b.n	a952 <usb_isr+0x9e>
    abac:	20004688 	.word	0x20004688
    abb0:	20004624 	.word	0x20004624
    abb4:	20004928 	.word	0x20004928
    abb8:	004000c8 	.word	0x004000c8
    abbc:	00400088 	.word	0x00400088
    abc0:	20004740 	.word	0x20004740
    abc4:	200046a9 	.word	0x200046a9
    abc8:	20004754 	.word	0x20004754
    abcc:	2000472c 	.word	0x2000472c
    abd0:	20004620 	.word	0x20004620
    abd4:	200046a8 	.word	0x200046a8
    abd8:	200045f7 	.word	0x200045f7
    abdc:	20004738 	.word	0x20004738
    abe0:	20004644 	.word	0x20004644
    abe4:	20004734 	.word	0x20004734
    abe8:	40072094 	.word	0x40072094
    abec:	1fffae74 	.word	0x1fffae74
    abf0:	20004744 	.word	0x20004744
    abf4:	200046ec 	.word	0x200046ec
    abf8:	1fffadbc 	.word	0x1fffadbc
    abfc:	00030080 	.word	0x00030080
    ac00:	40072080 	.word	0x40072080
    ac04:	40072090 	.word	0x40072090
    ac08:	1fff8000 	.word	0x1fff8000
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    ac0c:	2202      	movs	r2, #2
    ac0e:	552a      	strb	r2, [r5, r4]
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
						break;
					  default:
						break;
					}
					b->desc = BDT_DESC(packet->len,
    ac10:	881a      	ldrh	r2, [r3, #0]
    ac12:	f017 0f08 	tst.w	r7, #8
    ac16:	bf0c      	ite	eq
    ac18:	2388      	moveq	r3, #136	; 0x88
    ac1a:	23c8      	movne	r3, #200	; 0xc8
    ac1c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    ac20:	f848 3039 	str.w	r3, [r8, r9, lsl #3]
    ac24:	e695      	b.n	a952 <usb_isr+0x9e>
		goto restart;
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    ac26:	07e0      	lsls	r0, r4, #31
    ac28:	d464      	bmi.n	acf4 <usb_isr+0x440>
		USB0_CTL = USB_CTL_USBENSOFEN;
		return;
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    ac2a:	0621      	lsls	r1, r4, #24
    ac2c:	f100 80cf 	bmi.w	adce <usb_isr+0x51a>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    ac30:	07a2      	lsls	r2, r4, #30
    ac32:	d506      	bpl.n	ac42 <usb_isr+0x38e>
		uint8_t err = USB0_ERRSTAT;
    ac34:	4a8a      	ldr	r2, [pc, #552]	; (ae60 <usb_isr+0x5ac>)
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    ac36:	498b      	ldr	r1, [pc, #556]	; (ae64 <usb_isr+0x5b0>)
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    ac38:	7813      	ldrb	r3, [r2, #0]
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    ac3a:	2002      	movs	r0, #2
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    ac3c:	b2db      	uxtb	r3, r3
		USB0_ERRSTAT = err;
    ac3e:	7013      	strb	r3, [r2, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    ac40:	7008      	strb	r0, [r1, #0]
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    ac42:	06e3      	lsls	r3, r4, #27
    ac44:	d502      	bpl.n	ac4c <usb_isr+0x398>
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    ac46:	4b87      	ldr	r3, [pc, #540]	; (ae64 <usb_isr+0x5b0>)
    ac48:	2210      	movs	r2, #16
    ac4a:	701a      	strb	r2, [r3, #0]
	}

}
    ac4c:	b009      	add	sp, #36	; 0x24
    ac4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					b->addr = usb_audio_transmit_buffer;
					b->desc = (len << 16) | BDT_OWN;
					tx_state[endpoint] ^= 1;
				}
			} else if ((endpoint == AUDIO_RX_ENDPOINT-1) && !(stat & 0x08)) {
				usb_audio_receive_callback(b->desc >> 16);
    ac52:	f858 0039 	ldr.w	r0, [r8, r9, lsl #3]
    ac56:	0c00      	lsrs	r0, r0, #16
    ac58:	f7ff fbe0 	bl	a41c <usb_audio_receive_callback>
				b->addr = usb_audio_receive_buffer;
    ac5c:	4a82      	ldr	r2, [pc, #520]	; (ae68 <usb_isr+0x5b4>)
				b->desc = (AUDIO_RX_SIZE << 16) | BDT_OWN;
    ac5e:	4b83      	ldr	r3, [pc, #524]	; (ae6c <usb_isr+0x5b8>)
					b->desc = (len << 16) | BDT_OWN;
					tx_state[endpoint] ^= 1;
				}
			} else if ((endpoint == AUDIO_RX_ENDPOINT-1) && !(stat & 0x08)) {
				usb_audio_receive_callback(b->desc >> 16);
				b->addr = usb_audio_receive_buffer;
    ac60:	607a      	str	r2, [r7, #4]
				b->desc = (AUDIO_RX_SIZE << 16) | BDT_OWN;
    ac62:	f848 3039 	str.w	r3, [r8, r9, lsl #3]
    ac66:	e674      	b.n	a952 <usb_isr+0x9e>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    ac68:	f240 3002 	movw	r0, #770	; 0x302
    ac6c:	4281      	cmp	r1, r0
    ac6e:	f000 8226 	beq.w	b0be <usb_isr+0x80a>
    ac72:	f200 80b6 	bhi.w	ade2 <usb_isr+0x52e>
    ac76:	f5b1 7f81 	cmp.w	r1, #258	; 0x102
    ac7a:	f000 8205 	beq.w	b088 <usb_isr+0x7d4>
    ac7e:	f200 80dd 	bhi.w	ae3c <usb_isr+0x588>
    ac82:	2980      	cmp	r1, #128	; 0x80
    ac84:	f000 822e 	beq.w	b0e4 <usb_isr+0x830>
    ac88:	2982      	cmp	r1, #130	; 0x82
    ac8a:	f040 80df 	bne.w	ae4c <usb_isr+0x598>
    ac8e:	4b78      	ldr	r3, [pc, #480]	; (ae70 <usb_isr+0x5bc>)
    ac90:	8899      	ldrh	r1, [r3, #4]
    ac92:	f001 017f 	and.w	r1, r1, #127	; 0x7f
		datalen = 2;
		data = reply_buffer;
		break;
	  case 0x0082: // GET_STATUS (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS) {
    ac96:	2908      	cmp	r1, #8
    ac98:	f200 80d8 	bhi.w	ae4c <usb_isr+0x598>
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    ac9c:	4875      	ldr	r0, [pc, #468]	; (ae74 <usb_isr+0x5c0>)
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    ac9e:	4d76      	ldr	r5, [pc, #472]	; (ae78 <usb_isr+0x5c4>)
    aca0:	4b73      	ldr	r3, [pc, #460]	; (ae70 <usb_isr+0x5bc>)
    aca2:	702a      	strb	r2, [r5, #0]
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    aca4:	0089      	lsls	r1, r1, #2
    aca6:	4408      	add	r0, r1
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
    aca8:	706a      	strb	r2, [r5, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    acaa:	7802      	ldrb	r2, [r0, #0]
    acac:	88df      	ldrh	r7, [r3, #6]
		data = reply_buffer;
    acae:	4972      	ldr	r1, [pc, #456]	; (ae78 <usb_isr+0x5c4>)
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    acb0:	0790      	lsls	r0, r2, #30
    acb2:	bf48      	it	mi
    acb4:	2201      	movmi	r2, #1
		data = reply_buffer;
		datalen = 2;
    acb6:	f04f 0002 	mov.w	r0, #2
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    acba:	bf48      	it	mi
    acbc:	702a      	strbmi	r2, [r5, #0]
		data = reply_buffer;
		datalen = 2;
    acbe:	9007      	str	r0, [sp, #28]
    acc0:	e114      	b.n	aeec <usb_isr+0x638>
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    acc2:	2204      	movs	r2, #4
    acc4:	552a      	strb	r2, [r5, r4]
						break;
    acc6:	e7a3      	b.n	ac10 <usb_isr+0x35c>
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    acc8:	2205      	movs	r2, #5
    acca:	552a      	strb	r2, [r5, r4]
						break;
    accc:	e7a0      	b.n	ac10 <usb_isr+0x35c>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    acce:	2203      	movs	r2, #3
    acd0:	552a      	strb	r2, [r5, r4]
						break;
    acd2:	e79d      	b.n	ac10 <usb_isr+0x35c>
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    acd4:	2f40      	cmp	r7, #64	; 0x40
    acd6:	bf18      	it	ne
    acd8:	2100      	movne	r1, #0
    acda:	e6ed      	b.n	aab8 <usb_isr+0x204>
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
			setup.bRequest = 0;
    acdc:	2100      	movs	r1, #0
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    acde:	789a      	ldrb	r2, [r3, #2]
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
			setup.bRequest = 0;
    ace0:	7059      	strb	r1, [r3, #1]
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    ace2:	4b66      	ldr	r3, [pc, #408]	; (ae7c <usb_isr+0x5c8>)
    ace4:	701a      	strb	r2, [r3, #0]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    ace6:	4a66      	ldr	r2, [pc, #408]	; (ae80 <usb_isr+0x5cc>)
    ace8:	2301      	movs	r3, #1
    acea:	7013      	strb	r3, [r2, #0]
    acec:	e631      	b.n	a952 <usb_isr+0x9e>
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
			if (t) {
				usb_cdc_transmit_flush_timer = --t;
				if (t == 0) usb_serial_flush_callback();
    acee:	f000 fd67 	bl	b7c0 <usb_serial_flush_callback>
    acf2:	e64e      	b.n	a992 <usb_isr+0xde>
		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    acf4:	4b63      	ldr	r3, [pc, #396]	; (ae84 <usb_isr+0x5d0>)

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    acf6:	4862      	ldr	r0, [pc, #392]	; (ae80 <usb_isr+0x5cc>)
		ep0_tx_bdt_bank = 0;
    acf8:	4963      	ldr	r1, [pc, #396]	; (ae88 <usb_isr+0x5d4>)
		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
    acfa:	611a      	str	r2, [r3, #16]

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    acfc:	f04f 0e02 	mov.w	lr, #2
    ad00:	f880 e000 	strb.w	lr, [r0]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    ad04:	4f5b      	ldr	r7, [pc, #364]	; (ae74 <usb_isr+0x5c0>)
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    ad06:	700a      	strb	r2, [r1, #0]

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    ad08:	4960      	ldr	r1, [pc, #384]	; (ae8c <usb_isr+0x5d8>)
    ad0a:	6019      	str	r1, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    ad0c:	6099      	str	r1, [r3, #8]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    ad0e:	4e54      	ldr	r6, [pc, #336]	; (ae60 <usb_isr+0x5ac>)
		USB0_ISTAT = 0xFF;
    ad10:	4d54      	ldr	r5, [pc, #336]	; (ae64 <usb_isr+0x5b0>)

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    ad12:	4c5a      	ldr	r4, [pc, #360]	; (ae7c <usb_isr+0x5c8>)
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
    ad14:	619a      	str	r2, [r3, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    ad16:	210d      	movs	r1, #13
    ad18:	7039      	strb	r1, [r7, #0]

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    ad1a:	21ff      	movs	r1, #255	; 0xff
    ad1c:	7031      	strb	r1, [r6, #0]

		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
    ad1e:	f8df e190 	ldr.w	lr, [pc, #400]	; aeb0 <usb_isr+0x5fc>
		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
		USB0_ISTAT = 0xFF;
    ad22:	7029      	strb	r1, [r5, #0]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    ad24:	7022      	strb	r2, [r4, #0]
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    ad26:	4d5a      	ldr	r5, [pc, #360]	; (ae90 <usb_isr+0x5dc>)
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    ad28:	4a5a      	ldr	r2, [pc, #360]	; (ae94 <usb_isr+0x5e0>)

		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
    ad2a:	f88e 1000 	strb.w	r1, [lr]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    ad2e:	279f      	movs	r7, #159	; 0x9f
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    ad30:	2401      	movs	r4, #1
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    ad32:	f806 7c04 	strb.w	r7, [r6, #-4]
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    ad36:	605d      	str	r5, [r3, #4]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    ad38:	7004      	strb	r4, [r0, #0]

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    ad3a:	60da      	str	r2, [r3, #12]
	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
	}

}
    ad3c:	b009      	add	sp, #36	; 0x24
    ad3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
    ad42:	4a55      	ldr	r2, [pc, #340]	; (ae98 <usb_isr+0x5e4>)
						b->desc = BDT_DESC(64,
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
    ad44:	f848 0039 	str.w	r0, [r8, r9, lsl #3]
						usb_rx_memory_needed++;
    ad48:	7813      	ldrb	r3, [r2, #0]
    ad4a:	3301      	adds	r3, #1
    ad4c:	7013      	strb	r3, [r2, #0]
    ad4e:	e600      	b.n	a952 <usb_isr+0x9e>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[endpoint] = packet;
    ad50:	f845 0024 	str.w	r0, [r5, r4, lsl #2]
    ad54:	4e51      	ldr	r6, [pc, #324]	; (ae9c <usb_isr+0x5e8>)
    ad56:	e5e4      	b.n	a922 <usb_isr+0x6e>
					}
					b->desc = BDT_DESC(packet->len,
						((uint32_t)b & 8) ? DATA1 : DATA0);
				} else {
					//serial_print("tx no packet\n");
					switch (tx_state[endpoint]) {
    ad58:	5d2b      	ldrb	r3, [r5, r4]
    ad5a:	2b03      	cmp	r3, #3
    ad5c:	f200 812a 	bhi.w	afb4 <usb_isr+0x700>
    ad60:	a201      	add	r2, pc, #4	; (adr r2, ad68 <usb_isr+0x4b4>)
    ad62:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    ad66:	bf00      	nop
    ad68:	0000a953 	.word	0x0000a953
    ad6c:	0000a953 	.word	0x0000a953
    ad70:	0000ae2f 	.word	0x0000ae2f
    ad74:	0000ae29 	.word	0x0000ae29
			int i;
			uint8_t *dst = (uint8_t *)usb_cdc_line_coding;
			//serial_print("set line coding ");
			for (i=0; i<7; i++) {
				//serial_phex(*buf);
				*dst++ = *buf++;
    ad78:	4a49      	ldr	r2, [pc, #292]	; (aea0 <usb_isr+0x5ec>)
    ad7a:	780c      	ldrb	r4, [r1, #0]
    ad7c:	7848      	ldrb	r0, [r1, #1]
    ad7e:	7014      	strb	r4, [r2, #0]
    ad80:	7050      	strb	r0, [r2, #1]
    ad82:	788c      	ldrb	r4, [r1, #2]
    ad84:	78c8      	ldrb	r0, [r1, #3]
    ad86:	7094      	strb	r4, [r2, #2]
    ad88:	70d0      	strb	r0, [r2, #3]
    ad8a:	790c      	ldrb	r4, [r1, #4]
			}
			//serial_phex32(usb_cdc_line_coding[0]);
			//serial_print("\n");
			if (usb_cdc_line_coding[0] == 134) usb_reboot_timer = 15;
    ad8c:	6810      	ldr	r0, [r2, #0]
			int i;
			uint8_t *dst = (uint8_t *)usb_cdc_line_coding;
			//serial_print("set line coding ");
			for (i=0; i<7; i++) {
				//serial_phex(*buf);
				*dst++ = *buf++;
    ad8e:	7114      	strb	r4, [r2, #4]
    ad90:	794c      	ldrb	r4, [r1, #5]
    ad92:	7154      	strb	r4, [r2, #5]
			}
			//serial_phex32(usb_cdc_line_coding[0]);
			//serial_print("\n");
			if (usb_cdc_line_coding[0] == 134) usb_reboot_timer = 15;
    ad94:	2886      	cmp	r0, #134	; 0x86
			int i;
			uint8_t *dst = (uint8_t *)usb_cdc_line_coding;
			//serial_print("set line coding ");
			for (i=0; i<7; i++) {
				//serial_phex(*buf);
				*dst++ = *buf++;
    ad96:	798c      	ldrb	r4, [r1, #6]
    ad98:	7194      	strb	r4, [r2, #6]
    ad9a:	f101 0107 	add.w	r1, r1, #7
			}
			//serial_phex32(usb_cdc_line_coding[0]);
			//serial_print("\n");
			if (usb_cdc_line_coding[0] == 134) usb_reboot_timer = 15;
    ad9e:	d049      	beq.n	ae34 <usb_isr+0x580>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    ada0:	4a39      	ldr	r2, [pc, #228]	; (ae88 <usb_isr+0x5d4>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    ada2:	4c40      	ldr	r4, [pc, #256]	; (aea4 <usb_isr+0x5f0>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    ada4:	7810      	ldrb	r0, [r2, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    ada6:	7826      	ldrb	r6, [r4, #0]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    ada8:	f080 0701 	eor.w	r7, r0, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    adac:	2e00      	cmp	r6, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    adae:	f040 0002 	orr.w	r0, r0, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    adb2:	7017      	strb	r7, [r2, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    adb4:	bf0c      	ite	eq
    adb6:	2288      	moveq	r2, #136	; 0x88
    adb8:	22c8      	movne	r2, #200	; 0xc8
    adba:	f849 2030 	str.w	r2, [r9, r0, lsl #3]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    adbe:	eb09 00c0 	add.w	r0, r9, r0, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    adc2:	f086 0601 	eor.w	r6, r6, #1
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    adc6:	2200      	movs	r2, #0
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    adc8:	7026      	strb	r6, [r4, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    adca:	6042      	str	r2, [r0, #4]
    adcc:	e687      	b.n	aade <usb_isr+0x22a>
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    adce:	4929      	ldr	r1, [pc, #164]	; (ae74 <usb_isr+0x5c0>)
		USB0_ISTAT = USB_ISTAT_STALL;
    add0:	4b24      	ldr	r3, [pc, #144]	; (ae64 <usb_isr+0x5b0>)
    add2:	2280      	movs	r2, #128	; 0x80
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    add4:	200d      	movs	r0, #13
    add6:	7008      	strb	r0, [r1, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    add8:	701a      	strb	r2, [r3, #0]
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    adda:	07a2      	lsls	r2, r4, #30
    addc:	f57f af31 	bpl.w	ac42 <usb_isr+0x38e>
    ade0:	e728      	b.n	ac34 <usb_isr+0x380>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    ade2:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
    ade6:	f000 8115 	beq.w	b014 <usb_isr+0x760>
    adea:	f240 824e 	bls.w	b28a <usb_isr+0x9d6>
    adee:	f5a1 61d0 	sub.w	r1, r1, #1664	; 0x680
    adf2:	2901      	cmp	r1, #1
    adf4:	d82a      	bhi.n	ae4c <usb_isr+0x598>
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
    adf6:	4a2c      	ldr	r2, [pc, #176]	; (aea8 <usb_isr+0x5f4>)
    adf8:	6851      	ldr	r1, [r2, #4]
    adfa:	b339      	cbz	r1, ae4c <usb_isr+0x598>
    adfc:	4b1c      	ldr	r3, [pc, #112]	; (ae70 <usb_isr+0x5bc>)
    adfe:	885d      	ldrh	r5, [r3, #2]
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    ae00:	889e      	ldrh	r6, [r3, #4]
    ae02:	e002      	b.n	ae0a <usb_isr+0x556>
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
    ae04:	320c      	adds	r2, #12
			if (list->addr == NULL) break;
    ae06:	6851      	ldr	r1, [r2, #4]
    ae08:	b301      	cbz	r1, ae4c <usb_isr+0x598>
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    ae0a:	8813      	ldrh	r3, [r2, #0]
    ae0c:	42ab      	cmp	r3, r5
    ae0e:	d1f9      	bne.n	ae04 <usb_isr+0x550>
    ae10:	8853      	ldrh	r3, [r2, #2]
    ae12:	42b3      	cmp	r3, r6
    ae14:	d1f6      	bne.n	ae04 <usb_isr+0x550>
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
    ae16:	0a2d      	lsrs	r5, r5, #8
    ae18:	2d03      	cmp	r5, #3
    ae1a:	f000 8279 	beq.w	b310 <usb_isr+0xa5c>
    ae1e:	4b14      	ldr	r3, [pc, #80]	; (ae70 <usb_isr+0x5bc>)
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
				} else {
					datalen = list->length;
    ae20:	8910      	ldrh	r0, [r2, #8]
    ae22:	9007      	str	r0, [sp, #28]
    ae24:	88df      	ldrh	r7, [r3, #6]
    ae26:	e061      	b.n	aeec <usb_isr+0x638>
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    ae28:	2301      	movs	r3, #1
    ae2a:	552b      	strb	r3, [r5, r4]
						break;
    ae2c:	e591      	b.n	a952 <usb_isr+0x9e>
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    ae2e:	2300      	movs	r3, #0
    ae30:	552b      	strb	r3, [r5, r4]
						break;
    ae32:	e58e      	b.n	a952 <usb_isr+0x9e>
				//serial_phex(*buf);
				*dst++ = *buf++;
			}
			//serial_phex32(usb_cdc_line_coding[0]);
			//serial_print("\n");
			if (usb_cdc_line_coding[0] == 134) usb_reboot_timer = 15;
    ae34:	4a1d      	ldr	r2, [pc, #116]	; (aeac <usb_isr+0x5f8>)
    ae36:	200f      	movs	r0, #15
    ae38:	7010      	strb	r0, [r2, #0]
    ae3a:	e7b1      	b.n	ada0 <usb_isr+0x4ec>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    ae3c:	f240 1321 	movw	r3, #289	; 0x121
    ae40:	4299      	cmp	r1, r3
    ae42:	d006      	beq.n	ae52 <usb_isr+0x59e>
    ae44:	f240 2321 	movw	r3, #545	; 0x221
    ae48:	4299      	cmp	r1, r3
    ae4a:	d002      	beq.n	ae52 <usb_isr+0x59e>
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    ae4c:	4a09      	ldr	r2, [pc, #36]	; (ae74 <usb_isr+0x5c0>)
    ae4e:	230f      	movs	r3, #15
    ae50:	7013      	strb	r3, [r2, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    ae52:	4a0b      	ldr	r2, [pc, #44]	; (ae80 <usb_isr+0x5cc>)
    ae54:	2301      	movs	r3, #1
    ae56:	7013      	strb	r3, [r2, #0]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    ae58:	4a09      	ldr	r2, [pc, #36]	; (ae80 <usb_isr+0x5cc>)
    ae5a:	2301      	movs	r3, #1
    ae5c:	7013      	strb	r3, [r2, #0]
    ae5e:	e578      	b.n	a952 <usb_isr+0x9e>
    ae60:	40072088 	.word	0x40072088
    ae64:	40072080 	.word	0x40072080
    ae68:	1fffadc0 	.word	0x1fffadc0
    ae6c:	00b40080 	.word	0x00b40080
    ae70:	2000472c 	.word	0x2000472c
    ae74:	400720c0 	.word	0x400720c0
    ae78:	20004738 	.word	0x20004738
    ae7c:	40072098 	.word	0x40072098
    ae80:	40072094 	.word	0x40072094
    ae84:	1fff8000 	.word	0x1fff8000
    ae88:	20004734 	.word	0x20004734
    ae8c:	00400088 	.word	0x00400088
    ae90:	20004648 	.word	0x20004648
    ae94:	200046ac 	.word	0x200046ac
    ae98:	20004735 	.word	0x20004735
    ae9c:	20004624 	.word	0x20004624
    aea0:	20004938 	.word	0x20004938
    aea4:	200046a8 	.word	0x200046a8
    aea8:	00012514 	.word	0x00012514
    aeac:	200046a9 	.word	0x200046a9
    aeb0:	4007208c 	.word	0x4007208c
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    aeb4:	f248 20a1 	movw	r0, #33441	; 0x82a1
    aeb8:	4281      	cmp	r1, r0
    aeba:	f000 80d8 	beq.w	b06e <usb_isr+0x7ba>
    aebe:	f200 80cd 	bhi.w	b05c <usb_isr+0x7a8>
    aec2:	f248 10a1 	movw	r0, #33185	; 0x81a1
    aec6:	4281      	cmp	r1, r0
    aec8:	f000 80d1 	beq.w	b06e <usb_isr+0x7ba>
    aecc:	f248 10a2 	movw	r0, #33186	; 0x81a2
    aed0:	4281      	cmp	r1, r0
    aed2:	d1bb      	bne.n	ae4c <usb_isr+0x598>
	  		return;
	  	}
		break;

	  case 0x81A2: // GET_CUR (wValue=0, wIndex=interface, wLength=len)
		if (setup.wLength >= 3) {
    aed4:	4bae      	ldr	r3, [pc, #696]	; (b190 <usb_isr+0x8dc>)
    aed6:	88df      	ldrh	r7, [r3, #6]
    aed8:	2f02      	cmp	r7, #2
    aeda:	d9b7      	bls.n	ae4c <usb_isr+0x598>
			reply_buffer[0] = 44100 & 255;
    aedc:	49ad      	ldr	r1, [pc, #692]	; (b194 <usb_isr+0x8e0>)
    aede:	2044      	movs	r0, #68	; 0x44
			reply_buffer[1] = 44100 >> 8;
			reply_buffer[2] = 0;
    aee0:	708a      	strb	r2, [r1, #2]
	  	}
		break;

	  case 0x81A2: // GET_CUR (wValue=0, wIndex=interface, wLength=len)
		if (setup.wLength >= 3) {
			reply_buffer[0] = 44100 & 255;
    aee2:	7008      	strb	r0, [r1, #0]
			reply_buffer[1] = 44100 >> 8;
    aee4:	22ac      	movs	r2, #172	; 0xac
			reply_buffer[2] = 0;
			datalen = 3;
    aee6:	2003      	movs	r0, #3
		break;

	  case 0x81A2: // GET_CUR (wValue=0, wIndex=interface, wLength=len)
		if (setup.wLength >= 3) {
			reply_buffer[0] = 44100 & 255;
			reply_buffer[1] = 44100 >> 8;
    aee8:	704a      	strb	r2, [r1, #1]
			reply_buffer[2] = 0;
			datalen = 3;
    aeea:	9007      	str	r0, [sp, #28]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    aeec:	4287      	cmp	r7, r0
    aeee:	f080 8093 	bcs.w	b018 <usb_isr+0x764>
    aef2:	2f40      	cmp	r7, #64	; 0x40
    aef4:	463e      	mov	r6, r7
    aef6:	f894 e000 	ldrb.w	lr, [r4]
    aefa:	9707      	str	r7, [sp, #28]
    aefc:	bf28      	it	cs
    aefe:	2640      	movcs	r6, #64	; 0x40
    af00:	198a      	adds	r2, r1, r6
    af02:	f08e 0801 	eor.w	r8, lr, #1
    af06:	1bb8      	subs	r0, r7, r6
    af08:	0433      	lsls	r3, r6, #16
    af0a:	9202      	str	r2, [sp, #8]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    af0c:	4aa2      	ldr	r2, [pc, #648]	; (b198 <usb_isr+0x8e4>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    af0e:	f884 8000 	strb.w	r8, [r4]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    af12:	7815      	ldrb	r5, [r2, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    af14:	f1be 0f00 	cmp.w	lr, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    af18:	f045 0c02 	orr.w	ip, r5, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    af1c:	bf0c      	ite	eq
    af1e:	2788      	moveq	r7, #136	; 0x88
    af20:	27c8      	movne	r7, #200	; 0xc8
    af22:	431f      	orrs	r7, r3
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    af24:	eb09 03cc 	add.w	r3, r9, ip, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    af28:	f849 703c 	str.w	r7, [r9, ip, lsl #3]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    af2c:	f085 0701 	eor.w	r7, r5, #1
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    af30:	6059      	str	r1, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    af32:	7017      	strb	r7, [r2, #0]
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    af34:	4999      	ldr	r1, [pc, #612]	; (b19c <usb_isr+0x8e8>)
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    af36:	2800      	cmp	r0, #0
    af38:	d050      	beq.n	afdc <usb_isr+0x728>

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
    af3a:	2840      	cmp	r0, #64	; 0x40
    af3c:	d951      	bls.n	afe2 <usb_isr+0x72e>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    af3e:	4b98      	ldr	r3, [pc, #608]	; (b1a0 <usb_isr+0x8ec>)
    af40:	9c02      	ldr	r4, [sp, #8]
    af42:	f047 0702 	orr.w	r7, r7, #2
    af46:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
    af4a:	605c      	str	r4, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    af4c:	f1b8 0f00 	cmp.w	r8, #0
    af50:	d06f      	beq.n	b032 <usb_isr+0x77e>
	ep0_tx_data_toggle ^= 1;
    af52:	f881 e000 	strb.w	lr, [r1]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    af56:	4992      	ldr	r1, [pc, #584]	; (b1a0 <usb_isr+0x8ec>)
    af58:	4b92      	ldr	r3, [pc, #584]	; (b1a4 <usb_isr+0x8f0>)
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    af5a:	7015      	strb	r5, [r2, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    af5c:	f841 3037 	str.w	r3, [r1, r7, lsl #3]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    af60:	4622      	mov	r2, r4
    af62:	3840      	subs	r0, #64	; 0x40
    af64:	3240      	adds	r2, #64	; 0x40
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    af66:	4b90      	ldr	r3, [pc, #576]	; (b1a8 <usb_isr+0x8f4>)
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    af68:	9901      	ldr	r1, [sp, #4]
	ep0_tx_len = datalen;
    af6a:	8018      	strh	r0, [r3, #0]
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    af6c:	600a      	str	r2, [r1, #0]
    af6e:	e770      	b.n	ae52 <usb_isr+0x59e>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    af70:	f242 0221 	movw	r2, #8225	; 0x2021
    af74:	4291      	cmp	r1, r2
    af76:	f43f af6c 	beq.w	ae52 <usb_isr+0x59e>
    af7a:	f242 2221 	movw	r2, #8737	; 0x2221
    af7e:	4291      	cmp	r1, r2
    af80:	f47f af64 	bne.w	ae4c <usb_isr+0x598>
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
#if defined(CDC_STATUS_INTERFACE)
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		usb_cdc_line_rtsdtr_millis = systick_millis_count;
    af84:	4d89      	ldr	r5, [pc, #548]	; (b1ac <usb_isr+0x8f8>)
		usb_cdc_line_rtsdtr = setup.wValue;
    af86:	4b82      	ldr	r3, [pc, #520]	; (b190 <usb_isr+0x8dc>)
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
#if defined(CDC_STATUS_INTERFACE)
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		usb_cdc_line_rtsdtr_millis = systick_millis_count;
    af88:	4889      	ldr	r0, [pc, #548]	; (b1b0 <usb_isr+0x8fc>)
		usb_cdc_line_rtsdtr = setup.wValue;
    af8a:	4a8a      	ldr	r2, [pc, #552]	; (b1b4 <usb_isr+0x900>)
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
#if defined(CDC_STATUS_INTERFACE)
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		usb_cdc_line_rtsdtr_millis = systick_millis_count;
    af8c:	682d      	ldr	r5, [r5, #0]
		usb_cdc_line_rtsdtr = setup.wValue;
    af8e:	7899      	ldrb	r1, [r3, #2]
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
#if defined(CDC_STATUS_INTERFACE)
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		usb_cdc_line_rtsdtr_millis = systick_millis_count;
    af90:	6005      	str	r5, [r0, #0]
		usb_cdc_line_rtsdtr = setup.wValue;
    af92:	7011      	strb	r1, [r2, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    af94:	4a80      	ldr	r2, [pc, #512]	; (b198 <usb_isr+0x8e4>)
    af96:	7815      	ldrb	r5, [r2, #0]
    af98:	f045 0102 	orr.w	r1, r5, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    af9c:	f085 0701 	eor.w	r7, r5, #1
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    afa0:	eb09 00c1 	add.w	r0, r9, r1, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    afa4:	7017      	strb	r7, [r2, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    afa6:	25c8      	movs	r5, #200	; 0xc8
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    afa8:	2200      	movs	r2, #0
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    afaa:	f849 5031 	str.w	r5, [r9, r1, lsl #3]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    afae:	6042      	str	r2, [r0, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    afb0:	7022      	strb	r2, [r4, #0]
    afb2:	e74e      	b.n	ae52 <usb_isr+0x59e>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
						break;
					  default:
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    afb4:	f017 0f08 	tst.w	r7, #8
    afb8:	bf0c      	ite	eq
    afba:	2302      	moveq	r3, #2
    afbc:	2303      	movne	r3, #3
    afbe:	552b      	strb	r3, [r5, r4]
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
    afc0:	e4c7      	b.n	a952 <usb_isr+0x9e>
	  // case 0xC940:
#endif

#if defined(AUDIO_INTERFACE)
	  case 0x0B01: // SET_INTERFACE (alternate setting)
		if (setup.wIndex == AUDIO_INTERFACE+1) {
    afc2:	4b73      	ldr	r3, [pc, #460]	; (b190 <usb_isr+0x8dc>)
    afc4:	889a      	ldrh	r2, [r3, #4]
    afc6:	2a04      	cmp	r2, #4
    afc8:	f000 8181 	beq.w	b2ce <usb_isr+0xa1a>
					b->addr = usb_audio_transmit_buffer;
					b->desc = (176 << 16) | BDT_OWN;
					tx_state[AUDIO_TX_ENDPOINT-1] = state ^ 1;
				}
			}
		} else if (setup.wIndex == AUDIO_INTERFACE+2) {
    afcc:	2a05      	cmp	r2, #5
    afce:	f47f af3d 	bne.w	ae4c <usb_isr+0x598>
			usb_audio_receive_setting = setup.wValue;
    afd2:	4b6f      	ldr	r3, [pc, #444]	; (b190 <usb_isr+0x8dc>)
    afd4:	4a78      	ldr	r2, [pc, #480]	; (b1b8 <usb_isr+0x904>)
    afd6:	8859      	ldrh	r1, [r3, #2]
    afd8:	7011      	strb	r1, [r2, #0]
    afda:	e7db      	b.n	af94 <usb_isr+0x6e0>
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    afdc:	2e40      	cmp	r6, #64	; 0x40
    afde:	f47f af38 	bne.w	ae52 <usb_isr+0x59e>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    afe2:	f047 0702 	orr.w	r7, r7, #2
    afe6:	eb09 03c7 	add.w	r3, r9, r7, lsl #3
    afea:	9e02      	ldr	r6, [sp, #8]
    afec:	605e      	str	r6, [r3, #4]
    afee:	496c      	ldr	r1, [pc, #432]	; (b1a0 <usb_isr+0x8ec>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    aff0:	0403      	lsls	r3, r0, #16
    aff2:	f1b8 0f00 	cmp.w	r8, #0
    aff6:	d127      	bne.n	b048 <usb_isr+0x794>
    aff8:	f043 0388 	orr.w	r3, r3, #136	; 0x88
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    affc:	4406      	add	r6, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    affe:	f841 3037 	str.w	r3, [r1, r7, lsl #3]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    b002:	7015      	strb	r5, [r2, #0]
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    b004:	f884 e000 	strb.w	lr, [r4]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    b008:	4632      	mov	r2, r6
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    b00a:	2840      	cmp	r0, #64	; 0x40
    b00c:	f47f af21 	bne.w	ae52 <usb_isr+0x59e>
    b010:	2000      	movs	r0, #0
    b012:	e7a8      	b.n	af66 <usb_isr+0x6b2>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    b014:	2000      	movs	r0, #0

static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
    b016:	4601      	mov	r1, r0
    b018:	2840      	cmp	r0, #64	; 0x40
    b01a:	4606      	mov	r6, r0
    b01c:	f894 e000 	ldrb.w	lr, [r4]
    b020:	bf28      	it	cs
    b022:	2640      	movcs	r6, #64	; 0x40
    b024:	198a      	adds	r2, r1, r6
    b026:	f08e 0801 	eor.w	r8, lr, #1
    b02a:	1b80      	subs	r0, r0, r6
    b02c:	0433      	lsls	r3, r6, #16
    b02e:	9202      	str	r2, [sp, #8]
    b030:	e76c      	b.n	af0c <usb_isr+0x658>
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    b032:	f881 e000 	strb.w	lr, [r1]
	ep0_tx_bdt_bank ^= 1;
    b036:	7015      	strb	r5, [r2, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    b038:	4959      	ldr	r1, [pc, #356]	; (b1a0 <usb_isr+0x8ec>)
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    b03a:	9a02      	ldr	r2, [sp, #8]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    b03c:	4b5f      	ldr	r3, [pc, #380]	; (b1bc <usb_isr+0x908>)
    b03e:	f841 3037 	str.w	r3, [r1, r7, lsl #3]
    b042:	3840      	subs	r0, #64	; 0x40
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    b044:	3240      	adds	r2, #64	; 0x40
    b046:	e78e      	b.n	af66 <usb_isr+0x6b2>
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    b048:	7015      	strb	r5, [r2, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    b04a:	9a02      	ldr	r2, [sp, #8]
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    b04c:	f884 e000 	strb.w	lr, [r4]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    b050:	f043 03c8 	orr.w	r3, r3, #200	; 0xc8
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    b054:	4402      	add	r2, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    b056:	f841 3037 	str.w	r3, [r1, r7, lsl #3]
    b05a:	e7d6      	b.n	b00a <usb_isr+0x756>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    b05c:	f248 32a1 	movw	r2, #33697	; 0x83a1
    b060:	4291      	cmp	r1, r2
    b062:	d004      	beq.n	b06e <usb_isr+0x7ba>
    b064:	f248 42a1 	movw	r2, #33953	; 0x84a1
    b068:	4291      	cmp	r1, r2
    b06a:	f47f aeef 	bne.w	ae4c <usb_isr+0x598>
		return;
	  case 0x81A1: // GET FEATURE
	  case 0x82A1:
	  case 0x83A1:
	  case 0x84A1:
	  	if (usb_audio_get_feature(&setup, reply_buffer, &datalen)) {
    b06e:	4d48      	ldr	r5, [pc, #288]	; (b190 <usb_isr+0x8dc>)
    b070:	4948      	ldr	r1, [pc, #288]	; (b194 <usb_isr+0x8e0>)
    b072:	4628      	mov	r0, r5
    b074:	aa07      	add	r2, sp, #28
    b076:	f7ff fb0b 	bl	a690 <usb_audio_get_feature>
    b07a:	2800      	cmp	r0, #0
    b07c:	f43f aee6 	beq.w	ae4c <usb_isr+0x598>
    b080:	88ef      	ldrh	r7, [r5, #6]
    b082:	9807      	ldr	r0, [sp, #28]
	  		data = reply_buffer;
    b084:	4943      	ldr	r1, [pc, #268]	; (b194 <usb_isr+0x8e0>)
    b086:	e731      	b.n	aeec <usb_isr+0x638>
    b088:	4b41      	ldr	r3, [pc, #260]	; (b190 <usb_isr+0x8dc>)
    b08a:	889a      	ldrh	r2, [r3, #4]
    b08c:	f002 027f 	and.w	r2, r2, #127	; 0x7f
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    b090:	2a08      	cmp	r2, #8
    b092:	f63f aedb 	bhi.w	ae4c <usb_isr+0x598>
    b096:	8859      	ldrh	r1, [r3, #2]
    b098:	2900      	cmp	r1, #0
    b09a:	f47f aed7 	bne.w	ae4c <usb_isr+0x598>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    b09e:	4948      	ldr	r1, [pc, #288]	; (b1c0 <usb_isr+0x90c>)
    b0a0:	0092      	lsls	r2, r2, #2
    b0a2:	4411      	add	r1, r2
    b0a4:	780a      	ldrb	r2, [r1, #0]
    b0a6:	f022 0202 	bic.w	r2, r2, #2
    b0aa:	700a      	strb	r2, [r1, #0]
    b0ac:	e772      	b.n	af94 <usb_isr+0x6e0>
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    b0ae:	4b45      	ldr	r3, [pc, #276]	; (b1c4 <usb_isr+0x910>)
    b0b0:	4938      	ldr	r1, [pc, #224]	; (b194 <usb_isr+0x8e0>)
    b0b2:	781a      	ldrb	r2, [r3, #0]
    b0b4:	4b36      	ldr	r3, [pc, #216]	; (b190 <usb_isr+0x8dc>)
		datalen = 1;
    b0b6:	9007      	str	r0, [sp, #28]
    b0b8:	88df      	ldrh	r7, [r3, #6]
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    b0ba:	700a      	strb	r2, [r1, #0]
    b0bc:	e716      	b.n	aeec <usb_isr+0x638>
    b0be:	4b34      	ldr	r3, [pc, #208]	; (b190 <usb_isr+0x8dc>)
    b0c0:	889a      	ldrh	r2, [r3, #4]
    b0c2:	f002 027f 	and.w	r2, r2, #127	; 0x7f
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    b0c6:	2a08      	cmp	r2, #8
    b0c8:	f63f aec0 	bhi.w	ae4c <usb_isr+0x598>
    b0cc:	8859      	ldrh	r1, [r3, #2]
    b0ce:	2900      	cmp	r1, #0
    b0d0:	f47f aebc 	bne.w	ae4c <usb_isr+0x598>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    b0d4:	493a      	ldr	r1, [pc, #232]	; (b1c0 <usb_isr+0x90c>)
    b0d6:	0092      	lsls	r2, r2, #2
    b0d8:	4411      	add	r1, r2
    b0da:	780a      	ldrb	r2, [r1, #0]
    b0dc:	f042 0202 	orr.w	r2, r2, #2
    b0e0:	700a      	strb	r2, [r1, #0]
    b0e2:	e757      	b.n	af94 <usb_isr+0x6e0>
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    b0e4:	492b      	ldr	r1, [pc, #172]	; (b194 <usb_isr+0x8e0>)
    b0e6:	4b2a      	ldr	r3, [pc, #168]	; (b190 <usb_isr+0x8dc>)
    b0e8:	700a      	strb	r2, [r1, #0]
		reply_buffer[1] = 0;
		datalen = 2;
    b0ea:	2002      	movs	r0, #2
    b0ec:	88df      	ldrh	r7, [r3, #6]
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
    b0ee:	704a      	strb	r2, [r1, #1]
		datalen = 2;
    b0f0:	9007      	str	r0, [sp, #28]
    b0f2:	e6fb      	b.n	aeec <usb_isr+0x638>
	switch (setup.wRequestAndType) {
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
    b0f4:	4b26      	ldr	r3, [pc, #152]	; (b190 <usb_isr+0x8dc>)
    b0f6:	4d2a      	ldr	r5, [pc, #168]	; (b1a0 <usb_isr+0x8ec>)
    b0f8:	789a      	ldrb	r2, [r3, #2]
    b0fa:	4b32      	ldr	r3, [pc, #200]	; (b1c4 <usb_isr+0x910>)
    b0fc:	f505 7680 	add.w	r6, r5, #256	; 0x100
    b100:	701a      	strb	r2, [r3, #0]
    b102:	e002      	b.n	b10a <usb_isr+0x856>
    b104:	3508      	adds	r5, #8
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    b106:	42ae      	cmp	r6, r5
    b108:	d007      	beq.n	b11a <usb_isr+0x866>
			if (table[i].desc & BDT_OWN) {
    b10a:	6a2b      	ldr	r3, [r5, #32]
    b10c:	061f      	lsls	r7, r3, #24
    b10e:	d5f9      	bpl.n	b104 <usb_isr+0x850>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    b110:	6a68      	ldr	r0, [r5, #36]	; 0x24
    b112:	3808      	subs	r0, #8
    b114:	f000 f9d2 	bl	b4bc <usb_free>
    b118:	e7f4      	b.n	b104 <usb_isr+0x850>
    b11a:	492b      	ldr	r1, [pc, #172]	; (b1c8 <usb_isr+0x914>)
    b11c:	4b2b      	ldr	r3, [pc, #172]	; (b1cc <usb_isr+0x918>)
    b11e:	4a2c      	ldr	r2, [pc, #176]	; (b1d0 <usb_isr+0x91c>)
    b120:	9102      	str	r1, [sp, #8]
    b122:	492c      	ldr	r1, [pc, #176]	; (b1d4 <usb_isr+0x920>)
    b124:	4e2c      	ldr	r6, [pc, #176]	; (b1d8 <usb_isr+0x924>)
    b126:	4d2d      	ldr	r5, [pc, #180]	; (b1dc <usb_isr+0x928>)
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    b128:	9405      	str	r4, [sp, #20]
    b12a:	9603      	str	r6, [sp, #12]
    b12c:	9504      	str	r5, [sp, #16]
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    b12e:	f04f 0800 	mov.w	r8, #0
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    b132:	4614      	mov	r4, r2
    b134:	460e      	mov	r6, r1
    b136:	461d      	mov	r5, r3
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    b138:	6828      	ldr	r0, [r5, #0]
			while (p) {
    b13a:	b128      	cbz	r0, b148 <usb_isr+0x894>
				n = p->next;
    b13c:	6847      	ldr	r7, [r0, #4]
				usb_free(p);
    b13e:	f000 f9bd 	bl	b4bc <usb_free>
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
			while (p) {
    b142:	4638      	mov	r0, r7
    b144:	2f00      	cmp	r7, #0
    b146:	d1f9      	bne.n	b13c <usb_isr+0x888>
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
    b148:	2300      	movs	r3, #0
    b14a:	602b      	str	r3, [r5, #0]
			rx_last[i] = NULL;
    b14c:	9b03      	ldr	r3, [sp, #12]
			p = tx_first[i];
    b14e:	6820      	ldr	r0, [r4, #0]
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
    b150:	461a      	mov	r2, r3
    b152:	2300      	movs	r3, #0
    b154:	f842 3028 	str.w	r3, [r2, r8, lsl #2]
			p = tx_first[i];
			while (p) {
    b158:	b128      	cbz	r0, b166 <usb_isr+0x8b2>
				n = p->next;
    b15a:	6847      	ldr	r7, [r0, #4]
				usb_free(p);
    b15c:	f000 f9ae 	bl	b4bc <usb_free>
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
			p = tx_first[i];
			while (p) {
    b160:	4638      	mov	r0, r7
    b162:	2f00      	cmp	r7, #0
    b164:	d1f9      	bne.n	b15a <usb_isr+0x8a6>
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    b166:	2200      	movs	r2, #0
    b168:	6022      	str	r2, [r4, #0]
			tx_last[i] = NULL;
    b16a:	9a02      	ldr	r2, [sp, #8]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    b16c:	7833      	ldrb	r3, [r6, #0]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    b16e:	4611      	mov	r1, r2
    b170:	2200      	movs	r2, #0
    b172:	f841 2f04 	str.w	r2, [r1, #4]!
			usb_rx_byte_count_data[i] = 0;
    b176:	9a04      	ldr	r2, [sp, #16]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    b178:	9102      	str	r1, [sp, #8]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    b17a:	3b02      	subs	r3, #2
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    b17c:	f04f 0100 	mov.w	r1, #0
    b180:	f822 1018 	strh.w	r1, [r2, r8, lsl #1]
			switch (tx_state[i]) {
    b184:	2b03      	cmp	r3, #3
    b186:	d82e      	bhi.n	b1e6 <usb_isr+0x932>
    b188:	e8df f003 	tbb	[pc, r3]
    b18c:	2a762a76 	.word	0x2a762a76
    b190:	2000472c 	.word	0x2000472c
    b194:	20004738 	.word	0x20004738
    b198:	20004734 	.word	0x20004734
    b19c:	200046a8 	.word	0x200046a8
    b1a0:	1fff8000 	.word	0x1fff8000
    b1a4:	004000c8 	.word	0x004000c8
    b1a8:	20004644 	.word	0x20004644
    b1ac:	200045ec 	.word	0x200045ec
    b1b0:	20004940 	.word	0x20004940
    b1b4:	20004764 	.word	0x20004764
    b1b8:	200045f7 	.word	0x200045f7
    b1bc:	00400088 	.word	0x00400088
    b1c0:	400720c0 	.word	0x400720c0
    b1c4:	20004740 	.word	0x20004740
    b1c8:	20004708 	.word	0x20004708
    b1cc:	20004688 	.word	0x20004688
    b1d0:	200046ec 	.word	0x200046ec
    b1d4:	20004744 	.word	0x20004744
    b1d8:	20004624 	.word	0x20004624
    b1dc:	20004928 	.word	0x20004928
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    b1e0:	f04f 0301 	mov.w	r3, #1
    b1e4:	7033      	strb	r3, [r6, #0]
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
    b1e6:	f108 0801 	add.w	r8, r8, #1
    b1ea:	f1b8 0f08 	cmp.w	r8, #8
    b1ee:	f105 0504 	add.w	r5, r5, #4
    b1f2:	f104 0404 	add.w	r4, r4, #4
    b1f6:	f106 0601 	add.w	r6, r6, #1
    b1fa:	d19d      	bne.n	b138 <usb_isr+0x884>
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
    b1fc:	4b55      	ldr	r3, [pc, #340]	; (b354 <usb_isr+0xaa0>)
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    b1fe:	4956      	ldr	r1, [pc, #344]	; (b358 <usb_isr+0xaa4>)
    b200:	9c05      	ldr	r4, [sp, #20]
    b202:	9402      	str	r4, [sp, #8]
    b204:	2200      	movs	r2, #0
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
    b206:	f8df 8188 	ldr.w	r8, [pc, #392]	; b390 <usb_isr+0xadc>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    b20a:	700a      	strb	r2, [r1, #0]
    b20c:	2702      	movs	r7, #2
    b20e:	2601      	movs	r6, #1
    b210:	461c      	mov	r4, r3
    b212:	e011      	b.n	b238 <usb_isr+0x984>
    b214:	00b5      	lsls	r5, r6, #2
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    b216:	f045 0202 	orr.w	r2, r5, #2
			table[index(i, TX, ODD)].desc = 0;
    b21a:	f045 0503 	orr.w	r5, r5, #3
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    b21e:	2100      	movs	r1, #0
			table[index(i, TX, ODD)].desc = 0;
#ifdef AUDIO_INTERFACE
			if (i == AUDIO_SYNC_ENDPOINT) {
    b220:	2e08      	cmp	r6, #8
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    b222:	f849 1032 	str.w	r1, [r9, r2, lsl #3]
			table[index(i, TX, ODD)].desc = 0;
    b226:	f849 1035 	str.w	r1, [r9, r5, lsl #3]
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    b22a:	4d4c      	ldr	r5, [pc, #304]	; (b35c <usb_isr+0xaa8>)
			table[index(i, TX, ODD)].desc = 0;
#ifdef AUDIO_INTERFACE
			if (i == AUDIO_SYNC_ENDPOINT) {
    b22c:	f000 8085 	beq.w	b33a <usb_isr+0xa86>
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    b230:	2f09      	cmp	r7, #9
    b232:	d025      	beq.n	b280 <usb_isr+0x9cc>
    b234:	3601      	adds	r6, #1
    b236:	3701      	adds	r7, #1
			epconf = *cfg++;
    b238:	f818 2b01 	ldrb.w	r2, [r8], #1
			*reg = epconf;
    b23c:	f804 2b04 	strb.w	r2, [r4], #4
			reg += 4;
#ifdef AUDIO_INTERFACE
			if (i == AUDIO_RX_ENDPOINT) {
    b240:	2e07      	cmp	r6, #7
    b242:	d06a      	beq.n	b31a <usb_isr+0xa66>
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    b244:	0715      	lsls	r5, r2, #28
    b246:	d5e5      	bpl.n	b214 <usb_isr+0x960>
				usb_packet_t *p;
				p = usb_malloc();
    b248:	f000 f918 	bl	b47c <usb_malloc>
				if (p) {
    b24c:	b388      	cbz	r0, b2b2 <usb_isr+0x9fe>
					table[index(i, RX, EVEN)].addr = p->buf;
    b24e:	00b5      	lsls	r5, r6, #2
    b250:	eb09 1246 	add.w	r2, r9, r6, lsl #5
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    b254:	4b42      	ldr	r3, [pc, #264]	; (b360 <usb_isr+0xaac>)
    b256:	f849 3035 	str.w	r3, [r9, r5, lsl #3]
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
    b25a:	3008      	adds	r0, #8
    b25c:	6050      	str	r0, [r2, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
    b25e:	f000 f90d 	bl	b47c <usb_malloc>
				if (p) {
    b262:	b1e8      	cbz	r0, b2a0 <usb_isr+0x9ec>
					table[index(i, RX, ODD)].addr = p->buf;
    b264:	f045 0201 	orr.w	r2, r5, #1
    b268:	eb09 01c2 	add.w	r1, r9, r2, lsl #3
    b26c:	3008      	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    b26e:	4b3d      	ldr	r3, [pc, #244]	; (b364 <usb_isr+0xab0>)
    b270:	f849 3032 	str.w	r3, [r9, r2, lsl #3]
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    b274:	6048      	str	r0, [r1, #4]
    b276:	e7ce      	b.n	b216 <usb_isr+0x962>
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
			  case TX_STATE_EVEN_FREE:
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    b278:	f04f 0300 	mov.w	r3, #0
    b27c:	7033      	strb	r3, [r6, #0]
    b27e:	e7b2      	b.n	b1e6 <usb_isr+0x932>
    b280:	4b39      	ldr	r3, [pc, #228]	; (b368 <usb_isr+0xab4>)
    b282:	9c02      	ldr	r4, [sp, #8]
    b284:	88df      	ldrh	r7, [r3, #6]
    b286:	9807      	ldr	r0, [sp, #28]
    b288:	e630      	b.n	aeec <usb_isr+0x638>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    b28a:	f240 3321 	movw	r3, #801	; 0x321
    b28e:	4299      	cmp	r1, r3
    b290:	f43f addf 	beq.w	ae52 <usb_isr+0x59e>
    b294:	f240 4321 	movw	r3, #1057	; 0x421
    b298:	4299      	cmp	r1, r3
    b29a:	f43f adda 	beq.w	ae52 <usb_isr+0x59e>
    b29e:	e5d5      	b.n	ae4c <usb_isr+0x598>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
    b2a0:	4b2d      	ldr	r3, [pc, #180]	; (b358 <usb_isr+0xaa4>)
    b2a2:	781a      	ldrb	r2, [r3, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    b2a4:	f045 0101 	orr.w	r1, r5, #1
					usb_rx_memory_needed++;
    b2a8:	3201      	adds	r2, #1
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    b2aa:	f849 0031 	str.w	r0, [r9, r1, lsl #3]
					usb_rx_memory_needed++;
    b2ae:	701a      	strb	r2, [r3, #0]
    b2b0:	e7b1      	b.n	b216 <usb_isr+0x962>
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
    b2b2:	4b29      	ldr	r3, [pc, #164]	; (b358 <usb_isr+0xaa4>)
    b2b4:	781a      	ldrb	r2, [r3, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    b2b6:	00b5      	lsls	r5, r6, #2
					usb_rx_memory_needed++;
    b2b8:	3201      	adds	r2, #1
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    b2ba:	f849 0035 	str.w	r0, [r9, r5, lsl #3]
					usb_rx_memory_needed++;
    b2be:	701a      	strb	r2, [r3, #0]
    b2c0:	e7cd      	b.n	b25e <usb_isr+0x9aa>
		break;
	  case 0x0A81: // GET_INTERFACE (alternate setting)
		datalen = 1;
		data = reply_buffer;
		if (setup.wIndex == AUDIO_INTERFACE+1) {
			reply_buffer[0] = usb_audio_transmit_setting;
    b2c2:	4a2a      	ldr	r2, [pc, #168]	; (b36c <usb_isr+0xab8>)
    b2c4:	492a      	ldr	r1, [pc, #168]	; (b370 <usb_isr+0xabc>)
    b2c6:	7812      	ldrb	r2, [r2, #0]
    b2c8:	88df      	ldrh	r7, [r3, #6]
    b2ca:	700a      	strb	r2, [r1, #0]
    b2cc:	e60e      	b.n	aeec <usb_isr+0x638>
#endif

#if defined(AUDIO_INTERFACE)
	  case 0x0B01: // SET_INTERFACE (alternate setting)
		if (setup.wIndex == AUDIO_INTERFACE+1) {
			usb_audio_transmit_setting = setup.wValue;
    b2ce:	789a      	ldrb	r2, [r3, #2]
    b2d0:	4926      	ldr	r1, [pc, #152]	; (b36c <usb_isr+0xab8>)
    b2d2:	700a      	strb	r2, [r1, #0]
			if (usb_audio_transmit_setting > 0) {
    b2d4:	2a00      	cmp	r2, #0
    b2d6:	f43f ae5d 	beq.w	af94 <usb_isr+0x6e0>
				bdt_t *b = &table[index(AUDIO_TX_ENDPOINT, TX, EVEN)];
				uint8_t state = tx_state[AUDIO_TX_ENDPOINT-1];
    b2da:	4d26      	ldr	r5, [pc, #152]	; (b374 <usb_isr+0xac0>)
#if defined(AUDIO_INTERFACE)
	  case 0x0B01: // SET_INTERFACE (alternate setting)
		if (setup.wIndex == AUDIO_INTERFACE+1) {
			usb_audio_transmit_setting = setup.wValue;
			if (usb_audio_transmit_setting > 0) {
				bdt_t *b = &table[index(AUDIO_TX_ENDPOINT, TX, EVEN)];
    b2dc:	4a26      	ldr	r2, [pc, #152]	; (b378 <usb_isr+0xac4>)
				uint8_t state = tx_state[AUDIO_TX_ENDPOINT-1];
    b2de:	796f      	ldrb	r7, [r5, #5]
#if defined(AUDIO_INTERFACE)
	  case 0x0B01: // SET_INTERFACE (alternate setting)
		if (setup.wIndex == AUDIO_INTERFACE+1) {
			usb_audio_transmit_setting = setup.wValue;
			if (usb_audio_transmit_setting > 0) {
				bdt_t *b = &table[index(AUDIO_TX_ENDPOINT, TX, EVEN)];
    b2e0:	f1a2 0608 	sub.w	r6, r2, #8
    b2e4:	2f00      	cmp	r7, #0
    b2e6:	bf18      	it	ne
    b2e8:	4616      	movne	r6, r2
				uint8_t state = tx_state[AUDIO_TX_ENDPOINT-1];
				if (state) b++;
				if (!(b->desc & BDT_OWN)) {
    b2ea:	6832      	ldr	r2, [r6, #0]
    b2ec:	f012 0180 	ands.w	r1, r2, #128	; 0x80
    b2f0:	f47f ae50 	bne.w	af94 <usb_isr+0x6e0>
					memset(usb_audio_transmit_buffer, 0, 176);
    b2f4:	f8df 809c 	ldr.w	r8, [pc, #156]	; b394 <usb_isr+0xae0>
    b2f8:	22b0      	movs	r2, #176	; 0xb0
    b2fa:	4640      	mov	r0, r8
    b2fc:	f002 ff6a 	bl	e1d4 <memset>
					b->addr = usb_audio_transmit_buffer;
					b->desc = (176 << 16) | BDT_OWN;
					tx_state[AUDIO_TX_ENDPOINT-1] = state ^ 1;
    b300:	f087 0701 	eor.w	r7, r7, #1
				uint8_t state = tx_state[AUDIO_TX_ENDPOINT-1];
				if (state) b++;
				if (!(b->desc & BDT_OWN)) {
					memset(usb_audio_transmit_buffer, 0, 176);
					b->addr = usb_audio_transmit_buffer;
					b->desc = (176 << 16) | BDT_OWN;
    b304:	4a1d      	ldr	r2, [pc, #116]	; (b37c <usb_isr+0xac8>)
				bdt_t *b = &table[index(AUDIO_TX_ENDPOINT, TX, EVEN)];
				uint8_t state = tx_state[AUDIO_TX_ENDPOINT-1];
				if (state) b++;
				if (!(b->desc & BDT_OWN)) {
					memset(usb_audio_transmit_buffer, 0, 176);
					b->addr = usb_audio_transmit_buffer;
    b306:	f8c6 8004 	str.w	r8, [r6, #4]
					b->desc = (176 << 16) | BDT_OWN;
					tx_state[AUDIO_TX_ENDPOINT-1] = state ^ 1;
    b30a:	716f      	strb	r7, [r5, #5]
				uint8_t state = tx_state[AUDIO_TX_ENDPOINT-1];
				if (state) b++;
				if (!(b->desc & BDT_OWN)) {
					memset(usb_audio_transmit_buffer, 0, 176);
					b->addr = usb_audio_transmit_buffer;
					b->desc = (176 << 16) | BDT_OWN;
    b30c:	6032      	str	r2, [r6, #0]
    b30e:	e641      	b.n	af94 <usb_isr+0x6e0>
    b310:	4b15      	ldr	r3, [pc, #84]	; (b368 <usb_isr+0xab4>)
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    b312:	7808      	ldrb	r0, [r1, #0]
    b314:	88df      	ldrh	r7, [r3, #6]
    b316:	9007      	str	r0, [sp, #28]
    b318:	e5e8      	b.n	aeec <usb_isr+0x638>
			epconf = *cfg++;
			*reg = epconf;
			reg += 4;
#ifdef AUDIO_INTERFACE
			if (i == AUDIO_RX_ENDPOINT) {
				table[index(i, RX, EVEN)].addr = usb_audio_receive_buffer;
    b31a:	4a19      	ldr	r2, [pc, #100]	; (b380 <usb_isr+0xacc>)
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
    b31c:	4919      	ldr	r1, [pc, #100]	; (b384 <usb_isr+0xad0>)
			epconf = *cfg++;
			*reg = epconf;
			reg += 4;
#ifdef AUDIO_INTERFACE
			if (i == AUDIO_RX_ENDPOINT) {
				table[index(i, RX, EVEN)].addr = usb_audio_receive_buffer;
    b31e:	f8c9 20e4 	str.w	r2, [r9, #228]	; 0xe4
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
    b322:	f8c9 20ec 	str.w	r2, [r9, #236]	; 0xec
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    b326:	2200      	movs	r2, #0
			*reg = epconf;
			reg += 4;
#ifdef AUDIO_INTERFACE
			if (i == AUDIO_RX_ENDPOINT) {
				table[index(i, RX, EVEN)].addr = usb_audio_receive_buffer;
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
    b328:	f8c9 10e0 	str.w	r1, [r9, #224]	; 0xe0
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
    b32c:	f8c9 10e8 	str.w	r1, [r9, #232]	; 0xe8
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    b330:	f8c9 20f0 	str.w	r2, [r9, #240]	; 0xf0
			table[index(i, TX, ODD)].desc = 0;
    b334:	f8c9 20f8 	str.w	r2, [r9, #248]	; 0xf8
    b338:	e77c      	b.n	b234 <usb_isr+0x980>
#ifdef AUDIO_INTERFACE
			if (i == AUDIO_SYNC_ENDPOINT) {
				table[index(i, TX, EVEN)].addr = &usb_audio_sync_feedback;
    b33a:	eb05 06c2 	add.w	r6, r5, r2, lsl #3
    b33e:	4f0a      	ldr	r7, [pc, #40]	; (b368 <usb_isr+0xab4>)
				table[index(i, TX, EVEN)].desc = (3<<16) | BDT_OWN;
    b340:	4811      	ldr	r0, [pc, #68]	; (b388 <usb_isr+0xad4>)
			}
			table[index(i, TX, EVEN)].desc = 0;
			table[index(i, TX, ODD)].desc = 0;
#ifdef AUDIO_INTERFACE
			if (i == AUDIO_SYNC_ENDPOINT) {
				table[index(i, TX, EVEN)].addr = &usb_audio_sync_feedback;
    b342:	4b12      	ldr	r3, [pc, #72]	; (b38c <usb_isr+0xad8>)
				table[index(i, TX, EVEN)].desc = (3<<16) | BDT_OWN;
    b344:	f845 0032 	str.w	r0, [r5, r2, lsl #3]
    b348:	9c02      	ldr	r4, [sp, #8]
    b34a:	88ff      	ldrh	r7, [r7, #6]
			}
			table[index(i, TX, EVEN)].desc = 0;
			table[index(i, TX, ODD)].desc = 0;
#ifdef AUDIO_INTERFACE
			if (i == AUDIO_SYNC_ENDPOINT) {
				table[index(i, TX, EVEN)].addr = &usb_audio_sync_feedback;
    b34c:	6073      	str	r3, [r6, #4]
    b34e:	9807      	ldr	r0, [sp, #28]
    b350:	e5cc      	b.n	aeec <usb_isr+0x638>
    b352:	bf00      	nop
    b354:	400720c4 	.word	0x400720c4
    b358:	20004735 	.word	0x20004735
    b35c:	1fff8000 	.word	0x1fff8000
    b360:	00400088 	.word	0x00400088
    b364:	004000c8 	.word	0x004000c8
    b368:	2000472c 	.word	0x2000472c
    b36c:	200045f6 	.word	0x200045f6
    b370:	20004738 	.word	0x20004738
    b374:	20004744 	.word	0x20004744
    b378:	1fff80d8 	.word	0x1fff80d8
    b37c:	00b00080 	.word	0x00b00080
    b380:	1fffadc0 	.word	0x1fffadc0
    b384:	00b40080 	.word	0x00b40080
    b388:	00030080 	.word	0x00030080
    b38c:	1fffadbc 	.word	0x1fffadbc
    b390:	0001250c 	.word	0x0001250c
    b394:	1fffae74 	.word	0x1fffae74

0000b398 <usb_init>:
}



void usb_init(void)
{
    b398:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    b39c:	4c20      	ldr	r4, [pc, #128]	; (b420 <usb_init+0x88>)
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    b39e:	f000 fc2f 	bl	bc00 <usb_init_serialnumber>

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    b3a2:	2200      	movs	r2, #0
    b3a4:	f504 7084 	add.w	r0, r4, #264	; 0x108
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    b3a8:	4623      	mov	r3, r4

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    b3aa:	601a      	str	r2, [r3, #0]
		table[i].addr = 0;
    b3ac:	605a      	str	r2, [r3, #4]
    b3ae:	3308      	adds	r3, #8
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
    b3b0:	4283      	cmp	r3, r0
		table[i].desc = 0;
    b3b2:	f04f 0100 	mov.w	r1, #0
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
    b3b6:	d1f8      	bne.n	b3aa <usb_init+0x12>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    b3b8:	4a1a      	ldr	r2, [pc, #104]	; (b424 <usb_init+0x8c>)
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    b3ba:	4f1b      	ldr	r7, [pc, #108]	; (b428 <usb_init+0x90>)
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    b3bc:	6813      	ldr	r3, [r2, #0]
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    b3be:	4d1b      	ldr	r5, [pc, #108]	; (b42c <usb_init+0x94>)
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    b3c0:	481b      	ldr	r0, [pc, #108]	; (b430 <usb_init+0x98>)

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    b3c2:	4e1c      	ldr	r6, [pc, #112]	; (b434 <usb_init+0x9c>)
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    b3c4:	f8df 8078 	ldr.w	r8, [pc, #120]	; b440 <usb_init+0xa8>
	USB0_ERRSTAT = 0xFF;
    b3c8:	f8df c078 	ldr.w	ip, [pc, #120]	; b444 <usb_init+0xac>
	USB0_OTGISTAT = 0xFF;

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    b3cc:	f8df 9078 	ldr.w	r9, [pc, #120]	; b448 <usb_init+0xb0>
	USB0_USBCTRL = 0;
    b3d0:	f8df e078 	ldr.w	lr, [pc, #120]	; b44c <usb_init+0xb4>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    b3d4:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    b3d8:	6013      	str	r3, [r2, #0]
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    b3da:	f3c4 2307 	ubfx	r3, r4, #8, #8
    b3de:	703b      	strb	r3, [r7, #0]
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    b3e0:	f3c4 4307 	ubfx	r3, r4, #16, #8
    b3e4:	702b      	strb	r3, [r5, #0]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    b3e6:	0e24      	lsrs	r4, r4, #24

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    b3e8:	23ff      	movs	r3, #255	; 0xff
	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    b3ea:	f502 3228 	add.w	r2, r2, #172032	; 0x2a000
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    b3ee:	7004      	strb	r4, [r0, #0]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    b3f0:	4d11      	ldr	r5, [pc, #68]	; (b438 <usb_init+0xa0>)
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    b3f2:	f888 3000 	strb.w	r3, [r8]
	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    b3f6:	4811      	ldr	r0, [pc, #68]	; (b43c <usb_init+0xa4>)
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
    b3f8:	f88c 3000 	strb.w	r3, [ip]
	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    b3fc:	32d4      	adds	r2, #212	; 0xd4
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    b3fe:	7033      	strb	r3, [r6, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    b400:	2301      	movs	r3, #1
    b402:	f889 3000 	strb.w	r3, [r9]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    b406:	2670      	movs	r6, #112	; 0x70

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    b408:	f88e 1000 	strb.w	r1, [lr]
	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    b40c:	f44f 7400 	mov.w	r4, #512	; 0x200

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    b410:	2110      	movs	r1, #16
	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    b412:	f807 3c18 	strb.w	r3, [r7, #-24]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    b416:	702e      	strb	r6, [r5, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    b418:	6004      	str	r4, [r0, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    b41a:	7011      	strb	r1, [r2, #0]
    b41c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    b420:	1fff8000 	.word	0x1fff8000
    b424:	40048034 	.word	0x40048034
    b428:	4007209c 	.word	0x4007209c
    b42c:	400720b0 	.word	0x400720b0
    b430:	400720b4 	.word	0x400720b4
    b434:	40072010 	.word	0x40072010
    b438:	e000e449 	.word	0xe000e449
    b43c:	e000e108 	.word	0xe000e108
    b440:	40072080 	.word	0x40072080
    b444:	40072088 	.word	0x40072088
    b448:	40072094 	.word	0x40072094
    b44c:	40072100 	.word	0x40072100

0000b450 <usb_serial_class::clear()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    b450:	f000 b8ba 	b.w	b5c8 <usb_serial_flush_input>

0000b454 <usb_serial_class::peek()>:
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    b454:	f000 b892 	b.w	b57c <usb_serial_peekchar>

0000b458 <usb_serial_class::read()>:
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    b458:	f000 b86c 	b.w	b534 <usb_serial_getchar>

0000b45c <usb_serial_class::available()>:
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    b45c:	f000 b8a6 	b.w	b5ac <usb_serial_available>

0000b460 <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    b460:	f000 b982 	b.w	b768 <usb_serial_flush_output>

0000b464 <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    b464:	f000 b95c 	b.w	b720 <usb_serial_write_buffer_free>

0000b468 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    b468:	4608      	mov	r0, r1
    b46a:	4611      	mov	r1, r2
    b46c:	f000 b8c8 	b.w	b600 <usb_serial_write>

0000b470 <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    b470:	4608      	mov	r0, r1
    b472:	f000 b949 	b.w	b708 <usb_serial_putchar>
    b476:	bf00      	nop

0000b478 <serialEvent()>:
#endif

#endif // F_CPU

void serialEvent() __attribute__((weak));
void serialEvent() {}
    b478:	4770      	bx	lr
    b47a:	bf00      	nop

0000b47c <usb_malloc>:
usb_packet_t * usb_malloc(void)
{
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    b47c:	b672      	cpsid	i
	avail = usb_buffer_available;
    b47e:	480d      	ldr	r0, [pc, #52]	; (b4b4 <usb_malloc+0x38>)
    b480:	6802      	ldr	r2, [r0, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    b482:	fab2 f382 	clz	r3, r2
	if (n >= NUM_USB_BUFFERS) {
    b486:	2b1d      	cmp	r3, #29
    b488:	dc10      	bgt.n	b4ac <usb_malloc+0x30>
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    b48a:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    b48e:	40d9      	lsrs	r1, r3
    b490:	ea22 0201 	bic.w	r2, r2, r1
    b494:	6002      	str	r2, [r0, #0]
	__enable_irq();
    b496:	b662      	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    b498:	4807      	ldr	r0, [pc, #28]	; (b4b8 <usb_malloc+0x3c>)
    b49a:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
    b49e:	00db      	lsls	r3, r3, #3
    b4a0:	18c2      	adds	r2, r0, r3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    b4a2:	2100      	movs	r1, #0
    b4a4:	50c1      	str	r1, [r0, r3]
	*(uint32_t *)(p + 4) = 0;
	return (usb_packet_t *)p;
    b4a6:	4610      	mov	r0, r2
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
	*(uint32_t *)(p + 4) = 0;
    b4a8:	6051      	str	r1, [r2, #4]
	return (usb_packet_t *)p;
}
    b4aa:	4770      	bx	lr

	__disable_irq();
	avail = usb_buffer_available;
	n = __builtin_clz(avail); // clz = count leading zeros
	if (n >= NUM_USB_BUFFERS) {
		__enable_irq();
    b4ac:	b662      	cpsie	i
		return NULL;
    b4ae:	2000      	movs	r0, #0
    b4b0:	4770      	bx	lr
    b4b2:	bf00      	nop
    b4b4:	1fffbb04 	.word	0x1fffbb04
    b4b8:	1fffaf28 	.word	0x1fffaf28

0000b4bc <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    b4bc:	4b0d      	ldr	r3, [pc, #52]	; (b4f4 <usb_free+0x38>)
    b4be:	4a0e      	ldr	r2, [pc, #56]	; (b4f8 <usb_free+0x3c>)
    b4c0:	1ac3      	subs	r3, r0, r3
    b4c2:	fba2 2303 	umull	r2, r3, r2, r3
    b4c6:	091b      	lsrs	r3, r3, #4
	if (n >= NUM_USB_BUFFERS) return;
    b4c8:	2b1d      	cmp	r3, #29
    b4ca:	d80c      	bhi.n	b4e6 <usb_free+0x2a>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    b4cc:	4a0b      	ldr	r2, [pc, #44]	; (b4fc <usb_free+0x40>)
    b4ce:	7812      	ldrb	r2, [r2, #0]
    b4d0:	b952      	cbnz	r2, b4e8 <usb_free+0x2c>
		usb_rx_memory(p);
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    b4d2:	b672      	cpsid	i
	usb_buffer_available |= mask;
    b4d4:	480a      	ldr	r0, [pc, #40]	; (b500 <usb_free+0x44>)
    b4d6:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    b4da:	6802      	ldr	r2, [r0, #0]
    b4dc:	fa21 f303 	lsr.w	r3, r1, r3
    b4e0:	431a      	orrs	r2, r3
    b4e2:	6002      	str	r2, [r0, #0]
	__enable_irq();
    b4e4:	b662      	cpsie	i
    b4e6:	4770      	bx	lr
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    b4e8:	4a06      	ldr	r2, [pc, #24]	; (b504 <usb_free+0x48>)
    b4ea:	7812      	ldrb	r2, [r2, #0]
    b4ec:	2a00      	cmp	r2, #0
    b4ee:	d0f0      	beq.n	b4d2 <usb_free+0x16>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    b4f0:	f7ff b956 	b.w	a7a0 <usb_rx_memory>
    b4f4:	1fffaf28 	.word	0x1fffaf28
    b4f8:	38e38e39 	.word	0x38e38e39
    b4fc:	20004735 	.word	0x20004735
    b500:	1fffbb04 	.word	0x1fffbb04
    b504:	20004740 	.word	0x20004740

0000b508 <usb_midi_flush_output>:
                usb_midi_write_packed(0x05 | cable | (0xF7 << 8));
	}
}

void usb_midi_flush_output(void)
{
    b508:	b538      	push	{r3, r4, r5, lr}
	if (tx_noautoflush == 0 && tx_packet && tx_packet->index > 0) {
    b50a:	4b08      	ldr	r3, [pc, #32]	; (b52c <usb_midi_flush_output+0x24>)
    b50c:	781c      	ldrb	r4, [r3, #0]
    b50e:	b924      	cbnz	r4, b51a <usb_midi_flush_output+0x12>
    b510:	4d07      	ldr	r5, [pc, #28]	; (b530 <usb_midi_flush_output+0x28>)
    b512:	6829      	ldr	r1, [r5, #0]
    b514:	b109      	cbz	r1, b51a <usb_midi_flush_output+0x12>
    b516:	884b      	ldrh	r3, [r1, #2]
    b518:	b903      	cbnz	r3, b51c <usb_midi_flush_output+0x14>
    b51a:	bd38      	pop	{r3, r4, r5, pc}
		tx_packet->len = tx_packet->index * 4;
    b51c:	009b      	lsls	r3, r3, #2
    b51e:	800b      	strh	r3, [r1, #0]
		usb_tx(MIDI_TX_ENDPOINT, tx_packet);
    b520:	2004      	movs	r0, #4
    b522:	f7ff f985 	bl	a830 <usb_tx>
		tx_packet = NULL;
    b526:	602c      	str	r4, [r5, #0]
    b528:	bd38      	pop	{r3, r4, r5, pc}
    b52a:	bf00      	nop
    b52c:	2000474c 	.word	0x2000474c
    b530:	20004750 	.word	0x20004750

0000b534 <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    b534:	b538      	push	{r3, r4, r5, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    b536:	4d0f      	ldr	r5, [pc, #60]	; (b574 <usb_serial_getchar+0x40>)
    b538:	6828      	ldr	r0, [r5, #0]
    b53a:	b178      	cbz	r0, b55c <usb_serial_getchar+0x28>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    b53c:	8843      	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
    b53e:	8802      	ldrh	r2, [r0, #0]
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    b540:	18c1      	adds	r1, r0, r3
    b542:	3301      	adds	r3, #1
	if (i >= rx_packet->len) {
    b544:	4293      	cmp	r3, r2
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    b546:	7a0c      	ldrb	r4, [r1, #8]
	if (i >= rx_packet->len) {
    b548:	d202      	bcs.n	b550 <usb_serial_getchar+0x1c>
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    b54a:	8043      	strh	r3, [r0, #2]
	}
	return c;
    b54c:	4620      	mov	r0, r4
}
    b54e:	bd38      	pop	{r3, r4, r5, pc}
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
    b550:	f7ff ffb4 	bl	b4bc <usb_free>
		rx_packet = NULL;
    b554:	2300      	movs	r3, #0
	} else {
		rx_packet->index = i;
	}
	return c;
    b556:	4620      	mov	r0, r4
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
		rx_packet = NULL;
    b558:	602b      	str	r3, [r5, #0]
    b55a:	bd38      	pop	{r3, r4, r5, pc}
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    b55c:	4b06      	ldr	r3, [pc, #24]	; (b578 <usb_serial_getchar+0x44>)
    b55e:	781b      	ldrb	r3, [r3, #0]
    b560:	b12b      	cbz	r3, b56e <usb_serial_getchar+0x3a>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    b562:	2002      	movs	r0, #2
    b564:	f7ff f8e8 	bl	a738 <usb_rx>
    b568:	6028      	str	r0, [r5, #0]
		if (!rx_packet) return -1;
    b56a:	2800      	cmp	r0, #0
    b56c:	d1e6      	bne.n	b53c <usb_serial_getchar+0x8>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    b56e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    b572:	bd38      	pop	{r3, r4, r5, pc}
    b574:	20004760 	.word	0x20004760
    b578:	20004740 	.word	0x20004740

0000b57c <usb_serial_peekchar>:
	return c;
}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    b57c:	b510      	push	{r4, lr}
	if (!rx_packet) {
    b57e:	4c09      	ldr	r4, [pc, #36]	; (b5a4 <usb_serial_peekchar+0x28>)
    b580:	6820      	ldr	r0, [r4, #0]
    b582:	b118      	cbz	r0, b58c <usb_serial_peekchar+0x10>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
	return rx_packet->buf[rx_packet->index];
    b584:	8843      	ldrh	r3, [r0, #2]
    b586:	4418      	add	r0, r3
    b588:	7a00      	ldrb	r0, [r0, #8]
}
    b58a:	bd10      	pop	{r4, pc}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    b58c:	4b06      	ldr	r3, [pc, #24]	; (b5a8 <usb_serial_peekchar+0x2c>)
    b58e:	781b      	ldrb	r3, [r3, #0]
    b590:	b12b      	cbz	r3, b59e <usb_serial_peekchar+0x22>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    b592:	2002      	movs	r0, #2
    b594:	f7ff f8d0 	bl	a738 <usb_rx>
    b598:	6020      	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    b59a:	2800      	cmp	r0, #0
    b59c:	d1f2      	bne.n	b584 <usb_serial_peekchar+0x8>

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    b59e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    b5a2:	bd10      	pop	{r4, pc}
    b5a4:	20004760 	.word	0x20004760
    b5a8:	20004740 	.word	0x20004740

0000b5ac <usb_serial_available>:
// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    b5ac:	4b04      	ldr	r3, [pc, #16]	; (b5c0 <usb_serial_available+0x14>)
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    b5ae:	4a05      	ldr	r2, [pc, #20]	; (b5c4 <usb_serial_available+0x18>)
    b5b0:	681b      	ldr	r3, [r3, #0]

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    b5b2:	8850      	ldrh	r0, [r2, #2]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    b5b4:	b11b      	cbz	r3, b5be <usb_serial_available+0x12>
    b5b6:	881a      	ldrh	r2, [r3, #0]
    b5b8:	885b      	ldrh	r3, [r3, #2]
    b5ba:	1ad3      	subs	r3, r2, r3
    b5bc:	4418      	add	r0, r3
	return count;
}
    b5be:	4770      	bx	lr
    b5c0:	20004760 	.word	0x20004760
    b5c4:	20004928 	.word	0x20004928

0000b5c8 <usb_serial_flush_input>:
// discard any buffered input
void usb_serial_flush_input(void)
{
	usb_packet_t *rx;

	if (!usb_configuration) return;
    b5c8:	4b0b      	ldr	r3, [pc, #44]	; (b5f8 <usb_serial_flush_input+0x30>)
    b5ca:	781b      	ldrb	r3, [r3, #0]
    b5cc:	b19b      	cbz	r3, b5f6 <usb_serial_flush_input+0x2e>
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    b5ce:	b510      	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
    b5d0:	4c0a      	ldr	r4, [pc, #40]	; (b5fc <usb_serial_flush_input+0x34>)
    b5d2:	6820      	ldr	r0, [r4, #0]
    b5d4:	b148      	cbz	r0, b5ea <usb_serial_flush_input+0x22>
		usb_free(rx_packet);
    b5d6:	f7ff ff71 	bl	b4bc <usb_free>
		rx_packet = NULL;
    b5da:	2300      	movs	r3, #0
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    b5dc:	2002      	movs	r0, #2
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
    b5de:	6023      	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    b5e0:	f7ff f8aa 	bl	a738 <usb_rx>
		if (!rx) break;
    b5e4:	b130      	cbz	r0, b5f4 <usb_serial_flush_input+0x2c>
		usb_free(rx);
    b5e6:	f7ff ff69 	bl	b4bc <usb_free>
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    b5ea:	2002      	movs	r0, #2
    b5ec:	f7ff f8a4 	bl	a738 <usb_rx>
		if (!rx) break;
    b5f0:	2800      	cmp	r0, #0
    b5f2:	d1f8      	bne.n	b5e6 <usb_serial_flush_input+0x1e>
    b5f4:	bd10      	pop	{r4, pc}
    b5f6:	4770      	bx	lr
    b5f8:	20004740 	.word	0x20004740
    b5fc:	20004760 	.word	0x20004760

0000b600 <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    b600:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    b604:	f8df 90f8 	ldr.w	r9, [pc, #248]	; b700 <usb_serial_write+0x100>
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    b608:	b083      	sub	sp, #12
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    b60a:	2201      	movs	r2, #1
    b60c:	f889 2000 	strb.w	r2, [r9]
	while (size > 0) {
    b610:	9101      	str	r1, [sp, #4]
    b612:	b369      	cbz	r1, b670 <usb_serial_write+0x70>
    b614:	f8df 80ec 	ldr.w	r8, [pc, #236]	; b704 <usb_serial_write+0x104>
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    b618:	4f36      	ldr	r7, [pc, #216]	; (b6f4 <usb_serial_write+0xf4>)
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    b61a:	9e01      	ldr	r6, [sp, #4]
    b61c:	4683      	mov	fp, r0
		if (!tx_packet) {
    b61e:	f8d8 0000 	ldr.w	r0, [r8]
    b622:	b3b0      	cbz	r0, b692 <usb_serial_write+0x92>
    b624:	4d34      	ldr	r5, [pc, #208]	; (b6f8 <usb_serial_write+0xf8>)
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
    b626:	8844      	ldrh	r4, [r0, #2]
    b628:	f1c4 0140 	rsb	r1, r4, #64	; 0x40
    b62c:	42b1      	cmp	r1, r6
    b62e:	bf28      	it	cs
    b630:	4631      	movcs	r1, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    b632:	eb04 0e01 	add.w	lr, r4, r1
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    b636:	2200      	movs	r2, #0
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    b638:	fa1f fe8e 	uxth.w	lr, lr
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    b63c:	702a      	strb	r2, [r5, #0]
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
    b63e:	1a76      	subs	r6, r6, r1
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    b640:	f8a0 e002 	strh.w	lr, [r0, #2]
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
    b644:	f100 0208 	add.w	r2, r0, #8
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
    b648:	b151      	cbz	r1, b660 <usb_serial_write+0x60>
    b64a:	3c01      	subs	r4, #1
    b64c:	4422      	add	r2, r4
    b64e:	4459      	add	r1, fp
    b650:	f81b 4b01 	ldrb.w	r4, [fp], #1
    b654:	f802 4f01 	strb.w	r4, [r2, #1]!
    b658:	458b      	cmp	fp, r1
    b65a:	d1f9      	bne.n	b650 <usb_serial_write+0x50>
    b65c:	f8b0 e002 	ldrh.w	lr, [r0, #2]
		if (tx_packet->index >= CDC_TX_SIZE) {
    b660:	f1be 0f3f 	cmp.w	lr, #63	; 0x3f
    b664:	d80b      	bhi.n	b67e <usb_serial_write+0x7e>
			tx_packet->len = CDC_TX_SIZE;
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    b666:	4a25      	ldr	r2, [pc, #148]	; (b6fc <usb_serial_write+0xfc>)
    b668:	2105      	movs	r1, #5
    b66a:	7011      	strb	r1, [r2, #0]
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    b66c:	2e00      	cmp	r6, #0
    b66e:	d1d6      	bne.n	b61e <usb_serial_write+0x1e>
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
    b670:	9801      	ldr	r0, [sp, #4]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
    b672:	2300      	movs	r3, #0
    b674:	f889 3000 	strb.w	r3, [r9]
	return ret;
}
    b678:	b003      	add	sp, #12
    b67a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
		if (tx_packet->index >= CDC_TX_SIZE) {
			tx_packet->len = CDC_TX_SIZE;
    b67e:	2240      	movs	r2, #64	; 0x40
    b680:	8002      	strh	r2, [r0, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    b682:	4601      	mov	r1, r0
    b684:	2003      	movs	r0, #3
    b686:	f7ff f8d3 	bl	a830 <usb_tx>
			tx_packet = NULL;
    b68a:	2200      	movs	r2, #0
    b68c:	f8c8 2000 	str.w	r2, [r8]
    b690:	e7e9      	b.n	b666 <usb_serial_write+0x66>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    b692:	783a      	ldrb	r2, [r7, #0]
    b694:	b32a      	cbz	r2, b6e2 <usb_serial_write+0xe2>
    b696:	4d18      	ldr	r5, [pc, #96]	; (b6f8 <usb_serial_write+0xf8>)
    b698:	f24d 04e9 	movw	r4, #53481	; 0xd0e9
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
    b69c:	f04f 0a01 	mov.w	sl, #1
    b6a0:	e007      	b.n	b6b2 <usb_serial_write+0xb2>
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    b6a2:	3c01      	subs	r4, #1
    b6a4:	d016      	beq.n	b6d4 <usb_serial_write+0xd4>
    b6a6:	782a      	ldrb	r2, [r5, #0]
    b6a8:	b9a2      	cbnz	r2, b6d4 <usb_serial_write+0xd4>
					transmit_previous_timeout = 1;
					return -1;
				}
				yield();
    b6aa:	f000 f8ad 	bl	b808 <yield>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    b6ae:	783a      	ldrb	r2, [r7, #0]
    b6b0:	b1ba      	cbz	r2, b6e2 <usb_serial_write+0xe2>
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    b6b2:	2003      	movs	r0, #3
    b6b4:	f7ff f85e 	bl	a774 <usb_tx_packet_count>
    b6b8:	2807      	cmp	r0, #7
    b6ba:	d8f2      	bhi.n	b6a2 <usb_serial_write+0xa2>
					tx_noautoflush = 1;
    b6bc:	f889 a000 	strb.w	sl, [r9]
					tx_packet = usb_malloc();
    b6c0:	f7ff fedc 	bl	b47c <usb_malloc>
    b6c4:	f8c8 0000 	str.w	r0, [r8]
					if (tx_packet) break;
    b6c8:	2800      	cmp	r0, #0
    b6ca:	d1ac      	bne.n	b626 <usb_serial_write+0x26>
					tx_noautoflush = 0;
    b6cc:	4b0c      	ldr	r3, [pc, #48]	; (b700 <usb_serial_write+0x100>)
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    b6ce:	3c01      	subs	r4, #1
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
    b6d0:	7018      	strb	r0, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    b6d2:	d1e8      	bne.n	b6a6 <usb_serial_write+0xa6>
					transmit_previous_timeout = 1;
    b6d4:	2301      	movs	r3, #1
					return -1;
    b6d6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
					transmit_previous_timeout = 1;
    b6da:	702b      	strb	r3, [r5, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    b6dc:	b003      	add	sp, #12
    b6de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    b6e2:	2300      	movs	r3, #0
					return -1;
    b6e4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    b6e8:	f889 3000 	strb.w	r3, [r9]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    b6ec:	b003      	add	sp, #12
    b6ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b6f2:	bf00      	nop
    b6f4:	20004740 	.word	0x20004740
    b6f8:	2000475c 	.word	0x2000475c
    b6fc:	20004754 	.word	0x20004754
    b700:	20004755 	.word	0x20004755
    b704:	20004758 	.word	0x20004758

0000b708 <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    b708:	b500      	push	{lr}
    b70a:	b083      	sub	sp, #12
    b70c:	ab02      	add	r3, sp, #8
	return usb_serial_write(&c, 1);
    b70e:	2101      	movs	r1, #1
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    b710:	f803 0d01 	strb.w	r0, [r3, #-1]!
	return usb_serial_write(&c, 1);
    b714:	4618      	mov	r0, r3
    b716:	f7ff ff73 	bl	b600 <usb_serial_write>
}
    b71a:	b003      	add	sp, #12
    b71c:	f85d fb04 	ldr.w	pc, [sp], #4

0000b720 <usb_serial_write_buffer_free>:
	tx_noautoflush = 0;
	return ret;
}

int usb_serial_write_buffer_free(void)
{
    b720:	b538      	push	{r3, r4, r5, lr}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
    b722:	4d0e      	ldr	r5, [pc, #56]	; (b75c <usb_serial_write_buffer_free+0x3c>)

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    b724:	4c0e      	ldr	r4, [pc, #56]	; (b760 <usb_serial_write_buffer_free+0x40>)
	if (!tx_packet) {
    b726:	6828      	ldr	r0, [r5, #0]

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    b728:	2301      	movs	r3, #1
    b72a:	7023      	strb	r3, [r4, #0]
	if (!tx_packet) {
    b72c:	b128      	cbz	r0, b73a <usb_serial_write_buffer_free+0x1a>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    b72e:	8840      	ldrh	r0, [r0, #2]
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    b730:	2300      	movs	r3, #0
    b732:	7023      	strb	r3, [r4, #0]
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    b734:	f1c0 0040 	rsb	r0, r0, #64	; 0x40
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
	return len;
}
    b738:	bd38      	pop	{r3, r4, r5, pc}
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    b73a:	4b0a      	ldr	r3, [pc, #40]	; (b764 <usb_serial_write_buffer_free+0x44>)
    b73c:	781b      	ldrb	r3, [r3, #0]
    b73e:	b913      	cbnz	r3, b746 <usb_serial_write_buffer_free+0x26>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    b740:	2000      	movs	r0, #0
    b742:	7020      	strb	r0, [r4, #0]
			return 0;
    b744:	bd38      	pop	{r3, r4, r5, pc}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    b746:	2003      	movs	r0, #3
    b748:	f7ff f814 	bl	a774 <usb_tx_packet_count>
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    b74c:	2807      	cmp	r0, #7
    b74e:	d8f7      	bhi.n	b740 <usb_serial_write_buffer_free+0x20>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
    b750:	f7ff fe94 	bl	b47c <usb_malloc>
    b754:	6028      	str	r0, [r5, #0]
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    b756:	2800      	cmp	r0, #0
    b758:	d1e9      	bne.n	b72e <usb_serial_write_buffer_free+0xe>
    b75a:	e7f1      	b.n	b740 <usb_serial_write_buffer_free+0x20>
    b75c:	20004758 	.word	0x20004758
    b760:	20004755 	.word	0x20004755
    b764:	20004740 	.word	0x20004740

0000b768 <usb_serial_flush_output>:
	tx_noautoflush = 0;
	return len;
}

void usb_serial_flush_output(void)
{
    b768:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!usb_configuration) return;
    b76a:	4b11      	ldr	r3, [pc, #68]	; (b7b0 <usb_serial_flush_output+0x48>)
    b76c:	781b      	ldrb	r3, [r3, #0]
    b76e:	b18b      	cbz	r3, b794 <usb_serial_flush_output+0x2c>
	tx_noautoflush = 1;
	if (tx_packet) {
    b770:	4e10      	ldr	r6, [pc, #64]	; (b7b4 <usb_serial_flush_output+0x4c>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    b772:	4d11      	ldr	r5, [pc, #68]	; (b7b8 <usb_serial_flush_output+0x50>)
	if (tx_packet) {
    b774:	6834      	ldr	r4, [r6, #0]
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    b776:	2701      	movs	r7, #1
    b778:	702f      	strb	r7, [r5, #0]
	if (tx_packet) {
    b77a:	b164      	cbz	r4, b796 <usb_serial_flush_output+0x2e>
		usb_cdc_transmit_flush_timer = 0;
    b77c:	4a0f      	ldr	r2, [pc, #60]	; (b7bc <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
    b77e:	8863      	ldrh	r3, [r4, #2]
void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
    b780:	2700      	movs	r7, #0
    b782:	7017      	strb	r7, [r2, #0]
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    b784:	4621      	mov	r1, r4
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
    b786:	8023      	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    b788:	2003      	movs	r0, #3
    b78a:	f7ff f851 	bl	a830 <usb_tx>
		tx_packet = NULL;
    b78e:	6037      	str	r7, [r6, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
	tx_noautoflush = 0;
    b790:	2300      	movs	r3, #0
    b792:	702b      	strb	r3, [r5, #0]
    b794:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    b796:	f7ff fe71 	bl	b47c <usb_malloc>
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    b79a:	4b08      	ldr	r3, [pc, #32]	; (b7bc <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
    b79c:	b128      	cbz	r0, b7aa <usb_serial_flush_output+0x42>
			usb_cdc_transmit_flush_timer = 0;
			usb_tx(CDC_TX_ENDPOINT, tx);
    b79e:	4601      	mov	r1, r0
    b7a0:	2003      	movs	r0, #3
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    b7a2:	701c      	strb	r4, [r3, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    b7a4:	f7ff f844 	bl	a830 <usb_tx>
    b7a8:	e7f2      	b.n	b790 <usb_serial_flush_output+0x28>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    b7aa:	701f      	strb	r7, [r3, #0]
    b7ac:	e7f0      	b.n	b790 <usb_serial_flush_output+0x28>
    b7ae:	bf00      	nop
    b7b0:	20004740 	.word	0x20004740
    b7b4:	20004758 	.word	0x20004758
    b7b8:	20004755 	.word	0x20004755
    b7bc:	20004754 	.word	0x20004754

0000b7c0 <usb_serial_flush_callback>:
	}
	tx_noautoflush = 0;
}

void usb_serial_flush_callback(void)
{
    b7c0:	b538      	push	{r3, r4, r5, lr}
	if (tx_noautoflush) return;
    b7c2:	4b0e      	ldr	r3, [pc, #56]	; (b7fc <usb_serial_flush_callback+0x3c>)
    b7c4:	781b      	ldrb	r3, [r3, #0]
    b7c6:	b973      	cbnz	r3, b7e6 <usb_serial_flush_callback+0x26>
	if (tx_packet) {
    b7c8:	4c0d      	ldr	r4, [pc, #52]	; (b800 <usb_serial_flush_callback+0x40>)
    b7ca:	6821      	ldr	r1, [r4, #0]
    b7cc:	b161      	cbz	r1, b7e8 <usb_serial_flush_callback+0x28>
    b7ce:	f003 05ff 	and.w	r5, r3, #255	; 0xff
		tx_packet->len = tx_packet->index;
    b7d2:	884b      	ldrh	r3, [r1, #2]
    b7d4:	800b      	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    b7d6:	2003      	movs	r0, #3
    b7d8:	f7ff f82a 	bl	a830 <usb_tx>
		tx_packet = NULL;
    b7dc:	6025      	str	r5, [r4, #0]
    b7de:	bd38      	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
    b7e0:	4b08      	ldr	r3, [pc, #32]	; (b804 <usb_serial_flush_callback+0x44>)
    b7e2:	2201      	movs	r2, #1
    b7e4:	701a      	strb	r2, [r3, #0]
    b7e6:	bd38      	pop	{r3, r4, r5, pc}
	if (tx_packet) {
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    b7e8:	f7ff fe48 	bl	b47c <usb_malloc>
		if (tx) {
    b7ec:	2800      	cmp	r0, #0
    b7ee:	d0f7      	beq.n	b7e0 <usb_serial_flush_callback+0x20>
			usb_tx(CDC_TX_ENDPOINT, tx);
    b7f0:	4601      	mov	r1, r0
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    b7f2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
    b7f6:	2003      	movs	r0, #3
    b7f8:	f7ff b81a 	b.w	a830 <usb_tx>
    b7fc:	20004755 	.word	0x20004755
    b800:	20004758 	.word	0x20004758
    b804:	20004754 	.word	0x20004754

0000b808 <yield>:
#include <Arduino.h>
#include "EventResponder.h"

void yield(void) __attribute__ ((weak));
void yield(void)
{
    b808:	b538      	push	{r3, r4, r5, lr}
	static uint8_t running=0;

	if (running) return; // TODO: does this need to be atomic?
    b80a:	4c22      	ldr	r4, [pc, #136]	; (b894 <yield+0x8c>)
    b80c:	7823      	ldrb	r3, [r4, #0]
    b80e:	b103      	cbz	r3, b812 <yield+0xa>
    b810:	bd38      	pop	{r3, r4, r5, pc}
	running = 1;
    b812:	2301      	movs	r3, #1
    b814:	7023      	strb	r3, [r4, #0]
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    b816:	f7ff fec9 	bl	b5ac <usb_serial_available>
	if (Serial.available()) serialEvent();
    b81a:	bb70      	cbnz	r0, b87a <yield+0x72>
	virtual void transmitterEnable(uint8_t pin) { serial_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial_set_cts(pin); }
	virtual int available(void)     { return serial_available(); }
    b81c:	f000 f848 	bl	b8b0 <serial_available>
	if (Serial1.available()) serialEvent1();
    b820:	bb40      	cbnz	r0, b874 <yield+0x6c>
	virtual void transmitterEnable(uint8_t pin) { serial2_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial2_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial2_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial2_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial2_set_cts(pin); }
	virtual int available(void)     { return serial2_available(); }
    b822:	f000 f8db 	bl	b9dc <serial2_available>
	if (Serial2.available()) serialEvent2();
    b826:	bb10      	cbnz	r0, b86e <yield+0x66>
	virtual void transmitterEnable(uint8_t pin) { serial3_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial3_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial3_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial3_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial3_set_cts(pin); }
	virtual int available(void)     { return serial3_available(); }
    b828:	f000 f96e 	bl	bb08 <serial3_available>
	if (Serial3.available()) serialEvent3();
    b82c:	b9e0      	cbnz	r0, b868 <yield+0x60>
	if (Serial5.available()) serialEvent5();
#endif
#if defined(HAS_KINETISK_UART5) || defined (HAS_KINETISK_LPUART0)
	if (Serial6.available()) serialEvent6();
#endif
	running = 0;
    b82e:	2300      	movs	r3, #0
    b830:	7023      	strb	r3, [r4, #0]

	static void runFromYield() {
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    b832:	f3ef 8305 	mrs	r3, IPSR
		if (ipsr != 0) return;
    b836:	2b00      	cmp	r3, #0
    b838:	d1ea      	bne.n	b810 <yield+0x8>
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    b83a:	f3ef 8110 	mrs	r1, PRIMASK
		__disable_irq();
    b83e:	b672      	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    b840:	4b15      	ldr	r3, [pc, #84]	; (b898 <yield+0x90>)
    b842:	6818      	ldr	r0, [r3, #0]
		if (first == nullptr) {
    b844:	b1e0      	cbz	r0, b880 <yield+0x78>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    b846:	4c15      	ldr	r4, [pc, #84]	; (b89c <yield+0x94>)
    b848:	7822      	ldrb	r2, [r4, #0]
    b84a:	b9ca      	cbnz	r2, b880 <yield+0x78>
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
		firstYield = first->_next;
    b84c:	6945      	ldr	r5, [r0, #20]
    b84e:	601d      	str	r5, [r3, #0]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    b850:	2301      	movs	r3, #1
    b852:	7023      	strb	r3, [r4, #0]
		firstYield = first->_next;
		if (firstYield) {
    b854:	b1c5      	cbz	r5, b888 <yield+0x80>
			firstYield->_prev = nullptr;
    b856:	61aa      	str	r2, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    b858:	b901      	cbnz	r1, b85c <yield+0x54>
    b85a:	b662      	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    b85c:	2500      	movs	r5, #0
    b85e:	7745      	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    b860:	6883      	ldr	r3, [r0, #8]
    b862:	4798      	blx	r3
		runningFromYield = false;
    b864:	7025      	strb	r5, [r4, #0]
    b866:	e7d3      	b.n	b810 <yield+0x8>
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
	if (Serial.available()) serialEvent();
	if (Serial1.available()) serialEvent1();
	if (Serial2.available()) serialEvent2();
	if (Serial3.available()) serialEvent3();
    b868:	f000 f820 	bl	b8ac <serialEvent3()>
    b86c:	e7df      	b.n	b82e <yield+0x26>

	if (running) return; // TODO: does this need to be atomic?
	running = 1;
	if (Serial.available()) serialEvent();
	if (Serial1.available()) serialEvent1();
	if (Serial2.available()) serialEvent2();
    b86e:	f000 f81b 	bl	b8a8 <serialEvent2()>
    b872:	e7d9      	b.n	b828 <yield+0x20>
	static uint8_t running=0;

	if (running) return; // TODO: does this need to be atomic?
	running = 1;
	if (Serial.available()) serialEvent();
	if (Serial1.available()) serialEvent1();
    b874:	f000 f816 	bl	b8a4 <serialEvent1()>
    b878:	e7d3      	b.n	b822 <yield+0x1a>
{
	static uint8_t running=0;

	if (running) return; // TODO: does this need to be atomic?
	running = 1;
	if (Serial.available()) serialEvent();
    b87a:	f7ff fdfd 	bl	b478 <serialEvent()>
    b87e:	e7cd      	b.n	b81c <yield+0x14>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    b880:	2900      	cmp	r1, #0
    b882:	d1c5      	bne.n	b810 <yield+0x8>
    b884:	b662      	cpsie	i
    b886:	bd38      	pop	{r3, r4, r5, pc}
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    b888:	4b05      	ldr	r3, [pc, #20]	; (b8a0 <yield+0x98>)
    b88a:	601d      	str	r5, [r3, #0]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    b88c:	2900      	cmp	r1, #0
    b88e:	d1e5      	bne.n	b85c <yield+0x54>
    b890:	e7e3      	b.n	b85a <yield+0x52>
    b892:	bf00      	nop
    b894:	20004765 	.word	0x20004765
    b898:	200045dc 	.word	0x200045dc
    b89c:	200045e0 	.word	0x200045e0
    b8a0:	200045d8 	.word	0x200045d8

0000b8a4 <serialEvent1()>:
#include "HardwareSerial.h"

HardwareSerial Serial1;

void serialEvent1() __attribute__((weak));
void serialEvent1() {}
    b8a4:	4770      	bx	lr
    b8a6:	bf00      	nop

0000b8a8 <serialEvent2()>:
#include "HardwareSerial.h"

HardwareSerial2 Serial2;

void serialEvent2() __attribute__((weak));
void serialEvent2() {}
    b8a8:	4770      	bx	lr
    b8aa:	bf00      	nop

0000b8ac <serialEvent3()>:
#include "HardwareSerial.h"

HardwareSerial3 Serial3;

void serialEvent3() __attribute__((weak));
void serialEvent3() {}
    b8ac:	4770      	bx	lr
    b8ae:	bf00      	nop

0000b8b0 <serial_available>:

int serial_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    b8b0:	4a05      	ldr	r2, [pc, #20]	; (b8c8 <serial_available+0x18>)
	tail = rx_buffer_tail;
    b8b2:	4b06      	ldr	r3, [pc, #24]	; (b8cc <serial_available+0x1c>)

int serial_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    b8b4:	7810      	ldrb	r0, [r2, #0]
	tail = rx_buffer_tail;
    b8b6:	781b      	ldrb	r3, [r3, #0]

int serial_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    b8b8:	b2c0      	uxtb	r0, r0
	tail = rx_buffer_tail;
    b8ba:	b2db      	uxtb	r3, r3
	if (head >= tail) return head - tail;
    b8bc:	4298      	cmp	r0, r3
	return SERIAL1_RX_BUFFER_SIZE + head - tail;
    b8be:	bf38      	it	cc
    b8c0:	3040      	addcc	r0, #64	; 0x40
    b8c2:	1ac0      	subs	r0, r0, r3
}
    b8c4:	4770      	bx	lr
    b8c6:	bf00      	nop
    b8c8:	2000476c 	.word	0x2000476c
    b8cc:	2000476d 	.word	0x2000476d

0000b8d0 <uart0_status_isr>:
//   Receive data above watermark   UART_S1_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void uart0_status_isr(void)
{
    b8d0:	b4f0      	push	{r4, r5, r6, r7}
	uint8_t c;
#ifdef HAS_KINETISK_UART0_FIFO
	uint32_t newhead;
	uint8_t avail;

	if (UART0_S1 & (UART_S1_RDRF | UART_S1_IDLE)) {
    b8d2:	4b38      	ldr	r3, [pc, #224]	; (b9b4 <uart0_status_isr+0xe4>)
    b8d4:	791a      	ldrb	r2, [r3, #4]
    b8d6:	f012 0f30 	tst.w	r2, #48	; 0x30
    b8da:	d02c      	beq.n	b936 <uart0_status_isr+0x66>
		__disable_irq();
    b8dc:	b672      	cpsid	i
		avail = UART0_RCFIFO;
    b8de:	7d99      	ldrb	r1, [r3, #22]
		if (avail == 0) {
    b8e0:	f001 02ff 	and.w	r2, r1, #255	; 0xff
    b8e4:	2900      	cmp	r1, #0
    b8e6:	d03d      	beq.n	b964 <uart0_status_isr+0x94>
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
    b8e8:	b662      	cpsie	i
			head = rx_buffer_head;
    b8ea:	4f33      	ldr	r7, [pc, #204]	; (b9b8 <uart0_status_isr+0xe8>)
			tail = rx_buffer_tail;
    b8ec:	4933      	ldr	r1, [pc, #204]	; (b9bc <uart0_status_isr+0xec>)
			// which transmit interrupts are enabled.
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
			head = rx_buffer_head;
    b8ee:	7838      	ldrb	r0, [r7, #0]
			tail = rx_buffer_tail;
    b8f0:	780d      	ldrb	r5, [r1, #0]
				}
				newhead = head + 1;
				if (newhead >= SERIAL1_RX_BUFFER_SIZE) newhead = 0;
				if (newhead != tail) {
					head = newhead;
					rx_buffer[head] = n;
    b8f2:	4e33      	ldr	r6, [pc, #204]	; (b9c0 <uart0_status_isr+0xf0>)
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART0_C3 & 0x80)) {
					n = UART0_D | 0x100;
				} else {
					n = UART0_D;
    b8f4:	461c      	mov	r4, r3
			// which transmit interrupts are enabled.
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
			head = rx_buffer_head;
    b8f6:	b2c0      	uxtb	r0, r0
			tail = rx_buffer_tail;
    b8f8:	b2ed      	uxtb	r5, r5
				if (use9Bits && (UART0_C3 & 0x80)) {
					n = UART0_D | 0x100;
				} else {
					n = UART0_D;
				}
				newhead = head + 1;
    b8fa:	1c43      	adds	r3, r0, #1
				if (newhead >= SERIAL1_RX_BUFFER_SIZE) newhead = 0;
    b8fc:	2b40      	cmp	r3, #64	; 0x40
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART0_C3 & 0x80)) {
					n = UART0_D | 0x100;
				} else {
					n = UART0_D;
    b8fe:	79e1      	ldrb	r1, [r4, #7]
				}
				newhead = head + 1;
				if (newhead >= SERIAL1_RX_BUFFER_SIZE) newhead = 0;
    b900:	bf28      	it	cs
    b902:	2300      	movcs	r3, #0
				if (newhead != tail) {
    b904:	42ab      	cmp	r3, r5
					head = newhead;
					rx_buffer[head] = n;
				}
			} while (--avail > 0);
    b906:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART0_C3 & 0x80)) {
					n = UART0_D | 0x100;
				} else {
					n = UART0_D;
    b90a:	b2c9      	uxtb	r1, r1
				}
				newhead = head + 1;
				if (newhead >= SERIAL1_RX_BUFFER_SIZE) newhead = 0;
				if (newhead != tail) {
					head = newhead;
					rx_buffer[head] = n;
    b90c:	bf1c      	itt	ne
    b90e:	54f1      	strbne	r1, [r6, r3]
    b910:	4618      	movne	r0, r3
				}
			} while (--avail > 0);
    b912:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
    b916:	d1f0      	bne.n	b8fa <uart0_status_isr+0x2a>
			rx_buffer_head = head;
			if (rts_pin) {
    b918:	4b2a      	ldr	r3, [pc, #168]	; (b9c4 <uart0_status_isr+0xf4>)
    b91a:	681b      	ldr	r3, [r3, #0]
				if (newhead != tail) {
					head = newhead;
					rx_buffer[head] = n;
				}
			} while (--avail > 0);
			rx_buffer_head = head;
    b91c:	b2c2      	uxtb	r2, r0
    b91e:	703a      	strb	r2, [r7, #0]
			if (rts_pin) {
    b920:	b14b      	cbz	r3, b936 <uart0_status_isr+0x66>
				int avail;
				if (head >= tail) avail = head - tail;
    b922:	42a8      	cmp	r0, r5
				else avail = SERIAL1_RX_BUFFER_SIZE + head - tail;
    b924:	bf36      	itet	cc
    b926:	f1c5 0540 	rsbcc	r5, r5, #64	; 0x40
				}
			} while (--avail > 0);
			rx_buffer_head = head;
			if (rts_pin) {
				int avail;
				if (head >= tail) avail = head - tail;
    b92a:	1b40      	subcs	r0, r0, r5
				else avail = SERIAL1_RX_BUFFER_SIZE + head - tail;
    b92c:	1940      	addcc	r0, r0, r5
				if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
    b92e:	2827      	cmp	r0, #39	; 0x27
    b930:	bfc4      	itt	gt
    b932:	2201      	movgt	r2, #1
    b934:	701a      	strbgt	r2, [r3, #0]
			}
		}
	}
	c = UART0_C2;
    b936:	491f      	ldr	r1, [pc, #124]	; (b9b4 <uart0_status_isr+0xe4>)
    b938:	78ca      	ldrb	r2, [r1, #3]
    b93a:	b2d2      	uxtb	r2, r2
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
    b93c:	0615      	lsls	r5, r2, #24
    b93e:	d416      	bmi.n	b96e <uart0_status_isr+0x9e>
			UART0_D = n;
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART0_S1 & UART_S1_TC)) {
    b940:	0652      	lsls	r2, r2, #25
    b942:	d50d      	bpl.n	b960 <uart0_status_isr+0x90>
    b944:	4b1b      	ldr	r3, [pc, #108]	; (b9b4 <uart0_status_isr+0xe4>)
    b946:	791b      	ldrb	r3, [r3, #4]
    b948:	065b      	lsls	r3, r3, #25
    b94a:	d509      	bpl.n	b960 <uart0_status_isr+0x90>
		transmitting = 0;
		if (transmit_pin) transmit_deassert();
    b94c:	4b1e      	ldr	r3, [pc, #120]	; (b9c8 <uart0_status_isr+0xf8>)
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART0_S1 & UART_S1_TC)) {
		transmitting = 0;
    b94e:	491f      	ldr	r1, [pc, #124]	; (b9cc <uart0_status_isr+0xfc>)
		if (transmit_pin) transmit_deassert();
    b950:	681b      	ldr	r3, [r3, #0]
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART0_S1 & UART_S1_TC)) {
		transmitting = 0;
    b952:	2200      	movs	r2, #0
    b954:	700a      	strb	r2, [r1, #0]
		if (transmit_pin) transmit_deassert();
    b956:	b103      	cbz	r3, b95a <uart0_status_isr+0x8a>
    b958:	701a      	strb	r2, [r3, #0]
		UART0_C2 = C2_TX_INACTIVE;
    b95a:	4b16      	ldr	r3, [pc, #88]	; (b9b4 <uart0_status_isr+0xe4>)
    b95c:	223c      	movs	r2, #60	; 0x3c
    b95e:	70da      	strb	r2, [r3, #3]
	}
}
    b960:	bcf0      	pop	{r4, r5, r6, r7}
    b962:	4770      	bx	lr
			// the chance, interrupts are disabled so a higher
			// priority interrupt (hopefully) doesn't delay.
			// TODO: change this to disabling the IDLE interrupt
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
    b964:	2240      	movs	r2, #64	; 0x40
			// to read the data register.  But reading with no
			// data causes a FIFO underrun, which causes the
			// FIFO to return corrupted data.  If anyone from
			// Freescale reads this, what a poor design!  There
			// write should be a write-1-to-clear for IDLE.
			c = UART0_D;
    b966:	79d9      	ldrb	r1, [r3, #7]
			// the chance, interrupts are disabled so a higher
			// priority interrupt (hopefully) doesn't delay.
			// TODO: change this to disabling the IDLE interrupt
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
    b968:	745a      	strb	r2, [r3, #17]
			__enable_irq();
    b96a:	b662      	cpsie	i
    b96c:	e7e3      	b.n	b936 <uart0_status_isr+0x66>
				if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
			}
		}
	}
	c = UART0_C2;
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
    b96e:	790b      	ldrb	r3, [r1, #4]
    b970:	061c      	lsls	r4, r3, #24
    b972:	d5e5      	bpl.n	b940 <uart0_status_isr+0x70>
		head = tx_buffer_head;
    b974:	4b16      	ldr	r3, [pc, #88]	; (b9d0 <uart0_status_isr+0x100>)
		tail = tx_buffer_tail;
    b976:	4e17      	ldr	r6, [pc, #92]	; (b9d4 <uart0_status_isr+0x104>)
			}
		}
	}
	c = UART0_C2;
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    b978:	781c      	ldrb	r4, [r3, #0]
		tail = tx_buffer_tail;
    b97a:	7833      	ldrb	r3, [r6, #0]
			}
		}
	}
	c = UART0_C2;
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    b97c:	b2e4      	uxtb	r4, r4
		tail = tx_buffer_tail;
    b97e:	b2db      	uxtb	r3, r3
		do {
			if (tail == head) break;
    b980:	429c      	cmp	r4, r3
    b982:	d00e      	beq.n	b9a2 <uart0_status_isr+0xd2>
    b984:	4d14      	ldr	r5, [pc, #80]	; (b9d8 <uart0_status_isr+0x108>)
    b986:	e001      	b.n	b98c <uart0_status_isr+0xbc>
    b988:	42a3      	cmp	r3, r4
    b98a:	d00a      	beq.n	b9a2 <uart0_status_isr+0xd2>
			if (++tail >= SERIAL1_TX_BUFFER_SIZE) tail = 0;
    b98c:	3301      	adds	r3, #1
    b98e:	2b40      	cmp	r3, #64	; 0x40
    b990:	bf28      	it	cs
    b992:	2300      	movcs	r3, #0
			avail = UART0_S1;
    b994:	7908      	ldrb	r0, [r1, #4]
			n = tx_buffer[tail];
    b996:	5ce8      	ldrb	r0, [r5, r3]
    b998:	b2c0      	uxtb	r0, r0
			if (use9Bits) UART0_C3 = (UART0_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART0_D = n;
    b99a:	71c8      	strb	r0, [r1, #7]
		} while (UART0_TCFIFO < 8);
    b99c:	7d08      	ldrb	r0, [r1, #20]
    b99e:	2807      	cmp	r0, #7
    b9a0:	d9f2      	bls.n	b988 <uart0_status_isr+0xb8>
		tx_buffer_tail = tail;
    b9a2:	b2db      	uxtb	r3, r3
		if (UART0_S1 & UART_S1_TDRE) UART0_C2 = C2_TX_COMPLETING;
    b9a4:	4903      	ldr	r1, [pc, #12]	; (b9b4 <uart0_status_isr+0xe4>)
			avail = UART0_S1;
			n = tx_buffer[tail];
			if (use9Bits) UART0_C3 = (UART0_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART0_D = n;
		} while (UART0_TCFIFO < 8);
		tx_buffer_tail = tail;
    b9a6:	7033      	strb	r3, [r6, #0]
		if (UART0_S1 & UART_S1_TDRE) UART0_C2 = C2_TX_COMPLETING;
    b9a8:	790b      	ldrb	r3, [r1, #4]
    b9aa:	0618      	lsls	r0, r3, #24
    b9ac:	bf44      	itt	mi
    b9ae:	237c      	movmi	r3, #124	; 0x7c
    b9b0:	70cb      	strbmi	r3, [r1, #3]
    b9b2:	e7c5      	b.n	b940 <uart0_status_isr+0x70>
    b9b4:	4006a000 	.word	0x4006a000
    b9b8:	2000476c 	.word	0x2000476c
    b9bc:	2000476d 	.word	0x2000476d
    b9c0:	200047b0 	.word	0x200047b0
    b9c4:	20004768 	.word	0x20004768
    b9c8:	200047f4 	.word	0x200047f4
    b9cc:	200047f0 	.word	0x200047f0
    b9d0:	200047f8 	.word	0x200047f8
    b9d4:	200047f1 	.word	0x200047f1
    b9d8:	20004770 	.word	0x20004770

0000b9dc <serial2_available>:

int serial2_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    b9dc:	4a05      	ldr	r2, [pc, #20]	; (b9f4 <serial2_available+0x18>)
	tail = rx_buffer_tail;
    b9de:	4b06      	ldr	r3, [pc, #24]	; (b9f8 <serial2_available+0x1c>)

int serial2_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    b9e0:	7810      	ldrb	r0, [r2, #0]
	tail = rx_buffer_tail;
    b9e2:	781b      	ldrb	r3, [r3, #0]

int serial2_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    b9e4:	b2c0      	uxtb	r0, r0
	tail = rx_buffer_tail;
    b9e6:	b2db      	uxtb	r3, r3
	if (head >= tail) return head - tail;
    b9e8:	4298      	cmp	r0, r3
	return SERIAL2_RX_BUFFER_SIZE + head - tail;
    b9ea:	bf38      	it	cc
    b9ec:	3040      	addcc	r0, #64	; 0x40
    b9ee:	1ac0      	subs	r0, r0, r3
}
    b9f0:	4770      	bx	lr
    b9f2:	bf00      	nop
    b9f4:	2000486c 	.word	0x2000486c
    b9f8:	20004801 	.word	0x20004801

0000b9fc <uart1_status_isr>:
//   Receive data above watermark   UART_S1_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void uart1_status_isr(void)
{
    b9fc:	b4f0      	push	{r4, r5, r6, r7}
	uint8_t c;
#ifdef HAS_KINETISK_UART1_FIFO
	uint32_t newhead;
	uint8_t avail;

	if (UART1_S1 & (UART_S1_RDRF | UART_S1_IDLE)) {
    b9fe:	4b38      	ldr	r3, [pc, #224]	; (bae0 <uart1_status_isr+0xe4>)
    ba00:	791a      	ldrb	r2, [r3, #4]
    ba02:	f012 0f30 	tst.w	r2, #48	; 0x30
    ba06:	d02c      	beq.n	ba62 <uart1_status_isr+0x66>
		__disable_irq();
    ba08:	b672      	cpsid	i
		avail = UART1_RCFIFO;
    ba0a:	7d99      	ldrb	r1, [r3, #22]
		if (avail == 0) {
    ba0c:	f001 02ff 	and.w	r2, r1, #255	; 0xff
    ba10:	2900      	cmp	r1, #0
    ba12:	d03d      	beq.n	ba90 <uart1_status_isr+0x94>
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART1_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
    ba14:	b662      	cpsie	i
			head = rx_buffer_head;
    ba16:	4f33      	ldr	r7, [pc, #204]	; (bae4 <uart1_status_isr+0xe8>)
			tail = rx_buffer_tail;
    ba18:	4933      	ldr	r1, [pc, #204]	; (bae8 <uart1_status_isr+0xec>)
			// which transmit interrupts are enabled.
			UART1_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
			head = rx_buffer_head;
    ba1a:	7838      	ldrb	r0, [r7, #0]
			tail = rx_buffer_tail;
    ba1c:	780d      	ldrb	r5, [r1, #0]
				}
				newhead = head + 1;
				if (newhead >= SERIAL2_RX_BUFFER_SIZE) newhead = 0;
				if (newhead != tail) {
					head = newhead;
					rx_buffer[head] = n;
    ba1e:	4e33      	ldr	r6, [pc, #204]	; (baec <uart1_status_isr+0xf0>)
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART1_C3 & 0x80)) {
					n = UART1_D | 0x100;
				} else {
					n = UART1_D;
    ba20:	461c      	mov	r4, r3
			// which transmit interrupts are enabled.
			UART1_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
			head = rx_buffer_head;
    ba22:	b2c0      	uxtb	r0, r0
			tail = rx_buffer_tail;
    ba24:	b2ed      	uxtb	r5, r5
				if (use9Bits && (UART1_C3 & 0x80)) {
					n = UART1_D | 0x100;
				} else {
					n = UART1_D;
				}
				newhead = head + 1;
    ba26:	1c43      	adds	r3, r0, #1
				if (newhead >= SERIAL2_RX_BUFFER_SIZE) newhead = 0;
    ba28:	2b40      	cmp	r3, #64	; 0x40
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART1_C3 & 0x80)) {
					n = UART1_D | 0x100;
				} else {
					n = UART1_D;
    ba2a:	79e1      	ldrb	r1, [r4, #7]
				}
				newhead = head + 1;
				if (newhead >= SERIAL2_RX_BUFFER_SIZE) newhead = 0;
    ba2c:	bf28      	it	cs
    ba2e:	2300      	movcs	r3, #0
				if (newhead != tail) {
    ba30:	42ab      	cmp	r3, r5
					head = newhead;
					rx_buffer[head] = n;
				}
			} while (--avail > 0);
    ba32:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART1_C3 & 0x80)) {
					n = UART1_D | 0x100;
				} else {
					n = UART1_D;
    ba36:	b2c9      	uxtb	r1, r1
				}
				newhead = head + 1;
				if (newhead >= SERIAL2_RX_BUFFER_SIZE) newhead = 0;
				if (newhead != tail) {
					head = newhead;
					rx_buffer[head] = n;
    ba38:	bf1c      	itt	ne
    ba3a:	54f1      	strbne	r1, [r6, r3]
    ba3c:	4618      	movne	r0, r3
				}
			} while (--avail > 0);
    ba3e:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
    ba42:	d1f0      	bne.n	ba26 <uart1_status_isr+0x2a>
			rx_buffer_head = head;
			if (rts_pin) {
    ba44:	4b2a      	ldr	r3, [pc, #168]	; (baf0 <uart1_status_isr+0xf4>)
    ba46:	681b      	ldr	r3, [r3, #0]
				if (newhead != tail) {
					head = newhead;
					rx_buffer[head] = n;
				}
			} while (--avail > 0);
			rx_buffer_head = head;
    ba48:	b2c2      	uxtb	r2, r0
    ba4a:	703a      	strb	r2, [r7, #0]
			if (rts_pin) {
    ba4c:	b14b      	cbz	r3, ba62 <uart1_status_isr+0x66>
				int avail;
				if (head >= tail) avail = head - tail;
    ba4e:	42a8      	cmp	r0, r5
				else avail = SERIAL2_RX_BUFFER_SIZE + head - tail;
    ba50:	bf36      	itet	cc
    ba52:	f1c5 0540 	rsbcc	r5, r5, #64	; 0x40
				}
			} while (--avail > 0);
			rx_buffer_head = head;
			if (rts_pin) {
				int avail;
				if (head >= tail) avail = head - tail;
    ba56:	1b40      	subcs	r0, r0, r5
				else avail = SERIAL2_RX_BUFFER_SIZE + head - tail;
    ba58:	1940      	addcc	r0, r0, r5
				if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
    ba5a:	2827      	cmp	r0, #39	; 0x27
    ba5c:	bfc4      	itt	gt
    ba5e:	2201      	movgt	r2, #1
    ba60:	701a      	strbgt	r2, [r3, #0]
			}
		}
	}
	c = UART1_C2;
    ba62:	491f      	ldr	r1, [pc, #124]	; (bae0 <uart1_status_isr+0xe4>)
    ba64:	78ca      	ldrb	r2, [r1, #3]
    ba66:	b2d2      	uxtb	r2, r2
	if ((c & UART_C2_TIE) && (UART1_S1 & UART_S1_TDRE)) {
    ba68:	0615      	lsls	r5, r2, #24
    ba6a:	d416      	bmi.n	ba9a <uart1_status_isr+0x9e>
			UART1_D = n;
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART1_S1 & UART_S1_TC)) {
    ba6c:	0652      	lsls	r2, r2, #25
    ba6e:	d50d      	bpl.n	ba8c <uart1_status_isr+0x90>
    ba70:	4b1b      	ldr	r3, [pc, #108]	; (bae0 <uart1_status_isr+0xe4>)
    ba72:	791b      	ldrb	r3, [r3, #4]
    ba74:	065b      	lsls	r3, r3, #25
    ba76:	d509      	bpl.n	ba8c <uart1_status_isr+0x90>
		transmitting = 0;
		if (transmit_pin) transmit_deassert();
    ba78:	4b1e      	ldr	r3, [pc, #120]	; (baf4 <uart1_status_isr+0xf8>)
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART1_S1 & UART_S1_TC)) {
		transmitting = 0;
    ba7a:	491f      	ldr	r1, [pc, #124]	; (baf8 <uart1_status_isr+0xfc>)
		if (transmit_pin) transmit_deassert();
    ba7c:	681b      	ldr	r3, [r3, #0]
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART1_S1 & UART_S1_TC)) {
		transmitting = 0;
    ba7e:	2200      	movs	r2, #0
    ba80:	700a      	strb	r2, [r1, #0]
		if (transmit_pin) transmit_deassert();
    ba82:	b103      	cbz	r3, ba86 <uart1_status_isr+0x8a>
    ba84:	701a      	strb	r2, [r3, #0]
		UART1_C2 = C2_TX_INACTIVE;
    ba86:	4b16      	ldr	r3, [pc, #88]	; (bae0 <uart1_status_isr+0xe4>)
    ba88:	223c      	movs	r2, #60	; 0x3c
    ba8a:	70da      	strb	r2, [r3, #3]
	}
}
    ba8c:	bcf0      	pop	{r4, r5, r6, r7}
    ba8e:	4770      	bx	lr
			// the chance, interrupts are disabled so a higher
			// priority interrupt (hopefully) doesn't delay.
			// TODO: change this to disabling the IDLE interrupt
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART1_CFIFO = UART_CFIFO_RXFLUSH;
    ba90:	2240      	movs	r2, #64	; 0x40
			// to read the data register.  But reading with no
			// data causes a FIFO underrun, which causes the
			// FIFO to return corrupted data.  If anyone from
			// Freescale reads this, what a poor design!  There
			// write should be a write-1-to-clear for IDLE.
			c = UART1_D;
    ba92:	79d9      	ldrb	r1, [r3, #7]
			// the chance, interrupts are disabled so a higher
			// priority interrupt (hopefully) doesn't delay.
			// TODO: change this to disabling the IDLE interrupt
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART1_CFIFO = UART_CFIFO_RXFLUSH;
    ba94:	745a      	strb	r2, [r3, #17]
			__enable_irq();
    ba96:	b662      	cpsie	i
    ba98:	e7e3      	b.n	ba62 <uart1_status_isr+0x66>
				if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
			}
		}
	}
	c = UART1_C2;
	if ((c & UART_C2_TIE) && (UART1_S1 & UART_S1_TDRE)) {
    ba9a:	790b      	ldrb	r3, [r1, #4]
    ba9c:	061c      	lsls	r4, r3, #24
    ba9e:	d5e5      	bpl.n	ba6c <uart1_status_isr+0x70>
		head = tx_buffer_head;
    baa0:	4b16      	ldr	r3, [pc, #88]	; (bafc <uart1_status_isr+0x100>)
		tail = tx_buffer_tail;
    baa2:	4e17      	ldr	r6, [pc, #92]	; (bb00 <uart1_status_isr+0x104>)
			}
		}
	}
	c = UART1_C2;
	if ((c & UART_C2_TIE) && (UART1_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    baa4:	781c      	ldrb	r4, [r3, #0]
		tail = tx_buffer_tail;
    baa6:	7833      	ldrb	r3, [r6, #0]
			}
		}
	}
	c = UART1_C2;
	if ((c & UART_C2_TIE) && (UART1_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    baa8:	b2e4      	uxtb	r4, r4
		tail = tx_buffer_tail;
    baaa:	b2db      	uxtb	r3, r3
		do {
			if (tail == head) break;
    baac:	429c      	cmp	r4, r3
    baae:	d00e      	beq.n	bace <uart1_status_isr+0xd2>
    bab0:	4d14      	ldr	r5, [pc, #80]	; (bb04 <uart1_status_isr+0x108>)
    bab2:	e001      	b.n	bab8 <uart1_status_isr+0xbc>
    bab4:	42a3      	cmp	r3, r4
    bab6:	d00a      	beq.n	bace <uart1_status_isr+0xd2>
			if (++tail >= SERIAL2_TX_BUFFER_SIZE) tail = 0;
    bab8:	3301      	adds	r3, #1
    baba:	2b28      	cmp	r3, #40	; 0x28
    babc:	bf28      	it	cs
    babe:	2300      	movcs	r3, #0
			avail = UART1_S1;
    bac0:	7908      	ldrb	r0, [r1, #4]
			n = tx_buffer[tail];
    bac2:	5ce8      	ldrb	r0, [r5, r3]
    bac4:	b2c0      	uxtb	r0, r0
			if (use9Bits) UART1_C3 = (UART1_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART1_D = n;
    bac6:	71c8      	strb	r0, [r1, #7]
		} while (UART1_TCFIFO < 8);
    bac8:	7d08      	ldrb	r0, [r1, #20]
    baca:	2807      	cmp	r0, #7
    bacc:	d9f2      	bls.n	bab4 <uart1_status_isr+0xb8>
		tx_buffer_tail = tail;
    bace:	b2db      	uxtb	r3, r3
		if (UART1_S1 & UART_S1_TDRE) UART1_C2 = C2_TX_COMPLETING;
    bad0:	4903      	ldr	r1, [pc, #12]	; (bae0 <uart1_status_isr+0xe4>)
			avail = UART1_S1;
			n = tx_buffer[tail];
			if (use9Bits) UART1_C3 = (UART1_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART1_D = n;
		} while (UART1_TCFIFO < 8);
		tx_buffer_tail = tail;
    bad2:	7033      	strb	r3, [r6, #0]
		if (UART1_S1 & UART_S1_TDRE) UART1_C2 = C2_TX_COMPLETING;
    bad4:	790b      	ldrb	r3, [r1, #4]
    bad6:	0618      	lsls	r0, r3, #24
    bad8:	bf44      	itt	mi
    bada:	237c      	movmi	r3, #124	; 0x7c
    badc:	70cb      	strbmi	r3, [r1, #3]
    bade:	e7c5      	b.n	ba6c <uart1_status_isr+0x70>
    bae0:	4006b000 	.word	0x4006b000
    bae4:	2000486c 	.word	0x2000486c
    bae8:	20004801 	.word	0x20004801
    baec:	2000482c 	.word	0x2000482c
    baf0:	200047fc 	.word	0x200047fc
    baf4:	20004870 	.word	0x20004870
    baf8:	20004800 	.word	0x20004800
    bafc:	20004874 	.word	0x20004874
    bb00:	2000486d 	.word	0x2000486d
    bb04:	20004804 	.word	0x20004804

0000bb08 <serial3_available>:

int serial3_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    bb08:	4a05      	ldr	r2, [pc, #20]	; (bb20 <serial3_available+0x18>)
	tail = rx_buffer_tail;
    bb0a:	4b06      	ldr	r3, [pc, #24]	; (bb24 <serial3_available+0x1c>)

int serial3_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    bb0c:	7810      	ldrb	r0, [r2, #0]
	tail = rx_buffer_tail;
    bb0e:	781b      	ldrb	r3, [r3, #0]

int serial3_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    bb10:	b2c0      	uxtb	r0, r0
	tail = rx_buffer_tail;
    bb12:	b2db      	uxtb	r3, r3
	if (head >= tail) return head - tail;
    bb14:	4298      	cmp	r0, r3
	return SERIAL3_RX_BUFFER_SIZE + head - tail;
    bb16:	bf38      	it	cc
    bb18:	3040      	addcc	r0, #64	; 0x40
    bb1a:	1ac0      	subs	r0, r0, r3
}
    bb1c:	4770      	bx	lr
    bb1e:	bf00      	nop
    bb20:	2000487c 	.word	0x2000487c
    bb24:	2000487d 	.word	0x2000487d

0000bb28 <uart2_status_isr>:
//   Receive data above watermark   UART_S1_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void uart2_status_isr(void)
{
    bb28:	b430      	push	{r4, r5}
	uint32_t head, tail, n;
	uint8_t c;

	if (UART2_S1 & UART_S1_RDRF) {
    bb2a:	4b2b      	ldr	r3, [pc, #172]	; (bbd8 <uart2_status_isr+0xb0>)
    bb2c:	791a      	ldrb	r2, [r3, #4]
    bb2e:	0694      	lsls	r4, r2, #26
    bb30:	d51f      	bpl.n	bb72 <uart2_status_isr+0x4a>
		if (use9Bits && (UART2_C3 & 0x80)) {
			n = UART2_D | 0x100;
		} else {
			n = UART2_D;
		}
		head = rx_buffer_head + 1;
    bb32:	482a      	ldr	r0, [pc, #168]	; (bbdc <uart2_status_isr+0xb4>)

	if (UART2_S1 & UART_S1_RDRF) {
		if (use9Bits && (UART2_C3 & 0x80)) {
			n = UART2_D | 0x100;
		} else {
			n = UART2_D;
    bb34:	79da      	ldrb	r2, [r3, #7]
		}
		head = rx_buffer_head + 1;
    bb36:	7803      	ldrb	r3, [r0, #0]
		if (head >= SERIAL3_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    bb38:	4929      	ldr	r1, [pc, #164]	; (bbe0 <uart2_status_isr+0xb8>)
		if (use9Bits && (UART2_C3 & 0x80)) {
			n = UART2_D | 0x100;
		} else {
			n = UART2_D;
		}
		head = rx_buffer_head + 1;
    bb3a:	3301      	adds	r3, #1
    bb3c:	2b3f      	cmp	r3, #63	; 0x3f
		if (head >= SERIAL3_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    bb3e:	7809      	ldrb	r1, [r1, #0]
		if (use9Bits && (UART2_C3 & 0x80)) {
			n = UART2_D | 0x100;
		} else {
			n = UART2_D;
		}
		head = rx_buffer_head + 1;
    bb40:	bfc8      	it	gt
    bb42:	2300      	movgt	r3, #0
		if (head >= SERIAL3_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    bb44:	428b      	cmp	r3, r1

	if (UART2_S1 & UART_S1_RDRF) {
		if (use9Bits && (UART2_C3 & 0x80)) {
			n = UART2_D | 0x100;
		} else {
			n = UART2_D;
    bb46:	b2d2      	uxtb	r2, r2
		}
		head = rx_buffer_head + 1;
		if (head >= SERIAL3_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    bb48:	d003      	beq.n	bb52 <uart2_status_isr+0x2a>
			rx_buffer[head] = n;
    bb4a:	4c26      	ldr	r4, [pc, #152]	; (bbe4 <uart2_status_isr+0xbc>)
			rx_buffer_head = head;
    bb4c:	b2d9      	uxtb	r1, r3
			n = UART2_D;
		}
		head = rx_buffer_head + 1;
		if (head >= SERIAL3_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
			rx_buffer[head] = n;
    bb4e:	54e2      	strb	r2, [r4, r3]
			rx_buffer_head = head;
    bb50:	7001      	strb	r1, [r0, #0]
		}
		if (rts_pin) {
    bb52:	4a25      	ldr	r2, [pc, #148]	; (bbe8 <uart2_status_isr+0xc0>)
    bb54:	6811      	ldr	r1, [r2, #0]
    bb56:	b161      	cbz	r1, bb72 <uart2_status_isr+0x4a>
			int avail;
			tail = tx_buffer_tail;
    bb58:	4a24      	ldr	r2, [pc, #144]	; (bbec <uart2_status_isr+0xc4>)
    bb5a:	7812      	ldrb	r2, [r2, #0]
    bb5c:	b2d2      	uxtb	r2, r2
			if (head >= tail) avail = head - tail;
    bb5e:	4293      	cmp	r3, r2
			else avail = SERIAL3_RX_BUFFER_SIZE + head - tail;
    bb60:	bf36      	itet	cc
    bb62:	f1c2 0240 	rsbcc	r2, r2, #64	; 0x40
			rx_buffer_head = head;
		}
		if (rts_pin) {
			int avail;
			tail = tx_buffer_tail;
			if (head >= tail) avail = head - tail;
    bb66:	1a9b      	subcs	r3, r3, r2
			else avail = SERIAL3_RX_BUFFER_SIZE + head - tail;
    bb68:	189b      	addcc	r3, r3, r2
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
    bb6a:	2b27      	cmp	r3, #39	; 0x27
    bb6c:	bfc4      	itt	gt
    bb6e:	2301      	movgt	r3, #1
    bb70:	700b      	strbgt	r3, [r1, #0]
		}
	}
	c = UART2_C2;
    bb72:	4a19      	ldr	r2, [pc, #100]	; (bbd8 <uart2_status_isr+0xb0>)
    bb74:	78d3      	ldrb	r3, [r2, #3]
    bb76:	b2db      	uxtb	r3, r3
	if ((c & UART_C2_TIE) && (UART2_S1 & UART_S1_TDRE)) {
    bb78:	0618      	lsls	r0, r3, #24
    bb7a:	d411      	bmi.n	bba0 <uart2_status_isr+0x78>
			if (use9Bits) UART2_C3 = (UART2_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART2_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART2_S1 & UART_S1_TC)) {
    bb7c:	065a      	lsls	r2, r3, #25
    bb7e:	d50d      	bpl.n	bb9c <uart2_status_isr+0x74>
    bb80:	4b15      	ldr	r3, [pc, #84]	; (bbd8 <uart2_status_isr+0xb0>)
    bb82:	791b      	ldrb	r3, [r3, #4]
    bb84:	065b      	lsls	r3, r3, #25
    bb86:	d509      	bpl.n	bb9c <uart2_status_isr+0x74>
		transmitting = 0;
		if (transmit_pin) transmit_deassert();
    bb88:	4b19      	ldr	r3, [pc, #100]	; (bbf0 <uart2_status_isr+0xc8>)
			UART2_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART2_S1 & UART_S1_TC)) {
		transmitting = 0;
    bb8a:	491a      	ldr	r1, [pc, #104]	; (bbf4 <uart2_status_isr+0xcc>)
		if (transmit_pin) transmit_deassert();
    bb8c:	681b      	ldr	r3, [r3, #0]
			UART2_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART2_S1 & UART_S1_TC)) {
		transmitting = 0;
    bb8e:	2200      	movs	r2, #0
    bb90:	700a      	strb	r2, [r1, #0]
		if (transmit_pin) transmit_deassert();
    bb92:	b103      	cbz	r3, bb96 <uart2_status_isr+0x6e>
    bb94:	701a      	strb	r2, [r3, #0]
		UART2_C2 = C2_TX_INACTIVE;
    bb96:	4b10      	ldr	r3, [pc, #64]	; (bbd8 <uart2_status_isr+0xb0>)
    bb98:	222c      	movs	r2, #44	; 0x2c
    bb9a:	70da      	strb	r2, [r3, #3]
	}
}
    bb9c:	bc30      	pop	{r4, r5}
    bb9e:	4770      	bx	lr
			else avail = SERIAL3_RX_BUFFER_SIZE + head - tail;
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
		}
	}
	c = UART2_C2;
	if ((c & UART_C2_TIE) && (UART2_S1 & UART_S1_TDRE)) {
    bba0:	7911      	ldrb	r1, [r2, #4]
    bba2:	0609      	lsls	r1, r1, #24
    bba4:	d5ea      	bpl.n	bb7c <uart2_status_isr+0x54>
		head = tx_buffer_head;
    bba6:	4914      	ldr	r1, [pc, #80]	; (bbf8 <uart2_status_isr+0xd0>)
		tail = tx_buffer_tail;
    bba8:	4810      	ldr	r0, [pc, #64]	; (bbec <uart2_status_isr+0xc4>)
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
		}
	}
	c = UART2_C2;
	if ((c & UART_C2_TIE) && (UART2_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    bbaa:	780c      	ldrb	r4, [r1, #0]
		tail = tx_buffer_tail;
    bbac:	7801      	ldrb	r1, [r0, #0]
    bbae:	b2c9      	uxtb	r1, r1
		if (head == tail) {
    bbb0:	428c      	cmp	r4, r1
    bbb2:	d00d      	beq.n	bbd0 <uart2_status_isr+0xa8>
			UART2_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL3_TX_BUFFER_SIZE) tail = 0;
    bbb4:	1c4a      	adds	r2, r1, #1
    bbb6:	2a27      	cmp	r2, #39	; 0x27
    bbb8:	bf84      	itt	hi
    bbba:	2100      	movhi	r1, #0
    bbbc:	460a      	movhi	r2, r1
			n = tx_buffer[tail];
    bbbe:	4d0f      	ldr	r5, [pc, #60]	; (bbfc <uart2_status_isr+0xd4>)
			if (use9Bits) UART2_C3 = (UART2_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART2_D = n;
    bbc0:	4c05      	ldr	r4, [pc, #20]	; (bbd8 <uart2_status_isr+0xb0>)
    bbc2:	bf98      	it	ls
    bbc4:	b2d1      	uxtbls	r1, r2
		tail = tx_buffer_tail;
		if (head == tail) {
			UART2_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL3_TX_BUFFER_SIZE) tail = 0;
			n = tx_buffer[tail];
    bbc6:	5caa      	ldrb	r2, [r5, r2]
    bbc8:	b2d2      	uxtb	r2, r2
			if (use9Bits) UART2_C3 = (UART2_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART2_D = n;
    bbca:	71e2      	strb	r2, [r4, #7]
			tx_buffer_tail = tail;
    bbcc:	7001      	strb	r1, [r0, #0]
    bbce:	e7d5      	b.n	bb7c <uart2_status_isr+0x54>
	c = UART2_C2;
	if ((c & UART_C2_TIE) && (UART2_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		if (head == tail) {
			UART2_C2 = C2_TX_COMPLETING;
    bbd0:	216c      	movs	r1, #108	; 0x6c
    bbd2:	70d1      	strb	r1, [r2, #3]
    bbd4:	e7d2      	b.n	bb7c <uart2_status_isr+0x54>
    bbd6:	bf00      	nop
    bbd8:	4006c000 	.word	0x4006c000
    bbdc:	2000487c 	.word	0x2000487c
    bbe0:	2000487d 	.word	0x2000487d
    bbe4:	200048a8 	.word	0x200048a8
    bbe8:	20004878 	.word	0x20004878
    bbec:	200048e9 	.word	0x200048e9
    bbf0:	200048ec 	.word	0x200048ec
    bbf4:	200048e8 	.word	0x200048e8
    bbf8:	200048f0 	.word	0x200048f0
    bbfc:	20004880 	.word	0x20004880

0000bc00 <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    bc00:	b570      	push	{r4, r5, r6, lr}
    bc02:	b084      	sub	sp, #16
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    bc04:	b672      	cpsid	i
#if defined(HAS_KINETIS_FLASH_FTFA) || defined(HAS_KINETIS_FLASH_FTFL)
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    bc06:	4b19      	ldr	r3, [pc, #100]	; (bc6c <usb_init_serialnumber+0x6c>)
	FTFL_FCCOB0 = 0x41;
    bc08:	4d19      	ldr	r5, [pc, #100]	; (bc70 <usb_init_serialnumber+0x70>)
	FTFL_FCCOB1 = 15;
    bc0a:	481a      	ldr	r0, [pc, #104]	; (bc74 <usb_init_serialnumber+0x74>)
	char buf[11];
	uint32_t i, num;

	__disable_irq();
#if defined(HAS_KINETIS_FLASH_FTFA) || defined(HAS_KINETIS_FLASH_FTFL)
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    bc0c:	2270      	movs	r2, #112	; 0x70
	FTFL_FCCOB0 = 0x41;
    bc0e:	2641      	movs	r6, #65	; 0x41
	FTFL_FCCOB1 = 15;
    bc10:	240f      	movs	r4, #15
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    bc12:	2180      	movs	r1, #128	; 0x80
	char buf[11];
	uint32_t i, num;

	__disable_irq();
#if defined(HAS_KINETIS_FLASH_FTFA) || defined(HAS_KINETIS_FLASH_FTFL)
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    bc14:	701a      	strb	r2, [r3, #0]
	FTFL_FCCOB0 = 0x41;
    bc16:	702e      	strb	r6, [r5, #0]
	FTFL_FCCOB1 = 15;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    bc18:	461a      	mov	r2, r3

	__disable_irq();
#if defined(HAS_KINETIS_FLASH_FTFA) || defined(HAS_KINETIS_FLASH_FTFL)
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	FTFL_FCCOB0 = 0x41;
	FTFL_FCCOB1 = 15;
    bc1a:	7004      	strb	r4, [r0, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    bc1c:	7019      	strb	r1, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    bc1e:	7813      	ldrb	r3, [r2, #0]
    bc20:	061b      	lsls	r3, r3, #24
    bc22:	d5fc      	bpl.n	bc1e <usb_init_serialnumber+0x1e>
	num = *(uint32_t *)&FTFL_FCCOB7;
    bc24:	4b14      	ldr	r3, [pc, #80]	; (bc78 <usb_init_serialnumber+0x78>)
    bc26:	6818      	ldr	r0, [r3, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
    bc28:	b662      	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    bc2a:	4b14      	ldr	r3, [pc, #80]	; (bc7c <usb_init_serialnumber+0x7c>)
    bc2c:	4c14      	ldr	r4, [pc, #80]	; (bc80 <usb_init_serialnumber+0x80>)
    bc2e:	4298      	cmp	r0, r3
    bc30:	bf98      	it	ls
    bc32:	eb00 0080 	addls.w	r0, r0, r0, lsl #2
	ultoa(num, buf, 10);
    bc36:	a901      	add	r1, sp, #4
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    bc38:	bf98      	it	ls
    bc3a:	0040      	lslls	r0, r0, #1
	ultoa(num, buf, 10);
    bc3c:	220a      	movs	r2, #10
    bc3e:	f7fd ff1b 	bl	9a78 <ultoa>
    bc42:	a901      	add	r1, sp, #4
    bc44:	4620      	mov	r0, r4
	for (i=0; i<10; i++) {
    bc46:	2300      	movs	r3, #0
		char c = buf[i];
    bc48:	f811 2b01 	ldrb.w	r2, [r1], #1
    bc4c:	3301      	adds	r3, #1
		if (!c) break;
    bc4e:	b13a      	cbz	r2, bc60 <usb_init_serialnumber+0x60>
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    bc50:	2b0a      	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    bc52:	f820 2f02 	strh.w	r2, [r0, #2]!
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    bc56:	d1f7      	bne.n	bc48 <usb_init_serialnumber+0x48>
    bc58:	2316      	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    bc5a:	7023      	strb	r3, [r4, #0]
}
    bc5c:	b004      	add	sp, #16
    bc5e:	bd70      	pop	{r4, r5, r6, pc}
    bc60:	005b      	lsls	r3, r3, #1
    bc62:	b2db      	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    bc64:	7023      	strb	r3, [r4, #0]
}
    bc66:	b004      	add	sp, #16
    bc68:	bd70      	pop	{r4, r5, r6, pc}
    bc6a:	bf00      	nop
    bc6c:	40020000 	.word	0x40020000
    bc70:	40020007 	.word	0x40020007
    bc74:	40020006 	.word	0x40020006
    bc78:	40020008 	.word	0x40020008
    bc7c:	0098967f 	.word	0x0098967f
    bc80:	1fffbcb4 	.word	0x1fffbcb4

0000bc84 <arm_radix4_butterfly_q15>:
    bc84:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    bc88:	b092      	sub	sp, #72	; 0x48
    bc8a:	eb03 0743 	add.w	r7, r3, r3, lsl #1
    bc8e:	9101      	str	r1, [sp, #4]
    bc90:	0889      	lsrs	r1, r1, #2
    bc92:	9111      	str	r1, [sp, #68]	; 0x44
    bc94:	9c11      	ldr	r4, [sp, #68]	; 0x44
    bc96:	900f      	str	r0, [sp, #60]	; 0x3c
    bc98:	00b8      	lsls	r0, r7, #2
    bc9a:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    bc9c:	9208      	str	r2, [sp, #32]
    bc9e:	eb04 0644 	add.w	r6, r4, r4, lsl #1
    bca2:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
    bca6:	9006      	str	r0, [sp, #24]
    bca8:	2100      	movs	r1, #0
    bcaa:	00dd      	lsls	r5, r3, #3
    bcac:	eb07 0286 	add.w	r2, r7, r6, lsl #2
    bcb0:	009b      	lsls	r3, r3, #2
    bcb2:	9e08      	ldr	r6, [sp, #32]
    bcb4:	9505      	str	r5, [sp, #20]
    bcb6:	9304      	str	r3, [sp, #16]
    bcb8:	9402      	str	r4, [sp, #8]
    bcba:	460d      	mov	r5, r1
    bcbc:	460c      	mov	r4, r1
    bcbe:	460b      	mov	r3, r1
    bcc0:	eb07 0bc9 	add.w	fp, r7, r9, lsl #3
    bcc4:	eb07 0089 	add.w	r0, r7, r9, lsl #2
    bcc8:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
    bccc:	f85b 9003 	ldr.w	r9, [fp, r3]
    bcd0:	f858 7003 	ldr.w	r7, [r8, r3]
    bcd4:	f349 0a8d 	sbfx	sl, r9, #2, #14
    bcd8:	ea4f 08a9 	mov.w	r8, r9, asr #2
    bcdc:	f347 0c8d 	sbfx	ip, r7, #2, #14
    bce0:	ea4f 07a7 	mov.w	r7, r7, asr #2
    bce4:	fa1f fc8c 	uxth.w	ip, ip
    bce8:	ea4f 4917 	mov.w	r9, r7, lsr #16
    bcec:	fa1f f78a 	uxth.w	r7, sl
    bcf0:	ea4f 4a18 	mov.w	sl, r8, lsr #16
    bcf4:	ea4c 4909 	orr.w	r9, ip, r9, lsl #16
    bcf8:	ea47 480a 	orr.w	r8, r7, sl, lsl #16
    bcfc:	fa99 f718 	qadd16	r7, r9, r8
    bd00:	fad9 f918 	qsub16	r9, r9, r8
    bd04:	f850 a003 	ldr.w	sl, [r0, r3]
    bd08:	f852 c003 	ldr.w	ip, [r2, r3]
    bd0c:	f8cd 900c 	str.w	r9, [sp, #12]
    bd10:	ea4f 08aa 	mov.w	r8, sl, asr #2
    bd14:	f34a 098d 	sbfx	r9, sl, #2, #14
    bd18:	f34c 0a8d 	sbfx	sl, ip, #2, #14
    bd1c:	ea4f 0cac 	mov.w	ip, ip, asr #2
    bd20:	fa1f f989 	uxth.w	r9, r9
    bd24:	fa1f fa8a 	uxth.w	sl, sl
    bd28:	ea4f 4818 	mov.w	r8, r8, lsr #16
    bd2c:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
    bd30:	ea49 4808 	orr.w	r8, r9, r8, lsl #16
    bd34:	ea4a 4c0c 	orr.w	ip, sl, ip, lsl #16
    bd38:	fa98 fc1c 	qadd16	ip, r8, ip
    bd3c:	fa97 f82c 	shadd16	r8, r7, ip
    bd40:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
    bd44:	f849 8003 	str.w	r8, [r9, r3]
    bd48:	fad7 f91c 	qsub16	r9, r7, ip
    bd4c:	5937      	ldr	r7, [r6, r4]
    bd4e:	fb27 f809 	smuad	r8, r7, r9
    bd52:	fb47 f719 	smusdx	r7, r7, r9
    bd56:	0c3f      	lsrs	r7, r7, #16
    bd58:	043f      	lsls	r7, r7, #16
    bd5a:	ea47 4718 	orr.w	r7, r7, r8, lsr #16
    bd5e:	f850 c003 	ldr.w	ip, [r0, r3]
    bd62:	50c7      	str	r7, [r0, r3]
    bd64:	58d7      	ldr	r7, [r2, r3]
    bd66:	f34c 098d 	sbfx	r9, ip, #2, #14
    bd6a:	ea4f 08ac 	mov.w	r8, ip, asr #2
    bd6e:	f347 0c8d 	sbfx	ip, r7, #2, #14
    bd72:	10bf      	asrs	r7, r7, #2
    bd74:	fa1f f989 	uxth.w	r9, r9
    bd78:	fa1f fc8c 	uxth.w	ip, ip
    bd7c:	0c3f      	lsrs	r7, r7, #16
    bd7e:	ea4f 4818 	mov.w	r8, r8, lsr #16
    bd82:	ea49 4808 	orr.w	r8, r9, r8, lsl #16
    bd86:	ea4c 4707 	orr.w	r7, ip, r7, lsl #16
    bd8a:	fad8 f917 	qsub16	r9, r8, r7
    bd8e:	f8dd c00c 	ldr.w	ip, [sp, #12]
    bd92:	faac f719 	qasx	r7, ip, r9
    bd96:	faec f819 	qsax	r8, ip, r9
    bd9a:	f856 c005 	ldr.w	ip, [r6, r5]
    bd9e:	fb2c f908 	smuad	r9, ip, r8
    bda2:	fb4c fc18 	smusdx	ip, ip, r8
    bda6:	ea4f 481c 	mov.w	r8, ip, lsr #16
    bdaa:	ea4f 4c08 	mov.w	ip, r8, lsl #16
    bdae:	ea4c 4819 	orr.w	r8, ip, r9, lsr #16
    bdb2:	f84b 8003 	str.w	r8, [fp, r3]
    bdb6:	f856 c001 	ldr.w	ip, [r6, r1]
    bdba:	fb2c f807 	smuad	r8, ip, r7
    bdbe:	fb4c f717 	smusdx	r7, ip, r7
    bdc2:	0c3f      	lsrs	r7, r7, #16
    bdc4:	043f      	lsls	r7, r7, #16
    bdc6:	ea47 4718 	orr.w	r7, r7, r8, lsr #16
    bdca:	50d7      	str	r7, [r2, r3]
    bdcc:	9f05      	ldr	r7, [sp, #20]
    bdce:	f8dd 9010 	ldr.w	r9, [sp, #16]
    bdd2:	f8dd c018 	ldr.w	ip, [sp, #24]
    bdd6:	19e4      	adds	r4, r4, r7
    bdd8:	9f02      	ldr	r7, [sp, #8]
    bdda:	3304      	adds	r3, #4
    bddc:	3f01      	subs	r7, #1
    bdde:	444d      	add	r5, r9
    bde0:	4461      	add	r1, ip
    bde2:	9702      	str	r7, [sp, #8]
    bde4:	f47f af70 	bne.w	bcc8 <arm_radix4_butterfly_q15+0x44>
    bde8:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
    bdec:	f1b9 0f04 	cmp.w	r9, #4
    bdf0:	f240 809f 	bls.w	bf32 <arm_radix4_butterfly_q15+0x2ae>
    bdf4:	f8cd 9008 	str.w	r9, [sp, #8]
    bdf8:	9a04      	ldr	r2, [sp, #16]
    bdfa:	9902      	ldr	r1, [sp, #8]
    bdfc:	f8cd 9040 	str.w	r9, [sp, #64]	; 0x40
    be00:	464c      	mov	r4, r9
    be02:	08a4      	lsrs	r4, r4, #2
    be04:	1e67      	subs	r7, r4, #1
    be06:	970c      	str	r7, [sp, #48]	; 0x30
    be08:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    be0a:	940e      	str	r4, [sp, #56]	; 0x38
    be0c:	eb02 0342 	add.w	r3, r2, r2, lsl #1
    be10:	ea4f 0b82 	mov.w	fp, r2, lsl #2
    be14:	ea4f 0884 	mov.w	r8, r4, lsl #2
    be18:	00d2      	lsls	r2, r2, #3
    be1a:	2500      	movs	r5, #0
    be1c:	0098      	lsls	r0, r3, #2
    be1e:	ebc4 7684 	rsb	r6, r4, r4, lsl #30
    be22:	920b      	str	r2, [sp, #44]	; 0x2c
    be24:	eb07 0308 	add.w	r3, r7, r8
    be28:	008a      	lsls	r2, r1, #2
    be2a:	9504      	str	r5, [sp, #16]
    be2c:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
    be30:	900d      	str	r0, [sp, #52]	; 0x34
    be32:	9309      	str	r3, [sp, #36]	; 0x24
    be34:	9506      	str	r5, [sp, #24]
    be36:	9507      	str	r5, [sp, #28]
    be38:	9505      	str	r5, [sp, #20]
    be3a:	9203      	str	r2, [sp, #12]
    be3c:	00e1      	lsls	r1, r4, #3
    be3e:	ea4f 0986 	mov.w	r9, r6, lsl #2
    be42:	9808      	ldr	r0, [sp, #32]
    be44:	9d07      	ldr	r5, [sp, #28]
    be46:	9e01      	ldr	r6, [sp, #4]
    be48:	5947      	ldr	r7, [r0, r5]
    be4a:	9d04      	ldr	r5, [sp, #16]
    be4c:	9b05      	ldr	r3, [sp, #20]
    be4e:	9c06      	ldr	r4, [sp, #24]
    be50:	f850 b003 	ldr.w	fp, [r0, r3]
    be54:	f850 c004 	ldr.w	ip, [r0, r4]
    be58:	42ae      	cmp	r6, r5
    be5a:	d946      	bls.n	beea <arm_radix4_butterfly_q15+0x266>
    be5c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    be5e:	462a      	mov	r2, r5
    be60:	f853 0009 	ldr.w	r0, [r3, r9]
    be64:	f853 5008 	ldr.w	r5, [r3, r8]
    be68:	fa90 f415 	qadd16	r4, r0, r5
    be6c:	fad0 f015 	qsub16	r0, r0, r5
    be70:	681d      	ldr	r5, [r3, #0]
    be72:	585e      	ldr	r6, [r3, r1]
    be74:	fa95 f516 	qadd16	r5, r5, r6
    be78:	fa94 f625 	shadd16	r6, r4, r5
    be7c:	f346 0a4e 	sbfx	sl, r6, #1, #15
    be80:	1076      	asrs	r6, r6, #1
    be82:	fa1f fa8a 	uxth.w	sl, sl
    be86:	0c36      	lsrs	r6, r6, #16
    be88:	ea4a 4606 	orr.w	r6, sl, r6, lsl #16
    be8c:	f843 6009 	str.w	r6, [r3, r9]
    be90:	fad4 f525 	shsub16	r5, r4, r5
    be94:	fb27 f605 	smuad	r6, r7, r5
    be98:	fb47 f415 	smusdx	r4, r7, r5
    be9c:	0c25      	lsrs	r5, r4, #16
    be9e:	042c      	lsls	r4, r5, #16
    bea0:	ea44 4516 	orr.w	r5, r4, r6, lsr #16
    bea4:	681e      	ldr	r6, [r3, #0]
    bea6:	601d      	str	r5, [r3, #0]
    bea8:	585c      	ldr	r4, [r3, r1]
    beaa:	fad6 f514 	qsub16	r5, r6, r4
    beae:	faa0 f425 	shasx	r4, r0, r5
    beb2:	fae0 f625 	shsax	r6, r0, r5
    beb6:	fb2b f506 	smuad	r5, fp, r6
    beba:	fb4b f016 	smusdx	r0, fp, r6
    bebe:	0c06      	lsrs	r6, r0, #16
    bec0:	0430      	lsls	r0, r6, #16
    bec2:	ea40 4615 	orr.w	r6, r0, r5, lsr #16
    bec6:	f843 6008 	str.w	r6, [r3, r8]
    beca:	fb2c f604 	smuad	r6, ip, r4
    bece:	fb4c f414 	smusdx	r4, ip, r4
    bed2:	0c25      	lsrs	r5, r4, #16
    bed4:	0428      	lsls	r0, r5, #16
    bed6:	9c02      	ldr	r4, [sp, #8]
    bed8:	ea40 4516 	orr.w	r5, r0, r6, lsr #16
    bedc:	9e01      	ldr	r6, [sp, #4]
    bede:	9803      	ldr	r0, [sp, #12]
    bee0:	505d      	str	r5, [r3, r1]
    bee2:	1912      	adds	r2, r2, r4
    bee4:	4296      	cmp	r6, r2
    bee6:	4403      	add	r3, r0
    bee8:	d8ba      	bhi.n	be60 <arm_radix4_butterfly_q15+0x1dc>
    beea:	9804      	ldr	r0, [sp, #16]
    beec:	9c05      	ldr	r4, [sp, #20]
    beee:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
    bef2:	9f07      	ldr	r7, [sp, #28]
    bef4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    bef6:	1c46      	adds	r6, r0, #1
    bef8:	eb04 030c 	add.w	r3, r4, ip
    befc:	9604      	str	r6, [sp, #16]
    befe:	18bd      	adds	r5, r7, r2
    bf00:	9e06      	ldr	r6, [sp, #24]
    bf02:	9305      	str	r3, [sp, #20]
    bf04:	980d      	ldr	r0, [sp, #52]	; 0x34
    bf06:	9b09      	ldr	r3, [sp, #36]	; 0x24
    bf08:	9a04      	ldr	r2, [sp, #16]
    bf0a:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
    bf0e:	9507      	str	r5, [sp, #28]
    bf10:	1d1f      	adds	r7, r3, #4
    bf12:	1834      	adds	r4, r6, r0
    bf14:	4562      	cmp	r2, ip
    bf16:	9406      	str	r4, [sp, #24]
    bf18:	9709      	str	r7, [sp, #36]	; 0x24
    bf1a:	d992      	bls.n	be42 <arm_radix4_butterfly_q15+0x1be>
    bf1c:	9d10      	ldr	r5, [sp, #64]	; 0x40
    bf1e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    bf20:	08a9      	lsrs	r1, r5, #2
    bf22:	2904      	cmp	r1, #4
    bf24:	9110      	str	r1, [sp, #64]	; 0x40
    bf26:	d904      	bls.n	bf32 <arm_radix4_butterfly_q15+0x2ae>
    bf28:	980e      	ldr	r0, [sp, #56]	; 0x38
    bf2a:	9002      	str	r0, [sp, #8]
    bf2c:	4604      	mov	r4, r0
    bf2e:	4601      	mov	r1, r0
    bf30:	e767      	b.n	be02 <arm_radix4_butterfly_q15+0x17e>
    bf32:	9e11      	ldr	r6, [sp, #68]	; 0x44
    bf34:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    bf36:	1e71      	subs	r1, r6, #1
    bf38:	6820      	ldr	r0, [r4, #0]
    bf3a:	68a4      	ldr	r4, [r4, #8]
    bf3c:	f001 0601 	and.w	r6, r1, #1
    bf40:	fa90 f514 	qadd16	r5, r0, r4
    bf44:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    bf46:	6853      	ldr	r3, [r2, #4]
    bf48:	68d2      	ldr	r2, [r2, #12]
    bf4a:	fa93 f912 	qadd16	r9, r3, r2
    bf4e:	fa95 f729 	shadd16	r7, r5, r9
    bf52:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
    bf56:	f8c9 7000 	str.w	r7, [r9]
    bf5a:	fa93 f712 	qadd16	r7, r3, r2
    bf5e:	fad5 f527 	shsub16	r5, r5, r7
    bf62:	f8c9 5004 	str.w	r5, [r9, #4]
    bf66:	fad0 fc14 	qsub16	ip, r0, r4
    bf6a:	fad3 f312 	qsub16	r3, r3, r2
    bf6e:	faec f023 	shsax	r0, ip, r3
    bf72:	f8c9 0008 	str.w	r0, [r9, #8]
    bf76:	faac f223 	shasx	r2, ip, r3
    bf7a:	f8c9 200c 	str.w	r2, [r9, #12]
    bf7e:	f109 0310 	add.w	r3, r9, #16
    bf82:	2900      	cmp	r1, #0
    bf84:	d059      	beq.n	c03a <arm_radix4_butterfly_q15+0x3b6>
    bf86:	b1e6      	cbz	r6, bfc2 <arm_radix4_butterfly_q15+0x33e>
    bf88:	681c      	ldr	r4, [r3, #0]
    bf8a:	689d      	ldr	r5, [r3, #8]
    bf8c:	fa94 f615 	qadd16	r6, r4, r5
    bf90:	685a      	ldr	r2, [r3, #4]
    bf92:	68d8      	ldr	r0, [r3, #12]
    bf94:	fa92 fc10 	qadd16	ip, r2, r0
    bf98:	fa96 f72c 	shadd16	r7, r6, ip
    bf9c:	601f      	str	r7, [r3, #0]
    bf9e:	fa92 f710 	qadd16	r7, r2, r0
    bfa2:	fad6 f627 	shsub16	r6, r6, r7
    bfa6:	605e      	str	r6, [r3, #4]
    bfa8:	fad4 f415 	qsub16	r4, r4, r5
    bfac:	fad2 fc10 	qsub16	ip, r2, r0
    bfb0:	fae4 f02c 	shsax	r0, r4, ip
    bfb4:	6098      	str	r0, [r3, #8]
    bfb6:	faa4 f22c 	shasx	r2, r4, ip
    bfba:	60da      	str	r2, [r3, #12]
    bfbc:	3310      	adds	r3, #16
    bfbe:	3901      	subs	r1, #1
    bfc0:	d03b      	beq.n	c03a <arm_radix4_butterfly_q15+0x3b6>
    bfc2:	681d      	ldr	r5, [r3, #0]
    bfc4:	689e      	ldr	r6, [r3, #8]
    bfc6:	fa95 fc16 	qadd16	ip, r5, r6
    bfca:	685a      	ldr	r2, [r3, #4]
    bfcc:	68d8      	ldr	r0, [r3, #12]
    bfce:	fa92 f410 	qadd16	r4, r2, r0
    bfd2:	fa9c f724 	shadd16	r7, ip, r4
    bfd6:	601f      	str	r7, [r3, #0]
    bfd8:	fa92 f410 	qadd16	r4, r2, r0
    bfdc:	fadc f724 	shsub16	r7, ip, r4
    bfe0:	605f      	str	r7, [r3, #4]
    bfe2:	fad5 f416 	qsub16	r4, r5, r6
    bfe6:	fad2 f610 	qsub16	r6, r2, r0
    bfea:	fae4 f226 	shsax	r2, r4, r6
    bfee:	609a      	str	r2, [r3, #8]
    bff0:	faa4 f526 	shasx	r5, r4, r6
    bff4:	60dd      	str	r5, [r3, #12]
    bff6:	699e      	ldr	r6, [r3, #24]
    bff8:	691d      	ldr	r5, [r3, #16]
    bffa:	f103 0210 	add.w	r2, r3, #16
    bffe:	1e4c      	subs	r4, r1, #1
    c000:	fa95 f716 	qadd16	r7, r5, r6
    c004:	6959      	ldr	r1, [r3, #20]
    c006:	69d8      	ldr	r0, [r3, #28]
    c008:	fa91 fc10 	qadd16	ip, r1, r0
    c00c:	fa97 fc2c 	shadd16	ip, r7, ip
    c010:	f8c3 c010 	str.w	ip, [r3, #16]
    c014:	fa91 fc10 	qadd16	ip, r1, r0
    c018:	fad7 f72c 	shsub16	r7, r7, ip
    c01c:	6057      	str	r7, [r2, #4]
    c01e:	fad5 fc16 	qsub16	ip, r5, r6
    c022:	fad1 f310 	qsub16	r3, r1, r0
    c026:	faec f023 	shsax	r0, ip, r3
    c02a:	6090      	str	r0, [r2, #8]
    c02c:	faac f123 	shasx	r1, ip, r3
    c030:	60d1      	str	r1, [r2, #12]
    c032:	1e61      	subs	r1, r4, #1
    c034:	f102 0310 	add.w	r3, r2, #16
    c038:	d1c3      	bne.n	bfc2 <arm_radix4_butterfly_q15+0x33e>
    c03a:	b012      	add	sp, #72	; 0x48
    c03c:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    c040:	4770      	bx	lr
    c042:	bf00      	nop

0000c044 <arm_radix4_butterfly_inverse_q15>:
    c044:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    c048:	b092      	sub	sp, #72	; 0x48
    c04a:	eb03 0743 	add.w	r7, r3, r3, lsl #1
    c04e:	9101      	str	r1, [sp, #4]
    c050:	0889      	lsrs	r1, r1, #2
    c052:	9111      	str	r1, [sp, #68]	; 0x44
    c054:	9c11      	ldr	r4, [sp, #68]	; 0x44
    c056:	900f      	str	r0, [sp, #60]	; 0x3c
    c058:	00b8      	lsls	r0, r7, #2
    c05a:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    c05c:	9208      	str	r2, [sp, #32]
    c05e:	eb04 0644 	add.w	r6, r4, r4, lsl #1
    c062:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
    c066:	9006      	str	r0, [sp, #24]
    c068:	2100      	movs	r1, #0
    c06a:	00dd      	lsls	r5, r3, #3
    c06c:	eb07 0286 	add.w	r2, r7, r6, lsl #2
    c070:	009b      	lsls	r3, r3, #2
    c072:	9e08      	ldr	r6, [sp, #32]
    c074:	9505      	str	r5, [sp, #20]
    c076:	9304      	str	r3, [sp, #16]
    c078:	9402      	str	r4, [sp, #8]
    c07a:	460d      	mov	r5, r1
    c07c:	460c      	mov	r4, r1
    c07e:	460b      	mov	r3, r1
    c080:	eb07 0bc9 	add.w	fp, r7, r9, lsl #3
    c084:	eb07 0089 	add.w	r0, r7, r9, lsl #2
    c088:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
    c08c:	f85b 9003 	ldr.w	r9, [fp, r3]
    c090:	f858 7003 	ldr.w	r7, [r8, r3]
    c094:	f349 0a8d 	sbfx	sl, r9, #2, #14
    c098:	ea4f 08a9 	mov.w	r8, r9, asr #2
    c09c:	f347 0c8d 	sbfx	ip, r7, #2, #14
    c0a0:	ea4f 07a7 	mov.w	r7, r7, asr #2
    c0a4:	fa1f fc8c 	uxth.w	ip, ip
    c0a8:	ea4f 4917 	mov.w	r9, r7, lsr #16
    c0ac:	fa1f f78a 	uxth.w	r7, sl
    c0b0:	ea4f 4a18 	mov.w	sl, r8, lsr #16
    c0b4:	ea4c 4909 	orr.w	r9, ip, r9, lsl #16
    c0b8:	ea47 480a 	orr.w	r8, r7, sl, lsl #16
    c0bc:	fa99 f718 	qadd16	r7, r9, r8
    c0c0:	fad9 f918 	qsub16	r9, r9, r8
    c0c4:	f850 a003 	ldr.w	sl, [r0, r3]
    c0c8:	f852 c003 	ldr.w	ip, [r2, r3]
    c0cc:	f8cd 900c 	str.w	r9, [sp, #12]
    c0d0:	ea4f 08aa 	mov.w	r8, sl, asr #2
    c0d4:	f34a 098d 	sbfx	r9, sl, #2, #14
    c0d8:	f34c 0a8d 	sbfx	sl, ip, #2, #14
    c0dc:	ea4f 0cac 	mov.w	ip, ip, asr #2
    c0e0:	fa1f f989 	uxth.w	r9, r9
    c0e4:	fa1f fa8a 	uxth.w	sl, sl
    c0e8:	ea4f 4818 	mov.w	r8, r8, lsr #16
    c0ec:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
    c0f0:	ea49 4808 	orr.w	r8, r9, r8, lsl #16
    c0f4:	ea4a 4c0c 	orr.w	ip, sl, ip, lsl #16
    c0f8:	fa98 fc1c 	qadd16	ip, r8, ip
    c0fc:	fa97 f82c 	shadd16	r8, r7, ip
    c100:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
    c104:	f849 8003 	str.w	r8, [r9, r3]
    c108:	fad7 f91c 	qsub16	r9, r7, ip
    c10c:	5937      	ldr	r7, [r6, r4]
    c10e:	fb47 f809 	smusd	r8, r7, r9
    c112:	fb27 f719 	smuadx	r7, r7, r9
    c116:	0c3f      	lsrs	r7, r7, #16
    c118:	043f      	lsls	r7, r7, #16
    c11a:	ea47 4718 	orr.w	r7, r7, r8, lsr #16
    c11e:	f850 c003 	ldr.w	ip, [r0, r3]
    c122:	50c7      	str	r7, [r0, r3]
    c124:	58d7      	ldr	r7, [r2, r3]
    c126:	f34c 098d 	sbfx	r9, ip, #2, #14
    c12a:	ea4f 08ac 	mov.w	r8, ip, asr #2
    c12e:	f347 0c8d 	sbfx	ip, r7, #2, #14
    c132:	10bf      	asrs	r7, r7, #2
    c134:	fa1f f989 	uxth.w	r9, r9
    c138:	fa1f fc8c 	uxth.w	ip, ip
    c13c:	0c3f      	lsrs	r7, r7, #16
    c13e:	ea4f 4818 	mov.w	r8, r8, lsr #16
    c142:	ea49 4808 	orr.w	r8, r9, r8, lsl #16
    c146:	ea4c 4707 	orr.w	r7, ip, r7, lsl #16
    c14a:	fad8 f917 	qsub16	r9, r8, r7
    c14e:	f8dd c00c 	ldr.w	ip, [sp, #12]
    c152:	faec f719 	qsax	r7, ip, r9
    c156:	faac f819 	qasx	r8, ip, r9
    c15a:	f856 c005 	ldr.w	ip, [r6, r5]
    c15e:	fb4c f908 	smusd	r9, ip, r8
    c162:	fb2c fc18 	smuadx	ip, ip, r8
    c166:	ea4f 481c 	mov.w	r8, ip, lsr #16
    c16a:	ea4f 4c08 	mov.w	ip, r8, lsl #16
    c16e:	ea4c 4819 	orr.w	r8, ip, r9, lsr #16
    c172:	f84b 8003 	str.w	r8, [fp, r3]
    c176:	f856 c001 	ldr.w	ip, [r6, r1]
    c17a:	fb4c f807 	smusd	r8, ip, r7
    c17e:	fb2c f717 	smuadx	r7, ip, r7
    c182:	0c3f      	lsrs	r7, r7, #16
    c184:	043f      	lsls	r7, r7, #16
    c186:	ea47 4718 	orr.w	r7, r7, r8, lsr #16
    c18a:	50d7      	str	r7, [r2, r3]
    c18c:	9f05      	ldr	r7, [sp, #20]
    c18e:	f8dd 9010 	ldr.w	r9, [sp, #16]
    c192:	f8dd c018 	ldr.w	ip, [sp, #24]
    c196:	19e4      	adds	r4, r4, r7
    c198:	9f02      	ldr	r7, [sp, #8]
    c19a:	3304      	adds	r3, #4
    c19c:	3f01      	subs	r7, #1
    c19e:	444d      	add	r5, r9
    c1a0:	4461      	add	r1, ip
    c1a2:	9702      	str	r7, [sp, #8]
    c1a4:	f47f af70 	bne.w	c088 <arm_radix4_butterfly_inverse_q15+0x44>
    c1a8:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
    c1ac:	f1b9 0f04 	cmp.w	r9, #4
    c1b0:	f240 809f 	bls.w	c2f2 <arm_radix4_butterfly_inverse_q15+0x2ae>
    c1b4:	f8cd 9008 	str.w	r9, [sp, #8]
    c1b8:	9a04      	ldr	r2, [sp, #16]
    c1ba:	9902      	ldr	r1, [sp, #8]
    c1bc:	f8cd 9040 	str.w	r9, [sp, #64]	; 0x40
    c1c0:	464c      	mov	r4, r9
    c1c2:	08a4      	lsrs	r4, r4, #2
    c1c4:	1e67      	subs	r7, r4, #1
    c1c6:	970c      	str	r7, [sp, #48]	; 0x30
    c1c8:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    c1ca:	940e      	str	r4, [sp, #56]	; 0x38
    c1cc:	eb02 0342 	add.w	r3, r2, r2, lsl #1
    c1d0:	ea4f 0b82 	mov.w	fp, r2, lsl #2
    c1d4:	ea4f 0884 	mov.w	r8, r4, lsl #2
    c1d8:	00d2      	lsls	r2, r2, #3
    c1da:	2500      	movs	r5, #0
    c1dc:	0098      	lsls	r0, r3, #2
    c1de:	ebc4 7684 	rsb	r6, r4, r4, lsl #30
    c1e2:	920b      	str	r2, [sp, #44]	; 0x2c
    c1e4:	eb07 0308 	add.w	r3, r7, r8
    c1e8:	008a      	lsls	r2, r1, #2
    c1ea:	9504      	str	r5, [sp, #16]
    c1ec:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
    c1f0:	900d      	str	r0, [sp, #52]	; 0x34
    c1f2:	9309      	str	r3, [sp, #36]	; 0x24
    c1f4:	9506      	str	r5, [sp, #24]
    c1f6:	9507      	str	r5, [sp, #28]
    c1f8:	9505      	str	r5, [sp, #20]
    c1fa:	9203      	str	r2, [sp, #12]
    c1fc:	00e1      	lsls	r1, r4, #3
    c1fe:	ea4f 0986 	mov.w	r9, r6, lsl #2
    c202:	9808      	ldr	r0, [sp, #32]
    c204:	9d07      	ldr	r5, [sp, #28]
    c206:	9e01      	ldr	r6, [sp, #4]
    c208:	5947      	ldr	r7, [r0, r5]
    c20a:	9d04      	ldr	r5, [sp, #16]
    c20c:	9b05      	ldr	r3, [sp, #20]
    c20e:	9c06      	ldr	r4, [sp, #24]
    c210:	f850 b003 	ldr.w	fp, [r0, r3]
    c214:	f850 c004 	ldr.w	ip, [r0, r4]
    c218:	42ae      	cmp	r6, r5
    c21a:	d946      	bls.n	c2aa <arm_radix4_butterfly_inverse_q15+0x266>
    c21c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    c21e:	462a      	mov	r2, r5
    c220:	f853 0009 	ldr.w	r0, [r3, r9]
    c224:	f853 5008 	ldr.w	r5, [r3, r8]
    c228:	fa90 f415 	qadd16	r4, r0, r5
    c22c:	fad0 f015 	qsub16	r0, r0, r5
    c230:	681d      	ldr	r5, [r3, #0]
    c232:	585e      	ldr	r6, [r3, r1]
    c234:	fa95 f516 	qadd16	r5, r5, r6
    c238:	fa94 f625 	shadd16	r6, r4, r5
    c23c:	f346 0a4e 	sbfx	sl, r6, #1, #15
    c240:	1076      	asrs	r6, r6, #1
    c242:	fa1f fa8a 	uxth.w	sl, sl
    c246:	0c36      	lsrs	r6, r6, #16
    c248:	ea4a 4606 	orr.w	r6, sl, r6, lsl #16
    c24c:	f843 6009 	str.w	r6, [r3, r9]
    c250:	fad4 f525 	shsub16	r5, r4, r5
    c254:	fb47 f605 	smusd	r6, r7, r5
    c258:	fb27 f415 	smuadx	r4, r7, r5
    c25c:	0c25      	lsrs	r5, r4, #16
    c25e:	042c      	lsls	r4, r5, #16
    c260:	ea44 4516 	orr.w	r5, r4, r6, lsr #16
    c264:	681e      	ldr	r6, [r3, #0]
    c266:	601d      	str	r5, [r3, #0]
    c268:	585c      	ldr	r4, [r3, r1]
    c26a:	fad6 f514 	qsub16	r5, r6, r4
    c26e:	fae0 f425 	shsax	r4, r0, r5
    c272:	faa0 f625 	shasx	r6, r0, r5
    c276:	fb4b f506 	smusd	r5, fp, r6
    c27a:	fb2b f016 	smuadx	r0, fp, r6
    c27e:	0c06      	lsrs	r6, r0, #16
    c280:	0430      	lsls	r0, r6, #16
    c282:	ea40 4615 	orr.w	r6, r0, r5, lsr #16
    c286:	f843 6008 	str.w	r6, [r3, r8]
    c28a:	fb4c f604 	smusd	r6, ip, r4
    c28e:	fb2c f414 	smuadx	r4, ip, r4
    c292:	0c25      	lsrs	r5, r4, #16
    c294:	0428      	lsls	r0, r5, #16
    c296:	9c02      	ldr	r4, [sp, #8]
    c298:	ea40 4516 	orr.w	r5, r0, r6, lsr #16
    c29c:	9e01      	ldr	r6, [sp, #4]
    c29e:	9803      	ldr	r0, [sp, #12]
    c2a0:	505d      	str	r5, [r3, r1]
    c2a2:	1912      	adds	r2, r2, r4
    c2a4:	4296      	cmp	r6, r2
    c2a6:	4403      	add	r3, r0
    c2a8:	d8ba      	bhi.n	c220 <arm_radix4_butterfly_inverse_q15+0x1dc>
    c2aa:	9804      	ldr	r0, [sp, #16]
    c2ac:	9c05      	ldr	r4, [sp, #20]
    c2ae:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
    c2b2:	9f07      	ldr	r7, [sp, #28]
    c2b4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    c2b6:	1c46      	adds	r6, r0, #1
    c2b8:	eb04 030c 	add.w	r3, r4, ip
    c2bc:	9604      	str	r6, [sp, #16]
    c2be:	18bd      	adds	r5, r7, r2
    c2c0:	9e06      	ldr	r6, [sp, #24]
    c2c2:	9305      	str	r3, [sp, #20]
    c2c4:	980d      	ldr	r0, [sp, #52]	; 0x34
    c2c6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    c2c8:	9a04      	ldr	r2, [sp, #16]
    c2ca:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
    c2ce:	9507      	str	r5, [sp, #28]
    c2d0:	1d1f      	adds	r7, r3, #4
    c2d2:	1834      	adds	r4, r6, r0
    c2d4:	4562      	cmp	r2, ip
    c2d6:	9406      	str	r4, [sp, #24]
    c2d8:	9709      	str	r7, [sp, #36]	; 0x24
    c2da:	d992      	bls.n	c202 <arm_radix4_butterfly_inverse_q15+0x1be>
    c2dc:	9d10      	ldr	r5, [sp, #64]	; 0x40
    c2de:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    c2e0:	08a9      	lsrs	r1, r5, #2
    c2e2:	2904      	cmp	r1, #4
    c2e4:	9110      	str	r1, [sp, #64]	; 0x40
    c2e6:	d904      	bls.n	c2f2 <arm_radix4_butterfly_inverse_q15+0x2ae>
    c2e8:	980e      	ldr	r0, [sp, #56]	; 0x38
    c2ea:	9002      	str	r0, [sp, #8]
    c2ec:	4604      	mov	r4, r0
    c2ee:	4601      	mov	r1, r0
    c2f0:	e767      	b.n	c1c2 <arm_radix4_butterfly_inverse_q15+0x17e>
    c2f2:	9e11      	ldr	r6, [sp, #68]	; 0x44
    c2f4:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    c2f6:	1e71      	subs	r1, r6, #1
    c2f8:	6820      	ldr	r0, [r4, #0]
    c2fa:	68a4      	ldr	r4, [r4, #8]
    c2fc:	f001 0601 	and.w	r6, r1, #1
    c300:	fa90 f514 	qadd16	r5, r0, r4
    c304:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    c306:	6853      	ldr	r3, [r2, #4]
    c308:	68d2      	ldr	r2, [r2, #12]
    c30a:	fa93 f912 	qadd16	r9, r3, r2
    c30e:	fa95 f729 	shadd16	r7, r5, r9
    c312:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
    c316:	f8c9 7000 	str.w	r7, [r9]
    c31a:	fa93 f712 	qadd16	r7, r3, r2
    c31e:	fad5 f527 	shsub16	r5, r5, r7
    c322:	f8c9 5004 	str.w	r5, [r9, #4]
    c326:	fad0 fc14 	qsub16	ip, r0, r4
    c32a:	fad3 f312 	qsub16	r3, r3, r2
    c32e:	faac f023 	shasx	r0, ip, r3
    c332:	f8c9 0008 	str.w	r0, [r9, #8]
    c336:	faec f223 	shsax	r2, ip, r3
    c33a:	f8c9 200c 	str.w	r2, [r9, #12]
    c33e:	f109 0310 	add.w	r3, r9, #16
    c342:	2900      	cmp	r1, #0
    c344:	d059      	beq.n	c3fa <arm_radix4_butterfly_inverse_q15+0x3b6>
    c346:	b1e6      	cbz	r6, c382 <arm_radix4_butterfly_inverse_q15+0x33e>
    c348:	681c      	ldr	r4, [r3, #0]
    c34a:	689d      	ldr	r5, [r3, #8]
    c34c:	fa94 f615 	qadd16	r6, r4, r5
    c350:	685a      	ldr	r2, [r3, #4]
    c352:	68d8      	ldr	r0, [r3, #12]
    c354:	fa92 fc10 	qadd16	ip, r2, r0
    c358:	fa96 f72c 	shadd16	r7, r6, ip
    c35c:	601f      	str	r7, [r3, #0]
    c35e:	fa92 f710 	qadd16	r7, r2, r0
    c362:	fad6 f627 	shsub16	r6, r6, r7
    c366:	605e      	str	r6, [r3, #4]
    c368:	fad4 f415 	qsub16	r4, r4, r5
    c36c:	fad2 fc10 	qsub16	ip, r2, r0
    c370:	faa4 f02c 	shasx	r0, r4, ip
    c374:	6098      	str	r0, [r3, #8]
    c376:	fae4 f22c 	shsax	r2, r4, ip
    c37a:	60da      	str	r2, [r3, #12]
    c37c:	3310      	adds	r3, #16
    c37e:	3901      	subs	r1, #1
    c380:	d03b      	beq.n	c3fa <arm_radix4_butterfly_inverse_q15+0x3b6>
    c382:	681d      	ldr	r5, [r3, #0]
    c384:	689e      	ldr	r6, [r3, #8]
    c386:	fa95 fc16 	qadd16	ip, r5, r6
    c38a:	685a      	ldr	r2, [r3, #4]
    c38c:	68d8      	ldr	r0, [r3, #12]
    c38e:	fa92 f410 	qadd16	r4, r2, r0
    c392:	fa9c f724 	shadd16	r7, ip, r4
    c396:	601f      	str	r7, [r3, #0]
    c398:	fa92 f410 	qadd16	r4, r2, r0
    c39c:	fadc f724 	shsub16	r7, ip, r4
    c3a0:	605f      	str	r7, [r3, #4]
    c3a2:	fad5 f416 	qsub16	r4, r5, r6
    c3a6:	fad2 f610 	qsub16	r6, r2, r0
    c3aa:	faa4 f226 	shasx	r2, r4, r6
    c3ae:	609a      	str	r2, [r3, #8]
    c3b0:	fae4 f526 	shsax	r5, r4, r6
    c3b4:	60dd      	str	r5, [r3, #12]
    c3b6:	699e      	ldr	r6, [r3, #24]
    c3b8:	691d      	ldr	r5, [r3, #16]
    c3ba:	f103 0210 	add.w	r2, r3, #16
    c3be:	1e4c      	subs	r4, r1, #1
    c3c0:	fa95 f716 	qadd16	r7, r5, r6
    c3c4:	6959      	ldr	r1, [r3, #20]
    c3c6:	69d8      	ldr	r0, [r3, #28]
    c3c8:	fa91 fc10 	qadd16	ip, r1, r0
    c3cc:	fa97 fc2c 	shadd16	ip, r7, ip
    c3d0:	f8c3 c010 	str.w	ip, [r3, #16]
    c3d4:	fa91 fc10 	qadd16	ip, r1, r0
    c3d8:	fad7 f72c 	shsub16	r7, r7, ip
    c3dc:	6057      	str	r7, [r2, #4]
    c3de:	fad5 fc16 	qsub16	ip, r5, r6
    c3e2:	fad1 f310 	qsub16	r3, r1, r0
    c3e6:	faac f023 	shasx	r0, ip, r3
    c3ea:	6090      	str	r0, [r2, #8]
    c3ec:	faec f123 	shsax	r1, ip, r3
    c3f0:	60d1      	str	r1, [r2, #12]
    c3f2:	1e61      	subs	r1, r4, #1
    c3f4:	f102 0310 	add.w	r3, r2, #16
    c3f8:	d1c3      	bne.n	c382 <arm_radix4_butterfly_inverse_q15+0x33e>
    c3fa:	b012      	add	sp, #72	; 0x48
    c3fc:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    c400:	4770      	bx	lr
    c402:	bf00      	nop

0000c404 <arm_cfft_radix4_q15>:
    c404:	b570      	push	{r4, r5, r6, lr}
    c406:	7883      	ldrb	r3, [r0, #2]
    c408:	6842      	ldr	r2, [r0, #4]
    c40a:	460d      	mov	r5, r1
    c40c:	2b01      	cmp	r3, #1
    c40e:	4604      	mov	r4, r0
    c410:	8801      	ldrh	r1, [r0, #0]
    c412:	8983      	ldrh	r3, [r0, #12]
    c414:	4628      	mov	r0, r5
    c416:	d005      	beq.n	c424 <arm_cfft_radix4_q15+0x20>
    c418:	f7ff fc34 	bl	bc84 <arm_radix4_butterfly_q15>
    c41c:	78e0      	ldrb	r0, [r4, #3]
    c41e:	2801      	cmp	r0, #1
    c420:	d005      	beq.n	c42e <arm_cfft_radix4_q15+0x2a>
    c422:	bd70      	pop	{r4, r5, r6, pc}
    c424:	f7ff fe0e 	bl	c044 <arm_radix4_butterfly_inverse_q15>
    c428:	78e0      	ldrb	r0, [r4, #3]
    c42a:	2801      	cmp	r0, #1
    c42c:	d1f9      	bne.n	c422 <arm_cfft_radix4_q15+0x1e>
    c42e:	8821      	ldrh	r1, [r4, #0]
    c430:	89e2      	ldrh	r2, [r4, #14]
    c432:	68a3      	ldr	r3, [r4, #8]
    c434:	4628      	mov	r0, r5
    c436:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    c43a:	f000 b849 	b.w	c4d0 <arm_bitreversal_q15>
    c43e:	bf00      	nop

0000c440 <arm_cfft_radix4_init_q15>:
    c440:	b410      	push	{r4}
    c442:	4c1d      	ldr	r4, [pc, #116]	; (c4b8 <arm_cfft_radix4_init_q15+0x78>)
    c444:	8001      	strh	r1, [r0, #0]
    c446:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
    c44a:	6044      	str	r4, [r0, #4]
    c44c:	7082      	strb	r2, [r0, #2]
    c44e:	70c3      	strb	r3, [r0, #3]
    c450:	d02a      	beq.n	c4a8 <arm_cfft_radix4_init_q15+0x68>
    c452:	d909      	bls.n	c468 <arm_cfft_radix4_init_q15+0x28>
    c454:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
    c458:	d018      	beq.n	c48c <arm_cfft_radix4_init_q15+0x4c>
    c45a:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
    c45e:	d00e      	beq.n	c47e <arm_cfft_radix4_init_q15+0x3e>
    c460:	20ff      	movs	r0, #255	; 0xff
    c462:	b240      	sxtb	r0, r0
    c464:	bc10      	pop	{r4}
    c466:	4770      	bx	lr
    c468:	2910      	cmp	r1, #16
    c46a:	d016      	beq.n	c49a <arm_cfft_radix4_init_q15+0x5a>
    c46c:	2940      	cmp	r1, #64	; 0x40
    c46e:	d1f7      	bne.n	c460 <arm_cfft_radix4_init_q15+0x20>
    c470:	4b12      	ldr	r3, [pc, #72]	; (c4bc <arm_cfft_radix4_init_q15+0x7c>)
    c472:	f04f 1140 	mov.w	r1, #4194368	; 0x400040
    c476:	60c1      	str	r1, [r0, #12]
    c478:	6083      	str	r3, [r0, #8]
    c47a:	2000      	movs	r0, #0
    c47c:	e7f1      	b.n	c462 <arm_cfft_radix4_init_q15+0x22>
    c47e:	4b10      	ldr	r3, [pc, #64]	; (c4c0 <arm_cfft_radix4_init_q15+0x80>)
    c480:	f04f 1101 	mov.w	r1, #65537	; 0x10001
    c484:	60c1      	str	r1, [r0, #12]
    c486:	6083      	str	r3, [r0, #8]
    c488:	2000      	movs	r0, #0
    c48a:	e7ea      	b.n	c462 <arm_cfft_radix4_init_q15+0x22>
    c48c:	4a0d      	ldr	r2, [pc, #52]	; (c4c4 <arm_cfft_radix4_init_q15+0x84>)
    c48e:	f04f 1304 	mov.w	r3, #262148	; 0x40004
    c492:	60c3      	str	r3, [r0, #12]
    c494:	6082      	str	r2, [r0, #8]
    c496:	2000      	movs	r0, #0
    c498:	e7e3      	b.n	c462 <arm_cfft_radix4_init_q15+0x22>
    c49a:	4a0b      	ldr	r2, [pc, #44]	; (c4c8 <arm_cfft_radix4_init_q15+0x88>)
    c49c:	f04f 2301 	mov.w	r3, #16777472	; 0x1000100
    c4a0:	60c3      	str	r3, [r0, #12]
    c4a2:	6082      	str	r2, [r0, #8]
    c4a4:	2000      	movs	r0, #0
    c4a6:	e7dc      	b.n	c462 <arm_cfft_radix4_init_q15+0x22>
    c4a8:	4908      	ldr	r1, [pc, #32]	; (c4cc <arm_cfft_radix4_init_q15+0x8c>)
    c4aa:	f04f 1210 	mov.w	r2, #1048592	; 0x100010
    c4ae:	60c2      	str	r2, [r0, #12]
    c4b0:	6081      	str	r1, [r0, #8]
    c4b2:	2000      	movs	r0, #0
    c4b4:	e7d5      	b.n	c462 <arm_cfft_radix4_init_q15+0x22>
    c4b6:	bf00      	nop
    c4b8:	000126e8 	.word	0x000126e8
    c4bc:	00021766 	.word	0x00021766
    c4c0:	000216e8 	.word	0x000216e8
    c4c4:	000216ee 	.word	0x000216ee
    c4c8:	000218e6 	.word	0x000218e6
    c4cc:	00021706 	.word	0x00021706

0000c4d0 <arm_bitreversal_q15>:
    c4d0:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    c4d4:	b084      	sub	sp, #16
    c4d6:	0849      	lsrs	r1, r1, #1
    c4d8:	9101      	str	r1, [sp, #4]
    c4da:	9c01      	ldr	r4, [sp, #4]
    c4dc:	9e01      	ldr	r6, [sp, #4]
    c4de:	f8dd 8004 	ldr.w	r8, [sp, #4]
    c4e2:	3c02      	subs	r4, #2
    c4e4:	2100      	movs	r1, #0
    c4e6:	3601      	adds	r6, #1
    c4e8:	f014 0f02 	tst.w	r4, #2
    c4ec:	ea4f 0b42 	mov.w	fp, r2, lsl #1
    c4f0:	9403      	str	r4, [sp, #12]
    c4f2:	9602      	str	r6, [sp, #8]
    c4f4:	4602      	mov	r2, r0
    c4f6:	eb00 0588 	add.w	r5, r0, r8, lsl #2
    c4fa:	460f      	mov	r7, r1
    c4fc:	d059      	beq.n	c5b2 <arm_bitreversal_q15+0xe2>
    c4fe:	6829      	ldr	r1, [r5, #0]
    c500:	6842      	ldr	r2, [r0, #4]
    c502:	f8dd c00c 	ldr.w	ip, [sp, #12]
    c506:	6041      	str	r1, [r0, #4]
    c508:	2702      	movs	r7, #2
    c50a:	602a      	str	r2, [r5, #0]
    c50c:	45bc      	cmp	ip, r7
    c50e:	8819      	ldrh	r1, [r3, #0]
    c510:	445b      	add	r3, fp
    c512:	d36c      	bcc.n	c5ee <arm_bitreversal_q15+0x11e>
    c514:	42b9      	cmp	r1, r7
    c516:	d914      	bls.n	c542 <arm_bitreversal_q15+0x72>
    c518:	eb00 0981 	add.w	r9, r0, r1, lsl #2
    c51c:	f8dd 8008 	ldr.w	r8, [sp, #8]
    c520:	6884      	ldr	r4, [r0, #8]
    c522:	f8d9 a000 	ldr.w	sl, [r9]
    c526:	eb01 0c08 	add.w	ip, r1, r8
    c52a:	eb00 088c 	add.w	r8, r0, ip, lsl #2
    c52e:	f8c0 a008 	str.w	sl, [r0, #8]
    c532:	f8c9 4000 	str.w	r4, [r9]
    c536:	68ec      	ldr	r4, [r5, #12]
    c538:	f8d8 6000 	ldr.w	r6, [r8]
    c53c:	60ee      	str	r6, [r5, #12]
    c53e:	f8c8 4000 	str.w	r4, [r8]
    c542:	f100 0208 	add.w	r2, r0, #8
    c546:	3508      	adds	r5, #8
    c548:	f8dd 8004 	ldr.w	r8, [sp, #4]
    c54c:	e031      	b.n	c5b2 <arm_bitreversal_q15+0xe2>
    c54e:	42b1      	cmp	r1, r6
    c550:	d90d      	bls.n	c56e <arm_bitreversal_q15+0x9e>
    c552:	6896      	ldr	r6, [r2, #8]
    c554:	9600      	str	r6, [sp, #0]
    c556:	f850 6021 	ldr.w	r6, [r0, r1, lsl #2]
    c55a:	6096      	str	r6, [r2, #8]
    c55c:	9a00      	ldr	r2, [sp, #0]
    c55e:	f840 2021 	str.w	r2, [r0, r1, lsl #2]
    c562:	68ea      	ldr	r2, [r5, #12]
    c564:	f850 602a 	ldr.w	r6, [r0, sl, lsl #2]
    c568:	60ee      	str	r6, [r5, #12]
    c56a:	f840 202a 	str.w	r2, [r0, sl, lsl #2]
    c56e:	f850 1029 	ldr.w	r1, [r0, r9, lsl #2]
    c572:	6862      	ldr	r2, [r4, #4]
    c574:	6061      	str	r1, [r4, #4]
    c576:	f840 2029 	str.w	r2, [r0, r9, lsl #2]
    c57a:	f8bc 2000 	ldrh.w	r2, [ip]
    c57e:	9d02      	ldr	r5, [sp, #8]
    c580:	42ba      	cmp	r2, r7
    c582:	4611      	mov	r1, r2
    c584:	4415      	add	r5, r2
    c586:	d90e      	bls.n	c5a6 <arm_bitreversal_q15+0xd6>
    c588:	68a6      	ldr	r6, [r4, #8]
    c58a:	f850 9022 	ldr.w	r9, [r0, r2, lsl #2]
    c58e:	f8c4 9008 	str.w	r9, [r4, #8]
    c592:	f840 6022 	str.w	r6, [r0, r2, lsl #2]
    c596:	f8d8 200c 	ldr.w	r2, [r8, #12]
    c59a:	f850 6025 	ldr.w	r6, [r0, r5, lsl #2]
    c59e:	f8c8 600c 	str.w	r6, [r8, #12]
    c5a2:	f840 2025 	str.w	r2, [r0, r5, lsl #2]
    c5a6:	f108 0508 	add.w	r5, r8, #8
    c5aa:	f8dd 8004 	ldr.w	r8, [sp, #4]
    c5ae:	f104 0208 	add.w	r2, r4, #8
    c5b2:	eb01 0908 	add.w	r9, r1, r8
    c5b6:	6856      	ldr	r6, [r2, #4]
    c5b8:	f850 a029 	ldr.w	sl, [r0, r9, lsl #2]
    c5bc:	f8dd c008 	ldr.w	ip, [sp, #8]
    c5c0:	f8c2 a004 	str.w	sl, [r2, #4]
    c5c4:	f840 6029 	str.w	r6, [r0, r9, lsl #2]
    c5c8:	8819      	ldrh	r1, [r3, #0]
    c5ca:	eb01 0908 	add.w	r9, r1, r8
    c5ce:	f8dd 800c 	ldr.w	r8, [sp, #12]
    c5d2:	1cbe      	adds	r6, r7, #2
    c5d4:	1cb7      	adds	r7, r6, #2
    c5d6:	eb01 0a0c 	add.w	sl, r1, ip
    c5da:	45b0      	cmp	r8, r6
    c5dc:	eb03 0c0b 	add.w	ip, r3, fp
    c5e0:	f102 0408 	add.w	r4, r2, #8
    c5e4:	f105 0808 	add.w	r8, r5, #8
    c5e8:	eb0c 030b 	add.w	r3, ip, fp
    c5ec:	d2af      	bcs.n	c54e <arm_bitreversal_q15+0x7e>
    c5ee:	b004      	add	sp, #16
    c5f0:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    c5f4:	4770      	bx	lr
    c5f6:	bf00      	nop

0000c5f8 <sqrtf>:
    c5f8:	b5f0      	push	{r4, r5, r6, r7, lr}
    c5fa:	b08b      	sub	sp, #44	; 0x2c
    c5fc:	4605      	mov	r5, r0
    c5fe:	f000 f849 	bl	c694 <__ieee754_sqrtf>
    c602:	4b22      	ldr	r3, [pc, #136]	; (c68c <sqrtf+0x94>)
    c604:	f993 6000 	ldrsb.w	r6, [r3]
    c608:	1c73      	adds	r3, r6, #1
    c60a:	4604      	mov	r4, r0
    c60c:	d00a      	beq.n	c624 <sqrtf+0x2c>
    c60e:	4629      	mov	r1, r5
    c610:	4628      	mov	r0, r5
    c612:	f001 f869 	bl	d6e8 <__aeabi_fcmpun>
    c616:	4607      	mov	r7, r0
    c618:	b920      	cbnz	r0, c624 <sqrtf+0x2c>
    c61a:	2100      	movs	r1, #0
    c61c:	4628      	mov	r0, r5
    c61e:	f001 f83b 	bl	d698 <__aeabi_fcmplt>
    c622:	b910      	cbnz	r0, c62a <sqrtf+0x32>
    c624:	4620      	mov	r0, r4
    c626:	b00b      	add	sp, #44	; 0x2c
    c628:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c62a:	4b19      	ldr	r3, [pc, #100]	; (c690 <sqrtf+0x98>)
    c62c:	9708      	str	r7, [sp, #32]
    c62e:	2201      	movs	r2, #1
    c630:	4628      	mov	r0, r5
    c632:	e88d 000c 	stmia.w	sp, {r2, r3}
    c636:	f000 f9e7 	bl	ca08 <__aeabi_f2d>
    c63a:	2200      	movs	r2, #0
    c63c:	e9cd 0104 	strd	r0, r1, [sp, #16]
    c640:	e9cd 0102 	strd	r0, r1, [sp, #8]
    c644:	2300      	movs	r3, #0
    c646:	b19e      	cbz	r6, c670 <sqrtf+0x78>
    c648:	4610      	mov	r0, r2
    c64a:	4619      	mov	r1, r3
    c64c:	f000 fb5a 	bl	cd04 <__aeabi_ddiv>
    c650:	2e02      	cmp	r6, #2
    c652:	e9cd 0106 	strd	r0, r1, [sp, #24]
    c656:	d10d      	bne.n	c674 <sqrtf+0x7c>
    c658:	f001 fa62 	bl	db20 <__errno>
    c65c:	2321      	movs	r3, #33	; 0x21
    c65e:	6003      	str	r3, [r0, #0]
    c660:	9b08      	ldr	r3, [sp, #32]
    c662:	b96b      	cbnz	r3, c680 <sqrtf+0x88>
    c664:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    c668:	f000 fd1a 	bl	d0a0 <__aeabi_d2f>
    c66c:	b00b      	add	sp, #44	; 0x2c
    c66e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c670:	e9cd 2306 	strd	r2, r3, [sp, #24]
    c674:	4668      	mov	r0, sp
    c676:	f000 f861 	bl	c73c <matherr>
    c67a:	2800      	cmp	r0, #0
    c67c:	d1f0      	bne.n	c660 <sqrtf+0x68>
    c67e:	e7eb      	b.n	c658 <sqrtf+0x60>
    c680:	f001 fa4e 	bl	db20 <__errno>
    c684:	9b08      	ldr	r3, [sp, #32]
    c686:	6003      	str	r3, [r0, #0]
    c688:	e7ec      	b.n	c664 <sqrtf+0x6c>
    c68a:	bf00      	nop
    c68c:	1fffbcca 	.word	0x1fffbcca
    c690:	00021ee8 	.word	0x00021ee8

0000c694 <__ieee754_sqrtf>:
    c694:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
    c698:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
    c69c:	b570      	push	{r4, r5, r6, lr}
    c69e:	4604      	mov	r4, r0
    c6a0:	d22e      	bcs.n	c700 <__ieee754_sqrtf+0x6c>
    c6a2:	b362      	cbz	r2, c6fe <__ieee754_sqrtf+0x6a>
    c6a4:	2800      	cmp	r0, #0
    c6a6:	4603      	mov	r3, r0
    c6a8:	db3d      	blt.n	c726 <__ieee754_sqrtf+0x92>
    c6aa:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
    c6ae:	ea4f 50e0 	mov.w	r0, r0, asr #23
    c6b2:	d32c      	bcc.n	c70e <__ieee754_sqrtf+0x7a>
    c6b4:	387f      	subs	r0, #127	; 0x7f
    c6b6:	f3c3 0316 	ubfx	r3, r3, #0, #23
    c6ba:	07c2      	lsls	r2, r0, #31
    c6bc:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
    c6c0:	bf48      	it	mi
    c6c2:	005b      	lslmi	r3, r3, #1
    c6c4:	2600      	movs	r6, #0
    c6c6:	1040      	asrs	r0, r0, #1
    c6c8:	005b      	lsls	r3, r3, #1
    c6ca:	4631      	mov	r1, r6
    c6cc:	2419      	movs	r4, #25
    c6ce:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    c6d2:	188d      	adds	r5, r1, r2
    c6d4:	429d      	cmp	r5, r3
    c6d6:	dc02      	bgt.n	c6de <__ieee754_sqrtf+0x4a>
    c6d8:	1b5b      	subs	r3, r3, r5
    c6da:	18a9      	adds	r1, r5, r2
    c6dc:	4416      	add	r6, r2
    c6de:	3c01      	subs	r4, #1
    c6e0:	ea4f 0343 	mov.w	r3, r3, lsl #1
    c6e4:	ea4f 0252 	mov.w	r2, r2, lsr #1
    c6e8:	d1f3      	bne.n	c6d2 <__ieee754_sqrtf+0x3e>
    c6ea:	b113      	cbz	r3, c6f2 <__ieee754_sqrtf+0x5e>
    c6ec:	f006 0301 	and.w	r3, r6, #1
    c6f0:	441e      	add	r6, r3
    c6f2:	1076      	asrs	r6, r6, #1
    c6f4:	f106 567c 	add.w	r6, r6, #1056964608	; 0x3f000000
    c6f8:	eb06 50c0 	add.w	r0, r6, r0, lsl #23
    c6fc:	bd70      	pop	{r4, r5, r6, pc}
    c6fe:	bd70      	pop	{r4, r5, r6, pc}
    c700:	4601      	mov	r1, r0
    c702:	f000 fe2b 	bl	d35c <__aeabi_fmul>
    c706:	4621      	mov	r1, r4
    c708:	f000 fd20 	bl	d14c <__addsf3>
    c70c:	bd70      	pop	{r4, r5, r6, pc}
    c70e:	f414 0200 	ands.w	r2, r4, #8388608	; 0x800000
    c712:	d001      	beq.n	c718 <__ieee754_sqrtf+0x84>
    c714:	e00e      	b.n	c734 <__ieee754_sqrtf+0xa0>
    c716:	460a      	mov	r2, r1
    c718:	005b      	lsls	r3, r3, #1
    c71a:	021c      	lsls	r4, r3, #8
    c71c:	f102 0101 	add.w	r1, r2, #1
    c720:	d5f9      	bpl.n	c716 <__ieee754_sqrtf+0x82>
    c722:	1a80      	subs	r0, r0, r2
    c724:	e7c6      	b.n	c6b4 <__ieee754_sqrtf+0x20>
    c726:	4601      	mov	r1, r0
    c728:	f000 fd0e 	bl	d148 <__aeabi_fsub>
    c72c:	4601      	mov	r1, r0
    c72e:	f000 fec9 	bl	d4c4 <__aeabi_fdiv>
    c732:	bd70      	pop	{r4, r5, r6, pc}
    c734:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    c738:	e7f3      	b.n	c722 <__ieee754_sqrtf+0x8e>
    c73a:	bf00      	nop

0000c73c <matherr>:
    c73c:	2000      	movs	r0, #0
    c73e:	4770      	bx	lr

0000c740 <__aeabi_drsub>:
    c740:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
    c744:	e002      	b.n	c74c <__adddf3>
    c746:	bf00      	nop

0000c748 <__aeabi_dsub>:
    c748:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0000c74c <__adddf3>:
    c74c:	b530      	push	{r4, r5, lr}
    c74e:	ea4f 0441 	mov.w	r4, r1, lsl #1
    c752:	ea4f 0543 	mov.w	r5, r3, lsl #1
    c756:	ea94 0f05 	teq	r4, r5
    c75a:	bf08      	it	eq
    c75c:	ea90 0f02 	teqeq	r0, r2
    c760:	bf1f      	itttt	ne
    c762:	ea54 0c00 	orrsne.w	ip, r4, r0
    c766:	ea55 0c02 	orrsne.w	ip, r5, r2
    c76a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
    c76e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    c772:	f000 80e2 	beq.w	c93a <__adddf3+0x1ee>
    c776:	ea4f 5454 	mov.w	r4, r4, lsr #21
    c77a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
    c77e:	bfb8      	it	lt
    c780:	426d      	neglt	r5, r5
    c782:	dd0c      	ble.n	c79e <__adddf3+0x52>
    c784:	442c      	add	r4, r5
    c786:	ea80 0202 	eor.w	r2, r0, r2
    c78a:	ea81 0303 	eor.w	r3, r1, r3
    c78e:	ea82 0000 	eor.w	r0, r2, r0
    c792:	ea83 0101 	eor.w	r1, r3, r1
    c796:	ea80 0202 	eor.w	r2, r0, r2
    c79a:	ea81 0303 	eor.w	r3, r1, r3
    c79e:	2d36      	cmp	r5, #54	; 0x36
    c7a0:	bf88      	it	hi
    c7a2:	bd30      	pophi	{r4, r5, pc}
    c7a4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    c7a8:	ea4f 3101 	mov.w	r1, r1, lsl #12
    c7ac:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
    c7b0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
    c7b4:	d002      	beq.n	c7bc <__adddf3+0x70>
    c7b6:	4240      	negs	r0, r0
    c7b8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    c7bc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
    c7c0:	ea4f 3303 	mov.w	r3, r3, lsl #12
    c7c4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
    c7c8:	d002      	beq.n	c7d0 <__adddf3+0x84>
    c7ca:	4252      	negs	r2, r2
    c7cc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    c7d0:	ea94 0f05 	teq	r4, r5
    c7d4:	f000 80a7 	beq.w	c926 <__adddf3+0x1da>
    c7d8:	f1a4 0401 	sub.w	r4, r4, #1
    c7dc:	f1d5 0e20 	rsbs	lr, r5, #32
    c7e0:	db0d      	blt.n	c7fe <__adddf3+0xb2>
    c7e2:	fa02 fc0e 	lsl.w	ip, r2, lr
    c7e6:	fa22 f205 	lsr.w	r2, r2, r5
    c7ea:	1880      	adds	r0, r0, r2
    c7ec:	f141 0100 	adc.w	r1, r1, #0
    c7f0:	fa03 f20e 	lsl.w	r2, r3, lr
    c7f4:	1880      	adds	r0, r0, r2
    c7f6:	fa43 f305 	asr.w	r3, r3, r5
    c7fa:	4159      	adcs	r1, r3
    c7fc:	e00e      	b.n	c81c <__adddf3+0xd0>
    c7fe:	f1a5 0520 	sub.w	r5, r5, #32
    c802:	f10e 0e20 	add.w	lr, lr, #32
    c806:	2a01      	cmp	r2, #1
    c808:	fa03 fc0e 	lsl.w	ip, r3, lr
    c80c:	bf28      	it	cs
    c80e:	f04c 0c02 	orrcs.w	ip, ip, #2
    c812:	fa43 f305 	asr.w	r3, r3, r5
    c816:	18c0      	adds	r0, r0, r3
    c818:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
    c81c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    c820:	d507      	bpl.n	c832 <__adddf3+0xe6>
    c822:	f04f 0e00 	mov.w	lr, #0
    c826:	f1dc 0c00 	rsbs	ip, ip, #0
    c82a:	eb7e 0000 	sbcs.w	r0, lr, r0
    c82e:	eb6e 0101 	sbc.w	r1, lr, r1
    c832:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    c836:	d31b      	bcc.n	c870 <__adddf3+0x124>
    c838:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    c83c:	d30c      	bcc.n	c858 <__adddf3+0x10c>
    c83e:	0849      	lsrs	r1, r1, #1
    c840:	ea5f 0030 	movs.w	r0, r0, rrx
    c844:	ea4f 0c3c 	mov.w	ip, ip, rrx
    c848:	f104 0401 	add.w	r4, r4, #1
    c84c:	ea4f 5244 	mov.w	r2, r4, lsl #21
    c850:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
    c854:	f080 809a 	bcs.w	c98c <__adddf3+0x240>
    c858:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    c85c:	bf08      	it	eq
    c85e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    c862:	f150 0000 	adcs.w	r0, r0, #0
    c866:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    c86a:	ea41 0105 	orr.w	r1, r1, r5
    c86e:	bd30      	pop	{r4, r5, pc}
    c870:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
    c874:	4140      	adcs	r0, r0
    c876:	eb41 0101 	adc.w	r1, r1, r1
    c87a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    c87e:	f1a4 0401 	sub.w	r4, r4, #1
    c882:	d1e9      	bne.n	c858 <__adddf3+0x10c>
    c884:	f091 0f00 	teq	r1, #0
    c888:	bf04      	itt	eq
    c88a:	4601      	moveq	r1, r0
    c88c:	2000      	moveq	r0, #0
    c88e:	fab1 f381 	clz	r3, r1
    c892:	bf08      	it	eq
    c894:	3320      	addeq	r3, #32
    c896:	f1a3 030b 	sub.w	r3, r3, #11
    c89a:	f1b3 0220 	subs.w	r2, r3, #32
    c89e:	da0c      	bge.n	c8ba <__adddf3+0x16e>
    c8a0:	320c      	adds	r2, #12
    c8a2:	dd08      	ble.n	c8b6 <__adddf3+0x16a>
    c8a4:	f102 0c14 	add.w	ip, r2, #20
    c8a8:	f1c2 020c 	rsb	r2, r2, #12
    c8ac:	fa01 f00c 	lsl.w	r0, r1, ip
    c8b0:	fa21 f102 	lsr.w	r1, r1, r2
    c8b4:	e00c      	b.n	c8d0 <__adddf3+0x184>
    c8b6:	f102 0214 	add.w	r2, r2, #20
    c8ba:	bfd8      	it	le
    c8bc:	f1c2 0c20 	rsble	ip, r2, #32
    c8c0:	fa01 f102 	lsl.w	r1, r1, r2
    c8c4:	fa20 fc0c 	lsr.w	ip, r0, ip
    c8c8:	bfdc      	itt	le
    c8ca:	ea41 010c 	orrle.w	r1, r1, ip
    c8ce:	4090      	lslle	r0, r2
    c8d0:	1ae4      	subs	r4, r4, r3
    c8d2:	bfa2      	ittt	ge
    c8d4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
    c8d8:	4329      	orrge	r1, r5
    c8da:	bd30      	popge	{r4, r5, pc}
    c8dc:	ea6f 0404 	mvn.w	r4, r4
    c8e0:	3c1f      	subs	r4, #31
    c8e2:	da1c      	bge.n	c91e <__adddf3+0x1d2>
    c8e4:	340c      	adds	r4, #12
    c8e6:	dc0e      	bgt.n	c906 <__adddf3+0x1ba>
    c8e8:	f104 0414 	add.w	r4, r4, #20
    c8ec:	f1c4 0220 	rsb	r2, r4, #32
    c8f0:	fa20 f004 	lsr.w	r0, r0, r4
    c8f4:	fa01 f302 	lsl.w	r3, r1, r2
    c8f8:	ea40 0003 	orr.w	r0, r0, r3
    c8fc:	fa21 f304 	lsr.w	r3, r1, r4
    c900:	ea45 0103 	orr.w	r1, r5, r3
    c904:	bd30      	pop	{r4, r5, pc}
    c906:	f1c4 040c 	rsb	r4, r4, #12
    c90a:	f1c4 0220 	rsb	r2, r4, #32
    c90e:	fa20 f002 	lsr.w	r0, r0, r2
    c912:	fa01 f304 	lsl.w	r3, r1, r4
    c916:	ea40 0003 	orr.w	r0, r0, r3
    c91a:	4629      	mov	r1, r5
    c91c:	bd30      	pop	{r4, r5, pc}
    c91e:	fa21 f004 	lsr.w	r0, r1, r4
    c922:	4629      	mov	r1, r5
    c924:	bd30      	pop	{r4, r5, pc}
    c926:	f094 0f00 	teq	r4, #0
    c92a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
    c92e:	bf06      	itte	eq
    c930:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
    c934:	3401      	addeq	r4, #1
    c936:	3d01      	subne	r5, #1
    c938:	e74e      	b.n	c7d8 <__adddf3+0x8c>
    c93a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    c93e:	bf18      	it	ne
    c940:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    c944:	d029      	beq.n	c99a <__adddf3+0x24e>
    c946:	ea94 0f05 	teq	r4, r5
    c94a:	bf08      	it	eq
    c94c:	ea90 0f02 	teqeq	r0, r2
    c950:	d005      	beq.n	c95e <__adddf3+0x212>
    c952:	ea54 0c00 	orrs.w	ip, r4, r0
    c956:	bf04      	itt	eq
    c958:	4619      	moveq	r1, r3
    c95a:	4610      	moveq	r0, r2
    c95c:	bd30      	pop	{r4, r5, pc}
    c95e:	ea91 0f03 	teq	r1, r3
    c962:	bf1e      	ittt	ne
    c964:	2100      	movne	r1, #0
    c966:	2000      	movne	r0, #0
    c968:	bd30      	popne	{r4, r5, pc}
    c96a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
    c96e:	d105      	bne.n	c97c <__adddf3+0x230>
    c970:	0040      	lsls	r0, r0, #1
    c972:	4149      	adcs	r1, r1
    c974:	bf28      	it	cs
    c976:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
    c97a:	bd30      	pop	{r4, r5, pc}
    c97c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
    c980:	bf3c      	itt	cc
    c982:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
    c986:	bd30      	popcc	{r4, r5, pc}
    c988:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    c98c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
    c990:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    c994:	f04f 0000 	mov.w	r0, #0
    c998:	bd30      	pop	{r4, r5, pc}
    c99a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    c99e:	bf1a      	itte	ne
    c9a0:	4619      	movne	r1, r3
    c9a2:	4610      	movne	r0, r2
    c9a4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
    c9a8:	bf1c      	itt	ne
    c9aa:	460b      	movne	r3, r1
    c9ac:	4602      	movne	r2, r0
    c9ae:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    c9b2:	bf06      	itte	eq
    c9b4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
    c9b8:	ea91 0f03 	teqeq	r1, r3
    c9bc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
    c9c0:	bd30      	pop	{r4, r5, pc}
    c9c2:	bf00      	nop

0000c9c4 <__aeabi_ui2d>:
    c9c4:	f090 0f00 	teq	r0, #0
    c9c8:	bf04      	itt	eq
    c9ca:	2100      	moveq	r1, #0
    c9cc:	4770      	bxeq	lr
    c9ce:	b530      	push	{r4, r5, lr}
    c9d0:	f44f 6480 	mov.w	r4, #1024	; 0x400
    c9d4:	f104 0432 	add.w	r4, r4, #50	; 0x32
    c9d8:	f04f 0500 	mov.w	r5, #0
    c9dc:	f04f 0100 	mov.w	r1, #0
    c9e0:	e750      	b.n	c884 <__adddf3+0x138>
    c9e2:	bf00      	nop

0000c9e4 <__aeabi_i2d>:
    c9e4:	f090 0f00 	teq	r0, #0
    c9e8:	bf04      	itt	eq
    c9ea:	2100      	moveq	r1, #0
    c9ec:	4770      	bxeq	lr
    c9ee:	b530      	push	{r4, r5, lr}
    c9f0:	f44f 6480 	mov.w	r4, #1024	; 0x400
    c9f4:	f104 0432 	add.w	r4, r4, #50	; 0x32
    c9f8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
    c9fc:	bf48      	it	mi
    c9fe:	4240      	negmi	r0, r0
    ca00:	f04f 0100 	mov.w	r1, #0
    ca04:	e73e      	b.n	c884 <__adddf3+0x138>
    ca06:	bf00      	nop

0000ca08 <__aeabi_f2d>:
    ca08:	0042      	lsls	r2, r0, #1
    ca0a:	ea4f 01e2 	mov.w	r1, r2, asr #3
    ca0e:	ea4f 0131 	mov.w	r1, r1, rrx
    ca12:	ea4f 7002 	mov.w	r0, r2, lsl #28
    ca16:	bf1f      	itttt	ne
    ca18:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
    ca1c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    ca20:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
    ca24:	4770      	bxne	lr
    ca26:	f092 0f00 	teq	r2, #0
    ca2a:	bf14      	ite	ne
    ca2c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    ca30:	4770      	bxeq	lr
    ca32:	b530      	push	{r4, r5, lr}
    ca34:	f44f 7460 	mov.w	r4, #896	; 0x380
    ca38:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    ca3c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    ca40:	e720      	b.n	c884 <__adddf3+0x138>
    ca42:	bf00      	nop

0000ca44 <__aeabi_ul2d>:
    ca44:	ea50 0201 	orrs.w	r2, r0, r1
    ca48:	bf08      	it	eq
    ca4a:	4770      	bxeq	lr
    ca4c:	b530      	push	{r4, r5, lr}
    ca4e:	f04f 0500 	mov.w	r5, #0
    ca52:	e00a      	b.n	ca6a <__aeabi_l2d+0x16>

0000ca54 <__aeabi_l2d>:
    ca54:	ea50 0201 	orrs.w	r2, r0, r1
    ca58:	bf08      	it	eq
    ca5a:	4770      	bxeq	lr
    ca5c:	b530      	push	{r4, r5, lr}
    ca5e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
    ca62:	d502      	bpl.n	ca6a <__aeabi_l2d+0x16>
    ca64:	4240      	negs	r0, r0
    ca66:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    ca6a:	f44f 6480 	mov.w	r4, #1024	; 0x400
    ca6e:	f104 0432 	add.w	r4, r4, #50	; 0x32
    ca72:	ea5f 5c91 	movs.w	ip, r1, lsr #22
    ca76:	f43f aedc 	beq.w	c832 <__adddf3+0xe6>
    ca7a:	f04f 0203 	mov.w	r2, #3
    ca7e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    ca82:	bf18      	it	ne
    ca84:	3203      	addne	r2, #3
    ca86:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    ca8a:	bf18      	it	ne
    ca8c:	3203      	addne	r2, #3
    ca8e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
    ca92:	f1c2 0320 	rsb	r3, r2, #32
    ca96:	fa00 fc03 	lsl.w	ip, r0, r3
    ca9a:	fa20 f002 	lsr.w	r0, r0, r2
    ca9e:	fa01 fe03 	lsl.w	lr, r1, r3
    caa2:	ea40 000e 	orr.w	r0, r0, lr
    caa6:	fa21 f102 	lsr.w	r1, r1, r2
    caaa:	4414      	add	r4, r2
    caac:	e6c1      	b.n	c832 <__adddf3+0xe6>
    caae:	bf00      	nop

0000cab0 <__aeabi_dmul>:
    cab0:	b570      	push	{r4, r5, r6, lr}
    cab2:	f04f 0cff 	mov.w	ip, #255	; 0xff
    cab6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    caba:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    cabe:	bf1d      	ittte	ne
    cac0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    cac4:	ea94 0f0c 	teqne	r4, ip
    cac8:	ea95 0f0c 	teqne	r5, ip
    cacc:	f000 f8de 	bleq	cc8c <__aeabi_dmul+0x1dc>
    cad0:	442c      	add	r4, r5
    cad2:	ea81 0603 	eor.w	r6, r1, r3
    cad6:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
    cada:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
    cade:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
    cae2:	bf18      	it	ne
    cae4:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
    cae8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    caec:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    caf0:	d038      	beq.n	cb64 <__aeabi_dmul+0xb4>
    caf2:	fba0 ce02 	umull	ip, lr, r0, r2
    caf6:	f04f 0500 	mov.w	r5, #0
    cafa:	fbe1 e502 	umlal	lr, r5, r1, r2
    cafe:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
    cb02:	fbe0 e503 	umlal	lr, r5, r0, r3
    cb06:	f04f 0600 	mov.w	r6, #0
    cb0a:	fbe1 5603 	umlal	r5, r6, r1, r3
    cb0e:	f09c 0f00 	teq	ip, #0
    cb12:	bf18      	it	ne
    cb14:	f04e 0e01 	orrne.w	lr, lr, #1
    cb18:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
    cb1c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
    cb20:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
    cb24:	d204      	bcs.n	cb30 <__aeabi_dmul+0x80>
    cb26:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
    cb2a:	416d      	adcs	r5, r5
    cb2c:	eb46 0606 	adc.w	r6, r6, r6
    cb30:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
    cb34:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
    cb38:	ea4f 20c5 	mov.w	r0, r5, lsl #11
    cb3c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
    cb40:	ea4f 2ece 	mov.w	lr, lr, lsl #11
    cb44:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    cb48:	bf88      	it	hi
    cb4a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    cb4e:	d81e      	bhi.n	cb8e <__aeabi_dmul+0xde>
    cb50:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
    cb54:	bf08      	it	eq
    cb56:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
    cb5a:	f150 0000 	adcs.w	r0, r0, #0
    cb5e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    cb62:	bd70      	pop	{r4, r5, r6, pc}
    cb64:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
    cb68:	ea46 0101 	orr.w	r1, r6, r1
    cb6c:	ea40 0002 	orr.w	r0, r0, r2
    cb70:	ea81 0103 	eor.w	r1, r1, r3
    cb74:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
    cb78:	bfc2      	ittt	gt
    cb7a:	ebd4 050c 	rsbsgt	r5, r4, ip
    cb7e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    cb82:	bd70      	popgt	{r4, r5, r6, pc}
    cb84:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    cb88:	f04f 0e00 	mov.w	lr, #0
    cb8c:	3c01      	subs	r4, #1
    cb8e:	f300 80ab 	bgt.w	cce8 <__aeabi_dmul+0x238>
    cb92:	f114 0f36 	cmn.w	r4, #54	; 0x36
    cb96:	bfde      	ittt	le
    cb98:	2000      	movle	r0, #0
    cb9a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
    cb9e:	bd70      	pople	{r4, r5, r6, pc}
    cba0:	f1c4 0400 	rsb	r4, r4, #0
    cba4:	3c20      	subs	r4, #32
    cba6:	da35      	bge.n	cc14 <__aeabi_dmul+0x164>
    cba8:	340c      	adds	r4, #12
    cbaa:	dc1b      	bgt.n	cbe4 <__aeabi_dmul+0x134>
    cbac:	f104 0414 	add.w	r4, r4, #20
    cbb0:	f1c4 0520 	rsb	r5, r4, #32
    cbb4:	fa00 f305 	lsl.w	r3, r0, r5
    cbb8:	fa20 f004 	lsr.w	r0, r0, r4
    cbbc:	fa01 f205 	lsl.w	r2, r1, r5
    cbc0:	ea40 0002 	orr.w	r0, r0, r2
    cbc4:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
    cbc8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    cbcc:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    cbd0:	fa21 f604 	lsr.w	r6, r1, r4
    cbd4:	eb42 0106 	adc.w	r1, r2, r6
    cbd8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    cbdc:	bf08      	it	eq
    cbde:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    cbe2:	bd70      	pop	{r4, r5, r6, pc}
    cbe4:	f1c4 040c 	rsb	r4, r4, #12
    cbe8:	f1c4 0520 	rsb	r5, r4, #32
    cbec:	fa00 f304 	lsl.w	r3, r0, r4
    cbf0:	fa20 f005 	lsr.w	r0, r0, r5
    cbf4:	fa01 f204 	lsl.w	r2, r1, r4
    cbf8:	ea40 0002 	orr.w	r0, r0, r2
    cbfc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    cc00:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    cc04:	f141 0100 	adc.w	r1, r1, #0
    cc08:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    cc0c:	bf08      	it	eq
    cc0e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    cc12:	bd70      	pop	{r4, r5, r6, pc}
    cc14:	f1c4 0520 	rsb	r5, r4, #32
    cc18:	fa00 f205 	lsl.w	r2, r0, r5
    cc1c:	ea4e 0e02 	orr.w	lr, lr, r2
    cc20:	fa20 f304 	lsr.w	r3, r0, r4
    cc24:	fa01 f205 	lsl.w	r2, r1, r5
    cc28:	ea43 0302 	orr.w	r3, r3, r2
    cc2c:	fa21 f004 	lsr.w	r0, r1, r4
    cc30:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    cc34:	fa21 f204 	lsr.w	r2, r1, r4
    cc38:	ea20 0002 	bic.w	r0, r0, r2
    cc3c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
    cc40:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    cc44:	bf08      	it	eq
    cc46:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    cc4a:	bd70      	pop	{r4, r5, r6, pc}
    cc4c:	f094 0f00 	teq	r4, #0
    cc50:	d10f      	bne.n	cc72 <__aeabi_dmul+0x1c2>
    cc52:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
    cc56:	0040      	lsls	r0, r0, #1
    cc58:	eb41 0101 	adc.w	r1, r1, r1
    cc5c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    cc60:	bf08      	it	eq
    cc62:	3c01      	subeq	r4, #1
    cc64:	d0f7      	beq.n	cc56 <__aeabi_dmul+0x1a6>
    cc66:	ea41 0106 	orr.w	r1, r1, r6
    cc6a:	f095 0f00 	teq	r5, #0
    cc6e:	bf18      	it	ne
    cc70:	4770      	bxne	lr
    cc72:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
    cc76:	0052      	lsls	r2, r2, #1
    cc78:	eb43 0303 	adc.w	r3, r3, r3
    cc7c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    cc80:	bf08      	it	eq
    cc82:	3d01      	subeq	r5, #1
    cc84:	d0f7      	beq.n	cc76 <__aeabi_dmul+0x1c6>
    cc86:	ea43 0306 	orr.w	r3, r3, r6
    cc8a:	4770      	bx	lr
    cc8c:	ea94 0f0c 	teq	r4, ip
    cc90:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    cc94:	bf18      	it	ne
    cc96:	ea95 0f0c 	teqne	r5, ip
    cc9a:	d00c      	beq.n	ccb6 <__aeabi_dmul+0x206>
    cc9c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    cca0:	bf18      	it	ne
    cca2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    cca6:	d1d1      	bne.n	cc4c <__aeabi_dmul+0x19c>
    cca8:	ea81 0103 	eor.w	r1, r1, r3
    ccac:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    ccb0:	f04f 0000 	mov.w	r0, #0
    ccb4:	bd70      	pop	{r4, r5, r6, pc}
    ccb6:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    ccba:	bf06      	itte	eq
    ccbc:	4610      	moveq	r0, r2
    ccbe:	4619      	moveq	r1, r3
    ccc0:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    ccc4:	d019      	beq.n	ccfa <__aeabi_dmul+0x24a>
    ccc6:	ea94 0f0c 	teq	r4, ip
    ccca:	d102      	bne.n	ccd2 <__aeabi_dmul+0x222>
    cccc:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
    ccd0:	d113      	bne.n	ccfa <__aeabi_dmul+0x24a>
    ccd2:	ea95 0f0c 	teq	r5, ip
    ccd6:	d105      	bne.n	cce4 <__aeabi_dmul+0x234>
    ccd8:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
    ccdc:	bf1c      	itt	ne
    ccde:	4610      	movne	r0, r2
    cce0:	4619      	movne	r1, r3
    cce2:	d10a      	bne.n	ccfa <__aeabi_dmul+0x24a>
    cce4:	ea81 0103 	eor.w	r1, r1, r3
    cce8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    ccec:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    ccf0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    ccf4:	f04f 0000 	mov.w	r0, #0
    ccf8:	bd70      	pop	{r4, r5, r6, pc}
    ccfa:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    ccfe:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
    cd02:	bd70      	pop	{r4, r5, r6, pc}

0000cd04 <__aeabi_ddiv>:
    cd04:	b570      	push	{r4, r5, r6, lr}
    cd06:	f04f 0cff 	mov.w	ip, #255	; 0xff
    cd0a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    cd0e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    cd12:	bf1d      	ittte	ne
    cd14:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    cd18:	ea94 0f0c 	teqne	r4, ip
    cd1c:	ea95 0f0c 	teqne	r5, ip
    cd20:	f000 f8a7 	bleq	ce72 <__aeabi_ddiv+0x16e>
    cd24:	eba4 0405 	sub.w	r4, r4, r5
    cd28:	ea81 0e03 	eor.w	lr, r1, r3
    cd2c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    cd30:	ea4f 3101 	mov.w	r1, r1, lsl #12
    cd34:	f000 8088 	beq.w	ce48 <__aeabi_ddiv+0x144>
    cd38:	ea4f 3303 	mov.w	r3, r3, lsl #12
    cd3c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
    cd40:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
    cd44:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    cd48:	ea4f 2202 	mov.w	r2, r2, lsl #8
    cd4c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
    cd50:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
    cd54:	ea4f 2600 	mov.w	r6, r0, lsl #8
    cd58:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
    cd5c:	429d      	cmp	r5, r3
    cd5e:	bf08      	it	eq
    cd60:	4296      	cmpeq	r6, r2
    cd62:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
    cd66:	f504 7440 	add.w	r4, r4, #768	; 0x300
    cd6a:	d202      	bcs.n	cd72 <__aeabi_ddiv+0x6e>
    cd6c:	085b      	lsrs	r3, r3, #1
    cd6e:	ea4f 0232 	mov.w	r2, r2, rrx
    cd72:	1ab6      	subs	r6, r6, r2
    cd74:	eb65 0503 	sbc.w	r5, r5, r3
    cd78:	085b      	lsrs	r3, r3, #1
    cd7a:	ea4f 0232 	mov.w	r2, r2, rrx
    cd7e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    cd82:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
    cd86:	ebb6 0e02 	subs.w	lr, r6, r2
    cd8a:	eb75 0e03 	sbcs.w	lr, r5, r3
    cd8e:	bf22      	ittt	cs
    cd90:	1ab6      	subcs	r6, r6, r2
    cd92:	4675      	movcs	r5, lr
    cd94:	ea40 000c 	orrcs.w	r0, r0, ip
    cd98:	085b      	lsrs	r3, r3, #1
    cd9a:	ea4f 0232 	mov.w	r2, r2, rrx
    cd9e:	ebb6 0e02 	subs.w	lr, r6, r2
    cda2:	eb75 0e03 	sbcs.w	lr, r5, r3
    cda6:	bf22      	ittt	cs
    cda8:	1ab6      	subcs	r6, r6, r2
    cdaa:	4675      	movcs	r5, lr
    cdac:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    cdb0:	085b      	lsrs	r3, r3, #1
    cdb2:	ea4f 0232 	mov.w	r2, r2, rrx
    cdb6:	ebb6 0e02 	subs.w	lr, r6, r2
    cdba:	eb75 0e03 	sbcs.w	lr, r5, r3
    cdbe:	bf22      	ittt	cs
    cdc0:	1ab6      	subcs	r6, r6, r2
    cdc2:	4675      	movcs	r5, lr
    cdc4:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    cdc8:	085b      	lsrs	r3, r3, #1
    cdca:	ea4f 0232 	mov.w	r2, r2, rrx
    cdce:	ebb6 0e02 	subs.w	lr, r6, r2
    cdd2:	eb75 0e03 	sbcs.w	lr, r5, r3
    cdd6:	bf22      	ittt	cs
    cdd8:	1ab6      	subcs	r6, r6, r2
    cdda:	4675      	movcs	r5, lr
    cddc:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    cde0:	ea55 0e06 	orrs.w	lr, r5, r6
    cde4:	d018      	beq.n	ce18 <__aeabi_ddiv+0x114>
    cde6:	ea4f 1505 	mov.w	r5, r5, lsl #4
    cdea:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
    cdee:	ea4f 1606 	mov.w	r6, r6, lsl #4
    cdf2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    cdf6:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
    cdfa:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    cdfe:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
    ce02:	d1c0      	bne.n	cd86 <__aeabi_ddiv+0x82>
    ce04:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    ce08:	d10b      	bne.n	ce22 <__aeabi_ddiv+0x11e>
    ce0a:	ea41 0100 	orr.w	r1, r1, r0
    ce0e:	f04f 0000 	mov.w	r0, #0
    ce12:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
    ce16:	e7b6      	b.n	cd86 <__aeabi_ddiv+0x82>
    ce18:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    ce1c:	bf04      	itt	eq
    ce1e:	4301      	orreq	r1, r0
    ce20:	2000      	moveq	r0, #0
    ce22:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    ce26:	bf88      	it	hi
    ce28:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    ce2c:	f63f aeaf 	bhi.w	cb8e <__aeabi_dmul+0xde>
    ce30:	ebb5 0c03 	subs.w	ip, r5, r3
    ce34:	bf04      	itt	eq
    ce36:	ebb6 0c02 	subseq.w	ip, r6, r2
    ce3a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    ce3e:	f150 0000 	adcs.w	r0, r0, #0
    ce42:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    ce46:	bd70      	pop	{r4, r5, r6, pc}
    ce48:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
    ce4c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
    ce50:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
    ce54:	bfc2      	ittt	gt
    ce56:	ebd4 050c 	rsbsgt	r5, r4, ip
    ce5a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    ce5e:	bd70      	popgt	{r4, r5, r6, pc}
    ce60:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    ce64:	f04f 0e00 	mov.w	lr, #0
    ce68:	3c01      	subs	r4, #1
    ce6a:	e690      	b.n	cb8e <__aeabi_dmul+0xde>
    ce6c:	ea45 0e06 	orr.w	lr, r5, r6
    ce70:	e68d      	b.n	cb8e <__aeabi_dmul+0xde>
    ce72:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    ce76:	ea94 0f0c 	teq	r4, ip
    ce7a:	bf08      	it	eq
    ce7c:	ea95 0f0c 	teqeq	r5, ip
    ce80:	f43f af3b 	beq.w	ccfa <__aeabi_dmul+0x24a>
    ce84:	ea94 0f0c 	teq	r4, ip
    ce88:	d10a      	bne.n	cea0 <__aeabi_ddiv+0x19c>
    ce8a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    ce8e:	f47f af34 	bne.w	ccfa <__aeabi_dmul+0x24a>
    ce92:	ea95 0f0c 	teq	r5, ip
    ce96:	f47f af25 	bne.w	cce4 <__aeabi_dmul+0x234>
    ce9a:	4610      	mov	r0, r2
    ce9c:	4619      	mov	r1, r3
    ce9e:	e72c      	b.n	ccfa <__aeabi_dmul+0x24a>
    cea0:	ea95 0f0c 	teq	r5, ip
    cea4:	d106      	bne.n	ceb4 <__aeabi_ddiv+0x1b0>
    cea6:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    ceaa:	f43f aefd 	beq.w	cca8 <__aeabi_dmul+0x1f8>
    ceae:	4610      	mov	r0, r2
    ceb0:	4619      	mov	r1, r3
    ceb2:	e722      	b.n	ccfa <__aeabi_dmul+0x24a>
    ceb4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    ceb8:	bf18      	it	ne
    ceba:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    cebe:	f47f aec5 	bne.w	cc4c <__aeabi_dmul+0x19c>
    cec2:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
    cec6:	f47f af0d 	bne.w	cce4 <__aeabi_dmul+0x234>
    ceca:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
    cece:	f47f aeeb 	bne.w	cca8 <__aeabi_dmul+0x1f8>
    ced2:	e712      	b.n	ccfa <__aeabi_dmul+0x24a>

0000ced4 <__gedf2>:
    ced4:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
    ced8:	e006      	b.n	cee8 <__cmpdf2+0x4>
    ceda:	bf00      	nop

0000cedc <__ledf2>:
    cedc:	f04f 0c01 	mov.w	ip, #1
    cee0:	e002      	b.n	cee8 <__cmpdf2+0x4>
    cee2:	bf00      	nop

0000cee4 <__cmpdf2>:
    cee4:	f04f 0c01 	mov.w	ip, #1
    cee8:	f84d cd04 	str.w	ip, [sp, #-4]!
    ceec:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    cef0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    cef4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    cef8:	bf18      	it	ne
    cefa:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
    cefe:	d01b      	beq.n	cf38 <__cmpdf2+0x54>
    cf00:	b001      	add	sp, #4
    cf02:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
    cf06:	bf0c      	ite	eq
    cf08:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
    cf0c:	ea91 0f03 	teqne	r1, r3
    cf10:	bf02      	ittt	eq
    cf12:	ea90 0f02 	teqeq	r0, r2
    cf16:	2000      	moveq	r0, #0
    cf18:	4770      	bxeq	lr
    cf1a:	f110 0f00 	cmn.w	r0, #0
    cf1e:	ea91 0f03 	teq	r1, r3
    cf22:	bf58      	it	pl
    cf24:	4299      	cmppl	r1, r3
    cf26:	bf08      	it	eq
    cf28:	4290      	cmpeq	r0, r2
    cf2a:	bf2c      	ite	cs
    cf2c:	17d8      	asrcs	r0, r3, #31
    cf2e:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
    cf32:	f040 0001 	orr.w	r0, r0, #1
    cf36:	4770      	bx	lr
    cf38:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    cf3c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    cf40:	d102      	bne.n	cf48 <__cmpdf2+0x64>
    cf42:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    cf46:	d107      	bne.n	cf58 <__cmpdf2+0x74>
    cf48:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    cf4c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    cf50:	d1d6      	bne.n	cf00 <__cmpdf2+0x1c>
    cf52:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    cf56:	d0d3      	beq.n	cf00 <__cmpdf2+0x1c>
    cf58:	f85d 0b04 	ldr.w	r0, [sp], #4
    cf5c:	4770      	bx	lr
    cf5e:	bf00      	nop

0000cf60 <__aeabi_cdrcmple>:
    cf60:	4684      	mov	ip, r0
    cf62:	4610      	mov	r0, r2
    cf64:	4662      	mov	r2, ip
    cf66:	468c      	mov	ip, r1
    cf68:	4619      	mov	r1, r3
    cf6a:	4663      	mov	r3, ip
    cf6c:	e000      	b.n	cf70 <__aeabi_cdcmpeq>
    cf6e:	bf00      	nop

0000cf70 <__aeabi_cdcmpeq>:
    cf70:	b501      	push	{r0, lr}
    cf72:	f7ff ffb7 	bl	cee4 <__cmpdf2>
    cf76:	2800      	cmp	r0, #0
    cf78:	bf48      	it	mi
    cf7a:	f110 0f00 	cmnmi.w	r0, #0
    cf7e:	bd01      	pop	{r0, pc}

0000cf80 <__aeabi_dcmpeq>:
    cf80:	f84d ed08 	str.w	lr, [sp, #-8]!
    cf84:	f7ff fff4 	bl	cf70 <__aeabi_cdcmpeq>
    cf88:	bf0c      	ite	eq
    cf8a:	2001      	moveq	r0, #1
    cf8c:	2000      	movne	r0, #0
    cf8e:	f85d fb08 	ldr.w	pc, [sp], #8
    cf92:	bf00      	nop

0000cf94 <__aeabi_dcmplt>:
    cf94:	f84d ed08 	str.w	lr, [sp, #-8]!
    cf98:	f7ff ffea 	bl	cf70 <__aeabi_cdcmpeq>
    cf9c:	bf34      	ite	cc
    cf9e:	2001      	movcc	r0, #1
    cfa0:	2000      	movcs	r0, #0
    cfa2:	f85d fb08 	ldr.w	pc, [sp], #8
    cfa6:	bf00      	nop

0000cfa8 <__aeabi_dcmple>:
    cfa8:	f84d ed08 	str.w	lr, [sp, #-8]!
    cfac:	f7ff ffe0 	bl	cf70 <__aeabi_cdcmpeq>
    cfb0:	bf94      	ite	ls
    cfb2:	2001      	movls	r0, #1
    cfb4:	2000      	movhi	r0, #0
    cfb6:	f85d fb08 	ldr.w	pc, [sp], #8
    cfba:	bf00      	nop

0000cfbc <__aeabi_dcmpge>:
    cfbc:	f84d ed08 	str.w	lr, [sp, #-8]!
    cfc0:	f7ff ffce 	bl	cf60 <__aeabi_cdrcmple>
    cfc4:	bf94      	ite	ls
    cfc6:	2001      	movls	r0, #1
    cfc8:	2000      	movhi	r0, #0
    cfca:	f85d fb08 	ldr.w	pc, [sp], #8
    cfce:	bf00      	nop

0000cfd0 <__aeabi_dcmpgt>:
    cfd0:	f84d ed08 	str.w	lr, [sp, #-8]!
    cfd4:	f7ff ffc4 	bl	cf60 <__aeabi_cdrcmple>
    cfd8:	bf34      	ite	cc
    cfda:	2001      	movcc	r0, #1
    cfdc:	2000      	movcs	r0, #0
    cfde:	f85d fb08 	ldr.w	pc, [sp], #8
    cfe2:	bf00      	nop

0000cfe4 <__aeabi_dcmpun>:
    cfe4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    cfe8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    cfec:	d102      	bne.n	cff4 <__aeabi_dcmpun+0x10>
    cfee:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    cff2:	d10a      	bne.n	d00a <__aeabi_dcmpun+0x26>
    cff4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    cff8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    cffc:	d102      	bne.n	d004 <__aeabi_dcmpun+0x20>
    cffe:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    d002:	d102      	bne.n	d00a <__aeabi_dcmpun+0x26>
    d004:	f04f 0000 	mov.w	r0, #0
    d008:	4770      	bx	lr
    d00a:	f04f 0001 	mov.w	r0, #1
    d00e:	4770      	bx	lr

0000d010 <__aeabi_d2iz>:
    d010:	ea4f 0241 	mov.w	r2, r1, lsl #1
    d014:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
    d018:	d215      	bcs.n	d046 <__aeabi_d2iz+0x36>
    d01a:	d511      	bpl.n	d040 <__aeabi_d2iz+0x30>
    d01c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
    d020:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    d024:	d912      	bls.n	d04c <__aeabi_d2iz+0x3c>
    d026:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    d02a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    d02e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    d032:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    d036:	fa23 f002 	lsr.w	r0, r3, r2
    d03a:	bf18      	it	ne
    d03c:	4240      	negne	r0, r0
    d03e:	4770      	bx	lr
    d040:	f04f 0000 	mov.w	r0, #0
    d044:	4770      	bx	lr
    d046:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    d04a:	d105      	bne.n	d058 <__aeabi_d2iz+0x48>
    d04c:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
    d050:	bf08      	it	eq
    d052:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
    d056:	4770      	bx	lr
    d058:	f04f 0000 	mov.w	r0, #0
    d05c:	4770      	bx	lr
    d05e:	bf00      	nop

0000d060 <__aeabi_d2uiz>:
    d060:	004a      	lsls	r2, r1, #1
    d062:	d211      	bcs.n	d088 <__aeabi_d2uiz+0x28>
    d064:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
    d068:	d211      	bcs.n	d08e <__aeabi_d2uiz+0x2e>
    d06a:	d50d      	bpl.n	d088 <__aeabi_d2uiz+0x28>
    d06c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
    d070:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    d074:	d40e      	bmi.n	d094 <__aeabi_d2uiz+0x34>
    d076:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    d07a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    d07e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    d082:	fa23 f002 	lsr.w	r0, r3, r2
    d086:	4770      	bx	lr
    d088:	f04f 0000 	mov.w	r0, #0
    d08c:	4770      	bx	lr
    d08e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    d092:	d102      	bne.n	d09a <__aeabi_d2uiz+0x3a>
    d094:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    d098:	4770      	bx	lr
    d09a:	f04f 0000 	mov.w	r0, #0
    d09e:	4770      	bx	lr

0000d0a0 <__aeabi_d2f>:
    d0a0:	ea4f 0241 	mov.w	r2, r1, lsl #1
    d0a4:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    d0a8:	bf24      	itt	cs
    d0aa:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    d0ae:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    d0b2:	d90d      	bls.n	d0d0 <__aeabi_d2f+0x30>
    d0b4:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    d0b8:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    d0bc:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    d0c0:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    d0c4:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    d0c8:	bf08      	it	eq
    d0ca:	f020 0001 	biceq.w	r0, r0, #1
    d0ce:	4770      	bx	lr
    d0d0:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    d0d4:	d121      	bne.n	d11a <__aeabi_d2f+0x7a>
    d0d6:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    d0da:	bfbc      	itt	lt
    d0dc:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    d0e0:	4770      	bxlt	lr
    d0e2:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    d0e6:	ea4f 5252 	mov.w	r2, r2, lsr #21
    d0ea:	f1c2 0218 	rsb	r2, r2, #24
    d0ee:	f1c2 0c20 	rsb	ip, r2, #32
    d0f2:	fa10 f30c 	lsls.w	r3, r0, ip
    d0f6:	fa20 f002 	lsr.w	r0, r0, r2
    d0fa:	bf18      	it	ne
    d0fc:	f040 0001 	orrne.w	r0, r0, #1
    d100:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    d104:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    d108:	fa03 fc0c 	lsl.w	ip, r3, ip
    d10c:	ea40 000c 	orr.w	r0, r0, ip
    d110:	fa23 f302 	lsr.w	r3, r3, r2
    d114:	ea4f 0343 	mov.w	r3, r3, lsl #1
    d118:	e7cc      	b.n	d0b4 <__aeabi_d2f+0x14>
    d11a:	ea7f 5362 	mvns.w	r3, r2, asr #21
    d11e:	d107      	bne.n	d130 <__aeabi_d2f+0x90>
    d120:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    d124:	bf1e      	ittt	ne
    d126:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    d12a:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    d12e:	4770      	bxne	lr
    d130:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    d134:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    d138:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    d13c:	4770      	bx	lr
    d13e:	bf00      	nop

0000d140 <__aeabi_frsub>:
    d140:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
    d144:	e002      	b.n	d14c <__addsf3>
    d146:	bf00      	nop

0000d148 <__aeabi_fsub>:
    d148:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

0000d14c <__addsf3>:
    d14c:	0042      	lsls	r2, r0, #1
    d14e:	bf1f      	itttt	ne
    d150:	ea5f 0341 	movsne.w	r3, r1, lsl #1
    d154:	ea92 0f03 	teqne	r2, r3
    d158:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
    d15c:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
    d160:	d06a      	beq.n	d238 <__addsf3+0xec>
    d162:	ea4f 6212 	mov.w	r2, r2, lsr #24
    d166:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
    d16a:	bfc1      	itttt	gt
    d16c:	18d2      	addgt	r2, r2, r3
    d16e:	4041      	eorgt	r1, r0
    d170:	4048      	eorgt	r0, r1
    d172:	4041      	eorgt	r1, r0
    d174:	bfb8      	it	lt
    d176:	425b      	neglt	r3, r3
    d178:	2b19      	cmp	r3, #25
    d17a:	bf88      	it	hi
    d17c:	4770      	bxhi	lr
    d17e:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
    d182:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    d186:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    d18a:	bf18      	it	ne
    d18c:	4240      	negne	r0, r0
    d18e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    d192:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
    d196:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
    d19a:	bf18      	it	ne
    d19c:	4249      	negne	r1, r1
    d19e:	ea92 0f03 	teq	r2, r3
    d1a2:	d03f      	beq.n	d224 <__addsf3+0xd8>
    d1a4:	f1a2 0201 	sub.w	r2, r2, #1
    d1a8:	fa41 fc03 	asr.w	ip, r1, r3
    d1ac:	eb10 000c 	adds.w	r0, r0, ip
    d1b0:	f1c3 0320 	rsb	r3, r3, #32
    d1b4:	fa01 f103 	lsl.w	r1, r1, r3
    d1b8:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
    d1bc:	d502      	bpl.n	d1c4 <__addsf3+0x78>
    d1be:	4249      	negs	r1, r1
    d1c0:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
    d1c4:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    d1c8:	d313      	bcc.n	d1f2 <__addsf3+0xa6>
    d1ca:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
    d1ce:	d306      	bcc.n	d1de <__addsf3+0x92>
    d1d0:	0840      	lsrs	r0, r0, #1
    d1d2:	ea4f 0131 	mov.w	r1, r1, rrx
    d1d6:	f102 0201 	add.w	r2, r2, #1
    d1da:	2afe      	cmp	r2, #254	; 0xfe
    d1dc:	d251      	bcs.n	d282 <__addsf3+0x136>
    d1de:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
    d1e2:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
    d1e6:	bf08      	it	eq
    d1e8:	f020 0001 	biceq.w	r0, r0, #1
    d1ec:	ea40 0003 	orr.w	r0, r0, r3
    d1f0:	4770      	bx	lr
    d1f2:	0049      	lsls	r1, r1, #1
    d1f4:	eb40 0000 	adc.w	r0, r0, r0
    d1f8:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
    d1fc:	f1a2 0201 	sub.w	r2, r2, #1
    d200:	d1ed      	bne.n	d1de <__addsf3+0x92>
    d202:	fab0 fc80 	clz	ip, r0
    d206:	f1ac 0c08 	sub.w	ip, ip, #8
    d20a:	ebb2 020c 	subs.w	r2, r2, ip
    d20e:	fa00 f00c 	lsl.w	r0, r0, ip
    d212:	bfaa      	itet	ge
    d214:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
    d218:	4252      	neglt	r2, r2
    d21a:	4318      	orrge	r0, r3
    d21c:	bfbc      	itt	lt
    d21e:	40d0      	lsrlt	r0, r2
    d220:	4318      	orrlt	r0, r3
    d222:	4770      	bx	lr
    d224:	f092 0f00 	teq	r2, #0
    d228:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
    d22c:	bf06      	itte	eq
    d22e:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
    d232:	3201      	addeq	r2, #1
    d234:	3b01      	subne	r3, #1
    d236:	e7b5      	b.n	d1a4 <__addsf3+0x58>
    d238:	ea4f 0341 	mov.w	r3, r1, lsl #1
    d23c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
    d240:	bf18      	it	ne
    d242:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
    d246:	d021      	beq.n	d28c <__addsf3+0x140>
    d248:	ea92 0f03 	teq	r2, r3
    d24c:	d004      	beq.n	d258 <__addsf3+0x10c>
    d24e:	f092 0f00 	teq	r2, #0
    d252:	bf08      	it	eq
    d254:	4608      	moveq	r0, r1
    d256:	4770      	bx	lr
    d258:	ea90 0f01 	teq	r0, r1
    d25c:	bf1c      	itt	ne
    d25e:	2000      	movne	r0, #0
    d260:	4770      	bxne	lr
    d262:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
    d266:	d104      	bne.n	d272 <__addsf3+0x126>
    d268:	0040      	lsls	r0, r0, #1
    d26a:	bf28      	it	cs
    d26c:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
    d270:	4770      	bx	lr
    d272:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
    d276:	bf3c      	itt	cc
    d278:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
    d27c:	4770      	bxcc	lr
    d27e:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
    d282:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
    d286:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    d28a:	4770      	bx	lr
    d28c:	ea7f 6222 	mvns.w	r2, r2, asr #24
    d290:	bf16      	itet	ne
    d292:	4608      	movne	r0, r1
    d294:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
    d298:	4601      	movne	r1, r0
    d29a:	0242      	lsls	r2, r0, #9
    d29c:	bf06      	itte	eq
    d29e:	ea5f 2341 	movseq.w	r3, r1, lsl #9
    d2a2:	ea90 0f01 	teqeq	r0, r1
    d2a6:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
    d2aa:	4770      	bx	lr

0000d2ac <__aeabi_ui2f>:
    d2ac:	f04f 0300 	mov.w	r3, #0
    d2b0:	e004      	b.n	d2bc <__aeabi_i2f+0x8>
    d2b2:	bf00      	nop

0000d2b4 <__aeabi_i2f>:
    d2b4:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
    d2b8:	bf48      	it	mi
    d2ba:	4240      	negmi	r0, r0
    d2bc:	ea5f 0c00 	movs.w	ip, r0
    d2c0:	bf08      	it	eq
    d2c2:	4770      	bxeq	lr
    d2c4:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
    d2c8:	4601      	mov	r1, r0
    d2ca:	f04f 0000 	mov.w	r0, #0
    d2ce:	e01c      	b.n	d30a <__aeabi_l2f+0x2a>

0000d2d0 <__aeabi_ul2f>:
    d2d0:	ea50 0201 	orrs.w	r2, r0, r1
    d2d4:	bf08      	it	eq
    d2d6:	4770      	bxeq	lr
    d2d8:	f04f 0300 	mov.w	r3, #0
    d2dc:	e00a      	b.n	d2f4 <__aeabi_l2f+0x14>
    d2de:	bf00      	nop

0000d2e0 <__aeabi_l2f>:
    d2e0:	ea50 0201 	orrs.w	r2, r0, r1
    d2e4:	bf08      	it	eq
    d2e6:	4770      	bxeq	lr
    d2e8:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
    d2ec:	d502      	bpl.n	d2f4 <__aeabi_l2f+0x14>
    d2ee:	4240      	negs	r0, r0
    d2f0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    d2f4:	ea5f 0c01 	movs.w	ip, r1
    d2f8:	bf02      	ittt	eq
    d2fa:	4684      	moveq	ip, r0
    d2fc:	4601      	moveq	r1, r0
    d2fe:	2000      	moveq	r0, #0
    d300:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
    d304:	bf08      	it	eq
    d306:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
    d30a:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
    d30e:	fabc f28c 	clz	r2, ip
    d312:	3a08      	subs	r2, #8
    d314:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
    d318:	db10      	blt.n	d33c <__aeabi_l2f+0x5c>
    d31a:	fa01 fc02 	lsl.w	ip, r1, r2
    d31e:	4463      	add	r3, ip
    d320:	fa00 fc02 	lsl.w	ip, r0, r2
    d324:	f1c2 0220 	rsb	r2, r2, #32
    d328:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    d32c:	fa20 f202 	lsr.w	r2, r0, r2
    d330:	eb43 0002 	adc.w	r0, r3, r2
    d334:	bf08      	it	eq
    d336:	f020 0001 	biceq.w	r0, r0, #1
    d33a:	4770      	bx	lr
    d33c:	f102 0220 	add.w	r2, r2, #32
    d340:	fa01 fc02 	lsl.w	ip, r1, r2
    d344:	f1c2 0220 	rsb	r2, r2, #32
    d348:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
    d34c:	fa21 f202 	lsr.w	r2, r1, r2
    d350:	eb43 0002 	adc.w	r0, r3, r2
    d354:	bf08      	it	eq
    d356:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
    d35a:	4770      	bx	lr

0000d35c <__aeabi_fmul>:
    d35c:	f04f 0cff 	mov.w	ip, #255	; 0xff
    d360:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
    d364:	bf1e      	ittt	ne
    d366:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
    d36a:	ea92 0f0c 	teqne	r2, ip
    d36e:	ea93 0f0c 	teqne	r3, ip
    d372:	d06f      	beq.n	d454 <__aeabi_fmul+0xf8>
    d374:	441a      	add	r2, r3
    d376:	ea80 0c01 	eor.w	ip, r0, r1
    d37a:	0240      	lsls	r0, r0, #9
    d37c:	bf18      	it	ne
    d37e:	ea5f 2141 	movsne.w	r1, r1, lsl #9
    d382:	d01e      	beq.n	d3c2 <__aeabi_fmul+0x66>
    d384:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    d388:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
    d38c:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
    d390:	fba0 3101 	umull	r3, r1, r0, r1
    d394:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
    d398:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
    d39c:	bf3e      	ittt	cc
    d39e:	0049      	lslcc	r1, r1, #1
    d3a0:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
    d3a4:	005b      	lslcc	r3, r3, #1
    d3a6:	ea40 0001 	orr.w	r0, r0, r1
    d3aa:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
    d3ae:	2afd      	cmp	r2, #253	; 0xfd
    d3b0:	d81d      	bhi.n	d3ee <__aeabi_fmul+0x92>
    d3b2:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
    d3b6:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
    d3ba:	bf08      	it	eq
    d3bc:	f020 0001 	biceq.w	r0, r0, #1
    d3c0:	4770      	bx	lr
    d3c2:	f090 0f00 	teq	r0, #0
    d3c6:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
    d3ca:	bf08      	it	eq
    d3cc:	0249      	lsleq	r1, r1, #9
    d3ce:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
    d3d2:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
    d3d6:	3a7f      	subs	r2, #127	; 0x7f
    d3d8:	bfc2      	ittt	gt
    d3da:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
    d3de:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
    d3e2:	4770      	bxgt	lr
    d3e4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    d3e8:	f04f 0300 	mov.w	r3, #0
    d3ec:	3a01      	subs	r2, #1
    d3ee:	dc5d      	bgt.n	d4ac <__aeabi_fmul+0x150>
    d3f0:	f112 0f19 	cmn.w	r2, #25
    d3f4:	bfdc      	itt	le
    d3f6:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
    d3fa:	4770      	bxle	lr
    d3fc:	f1c2 0200 	rsb	r2, r2, #0
    d400:	0041      	lsls	r1, r0, #1
    d402:	fa21 f102 	lsr.w	r1, r1, r2
    d406:	f1c2 0220 	rsb	r2, r2, #32
    d40a:	fa00 fc02 	lsl.w	ip, r0, r2
    d40e:	ea5f 0031 	movs.w	r0, r1, rrx
    d412:	f140 0000 	adc.w	r0, r0, #0
    d416:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
    d41a:	bf08      	it	eq
    d41c:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
    d420:	4770      	bx	lr
    d422:	f092 0f00 	teq	r2, #0
    d426:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
    d42a:	bf02      	ittt	eq
    d42c:	0040      	lsleq	r0, r0, #1
    d42e:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
    d432:	3a01      	subeq	r2, #1
    d434:	d0f9      	beq.n	d42a <__aeabi_fmul+0xce>
    d436:	ea40 000c 	orr.w	r0, r0, ip
    d43a:	f093 0f00 	teq	r3, #0
    d43e:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    d442:	bf02      	ittt	eq
    d444:	0049      	lsleq	r1, r1, #1
    d446:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
    d44a:	3b01      	subeq	r3, #1
    d44c:	d0f9      	beq.n	d442 <__aeabi_fmul+0xe6>
    d44e:	ea41 010c 	orr.w	r1, r1, ip
    d452:	e78f      	b.n	d374 <__aeabi_fmul+0x18>
    d454:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
    d458:	ea92 0f0c 	teq	r2, ip
    d45c:	bf18      	it	ne
    d45e:	ea93 0f0c 	teqne	r3, ip
    d462:	d00a      	beq.n	d47a <__aeabi_fmul+0x11e>
    d464:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
    d468:	bf18      	it	ne
    d46a:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
    d46e:	d1d8      	bne.n	d422 <__aeabi_fmul+0xc6>
    d470:	ea80 0001 	eor.w	r0, r0, r1
    d474:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
    d478:	4770      	bx	lr
    d47a:	f090 0f00 	teq	r0, #0
    d47e:	bf17      	itett	ne
    d480:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
    d484:	4608      	moveq	r0, r1
    d486:	f091 0f00 	teqne	r1, #0
    d48a:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
    d48e:	d014      	beq.n	d4ba <__aeabi_fmul+0x15e>
    d490:	ea92 0f0c 	teq	r2, ip
    d494:	d101      	bne.n	d49a <__aeabi_fmul+0x13e>
    d496:	0242      	lsls	r2, r0, #9
    d498:	d10f      	bne.n	d4ba <__aeabi_fmul+0x15e>
    d49a:	ea93 0f0c 	teq	r3, ip
    d49e:	d103      	bne.n	d4a8 <__aeabi_fmul+0x14c>
    d4a0:	024b      	lsls	r3, r1, #9
    d4a2:	bf18      	it	ne
    d4a4:	4608      	movne	r0, r1
    d4a6:	d108      	bne.n	d4ba <__aeabi_fmul+0x15e>
    d4a8:	ea80 0001 	eor.w	r0, r0, r1
    d4ac:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
    d4b0:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    d4b4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    d4b8:	4770      	bx	lr
    d4ba:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    d4be:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
    d4c2:	4770      	bx	lr

0000d4c4 <__aeabi_fdiv>:
    d4c4:	f04f 0cff 	mov.w	ip, #255	; 0xff
    d4c8:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
    d4cc:	bf1e      	ittt	ne
    d4ce:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
    d4d2:	ea92 0f0c 	teqne	r2, ip
    d4d6:	ea93 0f0c 	teqne	r3, ip
    d4da:	d069      	beq.n	d5b0 <__aeabi_fdiv+0xec>
    d4dc:	eba2 0203 	sub.w	r2, r2, r3
    d4e0:	ea80 0c01 	eor.w	ip, r0, r1
    d4e4:	0249      	lsls	r1, r1, #9
    d4e6:	ea4f 2040 	mov.w	r0, r0, lsl #9
    d4ea:	d037      	beq.n	d55c <__aeabi_fdiv+0x98>
    d4ec:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    d4f0:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
    d4f4:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
    d4f8:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
    d4fc:	428b      	cmp	r3, r1
    d4fe:	bf38      	it	cc
    d500:	005b      	lslcc	r3, r3, #1
    d502:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
    d506:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
    d50a:	428b      	cmp	r3, r1
    d50c:	bf24      	itt	cs
    d50e:	1a5b      	subcs	r3, r3, r1
    d510:	ea40 000c 	orrcs.w	r0, r0, ip
    d514:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
    d518:	bf24      	itt	cs
    d51a:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
    d51e:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    d522:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
    d526:	bf24      	itt	cs
    d528:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
    d52c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    d530:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
    d534:	bf24      	itt	cs
    d536:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
    d53a:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    d53e:	011b      	lsls	r3, r3, #4
    d540:	bf18      	it	ne
    d542:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
    d546:	d1e0      	bne.n	d50a <__aeabi_fdiv+0x46>
    d548:	2afd      	cmp	r2, #253	; 0xfd
    d54a:	f63f af50 	bhi.w	d3ee <__aeabi_fmul+0x92>
    d54e:	428b      	cmp	r3, r1
    d550:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
    d554:	bf08      	it	eq
    d556:	f020 0001 	biceq.w	r0, r0, #1
    d55a:	4770      	bx	lr
    d55c:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
    d560:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
    d564:	327f      	adds	r2, #127	; 0x7f
    d566:	bfc2      	ittt	gt
    d568:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
    d56c:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
    d570:	4770      	bxgt	lr
    d572:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    d576:	f04f 0300 	mov.w	r3, #0
    d57a:	3a01      	subs	r2, #1
    d57c:	e737      	b.n	d3ee <__aeabi_fmul+0x92>
    d57e:	f092 0f00 	teq	r2, #0
    d582:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
    d586:	bf02      	ittt	eq
    d588:	0040      	lsleq	r0, r0, #1
    d58a:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
    d58e:	3a01      	subeq	r2, #1
    d590:	d0f9      	beq.n	d586 <__aeabi_fdiv+0xc2>
    d592:	ea40 000c 	orr.w	r0, r0, ip
    d596:	f093 0f00 	teq	r3, #0
    d59a:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    d59e:	bf02      	ittt	eq
    d5a0:	0049      	lsleq	r1, r1, #1
    d5a2:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
    d5a6:	3b01      	subeq	r3, #1
    d5a8:	d0f9      	beq.n	d59e <__aeabi_fdiv+0xda>
    d5aa:	ea41 010c 	orr.w	r1, r1, ip
    d5ae:	e795      	b.n	d4dc <__aeabi_fdiv+0x18>
    d5b0:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
    d5b4:	ea92 0f0c 	teq	r2, ip
    d5b8:	d108      	bne.n	d5cc <__aeabi_fdiv+0x108>
    d5ba:	0242      	lsls	r2, r0, #9
    d5bc:	f47f af7d 	bne.w	d4ba <__aeabi_fmul+0x15e>
    d5c0:	ea93 0f0c 	teq	r3, ip
    d5c4:	f47f af70 	bne.w	d4a8 <__aeabi_fmul+0x14c>
    d5c8:	4608      	mov	r0, r1
    d5ca:	e776      	b.n	d4ba <__aeabi_fmul+0x15e>
    d5cc:	ea93 0f0c 	teq	r3, ip
    d5d0:	d104      	bne.n	d5dc <__aeabi_fdiv+0x118>
    d5d2:	024b      	lsls	r3, r1, #9
    d5d4:	f43f af4c 	beq.w	d470 <__aeabi_fmul+0x114>
    d5d8:	4608      	mov	r0, r1
    d5da:	e76e      	b.n	d4ba <__aeabi_fmul+0x15e>
    d5dc:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
    d5e0:	bf18      	it	ne
    d5e2:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
    d5e6:	d1ca      	bne.n	d57e <__aeabi_fdiv+0xba>
    d5e8:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
    d5ec:	f47f af5c 	bne.w	d4a8 <__aeabi_fmul+0x14c>
    d5f0:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
    d5f4:	f47f af3c 	bne.w	d470 <__aeabi_fmul+0x114>
    d5f8:	e75f      	b.n	d4ba <__aeabi_fmul+0x15e>
    d5fa:	bf00      	nop

0000d5fc <__gesf2>:
    d5fc:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
    d600:	e006      	b.n	d610 <__cmpsf2+0x4>
    d602:	bf00      	nop

0000d604 <__lesf2>:
    d604:	f04f 0c01 	mov.w	ip, #1
    d608:	e002      	b.n	d610 <__cmpsf2+0x4>
    d60a:	bf00      	nop

0000d60c <__cmpsf2>:
    d60c:	f04f 0c01 	mov.w	ip, #1
    d610:	f84d cd04 	str.w	ip, [sp, #-4]!
    d614:	ea4f 0240 	mov.w	r2, r0, lsl #1
    d618:	ea4f 0341 	mov.w	r3, r1, lsl #1
    d61c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
    d620:	bf18      	it	ne
    d622:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
    d626:	d011      	beq.n	d64c <__cmpsf2+0x40>
    d628:	b001      	add	sp, #4
    d62a:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
    d62e:	bf18      	it	ne
    d630:	ea90 0f01 	teqne	r0, r1
    d634:	bf58      	it	pl
    d636:	ebb2 0003 	subspl.w	r0, r2, r3
    d63a:	bf88      	it	hi
    d63c:	17c8      	asrhi	r0, r1, #31
    d63e:	bf38      	it	cc
    d640:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
    d644:	bf18      	it	ne
    d646:	f040 0001 	orrne.w	r0, r0, #1
    d64a:	4770      	bx	lr
    d64c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
    d650:	d102      	bne.n	d658 <__cmpsf2+0x4c>
    d652:	ea5f 2c40 	movs.w	ip, r0, lsl #9
    d656:	d105      	bne.n	d664 <__cmpsf2+0x58>
    d658:	ea7f 6c23 	mvns.w	ip, r3, asr #24
    d65c:	d1e4      	bne.n	d628 <__cmpsf2+0x1c>
    d65e:	ea5f 2c41 	movs.w	ip, r1, lsl #9
    d662:	d0e1      	beq.n	d628 <__cmpsf2+0x1c>
    d664:	f85d 0b04 	ldr.w	r0, [sp], #4
    d668:	4770      	bx	lr
    d66a:	bf00      	nop

0000d66c <__aeabi_cfrcmple>:
    d66c:	4684      	mov	ip, r0
    d66e:	4608      	mov	r0, r1
    d670:	4661      	mov	r1, ip
    d672:	e7ff      	b.n	d674 <__aeabi_cfcmpeq>

0000d674 <__aeabi_cfcmpeq>:
    d674:	b50f      	push	{r0, r1, r2, r3, lr}
    d676:	f7ff ffc9 	bl	d60c <__cmpsf2>
    d67a:	2800      	cmp	r0, #0
    d67c:	bf48      	it	mi
    d67e:	f110 0f00 	cmnmi.w	r0, #0
    d682:	bd0f      	pop	{r0, r1, r2, r3, pc}

0000d684 <__aeabi_fcmpeq>:
    d684:	f84d ed08 	str.w	lr, [sp, #-8]!
    d688:	f7ff fff4 	bl	d674 <__aeabi_cfcmpeq>
    d68c:	bf0c      	ite	eq
    d68e:	2001      	moveq	r0, #1
    d690:	2000      	movne	r0, #0
    d692:	f85d fb08 	ldr.w	pc, [sp], #8
    d696:	bf00      	nop

0000d698 <__aeabi_fcmplt>:
    d698:	f84d ed08 	str.w	lr, [sp, #-8]!
    d69c:	f7ff ffea 	bl	d674 <__aeabi_cfcmpeq>
    d6a0:	bf34      	ite	cc
    d6a2:	2001      	movcc	r0, #1
    d6a4:	2000      	movcs	r0, #0
    d6a6:	f85d fb08 	ldr.w	pc, [sp], #8
    d6aa:	bf00      	nop

0000d6ac <__aeabi_fcmple>:
    d6ac:	f84d ed08 	str.w	lr, [sp, #-8]!
    d6b0:	f7ff ffe0 	bl	d674 <__aeabi_cfcmpeq>
    d6b4:	bf94      	ite	ls
    d6b6:	2001      	movls	r0, #1
    d6b8:	2000      	movhi	r0, #0
    d6ba:	f85d fb08 	ldr.w	pc, [sp], #8
    d6be:	bf00      	nop

0000d6c0 <__aeabi_fcmpge>:
    d6c0:	f84d ed08 	str.w	lr, [sp, #-8]!
    d6c4:	f7ff ffd2 	bl	d66c <__aeabi_cfrcmple>
    d6c8:	bf94      	ite	ls
    d6ca:	2001      	movls	r0, #1
    d6cc:	2000      	movhi	r0, #0
    d6ce:	f85d fb08 	ldr.w	pc, [sp], #8
    d6d2:	bf00      	nop

0000d6d4 <__aeabi_fcmpgt>:
    d6d4:	f84d ed08 	str.w	lr, [sp, #-8]!
    d6d8:	f7ff ffc8 	bl	d66c <__aeabi_cfrcmple>
    d6dc:	bf34      	ite	cc
    d6de:	2001      	movcc	r0, #1
    d6e0:	2000      	movcs	r0, #0
    d6e2:	f85d fb08 	ldr.w	pc, [sp], #8
    d6e6:	bf00      	nop

0000d6e8 <__aeabi_fcmpun>:
    d6e8:	ea4f 0240 	mov.w	r2, r0, lsl #1
    d6ec:	ea4f 0341 	mov.w	r3, r1, lsl #1
    d6f0:	ea7f 6c22 	mvns.w	ip, r2, asr #24
    d6f4:	d102      	bne.n	d6fc <__aeabi_fcmpun+0x14>
    d6f6:	ea5f 2c40 	movs.w	ip, r0, lsl #9
    d6fa:	d108      	bne.n	d70e <__aeabi_fcmpun+0x26>
    d6fc:	ea7f 6c23 	mvns.w	ip, r3, asr #24
    d700:	d102      	bne.n	d708 <__aeabi_fcmpun+0x20>
    d702:	ea5f 2c41 	movs.w	ip, r1, lsl #9
    d706:	d102      	bne.n	d70e <__aeabi_fcmpun+0x26>
    d708:	f04f 0000 	mov.w	r0, #0
    d70c:	4770      	bx	lr
    d70e:	f04f 0001 	mov.w	r0, #1
    d712:	4770      	bx	lr

0000d714 <__aeabi_f2iz>:
    d714:	ea4f 0240 	mov.w	r2, r0, lsl #1
    d718:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
    d71c:	d30f      	bcc.n	d73e <__aeabi_f2iz+0x2a>
    d71e:	f04f 039e 	mov.w	r3, #158	; 0x9e
    d722:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
    d726:	d90d      	bls.n	d744 <__aeabi_f2iz+0x30>
    d728:	ea4f 2300 	mov.w	r3, r0, lsl #8
    d72c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    d730:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
    d734:	fa23 f002 	lsr.w	r0, r3, r2
    d738:	bf18      	it	ne
    d73a:	4240      	negne	r0, r0
    d73c:	4770      	bx	lr
    d73e:	f04f 0000 	mov.w	r0, #0
    d742:	4770      	bx	lr
    d744:	f112 0f61 	cmn.w	r2, #97	; 0x61
    d748:	d101      	bne.n	d74e <__aeabi_f2iz+0x3a>
    d74a:	0242      	lsls	r2, r0, #9
    d74c:	d105      	bne.n	d75a <__aeabi_f2iz+0x46>
    d74e:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
    d752:	bf08      	it	eq
    d754:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
    d758:	4770      	bx	lr
    d75a:	f04f 0000 	mov.w	r0, #0
    d75e:	4770      	bx	lr

0000d760 <__aeabi_ldivmod>:
    d760:	b97b      	cbnz	r3, d782 <__aeabi_ldivmod+0x22>
    d762:	b972      	cbnz	r2, d782 <__aeabi_ldivmod+0x22>
    d764:	2900      	cmp	r1, #0
    d766:	bfbe      	ittt	lt
    d768:	2000      	movlt	r0, #0
    d76a:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
    d76e:	e006      	blt.n	d77e <__aeabi_ldivmod+0x1e>
    d770:	bf08      	it	eq
    d772:	2800      	cmpeq	r0, #0
    d774:	bf1c      	itt	ne
    d776:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
    d77a:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    d77e:	f000 b9b1 	b.w	dae4 <__aeabi_idiv0>
    d782:	f1ad 0c08 	sub.w	ip, sp, #8
    d786:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    d78a:	2900      	cmp	r1, #0
    d78c:	db09      	blt.n	d7a2 <__aeabi_ldivmod+0x42>
    d78e:	2b00      	cmp	r3, #0
    d790:	db1a      	blt.n	d7c8 <__aeabi_ldivmod+0x68>
    d792:	f000 f835 	bl	d800 <__udivmoddi4>
    d796:	f8dd e004 	ldr.w	lr, [sp, #4]
    d79a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    d79e:	b004      	add	sp, #16
    d7a0:	4770      	bx	lr
    d7a2:	4240      	negs	r0, r0
    d7a4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    d7a8:	2b00      	cmp	r3, #0
    d7aa:	db1b      	blt.n	d7e4 <__aeabi_ldivmod+0x84>
    d7ac:	f000 f828 	bl	d800 <__udivmoddi4>
    d7b0:	f8dd e004 	ldr.w	lr, [sp, #4]
    d7b4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    d7b8:	b004      	add	sp, #16
    d7ba:	4240      	negs	r0, r0
    d7bc:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    d7c0:	4252      	negs	r2, r2
    d7c2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    d7c6:	4770      	bx	lr
    d7c8:	4252      	negs	r2, r2
    d7ca:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    d7ce:	f000 f817 	bl	d800 <__udivmoddi4>
    d7d2:	f8dd e004 	ldr.w	lr, [sp, #4]
    d7d6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    d7da:	b004      	add	sp, #16
    d7dc:	4240      	negs	r0, r0
    d7de:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    d7e2:	4770      	bx	lr
    d7e4:	4252      	negs	r2, r2
    d7e6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    d7ea:	f000 f809 	bl	d800 <__udivmoddi4>
    d7ee:	f8dd e004 	ldr.w	lr, [sp, #4]
    d7f2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    d7f6:	b004      	add	sp, #16
    d7f8:	4252      	negs	r2, r2
    d7fa:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    d7fe:	4770      	bx	lr

0000d800 <__udivmoddi4>:
    d800:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    d804:	468c      	mov	ip, r1
    d806:	460e      	mov	r6, r1
    d808:	4604      	mov	r4, r0
    d80a:	9d08      	ldr	r5, [sp, #32]
    d80c:	2b00      	cmp	r3, #0
    d80e:	d150      	bne.n	d8b2 <__udivmoddi4+0xb2>
    d810:	428a      	cmp	r2, r1
    d812:	4617      	mov	r7, r2
    d814:	d96c      	bls.n	d8f0 <__udivmoddi4+0xf0>
    d816:	fab2 fe82 	clz	lr, r2
    d81a:	f1be 0f00 	cmp.w	lr, #0
    d81e:	d00b      	beq.n	d838 <__udivmoddi4+0x38>
    d820:	f1ce 0420 	rsb	r4, lr, #32
    d824:	fa20 f404 	lsr.w	r4, r0, r4
    d828:	fa01 f60e 	lsl.w	r6, r1, lr
    d82c:	ea44 0c06 	orr.w	ip, r4, r6
    d830:	fa02 f70e 	lsl.w	r7, r2, lr
    d834:	fa00 f40e 	lsl.w	r4, r0, lr
    d838:	ea4f 4917 	mov.w	r9, r7, lsr #16
    d83c:	0c22      	lsrs	r2, r4, #16
    d83e:	fbbc f0f9 	udiv	r0, ip, r9
    d842:	fa1f f887 	uxth.w	r8, r7
    d846:	fb09 c610 	mls	r6, r9, r0, ip
    d84a:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
    d84e:	fb00 f308 	mul.w	r3, r0, r8
    d852:	42b3      	cmp	r3, r6
    d854:	d909      	bls.n	d86a <__udivmoddi4+0x6a>
    d856:	19f6      	adds	r6, r6, r7
    d858:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
    d85c:	f080 8122 	bcs.w	daa4 <__udivmoddi4+0x2a4>
    d860:	42b3      	cmp	r3, r6
    d862:	f240 811f 	bls.w	daa4 <__udivmoddi4+0x2a4>
    d866:	3802      	subs	r0, #2
    d868:	443e      	add	r6, r7
    d86a:	1af6      	subs	r6, r6, r3
    d86c:	b2a2      	uxth	r2, r4
    d86e:	fbb6 f3f9 	udiv	r3, r6, r9
    d872:	fb09 6613 	mls	r6, r9, r3, r6
    d876:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
    d87a:	fb03 f808 	mul.w	r8, r3, r8
    d87e:	45a0      	cmp	r8, r4
    d880:	d909      	bls.n	d896 <__udivmoddi4+0x96>
    d882:	19e4      	adds	r4, r4, r7
    d884:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
    d888:	f080 810a 	bcs.w	daa0 <__udivmoddi4+0x2a0>
    d88c:	45a0      	cmp	r8, r4
    d88e:	f240 8107 	bls.w	daa0 <__udivmoddi4+0x2a0>
    d892:	3b02      	subs	r3, #2
    d894:	443c      	add	r4, r7
    d896:	ebc8 0404 	rsb	r4, r8, r4
    d89a:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    d89e:	2100      	movs	r1, #0
    d8a0:	2d00      	cmp	r5, #0
    d8a2:	d062      	beq.n	d96a <__udivmoddi4+0x16a>
    d8a4:	fa24 f40e 	lsr.w	r4, r4, lr
    d8a8:	2300      	movs	r3, #0
    d8aa:	602c      	str	r4, [r5, #0]
    d8ac:	606b      	str	r3, [r5, #4]
    d8ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    d8b2:	428b      	cmp	r3, r1
    d8b4:	d907      	bls.n	d8c6 <__udivmoddi4+0xc6>
    d8b6:	2d00      	cmp	r5, #0
    d8b8:	d055      	beq.n	d966 <__udivmoddi4+0x166>
    d8ba:	2100      	movs	r1, #0
    d8bc:	e885 0041 	stmia.w	r5, {r0, r6}
    d8c0:	4608      	mov	r0, r1
    d8c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    d8c6:	fab3 f183 	clz	r1, r3
    d8ca:	2900      	cmp	r1, #0
    d8cc:	f040 8090 	bne.w	d9f0 <__udivmoddi4+0x1f0>
    d8d0:	42b3      	cmp	r3, r6
    d8d2:	d302      	bcc.n	d8da <__udivmoddi4+0xda>
    d8d4:	4282      	cmp	r2, r0
    d8d6:	f200 80f8 	bhi.w	daca <__udivmoddi4+0x2ca>
    d8da:	1a84      	subs	r4, r0, r2
    d8dc:	eb66 0603 	sbc.w	r6, r6, r3
    d8e0:	2001      	movs	r0, #1
    d8e2:	46b4      	mov	ip, r6
    d8e4:	2d00      	cmp	r5, #0
    d8e6:	d040      	beq.n	d96a <__udivmoddi4+0x16a>
    d8e8:	e885 1010 	stmia.w	r5, {r4, ip}
    d8ec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    d8f0:	b912      	cbnz	r2, d8f8 <__udivmoddi4+0xf8>
    d8f2:	2701      	movs	r7, #1
    d8f4:	fbb7 f7f2 	udiv	r7, r7, r2
    d8f8:	fab7 fe87 	clz	lr, r7
    d8fc:	f1be 0f00 	cmp.w	lr, #0
    d900:	d135      	bne.n	d96e <__udivmoddi4+0x16e>
    d902:	1bf3      	subs	r3, r6, r7
    d904:	ea4f 4817 	mov.w	r8, r7, lsr #16
    d908:	fa1f fc87 	uxth.w	ip, r7
    d90c:	2101      	movs	r1, #1
    d90e:	fbb3 f0f8 	udiv	r0, r3, r8
    d912:	0c22      	lsrs	r2, r4, #16
    d914:	fb08 3610 	mls	r6, r8, r0, r3
    d918:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
    d91c:	fb0c f300 	mul.w	r3, ip, r0
    d920:	42b3      	cmp	r3, r6
    d922:	d907      	bls.n	d934 <__udivmoddi4+0x134>
    d924:	19f6      	adds	r6, r6, r7
    d926:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
    d92a:	d202      	bcs.n	d932 <__udivmoddi4+0x132>
    d92c:	42b3      	cmp	r3, r6
    d92e:	f200 80ce 	bhi.w	dace <__udivmoddi4+0x2ce>
    d932:	4610      	mov	r0, r2
    d934:	1af6      	subs	r6, r6, r3
    d936:	b2a2      	uxth	r2, r4
    d938:	fbb6 f3f8 	udiv	r3, r6, r8
    d93c:	fb08 6613 	mls	r6, r8, r3, r6
    d940:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
    d944:	fb0c fc03 	mul.w	ip, ip, r3
    d948:	45a4      	cmp	ip, r4
    d94a:	d907      	bls.n	d95c <__udivmoddi4+0x15c>
    d94c:	19e4      	adds	r4, r4, r7
    d94e:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
    d952:	d202      	bcs.n	d95a <__udivmoddi4+0x15a>
    d954:	45a4      	cmp	ip, r4
    d956:	f200 80b5 	bhi.w	dac4 <__udivmoddi4+0x2c4>
    d95a:	4613      	mov	r3, r2
    d95c:	ebcc 0404 	rsb	r4, ip, r4
    d960:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    d964:	e79c      	b.n	d8a0 <__udivmoddi4+0xa0>
    d966:	4629      	mov	r1, r5
    d968:	4628      	mov	r0, r5
    d96a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    d96e:	f1ce 0120 	rsb	r1, lr, #32
    d972:	fa06 f30e 	lsl.w	r3, r6, lr
    d976:	fa07 f70e 	lsl.w	r7, r7, lr
    d97a:	fa20 f901 	lsr.w	r9, r0, r1
    d97e:	ea4f 4817 	mov.w	r8, r7, lsr #16
    d982:	40ce      	lsrs	r6, r1
    d984:	ea49 0903 	orr.w	r9, r9, r3
    d988:	fbb6 faf8 	udiv	sl, r6, r8
    d98c:	ea4f 4419 	mov.w	r4, r9, lsr #16
    d990:	fb08 661a 	mls	r6, r8, sl, r6
    d994:	fa1f fc87 	uxth.w	ip, r7
    d998:	ea44 4306 	orr.w	r3, r4, r6, lsl #16
    d99c:	fb0a f20c 	mul.w	r2, sl, ip
    d9a0:	429a      	cmp	r2, r3
    d9a2:	fa00 f40e 	lsl.w	r4, r0, lr
    d9a6:	d90a      	bls.n	d9be <__udivmoddi4+0x1be>
    d9a8:	19db      	adds	r3, r3, r7
    d9aa:	f10a 31ff 	add.w	r1, sl, #4294967295	; 0xffffffff
    d9ae:	f080 8087 	bcs.w	dac0 <__udivmoddi4+0x2c0>
    d9b2:	429a      	cmp	r2, r3
    d9b4:	f240 8084 	bls.w	dac0 <__udivmoddi4+0x2c0>
    d9b8:	f1aa 0a02 	sub.w	sl, sl, #2
    d9bc:	443b      	add	r3, r7
    d9be:	1a9b      	subs	r3, r3, r2
    d9c0:	fa1f f989 	uxth.w	r9, r9
    d9c4:	fbb3 f1f8 	udiv	r1, r3, r8
    d9c8:	fb08 3311 	mls	r3, r8, r1, r3
    d9cc:	ea49 4303 	orr.w	r3, r9, r3, lsl #16
    d9d0:	fb01 f60c 	mul.w	r6, r1, ip
    d9d4:	429e      	cmp	r6, r3
    d9d6:	d907      	bls.n	d9e8 <__udivmoddi4+0x1e8>
    d9d8:	19db      	adds	r3, r3, r7
    d9da:	f101 32ff 	add.w	r2, r1, #4294967295	; 0xffffffff
    d9de:	d26b      	bcs.n	dab8 <__udivmoddi4+0x2b8>
    d9e0:	429e      	cmp	r6, r3
    d9e2:	d969      	bls.n	dab8 <__udivmoddi4+0x2b8>
    d9e4:	3902      	subs	r1, #2
    d9e6:	443b      	add	r3, r7
    d9e8:	1b9b      	subs	r3, r3, r6
    d9ea:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
    d9ee:	e78e      	b.n	d90e <__udivmoddi4+0x10e>
    d9f0:	f1c1 0e20 	rsb	lr, r1, #32
    d9f4:	fa22 f40e 	lsr.w	r4, r2, lr
    d9f8:	408b      	lsls	r3, r1
    d9fa:	4323      	orrs	r3, r4
    d9fc:	fa20 f70e 	lsr.w	r7, r0, lr
    da00:	fa06 f401 	lsl.w	r4, r6, r1
    da04:	ea4f 4c13 	mov.w	ip, r3, lsr #16
    da08:	fa26 f60e 	lsr.w	r6, r6, lr
    da0c:	433c      	orrs	r4, r7
    da0e:	fbb6 f9fc 	udiv	r9, r6, ip
    da12:	0c27      	lsrs	r7, r4, #16
    da14:	fb0c 6619 	mls	r6, ip, r9, r6
    da18:	fa1f f883 	uxth.w	r8, r3
    da1c:	ea47 4606 	orr.w	r6, r7, r6, lsl #16
    da20:	fb09 f708 	mul.w	r7, r9, r8
    da24:	42b7      	cmp	r7, r6
    da26:	fa02 f201 	lsl.w	r2, r2, r1
    da2a:	fa00 fa01 	lsl.w	sl, r0, r1
    da2e:	d908      	bls.n	da42 <__udivmoddi4+0x242>
    da30:	18f6      	adds	r6, r6, r3
    da32:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
    da36:	d241      	bcs.n	dabc <__udivmoddi4+0x2bc>
    da38:	42b7      	cmp	r7, r6
    da3a:	d93f      	bls.n	dabc <__udivmoddi4+0x2bc>
    da3c:	f1a9 0902 	sub.w	r9, r9, #2
    da40:	441e      	add	r6, r3
    da42:	1bf6      	subs	r6, r6, r7
    da44:	b2a0      	uxth	r0, r4
    da46:	fbb6 f4fc 	udiv	r4, r6, ip
    da4a:	fb0c 6614 	mls	r6, ip, r4, r6
    da4e:	ea40 4706 	orr.w	r7, r0, r6, lsl #16
    da52:	fb04 f808 	mul.w	r8, r4, r8
    da56:	45b8      	cmp	r8, r7
    da58:	d907      	bls.n	da6a <__udivmoddi4+0x26a>
    da5a:	18ff      	adds	r7, r7, r3
    da5c:	f104 30ff 	add.w	r0, r4, #4294967295	; 0xffffffff
    da60:	d228      	bcs.n	dab4 <__udivmoddi4+0x2b4>
    da62:	45b8      	cmp	r8, r7
    da64:	d926      	bls.n	dab4 <__udivmoddi4+0x2b4>
    da66:	3c02      	subs	r4, #2
    da68:	441f      	add	r7, r3
    da6a:	ea44 4009 	orr.w	r0, r4, r9, lsl #16
    da6e:	ebc8 0707 	rsb	r7, r8, r7
    da72:	fba0 8902 	umull	r8, r9, r0, r2
    da76:	454f      	cmp	r7, r9
    da78:	4644      	mov	r4, r8
    da7a:	464e      	mov	r6, r9
    da7c:	d314      	bcc.n	daa8 <__udivmoddi4+0x2a8>
    da7e:	d029      	beq.n	dad4 <__udivmoddi4+0x2d4>
    da80:	b365      	cbz	r5, dadc <__udivmoddi4+0x2dc>
    da82:	ebba 0304 	subs.w	r3, sl, r4
    da86:	eb67 0706 	sbc.w	r7, r7, r6
    da8a:	fa07 fe0e 	lsl.w	lr, r7, lr
    da8e:	40cb      	lsrs	r3, r1
    da90:	40cf      	lsrs	r7, r1
    da92:	ea4e 0303 	orr.w	r3, lr, r3
    da96:	e885 0088 	stmia.w	r5, {r3, r7}
    da9a:	2100      	movs	r1, #0
    da9c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    daa0:	4613      	mov	r3, r2
    daa2:	e6f8      	b.n	d896 <__udivmoddi4+0x96>
    daa4:	4610      	mov	r0, r2
    daa6:	e6e0      	b.n	d86a <__udivmoddi4+0x6a>
    daa8:	ebb8 0402 	subs.w	r4, r8, r2
    daac:	eb69 0603 	sbc.w	r6, r9, r3
    dab0:	3801      	subs	r0, #1
    dab2:	e7e5      	b.n	da80 <__udivmoddi4+0x280>
    dab4:	4604      	mov	r4, r0
    dab6:	e7d8      	b.n	da6a <__udivmoddi4+0x26a>
    dab8:	4611      	mov	r1, r2
    daba:	e795      	b.n	d9e8 <__udivmoddi4+0x1e8>
    dabc:	4681      	mov	r9, r0
    dabe:	e7c0      	b.n	da42 <__udivmoddi4+0x242>
    dac0:	468a      	mov	sl, r1
    dac2:	e77c      	b.n	d9be <__udivmoddi4+0x1be>
    dac4:	3b02      	subs	r3, #2
    dac6:	443c      	add	r4, r7
    dac8:	e748      	b.n	d95c <__udivmoddi4+0x15c>
    daca:	4608      	mov	r0, r1
    dacc:	e70a      	b.n	d8e4 <__udivmoddi4+0xe4>
    dace:	3802      	subs	r0, #2
    dad0:	443e      	add	r6, r7
    dad2:	e72f      	b.n	d934 <__udivmoddi4+0x134>
    dad4:	45c2      	cmp	sl, r8
    dad6:	d3e7      	bcc.n	daa8 <__udivmoddi4+0x2a8>
    dad8:	463e      	mov	r6, r7
    dada:	e7d1      	b.n	da80 <__udivmoddi4+0x280>
    dadc:	4629      	mov	r1, r5
    dade:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    dae2:	bf00      	nop

0000dae4 <__aeabi_idiv0>:
    dae4:	4770      	bx	lr
    dae6:	bf00      	nop

0000dae8 <__aeabi_atexit>:
    dae8:	460b      	mov	r3, r1
    daea:	4601      	mov	r1, r0
    daec:	4618      	mov	r0, r3
    daee:	f000 b801 	b.w	daf4 <__cxa_atexit>
    daf2:	bf00      	nop

0000daf4 <__cxa_atexit>:
    daf4:	4613      	mov	r3, r2
    daf6:	460a      	mov	r2, r1
    daf8:	4601      	mov	r1, r0
    dafa:	2002      	movs	r0, #2
    dafc:	f001 b842 	b.w	eb84 <__register_exitproc>

0000db00 <fcvtf>:
    db00:	b5f0      	push	{r4, r5, r6, r7, lr}
    db02:	b083      	sub	sp, #12
    db04:	4616      	mov	r6, r2
    db06:	461f      	mov	r7, r3
    db08:	460d      	mov	r5, r1
    db0a:	2400      	movs	r4, #0
    db0c:	f7fe ff7c 	bl	ca08 <__aeabi_f2d>
    db10:	9700      	str	r7, [sp, #0]
    db12:	4633      	mov	r3, r6
    db14:	462a      	mov	r2, r5
    db16:	9401      	str	r4, [sp, #4]
    db18:	f001 f896 	bl	ec48 <fcvtbuf>
    db1c:	b003      	add	sp, #12
    db1e:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000db20 <__errno>:
    db20:	4b01      	ldr	r3, [pc, #4]	; (db28 <__errno+0x8>)
    db22:	6818      	ldr	r0, [r3, #0]
    db24:	4770      	bx	lr
    db26:	bf00      	nop
    db28:	1fffc0f8 	.word	0x1fffc0f8

0000db2c <__libc_init_array>:
    db2c:	b570      	push	{r4, r5, r6, lr}
    db2e:	4e0f      	ldr	r6, [pc, #60]	; (db6c <__libc_init_array+0x40>)
    db30:	4d0f      	ldr	r5, [pc, #60]	; (db70 <__libc_init_array+0x44>)
    db32:	1b76      	subs	r6, r6, r5
    db34:	10b6      	asrs	r6, r6, #2
    db36:	bf18      	it	ne
    db38:	2400      	movne	r4, #0
    db3a:	d005      	beq.n	db48 <__libc_init_array+0x1c>
    db3c:	3401      	adds	r4, #1
    db3e:	f855 3b04 	ldr.w	r3, [r5], #4
    db42:	4798      	blx	r3
    db44:	42a6      	cmp	r6, r4
    db46:	d1f9      	bne.n	db3c <__libc_init_array+0x10>
    db48:	4e0a      	ldr	r6, [pc, #40]	; (db74 <__libc_init_array+0x48>)
    db4a:	4d0b      	ldr	r5, [pc, #44]	; (db78 <__libc_init_array+0x4c>)
    db4c:	1b76      	subs	r6, r6, r5
    db4e:	f014 fa5b 	bl	22008 <_init>
    db52:	10b6      	asrs	r6, r6, #2
    db54:	bf18      	it	ne
    db56:	2400      	movne	r4, #0
    db58:	d006      	beq.n	db68 <__libc_init_array+0x3c>
    db5a:	3401      	adds	r4, #1
    db5c:	f855 3b04 	ldr.w	r3, [r5], #4
    db60:	4798      	blx	r3
    db62:	42a6      	cmp	r6, r4
    db64:	d1f9      	bne.n	db5a <__libc_init_array+0x2e>
    db66:	bd70      	pop	{r4, r5, r6, pc}
    db68:	bd70      	pop	{r4, r5, r6, pc}
    db6a:	bf00      	nop
    db6c:	00022014 	.word	0x00022014
    db70:	00022014 	.word	0x00022014
    db74:	00022060 	.word	0x00022060
    db78:	00022014 	.word	0x00022014

0000db7c <malloc>:
    db7c:	4b02      	ldr	r3, [pc, #8]	; (db88 <malloc+0xc>)
    db7e:	4601      	mov	r1, r0
    db80:	6818      	ldr	r0, [r3, #0]
    db82:	f000 b80b 	b.w	db9c <_malloc_r>
    db86:	bf00      	nop
    db88:	1fffc0f8 	.word	0x1fffc0f8

0000db8c <free>:
    db8c:	4b02      	ldr	r3, [pc, #8]	; (db98 <free+0xc>)
    db8e:	4601      	mov	r1, r0
    db90:	6818      	ldr	r0, [r3, #0]
    db92:	f001 b931 	b.w	edf8 <_free_r>
    db96:	bf00      	nop
    db98:	1fffc0f8 	.word	0x1fffc0f8

0000db9c <_malloc_r>:
    db9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    dba0:	f101 050b 	add.w	r5, r1, #11
    dba4:	2d16      	cmp	r5, #22
    dba6:	b083      	sub	sp, #12
    dba8:	4606      	mov	r6, r0
    dbaa:	f240 809f 	bls.w	dcec <_malloc_r+0x150>
    dbae:	f035 0507 	bics.w	r5, r5, #7
    dbb2:	f100 80bf 	bmi.w	dd34 <_malloc_r+0x198>
    dbb6:	42a9      	cmp	r1, r5
    dbb8:	f200 80bc 	bhi.w	dd34 <_malloc_r+0x198>
    dbbc:	f000 fb58 	bl	e270 <__malloc_lock>
    dbc0:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
    dbc4:	f0c0 829c 	bcc.w	e100 <_malloc_r+0x564>
    dbc8:	0a6b      	lsrs	r3, r5, #9
    dbca:	f000 80ba 	beq.w	dd42 <_malloc_r+0x1a6>
    dbce:	2b04      	cmp	r3, #4
    dbd0:	f200 8183 	bhi.w	deda <_malloc_r+0x33e>
    dbd4:	09a8      	lsrs	r0, r5, #6
    dbd6:	f100 0e39 	add.w	lr, r0, #57	; 0x39
    dbda:	ea4f 034e 	mov.w	r3, lr, lsl #1
    dbde:	3038      	adds	r0, #56	; 0x38
    dbe0:	4fc4      	ldr	r7, [pc, #784]	; (def4 <_malloc_r+0x358>)
    dbe2:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    dbe6:	f1a3 0108 	sub.w	r1, r3, #8
    dbea:	685c      	ldr	r4, [r3, #4]
    dbec:	42a1      	cmp	r1, r4
    dbee:	d107      	bne.n	dc00 <_malloc_r+0x64>
    dbf0:	e0ac      	b.n	dd4c <_malloc_r+0x1b0>
    dbf2:	2a00      	cmp	r2, #0
    dbf4:	f280 80ac 	bge.w	dd50 <_malloc_r+0x1b4>
    dbf8:	68e4      	ldr	r4, [r4, #12]
    dbfa:	42a1      	cmp	r1, r4
    dbfc:	f000 80a6 	beq.w	dd4c <_malloc_r+0x1b0>
    dc00:	6863      	ldr	r3, [r4, #4]
    dc02:	f023 0303 	bic.w	r3, r3, #3
    dc06:	1b5a      	subs	r2, r3, r5
    dc08:	2a0f      	cmp	r2, #15
    dc0a:	ddf2      	ble.n	dbf2 <_malloc_r+0x56>
    dc0c:	49b9      	ldr	r1, [pc, #740]	; (def4 <_malloc_r+0x358>)
    dc0e:	693c      	ldr	r4, [r7, #16]
    dc10:	f101 0e08 	add.w	lr, r1, #8
    dc14:	4574      	cmp	r4, lr
    dc16:	f000 81b3 	beq.w	df80 <_malloc_r+0x3e4>
    dc1a:	6863      	ldr	r3, [r4, #4]
    dc1c:	f023 0303 	bic.w	r3, r3, #3
    dc20:	1b5a      	subs	r2, r3, r5
    dc22:	2a0f      	cmp	r2, #15
    dc24:	f300 8199 	bgt.w	df5a <_malloc_r+0x3be>
    dc28:	2a00      	cmp	r2, #0
    dc2a:	f8c1 e014 	str.w	lr, [r1, #20]
    dc2e:	f8c1 e010 	str.w	lr, [r1, #16]
    dc32:	f280 809e 	bge.w	dd72 <_malloc_r+0x1d6>
    dc36:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    dc3a:	f080 8167 	bcs.w	df0c <_malloc_r+0x370>
    dc3e:	08db      	lsrs	r3, r3, #3
    dc40:	f103 0c01 	add.w	ip, r3, #1
    dc44:	2201      	movs	r2, #1
    dc46:	109b      	asrs	r3, r3, #2
    dc48:	fa02 f303 	lsl.w	r3, r2, r3
    dc4c:	684a      	ldr	r2, [r1, #4]
    dc4e:	f851 803c 	ldr.w	r8, [r1, ip, lsl #3]
    dc52:	f8c4 8008 	str.w	r8, [r4, #8]
    dc56:	eb01 09cc 	add.w	r9, r1, ip, lsl #3
    dc5a:	431a      	orrs	r2, r3
    dc5c:	f1a9 0308 	sub.w	r3, r9, #8
    dc60:	60e3      	str	r3, [r4, #12]
    dc62:	604a      	str	r2, [r1, #4]
    dc64:	f841 403c 	str.w	r4, [r1, ip, lsl #3]
    dc68:	f8c8 400c 	str.w	r4, [r8, #12]
    dc6c:	1083      	asrs	r3, r0, #2
    dc6e:	2401      	movs	r4, #1
    dc70:	409c      	lsls	r4, r3
    dc72:	4294      	cmp	r4, r2
    dc74:	f200 808a 	bhi.w	dd8c <_malloc_r+0x1f0>
    dc78:	4214      	tst	r4, r2
    dc7a:	d106      	bne.n	dc8a <_malloc_r+0xee>
    dc7c:	f020 0003 	bic.w	r0, r0, #3
    dc80:	0064      	lsls	r4, r4, #1
    dc82:	4214      	tst	r4, r2
    dc84:	f100 0004 	add.w	r0, r0, #4
    dc88:	d0fa      	beq.n	dc80 <_malloc_r+0xe4>
    dc8a:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
    dc8e:	46cc      	mov	ip, r9
    dc90:	4680      	mov	r8, r0
    dc92:	f8dc 100c 	ldr.w	r1, [ip, #12]
    dc96:	458c      	cmp	ip, r1
    dc98:	d107      	bne.n	dcaa <_malloc_r+0x10e>
    dc9a:	e173      	b.n	df84 <_malloc_r+0x3e8>
    dc9c:	2a00      	cmp	r2, #0
    dc9e:	f280 8181 	bge.w	dfa4 <_malloc_r+0x408>
    dca2:	68c9      	ldr	r1, [r1, #12]
    dca4:	458c      	cmp	ip, r1
    dca6:	f000 816d 	beq.w	df84 <_malloc_r+0x3e8>
    dcaa:	684b      	ldr	r3, [r1, #4]
    dcac:	f023 0303 	bic.w	r3, r3, #3
    dcb0:	1b5a      	subs	r2, r3, r5
    dcb2:	2a0f      	cmp	r2, #15
    dcb4:	ddf2      	ble.n	dc9c <_malloc_r+0x100>
    dcb6:	460c      	mov	r4, r1
    dcb8:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    dcbc:	f854 8f08 	ldr.w	r8, [r4, #8]!
    dcc0:	194b      	adds	r3, r1, r5
    dcc2:	f045 0501 	orr.w	r5, r5, #1
    dcc6:	604d      	str	r5, [r1, #4]
    dcc8:	f042 0101 	orr.w	r1, r2, #1
    dccc:	f8c8 c00c 	str.w	ip, [r8, #12]
    dcd0:	4630      	mov	r0, r6
    dcd2:	f8cc 8008 	str.w	r8, [ip, #8]
    dcd6:	617b      	str	r3, [r7, #20]
    dcd8:	613b      	str	r3, [r7, #16]
    dcda:	f8c3 e00c 	str.w	lr, [r3, #12]
    dcde:	f8c3 e008 	str.w	lr, [r3, #8]
    dce2:	6059      	str	r1, [r3, #4]
    dce4:	509a      	str	r2, [r3, r2]
    dce6:	f000 fac5 	bl	e274 <__malloc_unlock>
    dcea:	e01f      	b.n	dd2c <_malloc_r+0x190>
    dcec:	2910      	cmp	r1, #16
    dcee:	d821      	bhi.n	dd34 <_malloc_r+0x198>
    dcf0:	f000 fabe 	bl	e270 <__malloc_lock>
    dcf4:	2510      	movs	r5, #16
    dcf6:	2306      	movs	r3, #6
    dcf8:	2002      	movs	r0, #2
    dcfa:	4f7e      	ldr	r7, [pc, #504]	; (def4 <_malloc_r+0x358>)
    dcfc:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    dd00:	f1a3 0208 	sub.w	r2, r3, #8
    dd04:	685c      	ldr	r4, [r3, #4]
    dd06:	4294      	cmp	r4, r2
    dd08:	f000 8145 	beq.w	df96 <_malloc_r+0x3fa>
    dd0c:	6863      	ldr	r3, [r4, #4]
    dd0e:	68e1      	ldr	r1, [r4, #12]
    dd10:	68a5      	ldr	r5, [r4, #8]
    dd12:	f023 0303 	bic.w	r3, r3, #3
    dd16:	4423      	add	r3, r4
    dd18:	4630      	mov	r0, r6
    dd1a:	685a      	ldr	r2, [r3, #4]
    dd1c:	60e9      	str	r1, [r5, #12]
    dd1e:	f042 0201 	orr.w	r2, r2, #1
    dd22:	608d      	str	r5, [r1, #8]
    dd24:	605a      	str	r2, [r3, #4]
    dd26:	f000 faa5 	bl	e274 <__malloc_unlock>
    dd2a:	3408      	adds	r4, #8
    dd2c:	4620      	mov	r0, r4
    dd2e:	b003      	add	sp, #12
    dd30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dd34:	2400      	movs	r4, #0
    dd36:	230c      	movs	r3, #12
    dd38:	4620      	mov	r0, r4
    dd3a:	6033      	str	r3, [r6, #0]
    dd3c:	b003      	add	sp, #12
    dd3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dd42:	2380      	movs	r3, #128	; 0x80
    dd44:	f04f 0e40 	mov.w	lr, #64	; 0x40
    dd48:	203f      	movs	r0, #63	; 0x3f
    dd4a:	e749      	b.n	dbe0 <_malloc_r+0x44>
    dd4c:	4670      	mov	r0, lr
    dd4e:	e75d      	b.n	dc0c <_malloc_r+0x70>
    dd50:	4423      	add	r3, r4
    dd52:	68e1      	ldr	r1, [r4, #12]
    dd54:	685a      	ldr	r2, [r3, #4]
    dd56:	68a5      	ldr	r5, [r4, #8]
    dd58:	f042 0201 	orr.w	r2, r2, #1
    dd5c:	60e9      	str	r1, [r5, #12]
    dd5e:	4630      	mov	r0, r6
    dd60:	608d      	str	r5, [r1, #8]
    dd62:	605a      	str	r2, [r3, #4]
    dd64:	f000 fa86 	bl	e274 <__malloc_unlock>
    dd68:	3408      	adds	r4, #8
    dd6a:	4620      	mov	r0, r4
    dd6c:	b003      	add	sp, #12
    dd6e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dd72:	4423      	add	r3, r4
    dd74:	4630      	mov	r0, r6
    dd76:	685a      	ldr	r2, [r3, #4]
    dd78:	f042 0201 	orr.w	r2, r2, #1
    dd7c:	605a      	str	r2, [r3, #4]
    dd7e:	f000 fa79 	bl	e274 <__malloc_unlock>
    dd82:	3408      	adds	r4, #8
    dd84:	4620      	mov	r0, r4
    dd86:	b003      	add	sp, #12
    dd88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dd8c:	68bc      	ldr	r4, [r7, #8]
    dd8e:	6863      	ldr	r3, [r4, #4]
    dd90:	f023 0803 	bic.w	r8, r3, #3
    dd94:	45a8      	cmp	r8, r5
    dd96:	d304      	bcc.n	dda2 <_malloc_r+0x206>
    dd98:	ebc5 0308 	rsb	r3, r5, r8
    dd9c:	2b0f      	cmp	r3, #15
    dd9e:	f300 808c 	bgt.w	deba <_malloc_r+0x31e>
    dda2:	4b55      	ldr	r3, [pc, #340]	; (def8 <_malloc_r+0x35c>)
    dda4:	f8df 9160 	ldr.w	r9, [pc, #352]	; df08 <_malloc_r+0x36c>
    dda8:	681a      	ldr	r2, [r3, #0]
    ddaa:	f8d9 3000 	ldr.w	r3, [r9]
    ddae:	3301      	adds	r3, #1
    ddb0:	442a      	add	r2, r5
    ddb2:	eb04 0a08 	add.w	sl, r4, r8
    ddb6:	f000 8160 	beq.w	e07a <_malloc_r+0x4de>
    ddba:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    ddbe:	320f      	adds	r2, #15
    ddc0:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
    ddc4:	f022 020f 	bic.w	r2, r2, #15
    ddc8:	4611      	mov	r1, r2
    ddca:	4630      	mov	r0, r6
    ddcc:	9201      	str	r2, [sp, #4]
    ddce:	f000 fc4b 	bl	e668 <_sbrk_r>
    ddd2:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    ddd6:	4683      	mov	fp, r0
    ddd8:	9a01      	ldr	r2, [sp, #4]
    ddda:	f000 8158 	beq.w	e08e <_malloc_r+0x4f2>
    ddde:	4582      	cmp	sl, r0
    dde0:	f200 80fc 	bhi.w	dfdc <_malloc_r+0x440>
    dde4:	4b45      	ldr	r3, [pc, #276]	; (defc <_malloc_r+0x360>)
    dde6:	6819      	ldr	r1, [r3, #0]
    dde8:	45da      	cmp	sl, fp
    ddea:	4411      	add	r1, r2
    ddec:	6019      	str	r1, [r3, #0]
    ddee:	f000 8153 	beq.w	e098 <_malloc_r+0x4fc>
    ddf2:	f8d9 0000 	ldr.w	r0, [r9]
    ddf6:	f8df e110 	ldr.w	lr, [pc, #272]	; df08 <_malloc_r+0x36c>
    ddfa:	3001      	adds	r0, #1
    ddfc:	bf1b      	ittet	ne
    ddfe:	ebca 0a0b 	rsbne	sl, sl, fp
    de02:	4451      	addne	r1, sl
    de04:	f8ce b000 	streq.w	fp, [lr]
    de08:	6019      	strne	r1, [r3, #0]
    de0a:	f01b 0107 	ands.w	r1, fp, #7
    de0e:	f000 8117 	beq.w	e040 <_malloc_r+0x4a4>
    de12:	f1c1 0008 	rsb	r0, r1, #8
    de16:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
    de1a:	4483      	add	fp, r0
    de1c:	3108      	adds	r1, #8
    de1e:	445a      	add	r2, fp
    de20:	f3c2 020b 	ubfx	r2, r2, #0, #12
    de24:	ebc2 0901 	rsb	r9, r2, r1
    de28:	4649      	mov	r1, r9
    de2a:	4630      	mov	r0, r6
    de2c:	9301      	str	r3, [sp, #4]
    de2e:	f000 fc1b 	bl	e668 <_sbrk_r>
    de32:	1c43      	adds	r3, r0, #1
    de34:	9b01      	ldr	r3, [sp, #4]
    de36:	f000 813f 	beq.w	e0b8 <_malloc_r+0x51c>
    de3a:	ebcb 0200 	rsb	r2, fp, r0
    de3e:	444a      	add	r2, r9
    de40:	f042 0201 	orr.w	r2, r2, #1
    de44:	6819      	ldr	r1, [r3, #0]
    de46:	f8c7 b008 	str.w	fp, [r7, #8]
    de4a:	4449      	add	r1, r9
    de4c:	42bc      	cmp	r4, r7
    de4e:	f8cb 2004 	str.w	r2, [fp, #4]
    de52:	6019      	str	r1, [r3, #0]
    de54:	f8df 90a4 	ldr.w	r9, [pc, #164]	; defc <_malloc_r+0x360>
    de58:	d016      	beq.n	de88 <_malloc_r+0x2ec>
    de5a:	f1b8 0f0f 	cmp.w	r8, #15
    de5e:	f240 80fd 	bls.w	e05c <_malloc_r+0x4c0>
    de62:	6862      	ldr	r2, [r4, #4]
    de64:	f1a8 030c 	sub.w	r3, r8, #12
    de68:	f023 0307 	bic.w	r3, r3, #7
    de6c:	18e0      	adds	r0, r4, r3
    de6e:	f002 0201 	and.w	r2, r2, #1
    de72:	f04f 0e05 	mov.w	lr, #5
    de76:	431a      	orrs	r2, r3
    de78:	2b0f      	cmp	r3, #15
    de7a:	6062      	str	r2, [r4, #4]
    de7c:	f8c0 e004 	str.w	lr, [r0, #4]
    de80:	f8c0 e008 	str.w	lr, [r0, #8]
    de84:	f200 811c 	bhi.w	e0c0 <_malloc_r+0x524>
    de88:	4b1d      	ldr	r3, [pc, #116]	; (df00 <_malloc_r+0x364>)
    de8a:	68bc      	ldr	r4, [r7, #8]
    de8c:	681a      	ldr	r2, [r3, #0]
    de8e:	4291      	cmp	r1, r2
    de90:	bf88      	it	hi
    de92:	6019      	strhi	r1, [r3, #0]
    de94:	4b1b      	ldr	r3, [pc, #108]	; (df04 <_malloc_r+0x368>)
    de96:	681a      	ldr	r2, [r3, #0]
    de98:	4291      	cmp	r1, r2
    de9a:	6862      	ldr	r2, [r4, #4]
    de9c:	bf88      	it	hi
    de9e:	6019      	strhi	r1, [r3, #0]
    dea0:	f022 0203 	bic.w	r2, r2, #3
    dea4:	4295      	cmp	r5, r2
    dea6:	eba2 0305 	sub.w	r3, r2, r5
    deaa:	d801      	bhi.n	deb0 <_malloc_r+0x314>
    deac:	2b0f      	cmp	r3, #15
    deae:	dc04      	bgt.n	deba <_malloc_r+0x31e>
    deb0:	4630      	mov	r0, r6
    deb2:	f000 f9df 	bl	e274 <__malloc_unlock>
    deb6:	2400      	movs	r4, #0
    deb8:	e738      	b.n	dd2c <_malloc_r+0x190>
    deba:	1962      	adds	r2, r4, r5
    debc:	f043 0301 	orr.w	r3, r3, #1
    dec0:	f045 0501 	orr.w	r5, r5, #1
    dec4:	6065      	str	r5, [r4, #4]
    dec6:	4630      	mov	r0, r6
    dec8:	60ba      	str	r2, [r7, #8]
    deca:	6053      	str	r3, [r2, #4]
    decc:	f000 f9d2 	bl	e274 <__malloc_unlock>
    ded0:	3408      	adds	r4, #8
    ded2:	4620      	mov	r0, r4
    ded4:	b003      	add	sp, #12
    ded6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    deda:	2b14      	cmp	r3, #20
    dedc:	d971      	bls.n	dfc2 <_malloc_r+0x426>
    dede:	2b54      	cmp	r3, #84	; 0x54
    dee0:	f200 80a4 	bhi.w	e02c <_malloc_r+0x490>
    dee4:	0b28      	lsrs	r0, r5, #12
    dee6:	f100 0e6f 	add.w	lr, r0, #111	; 0x6f
    deea:	ea4f 034e 	mov.w	r3, lr, lsl #1
    deee:	306e      	adds	r0, #110	; 0x6e
    def0:	e676      	b.n	dbe0 <_malloc_r+0x44>
    def2:	bf00      	nop
    def4:	1fffc0fc 	.word	0x1fffc0fc
    def8:	200048fc 	.word	0x200048fc
    defc:	20004900 	.word	0x20004900
    df00:	200048f8 	.word	0x200048f8
    df04:	200048f4 	.word	0x200048f4
    df08:	1fffc508 	.word	0x1fffc508
    df0c:	0a5a      	lsrs	r2, r3, #9
    df0e:	2a04      	cmp	r2, #4
    df10:	d95e      	bls.n	dfd0 <_malloc_r+0x434>
    df12:	2a14      	cmp	r2, #20
    df14:	f200 80b3 	bhi.w	e07e <_malloc_r+0x4e2>
    df18:	f102 015c 	add.w	r1, r2, #92	; 0x5c
    df1c:	0049      	lsls	r1, r1, #1
    df1e:	325b      	adds	r2, #91	; 0x5b
    df20:	eb07 0c81 	add.w	ip, r7, r1, lsl #2
    df24:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
    df28:	f8df 81dc 	ldr.w	r8, [pc, #476]	; e108 <_malloc_r+0x56c>
    df2c:	f1ac 0c08 	sub.w	ip, ip, #8
    df30:	458c      	cmp	ip, r1
    df32:	f000 8088 	beq.w	e046 <_malloc_r+0x4aa>
    df36:	684a      	ldr	r2, [r1, #4]
    df38:	f022 0203 	bic.w	r2, r2, #3
    df3c:	4293      	cmp	r3, r2
    df3e:	d202      	bcs.n	df46 <_malloc_r+0x3aa>
    df40:	6889      	ldr	r1, [r1, #8]
    df42:	458c      	cmp	ip, r1
    df44:	d1f7      	bne.n	df36 <_malloc_r+0x39a>
    df46:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    df4a:	687a      	ldr	r2, [r7, #4]
    df4c:	f8c4 c00c 	str.w	ip, [r4, #12]
    df50:	60a1      	str	r1, [r4, #8]
    df52:	f8cc 4008 	str.w	r4, [ip, #8]
    df56:	60cc      	str	r4, [r1, #12]
    df58:	e688      	b.n	dc6c <_malloc_r+0xd0>
    df5a:	1963      	adds	r3, r4, r5
    df5c:	f042 0701 	orr.w	r7, r2, #1
    df60:	f045 0501 	orr.w	r5, r5, #1
    df64:	6065      	str	r5, [r4, #4]
    df66:	4630      	mov	r0, r6
    df68:	614b      	str	r3, [r1, #20]
    df6a:	610b      	str	r3, [r1, #16]
    df6c:	f8c3 e00c 	str.w	lr, [r3, #12]
    df70:	f8c3 e008 	str.w	lr, [r3, #8]
    df74:	605f      	str	r7, [r3, #4]
    df76:	509a      	str	r2, [r3, r2]
    df78:	3408      	adds	r4, #8
    df7a:	f000 f97b 	bl	e274 <__malloc_unlock>
    df7e:	e6d5      	b.n	dd2c <_malloc_r+0x190>
    df80:	684a      	ldr	r2, [r1, #4]
    df82:	e673      	b.n	dc6c <_malloc_r+0xd0>
    df84:	f108 0801 	add.w	r8, r8, #1
    df88:	f018 0f03 	tst.w	r8, #3
    df8c:	f10c 0c08 	add.w	ip, ip, #8
    df90:	f47f ae7f 	bne.w	dc92 <_malloc_r+0xf6>
    df94:	e030      	b.n	dff8 <_malloc_r+0x45c>
    df96:	68dc      	ldr	r4, [r3, #12]
    df98:	42a3      	cmp	r3, r4
    df9a:	bf08      	it	eq
    df9c:	3002      	addeq	r0, #2
    df9e:	f43f ae35 	beq.w	dc0c <_malloc_r+0x70>
    dfa2:	e6b3      	b.n	dd0c <_malloc_r+0x170>
    dfa4:	440b      	add	r3, r1
    dfa6:	460c      	mov	r4, r1
    dfa8:	685a      	ldr	r2, [r3, #4]
    dfaa:	68c9      	ldr	r1, [r1, #12]
    dfac:	f854 5f08 	ldr.w	r5, [r4, #8]!
    dfb0:	f042 0201 	orr.w	r2, r2, #1
    dfb4:	605a      	str	r2, [r3, #4]
    dfb6:	4630      	mov	r0, r6
    dfb8:	60e9      	str	r1, [r5, #12]
    dfba:	608d      	str	r5, [r1, #8]
    dfbc:	f000 f95a 	bl	e274 <__malloc_unlock>
    dfc0:	e6b4      	b.n	dd2c <_malloc_r+0x190>
    dfc2:	f103 0e5c 	add.w	lr, r3, #92	; 0x5c
    dfc6:	f103 005b 	add.w	r0, r3, #91	; 0x5b
    dfca:	ea4f 034e 	mov.w	r3, lr, lsl #1
    dfce:	e607      	b.n	dbe0 <_malloc_r+0x44>
    dfd0:	099a      	lsrs	r2, r3, #6
    dfd2:	f102 0139 	add.w	r1, r2, #57	; 0x39
    dfd6:	0049      	lsls	r1, r1, #1
    dfd8:	3238      	adds	r2, #56	; 0x38
    dfda:	e7a1      	b.n	df20 <_malloc_r+0x384>
    dfdc:	42bc      	cmp	r4, r7
    dfde:	4b4a      	ldr	r3, [pc, #296]	; (e108 <_malloc_r+0x56c>)
    dfe0:	f43f af00 	beq.w	dde4 <_malloc_r+0x248>
    dfe4:	689c      	ldr	r4, [r3, #8]
    dfe6:	6862      	ldr	r2, [r4, #4]
    dfe8:	f022 0203 	bic.w	r2, r2, #3
    dfec:	e75a      	b.n	dea4 <_malloc_r+0x308>
    dfee:	f859 3908 	ldr.w	r3, [r9], #-8
    dff2:	4599      	cmp	r9, r3
    dff4:	f040 8082 	bne.w	e0fc <_malloc_r+0x560>
    dff8:	f010 0f03 	tst.w	r0, #3
    dffc:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
    e000:	d1f5      	bne.n	dfee <_malloc_r+0x452>
    e002:	687b      	ldr	r3, [r7, #4]
    e004:	ea23 0304 	bic.w	r3, r3, r4
    e008:	607b      	str	r3, [r7, #4]
    e00a:	0064      	lsls	r4, r4, #1
    e00c:	429c      	cmp	r4, r3
    e00e:	f63f aebd 	bhi.w	dd8c <_malloc_r+0x1f0>
    e012:	2c00      	cmp	r4, #0
    e014:	f43f aeba 	beq.w	dd8c <_malloc_r+0x1f0>
    e018:	421c      	tst	r4, r3
    e01a:	4640      	mov	r0, r8
    e01c:	f47f ae35 	bne.w	dc8a <_malloc_r+0xee>
    e020:	0064      	lsls	r4, r4, #1
    e022:	421c      	tst	r4, r3
    e024:	f100 0004 	add.w	r0, r0, #4
    e028:	d0fa      	beq.n	e020 <_malloc_r+0x484>
    e02a:	e62e      	b.n	dc8a <_malloc_r+0xee>
    e02c:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    e030:	d818      	bhi.n	e064 <_malloc_r+0x4c8>
    e032:	0be8      	lsrs	r0, r5, #15
    e034:	f100 0e78 	add.w	lr, r0, #120	; 0x78
    e038:	ea4f 034e 	mov.w	r3, lr, lsl #1
    e03c:	3077      	adds	r0, #119	; 0x77
    e03e:	e5cf      	b.n	dbe0 <_malloc_r+0x44>
    e040:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    e044:	e6eb      	b.n	de1e <_malloc_r+0x282>
    e046:	2101      	movs	r1, #1
    e048:	f8d8 3004 	ldr.w	r3, [r8, #4]
    e04c:	1092      	asrs	r2, r2, #2
    e04e:	fa01 f202 	lsl.w	r2, r1, r2
    e052:	431a      	orrs	r2, r3
    e054:	f8c8 2004 	str.w	r2, [r8, #4]
    e058:	4661      	mov	r1, ip
    e05a:	e777      	b.n	df4c <_malloc_r+0x3b0>
    e05c:	2301      	movs	r3, #1
    e05e:	f8cb 3004 	str.w	r3, [fp, #4]
    e062:	e725      	b.n	deb0 <_malloc_r+0x314>
    e064:	f240 5254 	movw	r2, #1364	; 0x554
    e068:	4293      	cmp	r3, r2
    e06a:	d820      	bhi.n	e0ae <_malloc_r+0x512>
    e06c:	0ca8      	lsrs	r0, r5, #18
    e06e:	f100 0e7d 	add.w	lr, r0, #125	; 0x7d
    e072:	ea4f 034e 	mov.w	r3, lr, lsl #1
    e076:	307c      	adds	r0, #124	; 0x7c
    e078:	e5b2      	b.n	dbe0 <_malloc_r+0x44>
    e07a:	3210      	adds	r2, #16
    e07c:	e6a4      	b.n	ddc8 <_malloc_r+0x22c>
    e07e:	2a54      	cmp	r2, #84	; 0x54
    e080:	d826      	bhi.n	e0d0 <_malloc_r+0x534>
    e082:	0b1a      	lsrs	r2, r3, #12
    e084:	f102 016f 	add.w	r1, r2, #111	; 0x6f
    e088:	0049      	lsls	r1, r1, #1
    e08a:	326e      	adds	r2, #110	; 0x6e
    e08c:	e748      	b.n	df20 <_malloc_r+0x384>
    e08e:	68bc      	ldr	r4, [r7, #8]
    e090:	6862      	ldr	r2, [r4, #4]
    e092:	f022 0203 	bic.w	r2, r2, #3
    e096:	e705      	b.n	dea4 <_malloc_r+0x308>
    e098:	f3ca 000b 	ubfx	r0, sl, #0, #12
    e09c:	2800      	cmp	r0, #0
    e09e:	f47f aea8 	bne.w	ddf2 <_malloc_r+0x256>
    e0a2:	4442      	add	r2, r8
    e0a4:	68bb      	ldr	r3, [r7, #8]
    e0a6:	f042 0201 	orr.w	r2, r2, #1
    e0aa:	605a      	str	r2, [r3, #4]
    e0ac:	e6ec      	b.n	de88 <_malloc_r+0x2ec>
    e0ae:	23fe      	movs	r3, #254	; 0xfe
    e0b0:	f04f 0e7f 	mov.w	lr, #127	; 0x7f
    e0b4:	207e      	movs	r0, #126	; 0x7e
    e0b6:	e593      	b.n	dbe0 <_malloc_r+0x44>
    e0b8:	2201      	movs	r2, #1
    e0ba:	f04f 0900 	mov.w	r9, #0
    e0be:	e6c1      	b.n	de44 <_malloc_r+0x2a8>
    e0c0:	f104 0108 	add.w	r1, r4, #8
    e0c4:	4630      	mov	r0, r6
    e0c6:	f000 fe97 	bl	edf8 <_free_r>
    e0ca:	f8d9 1000 	ldr.w	r1, [r9]
    e0ce:	e6db      	b.n	de88 <_malloc_r+0x2ec>
    e0d0:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    e0d4:	d805      	bhi.n	e0e2 <_malloc_r+0x546>
    e0d6:	0bda      	lsrs	r2, r3, #15
    e0d8:	f102 0178 	add.w	r1, r2, #120	; 0x78
    e0dc:	0049      	lsls	r1, r1, #1
    e0de:	3277      	adds	r2, #119	; 0x77
    e0e0:	e71e      	b.n	df20 <_malloc_r+0x384>
    e0e2:	f240 5154 	movw	r1, #1364	; 0x554
    e0e6:	428a      	cmp	r2, r1
    e0e8:	d805      	bhi.n	e0f6 <_malloc_r+0x55a>
    e0ea:	0c9a      	lsrs	r2, r3, #18
    e0ec:	f102 017d 	add.w	r1, r2, #125	; 0x7d
    e0f0:	0049      	lsls	r1, r1, #1
    e0f2:	327c      	adds	r2, #124	; 0x7c
    e0f4:	e714      	b.n	df20 <_malloc_r+0x384>
    e0f6:	21fe      	movs	r1, #254	; 0xfe
    e0f8:	227e      	movs	r2, #126	; 0x7e
    e0fa:	e711      	b.n	df20 <_malloc_r+0x384>
    e0fc:	687b      	ldr	r3, [r7, #4]
    e0fe:	e784      	b.n	e00a <_malloc_r+0x46e>
    e100:	08e8      	lsrs	r0, r5, #3
    e102:	1c43      	adds	r3, r0, #1
    e104:	005b      	lsls	r3, r3, #1
    e106:	e5f8      	b.n	dcfa <_malloc_r+0x15e>
    e108:	1fffc0fc 	.word	0x1fffc0fc

0000e10c <memmove>:
    e10c:	4288      	cmp	r0, r1
    e10e:	b5f0      	push	{r4, r5, r6, r7, lr}
    e110:	d90d      	bls.n	e12e <memmove+0x22>
    e112:	188b      	adds	r3, r1, r2
    e114:	4298      	cmp	r0, r3
    e116:	d20a      	bcs.n	e12e <memmove+0x22>
    e118:	1881      	adds	r1, r0, r2
    e11a:	2a00      	cmp	r2, #0
    e11c:	d051      	beq.n	e1c2 <memmove+0xb6>
    e11e:	1a9a      	subs	r2, r3, r2
    e120:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
    e124:	f801 4d01 	strb.w	r4, [r1, #-1]!
    e128:	4293      	cmp	r3, r2
    e12a:	d1f9      	bne.n	e120 <memmove+0x14>
    e12c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e12e:	2a0f      	cmp	r2, #15
    e130:	d948      	bls.n	e1c4 <memmove+0xb8>
    e132:	ea41 0300 	orr.w	r3, r1, r0
    e136:	079b      	lsls	r3, r3, #30
    e138:	d146      	bne.n	e1c8 <memmove+0xbc>
    e13a:	f100 0410 	add.w	r4, r0, #16
    e13e:	f101 0310 	add.w	r3, r1, #16
    e142:	4615      	mov	r5, r2
    e144:	f853 6c10 	ldr.w	r6, [r3, #-16]
    e148:	f844 6c10 	str.w	r6, [r4, #-16]
    e14c:	f853 6c0c 	ldr.w	r6, [r3, #-12]
    e150:	f844 6c0c 	str.w	r6, [r4, #-12]
    e154:	f853 6c08 	ldr.w	r6, [r3, #-8]
    e158:	f844 6c08 	str.w	r6, [r4, #-8]
    e15c:	3d10      	subs	r5, #16
    e15e:	f853 6c04 	ldr.w	r6, [r3, #-4]
    e162:	f844 6c04 	str.w	r6, [r4, #-4]
    e166:	2d0f      	cmp	r5, #15
    e168:	f103 0310 	add.w	r3, r3, #16
    e16c:	f104 0410 	add.w	r4, r4, #16
    e170:	d8e8      	bhi.n	e144 <memmove+0x38>
    e172:	f1a2 0310 	sub.w	r3, r2, #16
    e176:	f023 030f 	bic.w	r3, r3, #15
    e17a:	f002 0e0f 	and.w	lr, r2, #15
    e17e:	3310      	adds	r3, #16
    e180:	f1be 0f03 	cmp.w	lr, #3
    e184:	4419      	add	r1, r3
    e186:	4403      	add	r3, r0
    e188:	d921      	bls.n	e1ce <memmove+0xc2>
    e18a:	1f1e      	subs	r6, r3, #4
    e18c:	460d      	mov	r5, r1
    e18e:	4674      	mov	r4, lr
    e190:	3c04      	subs	r4, #4
    e192:	f855 7b04 	ldr.w	r7, [r5], #4
    e196:	f846 7f04 	str.w	r7, [r6, #4]!
    e19a:	2c03      	cmp	r4, #3
    e19c:	d8f8      	bhi.n	e190 <memmove+0x84>
    e19e:	f1ae 0404 	sub.w	r4, lr, #4
    e1a2:	f024 0403 	bic.w	r4, r4, #3
    e1a6:	3404      	adds	r4, #4
    e1a8:	4423      	add	r3, r4
    e1aa:	4421      	add	r1, r4
    e1ac:	f002 0203 	and.w	r2, r2, #3
    e1b0:	b162      	cbz	r2, e1cc <memmove+0xc0>
    e1b2:	3b01      	subs	r3, #1
    e1b4:	440a      	add	r2, r1
    e1b6:	f811 4b01 	ldrb.w	r4, [r1], #1
    e1ba:	f803 4f01 	strb.w	r4, [r3, #1]!
    e1be:	428a      	cmp	r2, r1
    e1c0:	d1f9      	bne.n	e1b6 <memmove+0xaa>
    e1c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e1c4:	4603      	mov	r3, r0
    e1c6:	e7f3      	b.n	e1b0 <memmove+0xa4>
    e1c8:	4603      	mov	r3, r0
    e1ca:	e7f2      	b.n	e1b2 <memmove+0xa6>
    e1cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e1ce:	4672      	mov	r2, lr
    e1d0:	e7ee      	b.n	e1b0 <memmove+0xa4>
    e1d2:	bf00      	nop

0000e1d4 <memset>:
    e1d4:	b470      	push	{r4, r5, r6}
    e1d6:	0784      	lsls	r4, r0, #30
    e1d8:	d046      	beq.n	e268 <memset+0x94>
    e1da:	1e54      	subs	r4, r2, #1
    e1dc:	2a00      	cmp	r2, #0
    e1de:	d041      	beq.n	e264 <memset+0x90>
    e1e0:	b2cd      	uxtb	r5, r1
    e1e2:	4603      	mov	r3, r0
    e1e4:	e002      	b.n	e1ec <memset+0x18>
    e1e6:	1e62      	subs	r2, r4, #1
    e1e8:	b3e4      	cbz	r4, e264 <memset+0x90>
    e1ea:	4614      	mov	r4, r2
    e1ec:	f803 5b01 	strb.w	r5, [r3], #1
    e1f0:	079a      	lsls	r2, r3, #30
    e1f2:	d1f8      	bne.n	e1e6 <memset+0x12>
    e1f4:	2c03      	cmp	r4, #3
    e1f6:	d92e      	bls.n	e256 <memset+0x82>
    e1f8:	b2cd      	uxtb	r5, r1
    e1fa:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    e1fe:	2c0f      	cmp	r4, #15
    e200:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    e204:	d919      	bls.n	e23a <memset+0x66>
    e206:	f103 0210 	add.w	r2, r3, #16
    e20a:	4626      	mov	r6, r4
    e20c:	3e10      	subs	r6, #16
    e20e:	2e0f      	cmp	r6, #15
    e210:	f842 5c10 	str.w	r5, [r2, #-16]
    e214:	f842 5c0c 	str.w	r5, [r2, #-12]
    e218:	f842 5c08 	str.w	r5, [r2, #-8]
    e21c:	f842 5c04 	str.w	r5, [r2, #-4]
    e220:	f102 0210 	add.w	r2, r2, #16
    e224:	d8f2      	bhi.n	e20c <memset+0x38>
    e226:	f1a4 0210 	sub.w	r2, r4, #16
    e22a:	f022 020f 	bic.w	r2, r2, #15
    e22e:	f004 040f 	and.w	r4, r4, #15
    e232:	3210      	adds	r2, #16
    e234:	2c03      	cmp	r4, #3
    e236:	4413      	add	r3, r2
    e238:	d90d      	bls.n	e256 <memset+0x82>
    e23a:	461e      	mov	r6, r3
    e23c:	4622      	mov	r2, r4
    e23e:	3a04      	subs	r2, #4
    e240:	2a03      	cmp	r2, #3
    e242:	f846 5b04 	str.w	r5, [r6], #4
    e246:	d8fa      	bhi.n	e23e <memset+0x6a>
    e248:	1f22      	subs	r2, r4, #4
    e24a:	f022 0203 	bic.w	r2, r2, #3
    e24e:	3204      	adds	r2, #4
    e250:	4413      	add	r3, r2
    e252:	f004 0403 	and.w	r4, r4, #3
    e256:	b12c      	cbz	r4, e264 <memset+0x90>
    e258:	b2c9      	uxtb	r1, r1
    e25a:	441c      	add	r4, r3
    e25c:	f803 1b01 	strb.w	r1, [r3], #1
    e260:	42a3      	cmp	r3, r4
    e262:	d1fb      	bne.n	e25c <memset+0x88>
    e264:	bc70      	pop	{r4, r5, r6}
    e266:	4770      	bx	lr
    e268:	4614      	mov	r4, r2
    e26a:	4603      	mov	r3, r0
    e26c:	e7c2      	b.n	e1f4 <memset+0x20>
    e26e:	bf00      	nop

0000e270 <__malloc_lock>:
    e270:	4770      	bx	lr
    e272:	bf00      	nop

0000e274 <__malloc_unlock>:
    e274:	4770      	bx	lr
    e276:	bf00      	nop

0000e278 <realloc>:
    e278:	4b02      	ldr	r3, [pc, #8]	; (e284 <realloc+0xc>)
    e27a:	460a      	mov	r2, r1
    e27c:	4601      	mov	r1, r0
    e27e:	6818      	ldr	r0, [r3, #0]
    e280:	f000 b802 	b.w	e288 <_realloc_r>
    e284:	1fffc0f8 	.word	0x1fffc0f8

0000e288 <_realloc_r>:
    e288:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e28c:	4617      	mov	r7, r2
    e28e:	b083      	sub	sp, #12
    e290:	2900      	cmp	r1, #0
    e292:	f000 80c1 	beq.w	e418 <_realloc_r+0x190>
    e296:	460e      	mov	r6, r1
    e298:	4681      	mov	r9, r0
    e29a:	f107 050b 	add.w	r5, r7, #11
    e29e:	f7ff ffe7 	bl	e270 <__malloc_lock>
    e2a2:	f856 ec04 	ldr.w	lr, [r6, #-4]
    e2a6:	2d16      	cmp	r5, #22
    e2a8:	f02e 0403 	bic.w	r4, lr, #3
    e2ac:	f1a6 0808 	sub.w	r8, r6, #8
    e2b0:	d840      	bhi.n	e334 <_realloc_r+0xac>
    e2b2:	2210      	movs	r2, #16
    e2b4:	4615      	mov	r5, r2
    e2b6:	42af      	cmp	r7, r5
    e2b8:	d841      	bhi.n	e33e <_realloc_r+0xb6>
    e2ba:	4294      	cmp	r4, r2
    e2bc:	da75      	bge.n	e3aa <_realloc_r+0x122>
    e2be:	4bc9      	ldr	r3, [pc, #804]	; (e5e4 <_realloc_r+0x35c>)
    e2c0:	6899      	ldr	r1, [r3, #8]
    e2c2:	eb08 0004 	add.w	r0, r8, r4
    e2c6:	4288      	cmp	r0, r1
    e2c8:	6841      	ldr	r1, [r0, #4]
    e2ca:	f000 80d9 	beq.w	e480 <_realloc_r+0x1f8>
    e2ce:	f021 0301 	bic.w	r3, r1, #1
    e2d2:	4403      	add	r3, r0
    e2d4:	685b      	ldr	r3, [r3, #4]
    e2d6:	07db      	lsls	r3, r3, #31
    e2d8:	d57d      	bpl.n	e3d6 <_realloc_r+0x14e>
    e2da:	f01e 0f01 	tst.w	lr, #1
    e2de:	d035      	beq.n	e34c <_realloc_r+0xc4>
    e2e0:	4639      	mov	r1, r7
    e2e2:	4648      	mov	r0, r9
    e2e4:	f7ff fc5a 	bl	db9c <_malloc_r>
    e2e8:	4607      	mov	r7, r0
    e2ea:	b1e0      	cbz	r0, e326 <_realloc_r+0x9e>
    e2ec:	f856 3c04 	ldr.w	r3, [r6, #-4]
    e2f0:	f023 0301 	bic.w	r3, r3, #1
    e2f4:	4443      	add	r3, r8
    e2f6:	f1a0 0208 	sub.w	r2, r0, #8
    e2fa:	429a      	cmp	r2, r3
    e2fc:	f000 8144 	beq.w	e588 <_realloc_r+0x300>
    e300:	1f22      	subs	r2, r4, #4
    e302:	2a24      	cmp	r2, #36	; 0x24
    e304:	f200 8131 	bhi.w	e56a <_realloc_r+0x2e2>
    e308:	2a13      	cmp	r2, #19
    e30a:	f200 8104 	bhi.w	e516 <_realloc_r+0x28e>
    e30e:	4603      	mov	r3, r0
    e310:	4632      	mov	r2, r6
    e312:	6811      	ldr	r1, [r2, #0]
    e314:	6019      	str	r1, [r3, #0]
    e316:	6851      	ldr	r1, [r2, #4]
    e318:	6059      	str	r1, [r3, #4]
    e31a:	6892      	ldr	r2, [r2, #8]
    e31c:	609a      	str	r2, [r3, #8]
    e31e:	4631      	mov	r1, r6
    e320:	4648      	mov	r0, r9
    e322:	f000 fd69 	bl	edf8 <_free_r>
    e326:	4648      	mov	r0, r9
    e328:	f7ff ffa4 	bl	e274 <__malloc_unlock>
    e32c:	4638      	mov	r0, r7
    e32e:	b003      	add	sp, #12
    e330:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e334:	f025 0507 	bic.w	r5, r5, #7
    e338:	2d00      	cmp	r5, #0
    e33a:	462a      	mov	r2, r5
    e33c:	dabb      	bge.n	e2b6 <_realloc_r+0x2e>
    e33e:	230c      	movs	r3, #12
    e340:	2000      	movs	r0, #0
    e342:	f8c9 3000 	str.w	r3, [r9]
    e346:	b003      	add	sp, #12
    e348:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e34c:	f856 3c08 	ldr.w	r3, [r6, #-8]
    e350:	ebc3 0a08 	rsb	sl, r3, r8
    e354:	f8da 3004 	ldr.w	r3, [sl, #4]
    e358:	f023 0c03 	bic.w	ip, r3, #3
    e35c:	eb04 030c 	add.w	r3, r4, ip
    e360:	4293      	cmp	r3, r2
    e362:	dbbd      	blt.n	e2e0 <_realloc_r+0x58>
    e364:	4657      	mov	r7, sl
    e366:	f8da 100c 	ldr.w	r1, [sl, #12]
    e36a:	f857 0f08 	ldr.w	r0, [r7, #8]!
    e36e:	1f22      	subs	r2, r4, #4
    e370:	2a24      	cmp	r2, #36	; 0x24
    e372:	60c1      	str	r1, [r0, #12]
    e374:	6088      	str	r0, [r1, #8]
    e376:	f200 8117 	bhi.w	e5a8 <_realloc_r+0x320>
    e37a:	2a13      	cmp	r2, #19
    e37c:	f240 8112 	bls.w	e5a4 <_realloc_r+0x31c>
    e380:	6831      	ldr	r1, [r6, #0]
    e382:	f8ca 1008 	str.w	r1, [sl, #8]
    e386:	6871      	ldr	r1, [r6, #4]
    e388:	f8ca 100c 	str.w	r1, [sl, #12]
    e38c:	2a1b      	cmp	r2, #27
    e38e:	f200 812b 	bhi.w	e5e8 <_realloc_r+0x360>
    e392:	3608      	adds	r6, #8
    e394:	f10a 0210 	add.w	r2, sl, #16
    e398:	6831      	ldr	r1, [r6, #0]
    e39a:	6011      	str	r1, [r2, #0]
    e39c:	6871      	ldr	r1, [r6, #4]
    e39e:	6051      	str	r1, [r2, #4]
    e3a0:	68b1      	ldr	r1, [r6, #8]
    e3a2:	6091      	str	r1, [r2, #8]
    e3a4:	463e      	mov	r6, r7
    e3a6:	461c      	mov	r4, r3
    e3a8:	46d0      	mov	r8, sl
    e3aa:	1b63      	subs	r3, r4, r5
    e3ac:	2b0f      	cmp	r3, #15
    e3ae:	d81d      	bhi.n	e3ec <_realloc_r+0x164>
    e3b0:	f8d8 3004 	ldr.w	r3, [r8, #4]
    e3b4:	f003 0301 	and.w	r3, r3, #1
    e3b8:	4323      	orrs	r3, r4
    e3ba:	4444      	add	r4, r8
    e3bc:	f8c8 3004 	str.w	r3, [r8, #4]
    e3c0:	6863      	ldr	r3, [r4, #4]
    e3c2:	f043 0301 	orr.w	r3, r3, #1
    e3c6:	6063      	str	r3, [r4, #4]
    e3c8:	4648      	mov	r0, r9
    e3ca:	f7ff ff53 	bl	e274 <__malloc_unlock>
    e3ce:	4630      	mov	r0, r6
    e3d0:	b003      	add	sp, #12
    e3d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e3d6:	f021 0103 	bic.w	r1, r1, #3
    e3da:	4421      	add	r1, r4
    e3dc:	4291      	cmp	r1, r2
    e3de:	db21      	blt.n	e424 <_realloc_r+0x19c>
    e3e0:	68c3      	ldr	r3, [r0, #12]
    e3e2:	6882      	ldr	r2, [r0, #8]
    e3e4:	460c      	mov	r4, r1
    e3e6:	60d3      	str	r3, [r2, #12]
    e3e8:	609a      	str	r2, [r3, #8]
    e3ea:	e7de      	b.n	e3aa <_realloc_r+0x122>
    e3ec:	f8d8 2004 	ldr.w	r2, [r8, #4]
    e3f0:	eb08 0105 	add.w	r1, r8, r5
    e3f4:	f002 0201 	and.w	r2, r2, #1
    e3f8:	4315      	orrs	r5, r2
    e3fa:	f043 0201 	orr.w	r2, r3, #1
    e3fe:	440b      	add	r3, r1
    e400:	f8c8 5004 	str.w	r5, [r8, #4]
    e404:	604a      	str	r2, [r1, #4]
    e406:	685a      	ldr	r2, [r3, #4]
    e408:	f042 0201 	orr.w	r2, r2, #1
    e40c:	3108      	adds	r1, #8
    e40e:	605a      	str	r2, [r3, #4]
    e410:	4648      	mov	r0, r9
    e412:	f000 fcf1 	bl	edf8 <_free_r>
    e416:	e7d7      	b.n	e3c8 <_realloc_r+0x140>
    e418:	4611      	mov	r1, r2
    e41a:	b003      	add	sp, #12
    e41c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e420:	f7ff bbbc 	b.w	db9c <_malloc_r>
    e424:	f01e 0f01 	tst.w	lr, #1
    e428:	f47f af5a 	bne.w	e2e0 <_realloc_r+0x58>
    e42c:	f856 3c08 	ldr.w	r3, [r6, #-8]
    e430:	ebc3 0a08 	rsb	sl, r3, r8
    e434:	f8da 3004 	ldr.w	r3, [sl, #4]
    e438:	f023 0c03 	bic.w	ip, r3, #3
    e43c:	eb01 0e0c 	add.w	lr, r1, ip
    e440:	4596      	cmp	lr, r2
    e442:	db8b      	blt.n	e35c <_realloc_r+0xd4>
    e444:	68c3      	ldr	r3, [r0, #12]
    e446:	6882      	ldr	r2, [r0, #8]
    e448:	4657      	mov	r7, sl
    e44a:	60d3      	str	r3, [r2, #12]
    e44c:	609a      	str	r2, [r3, #8]
    e44e:	f857 1f08 	ldr.w	r1, [r7, #8]!
    e452:	f8da 300c 	ldr.w	r3, [sl, #12]
    e456:	60cb      	str	r3, [r1, #12]
    e458:	1f22      	subs	r2, r4, #4
    e45a:	2a24      	cmp	r2, #36	; 0x24
    e45c:	6099      	str	r1, [r3, #8]
    e45e:	f200 8099 	bhi.w	e594 <_realloc_r+0x30c>
    e462:	2a13      	cmp	r2, #19
    e464:	d962      	bls.n	e52c <_realloc_r+0x2a4>
    e466:	6833      	ldr	r3, [r6, #0]
    e468:	f8ca 3008 	str.w	r3, [sl, #8]
    e46c:	6873      	ldr	r3, [r6, #4]
    e46e:	f8ca 300c 	str.w	r3, [sl, #12]
    e472:	2a1b      	cmp	r2, #27
    e474:	f200 80a0 	bhi.w	e5b8 <_realloc_r+0x330>
    e478:	3608      	adds	r6, #8
    e47a:	f10a 0310 	add.w	r3, sl, #16
    e47e:	e056      	b.n	e52e <_realloc_r+0x2a6>
    e480:	f021 0b03 	bic.w	fp, r1, #3
    e484:	44a3      	add	fp, r4
    e486:	f105 0010 	add.w	r0, r5, #16
    e48a:	4583      	cmp	fp, r0
    e48c:	da59      	bge.n	e542 <_realloc_r+0x2ba>
    e48e:	f01e 0f01 	tst.w	lr, #1
    e492:	f47f af25 	bne.w	e2e0 <_realloc_r+0x58>
    e496:	f856 1c08 	ldr.w	r1, [r6, #-8]
    e49a:	ebc1 0a08 	rsb	sl, r1, r8
    e49e:	f8da 1004 	ldr.w	r1, [sl, #4]
    e4a2:	f021 0c03 	bic.w	ip, r1, #3
    e4a6:	44e3      	add	fp, ip
    e4a8:	4558      	cmp	r0, fp
    e4aa:	f73f af57 	bgt.w	e35c <_realloc_r+0xd4>
    e4ae:	4657      	mov	r7, sl
    e4b0:	f8da 100c 	ldr.w	r1, [sl, #12]
    e4b4:	f857 0f08 	ldr.w	r0, [r7, #8]!
    e4b8:	1f22      	subs	r2, r4, #4
    e4ba:	2a24      	cmp	r2, #36	; 0x24
    e4bc:	60c1      	str	r1, [r0, #12]
    e4be:	6088      	str	r0, [r1, #8]
    e4c0:	f200 80b4 	bhi.w	e62c <_realloc_r+0x3a4>
    e4c4:	2a13      	cmp	r2, #19
    e4c6:	f240 80a5 	bls.w	e614 <_realloc_r+0x38c>
    e4ca:	6831      	ldr	r1, [r6, #0]
    e4cc:	f8ca 1008 	str.w	r1, [sl, #8]
    e4d0:	6871      	ldr	r1, [r6, #4]
    e4d2:	f8ca 100c 	str.w	r1, [sl, #12]
    e4d6:	2a1b      	cmp	r2, #27
    e4d8:	f200 80af 	bhi.w	e63a <_realloc_r+0x3b2>
    e4dc:	3608      	adds	r6, #8
    e4de:	f10a 0210 	add.w	r2, sl, #16
    e4e2:	6831      	ldr	r1, [r6, #0]
    e4e4:	6011      	str	r1, [r2, #0]
    e4e6:	6871      	ldr	r1, [r6, #4]
    e4e8:	6051      	str	r1, [r2, #4]
    e4ea:	68b1      	ldr	r1, [r6, #8]
    e4ec:	6091      	str	r1, [r2, #8]
    e4ee:	eb0a 0105 	add.w	r1, sl, r5
    e4f2:	ebc5 020b 	rsb	r2, r5, fp
    e4f6:	f042 0201 	orr.w	r2, r2, #1
    e4fa:	6099      	str	r1, [r3, #8]
    e4fc:	604a      	str	r2, [r1, #4]
    e4fe:	f8da 3004 	ldr.w	r3, [sl, #4]
    e502:	f003 0301 	and.w	r3, r3, #1
    e506:	431d      	orrs	r5, r3
    e508:	4648      	mov	r0, r9
    e50a:	f8ca 5004 	str.w	r5, [sl, #4]
    e50e:	f7ff feb1 	bl	e274 <__malloc_unlock>
    e512:	4638      	mov	r0, r7
    e514:	e75c      	b.n	e3d0 <_realloc_r+0x148>
    e516:	6833      	ldr	r3, [r6, #0]
    e518:	6003      	str	r3, [r0, #0]
    e51a:	6873      	ldr	r3, [r6, #4]
    e51c:	6043      	str	r3, [r0, #4]
    e51e:	2a1b      	cmp	r2, #27
    e520:	d827      	bhi.n	e572 <_realloc_r+0x2ea>
    e522:	f100 0308 	add.w	r3, r0, #8
    e526:	f106 0208 	add.w	r2, r6, #8
    e52a:	e6f2      	b.n	e312 <_realloc_r+0x8a>
    e52c:	463b      	mov	r3, r7
    e52e:	6832      	ldr	r2, [r6, #0]
    e530:	601a      	str	r2, [r3, #0]
    e532:	6872      	ldr	r2, [r6, #4]
    e534:	605a      	str	r2, [r3, #4]
    e536:	68b2      	ldr	r2, [r6, #8]
    e538:	609a      	str	r2, [r3, #8]
    e53a:	463e      	mov	r6, r7
    e53c:	4674      	mov	r4, lr
    e53e:	46d0      	mov	r8, sl
    e540:	e733      	b.n	e3aa <_realloc_r+0x122>
    e542:	eb08 0105 	add.w	r1, r8, r5
    e546:	ebc5 0b0b 	rsb	fp, r5, fp
    e54a:	f04b 0201 	orr.w	r2, fp, #1
    e54e:	6099      	str	r1, [r3, #8]
    e550:	604a      	str	r2, [r1, #4]
    e552:	f856 3c04 	ldr.w	r3, [r6, #-4]
    e556:	f003 0301 	and.w	r3, r3, #1
    e55a:	431d      	orrs	r5, r3
    e55c:	4648      	mov	r0, r9
    e55e:	f846 5c04 	str.w	r5, [r6, #-4]
    e562:	f7ff fe87 	bl	e274 <__malloc_unlock>
    e566:	4630      	mov	r0, r6
    e568:	e732      	b.n	e3d0 <_realloc_r+0x148>
    e56a:	4631      	mov	r1, r6
    e56c:	f7ff fdce 	bl	e10c <memmove>
    e570:	e6d5      	b.n	e31e <_realloc_r+0x96>
    e572:	68b3      	ldr	r3, [r6, #8]
    e574:	6083      	str	r3, [r0, #8]
    e576:	68f3      	ldr	r3, [r6, #12]
    e578:	60c3      	str	r3, [r0, #12]
    e57a:	2a24      	cmp	r2, #36	; 0x24
    e57c:	d028      	beq.n	e5d0 <_realloc_r+0x348>
    e57e:	f100 0310 	add.w	r3, r0, #16
    e582:	f106 0210 	add.w	r2, r6, #16
    e586:	e6c4      	b.n	e312 <_realloc_r+0x8a>
    e588:	f850 3c04 	ldr.w	r3, [r0, #-4]
    e58c:	f023 0303 	bic.w	r3, r3, #3
    e590:	441c      	add	r4, r3
    e592:	e70a      	b.n	e3aa <_realloc_r+0x122>
    e594:	4631      	mov	r1, r6
    e596:	4638      	mov	r0, r7
    e598:	4674      	mov	r4, lr
    e59a:	46d0      	mov	r8, sl
    e59c:	f7ff fdb6 	bl	e10c <memmove>
    e5a0:	463e      	mov	r6, r7
    e5a2:	e702      	b.n	e3aa <_realloc_r+0x122>
    e5a4:	463a      	mov	r2, r7
    e5a6:	e6f7      	b.n	e398 <_realloc_r+0x110>
    e5a8:	4631      	mov	r1, r6
    e5aa:	4638      	mov	r0, r7
    e5ac:	461c      	mov	r4, r3
    e5ae:	46d0      	mov	r8, sl
    e5b0:	f7ff fdac 	bl	e10c <memmove>
    e5b4:	463e      	mov	r6, r7
    e5b6:	e6f8      	b.n	e3aa <_realloc_r+0x122>
    e5b8:	68b3      	ldr	r3, [r6, #8]
    e5ba:	f8ca 3010 	str.w	r3, [sl, #16]
    e5be:	68f3      	ldr	r3, [r6, #12]
    e5c0:	f8ca 3014 	str.w	r3, [sl, #20]
    e5c4:	2a24      	cmp	r2, #36	; 0x24
    e5c6:	d01b      	beq.n	e600 <_realloc_r+0x378>
    e5c8:	3610      	adds	r6, #16
    e5ca:	f10a 0318 	add.w	r3, sl, #24
    e5ce:	e7ae      	b.n	e52e <_realloc_r+0x2a6>
    e5d0:	6933      	ldr	r3, [r6, #16]
    e5d2:	6103      	str	r3, [r0, #16]
    e5d4:	6973      	ldr	r3, [r6, #20]
    e5d6:	6143      	str	r3, [r0, #20]
    e5d8:	f106 0218 	add.w	r2, r6, #24
    e5dc:	f100 0318 	add.w	r3, r0, #24
    e5e0:	e697      	b.n	e312 <_realloc_r+0x8a>
    e5e2:	bf00      	nop
    e5e4:	1fffc0fc 	.word	0x1fffc0fc
    e5e8:	68b1      	ldr	r1, [r6, #8]
    e5ea:	f8ca 1010 	str.w	r1, [sl, #16]
    e5ee:	68f1      	ldr	r1, [r6, #12]
    e5f0:	f8ca 1014 	str.w	r1, [sl, #20]
    e5f4:	2a24      	cmp	r2, #36	; 0x24
    e5f6:	d00f      	beq.n	e618 <_realloc_r+0x390>
    e5f8:	3610      	adds	r6, #16
    e5fa:	f10a 0218 	add.w	r2, sl, #24
    e5fe:	e6cb      	b.n	e398 <_realloc_r+0x110>
    e600:	6933      	ldr	r3, [r6, #16]
    e602:	f8ca 3018 	str.w	r3, [sl, #24]
    e606:	6973      	ldr	r3, [r6, #20]
    e608:	f8ca 301c 	str.w	r3, [sl, #28]
    e60c:	3618      	adds	r6, #24
    e60e:	f10a 0320 	add.w	r3, sl, #32
    e612:	e78c      	b.n	e52e <_realloc_r+0x2a6>
    e614:	463a      	mov	r2, r7
    e616:	e764      	b.n	e4e2 <_realloc_r+0x25a>
    e618:	6932      	ldr	r2, [r6, #16]
    e61a:	f8ca 2018 	str.w	r2, [sl, #24]
    e61e:	6972      	ldr	r2, [r6, #20]
    e620:	f8ca 201c 	str.w	r2, [sl, #28]
    e624:	3618      	adds	r6, #24
    e626:	f10a 0220 	add.w	r2, sl, #32
    e62a:	e6b5      	b.n	e398 <_realloc_r+0x110>
    e62c:	4631      	mov	r1, r6
    e62e:	4638      	mov	r0, r7
    e630:	9301      	str	r3, [sp, #4]
    e632:	f7ff fd6b 	bl	e10c <memmove>
    e636:	9b01      	ldr	r3, [sp, #4]
    e638:	e759      	b.n	e4ee <_realloc_r+0x266>
    e63a:	68b1      	ldr	r1, [r6, #8]
    e63c:	f8ca 1010 	str.w	r1, [sl, #16]
    e640:	68f1      	ldr	r1, [r6, #12]
    e642:	f8ca 1014 	str.w	r1, [sl, #20]
    e646:	2a24      	cmp	r2, #36	; 0x24
    e648:	d003      	beq.n	e652 <_realloc_r+0x3ca>
    e64a:	3610      	adds	r6, #16
    e64c:	f10a 0218 	add.w	r2, sl, #24
    e650:	e747      	b.n	e4e2 <_realloc_r+0x25a>
    e652:	6932      	ldr	r2, [r6, #16]
    e654:	f8ca 2018 	str.w	r2, [sl, #24]
    e658:	6972      	ldr	r2, [r6, #20]
    e65a:	f8ca 201c 	str.w	r2, [sl, #28]
    e65e:	3618      	adds	r6, #24
    e660:	f10a 0220 	add.w	r2, sl, #32
    e664:	e73d      	b.n	e4e2 <_realloc_r+0x25a>
    e666:	bf00      	nop

0000e668 <_sbrk_r>:
    e668:	b538      	push	{r3, r4, r5, lr}
    e66a:	4c07      	ldr	r4, [pc, #28]	; (e688 <_sbrk_r+0x20>)
    e66c:	2300      	movs	r3, #0
    e66e:	4605      	mov	r5, r0
    e670:	4608      	mov	r0, r1
    e672:	6023      	str	r3, [r4, #0]
    e674:	f7fb f9e6 	bl	9a44 <_sbrk>
    e678:	1c43      	adds	r3, r0, #1
    e67a:	d000      	beq.n	e67e <_sbrk_r+0x16>
    e67c:	bd38      	pop	{r3, r4, r5, pc}
    e67e:	6823      	ldr	r3, [r4, #0]
    e680:	2b00      	cmp	r3, #0
    e682:	d0fb      	beq.n	e67c <_sbrk_r+0x14>
    e684:	602b      	str	r3, [r5, #0]
    e686:	bd38      	pop	{r3, r4, r5, pc}
    e688:	20004944 	.word	0x20004944
    e68c:	ffffffff 	.word	0xffffffff
    e690:	ffffffff 	.word	0xffffffff
    e694:	ffffffff 	.word	0xffffffff
    e698:	ffffffff 	.word	0xffffffff
    e69c:	ffffffff 	.word	0xffffffff
    e6a0:	eba2 0003 	sub.w	r0, r2, r3
    e6a4:	4770      	bx	lr
    e6a6:	bf00      	nop

0000e6a8 <strcmp>:
    e6a8:	7802      	ldrb	r2, [r0, #0]
    e6aa:	780b      	ldrb	r3, [r1, #0]
    e6ac:	2a01      	cmp	r2, #1
    e6ae:	bf28      	it	cs
    e6b0:	429a      	cmpcs	r2, r3
    e6b2:	d1f5      	bne.n	e6a0 <_sbrk_r+0x38>
    e6b4:	e96d 4504 	strd	r4, r5, [sp, #-16]!
    e6b8:	ea40 0401 	orr.w	r4, r0, r1
    e6bc:	e9cd 6702 	strd	r6, r7, [sp, #8]
    e6c0:	f06f 0c00 	mvn.w	ip, #0
    e6c4:	ea4f 7244 	mov.w	r2, r4, lsl #29
    e6c8:	b312      	cbz	r2, e710 <strcmp+0x68>
    e6ca:	ea80 0401 	eor.w	r4, r0, r1
    e6ce:	f014 0f07 	tst.w	r4, #7
    e6d2:	d16a      	bne.n	e7aa <strcmp+0x102>
    e6d4:	f000 0407 	and.w	r4, r0, #7
    e6d8:	f020 0007 	bic.w	r0, r0, #7
    e6dc:	f004 0503 	and.w	r5, r4, #3
    e6e0:	f021 0107 	bic.w	r1, r1, #7
    e6e4:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    e6e8:	e8f0 2304 	ldrd	r2, r3, [r0], #16
    e6ec:	f014 0f04 	tst.w	r4, #4
    e6f0:	e8f1 6704 	ldrd	r6, r7, [r1], #16
    e6f4:	fa0c f405 	lsl.w	r4, ip, r5
    e6f8:	ea62 0204 	orn	r2, r2, r4
    e6fc:	ea66 0604 	orn	r6, r6, r4
    e700:	d00a      	beq.n	e718 <strcmp+0x70>
    e702:	ea63 0304 	orn	r3, r3, r4
    e706:	4662      	mov	r2, ip
    e708:	ea67 0704 	orn	r7, r7, r4
    e70c:	4666      	mov	r6, ip
    e70e:	e003      	b.n	e718 <strcmp+0x70>
    e710:	e8f0 2304 	ldrd	r2, r3, [r0], #16
    e714:	e8f1 6704 	ldrd	r6, r7, [r1], #16
    e718:	fa82 f54c 	uadd8	r5, r2, ip
    e71c:	ea82 0406 	eor.w	r4, r2, r6
    e720:	faa4 f48c 	sel	r4, r4, ip
    e724:	bb6c      	cbnz	r4, e782 <strcmp+0xda>
    e726:	fa83 f54c 	uadd8	r5, r3, ip
    e72a:	ea83 0507 	eor.w	r5, r3, r7
    e72e:	faa5 f58c 	sel	r5, r5, ip
    e732:	b995      	cbnz	r5, e75a <strcmp+0xb2>
    e734:	e950 2302 	ldrd	r2, r3, [r0, #-8]
    e738:	e951 6702 	ldrd	r6, r7, [r1, #-8]
    e73c:	fa82 f54c 	uadd8	r5, r2, ip
    e740:	ea82 0406 	eor.w	r4, r2, r6
    e744:	faa4 f48c 	sel	r4, r4, ip
    e748:	fa83 f54c 	uadd8	r5, r3, ip
    e74c:	ea83 0507 	eor.w	r5, r3, r7
    e750:	faa5 f58c 	sel	r5, r5, ip
    e754:	4325      	orrs	r5, r4
    e756:	d0db      	beq.n	e710 <strcmp+0x68>
    e758:	b99c      	cbnz	r4, e782 <strcmp+0xda>
    e75a:	ba2d      	rev	r5, r5
    e75c:	fab5 f485 	clz	r4, r5
    e760:	f024 0407 	bic.w	r4, r4, #7
    e764:	fa27 f104 	lsr.w	r1, r7, r4
    e768:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    e76c:	fa23 f304 	lsr.w	r3, r3, r4
    e770:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    e774:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    e778:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    e77c:	eba0 0001 	sub.w	r0, r0, r1
    e780:	4770      	bx	lr
    e782:	ba24      	rev	r4, r4
    e784:	fab4 f484 	clz	r4, r4
    e788:	f024 0407 	bic.w	r4, r4, #7
    e78c:	fa26 f104 	lsr.w	r1, r6, r4
    e790:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    e794:	fa22 f204 	lsr.w	r2, r2, r4
    e798:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    e79c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    e7a0:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    e7a4:	eba0 0001 	sub.w	r0, r0, r1
    e7a8:	4770      	bx	lr
    e7aa:	f014 0f03 	tst.w	r4, #3
    e7ae:	d13c      	bne.n	e82a <strcmp+0x182>
    e7b0:	f010 0403 	ands.w	r4, r0, #3
    e7b4:	d128      	bne.n	e808 <strcmp+0x160>
    e7b6:	f850 2b08 	ldr.w	r2, [r0], #8
    e7ba:	f851 3b08 	ldr.w	r3, [r1], #8
    e7be:	fa82 f54c 	uadd8	r5, r2, ip
    e7c2:	ea82 0503 	eor.w	r5, r2, r3
    e7c6:	faa5 f58c 	sel	r5, r5, ip
    e7ca:	b95d      	cbnz	r5, e7e4 <strcmp+0x13c>
    e7cc:	f850 2c04 	ldr.w	r2, [r0, #-4]
    e7d0:	f851 3c04 	ldr.w	r3, [r1, #-4]
    e7d4:	fa82 f54c 	uadd8	r5, r2, ip
    e7d8:	ea82 0503 	eor.w	r5, r2, r3
    e7dc:	faa5 f58c 	sel	r5, r5, ip
    e7e0:	2d00      	cmp	r5, #0
    e7e2:	d0e8      	beq.n	e7b6 <strcmp+0x10e>
    e7e4:	ba2d      	rev	r5, r5
    e7e6:	fab5 f485 	clz	r4, r5
    e7ea:	f024 0407 	bic.w	r4, r4, #7
    e7ee:	fa23 f104 	lsr.w	r1, r3, r4
    e7f2:	fa22 f204 	lsr.w	r2, r2, r4
    e7f6:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    e7fa:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    e7fe:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    e802:	eba0 0001 	sub.w	r0, r0, r1
    e806:	4770      	bx	lr
    e808:	ea4f 04c4 	mov.w	r4, r4, lsl #3
    e80c:	f020 0003 	bic.w	r0, r0, #3
    e810:	f850 2b08 	ldr.w	r2, [r0], #8
    e814:	f021 0103 	bic.w	r1, r1, #3
    e818:	f851 3b08 	ldr.w	r3, [r1], #8
    e81c:	fa0c f404 	lsl.w	r4, ip, r4
    e820:	ea62 0204 	orn	r2, r2, r4
    e824:	ea63 0304 	orn	r3, r3, r4
    e828:	e7c9      	b.n	e7be <strcmp+0x116>
    e82a:	f010 0403 	ands.w	r4, r0, #3
    e82e:	d01a      	beq.n	e866 <strcmp+0x1be>
    e830:	eba1 0104 	sub.w	r1, r1, r4
    e834:	f020 0003 	bic.w	r0, r0, #3
    e838:	07e4      	lsls	r4, r4, #31
    e83a:	f850 2b04 	ldr.w	r2, [r0], #4
    e83e:	d006      	beq.n	e84e <strcmp+0x1a6>
    e840:	d20f      	bcs.n	e862 <strcmp+0x1ba>
    e842:	788b      	ldrb	r3, [r1, #2]
    e844:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
    e848:	1ae4      	subs	r4, r4, r3
    e84a:	d106      	bne.n	e85a <strcmp+0x1b2>
    e84c:	b12b      	cbz	r3, e85a <strcmp+0x1b2>
    e84e:	78cb      	ldrb	r3, [r1, #3]
    e850:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
    e854:	1ae4      	subs	r4, r4, r3
    e856:	d100      	bne.n	e85a <strcmp+0x1b2>
    e858:	b91b      	cbnz	r3, e862 <strcmp+0x1ba>
    e85a:	4620      	mov	r0, r4
    e85c:	f85d 4b10 	ldr.w	r4, [sp], #16
    e860:	4770      	bx	lr
    e862:	f101 0104 	add.w	r1, r1, #4
    e866:	f850 2b04 	ldr.w	r2, [r0], #4
    e86a:	07cc      	lsls	r4, r1, #31
    e86c:	f021 0103 	bic.w	r1, r1, #3
    e870:	f851 3b04 	ldr.w	r3, [r1], #4
    e874:	d848      	bhi.n	e908 <strcmp+0x260>
    e876:	d224      	bcs.n	e8c2 <strcmp+0x21a>
    e878:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
    e87c:	fa82 f54c 	uadd8	r5, r2, ip
    e880:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
    e884:	faa5 f58c 	sel	r5, r5, ip
    e888:	d10a      	bne.n	e8a0 <strcmp+0x1f8>
    e88a:	b965      	cbnz	r5, e8a6 <strcmp+0x1fe>
    e88c:	f851 3b04 	ldr.w	r3, [r1], #4
    e890:	ea84 0402 	eor.w	r4, r4, r2
    e894:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
    e898:	d10e      	bne.n	e8b8 <strcmp+0x210>
    e89a:	f850 2b04 	ldr.w	r2, [r0], #4
    e89e:	e7eb      	b.n	e878 <strcmp+0x1d0>
    e8a0:	ea4f 2313 	mov.w	r3, r3, lsr #8
    e8a4:	e055      	b.n	e952 <strcmp+0x2aa>
    e8a6:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
    e8aa:	d14d      	bne.n	e948 <strcmp+0x2a0>
    e8ac:	7808      	ldrb	r0, [r1, #0]
    e8ae:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    e8b2:	f1c0 0000 	rsb	r0, r0, #0
    e8b6:	4770      	bx	lr
    e8b8:	ea4f 6212 	mov.w	r2, r2, lsr #24
    e8bc:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    e8c0:	e047      	b.n	e952 <strcmp+0x2aa>
    e8c2:	ea02 441c 	and.w	r4, r2, ip, lsr #16
    e8c6:	fa82 f54c 	uadd8	r5, r2, ip
    e8ca:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
    e8ce:	faa5 f58c 	sel	r5, r5, ip
    e8d2:	d10a      	bne.n	e8ea <strcmp+0x242>
    e8d4:	b965      	cbnz	r5, e8f0 <strcmp+0x248>
    e8d6:	f851 3b04 	ldr.w	r3, [r1], #4
    e8da:	ea84 0402 	eor.w	r4, r4, r2
    e8de:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
    e8e2:	d10c      	bne.n	e8fe <strcmp+0x256>
    e8e4:	f850 2b04 	ldr.w	r2, [r0], #4
    e8e8:	e7eb      	b.n	e8c2 <strcmp+0x21a>
    e8ea:	ea4f 4313 	mov.w	r3, r3, lsr #16
    e8ee:	e030      	b.n	e952 <strcmp+0x2aa>
    e8f0:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
    e8f4:	d128      	bne.n	e948 <strcmp+0x2a0>
    e8f6:	880b      	ldrh	r3, [r1, #0]
    e8f8:	ea4f 4212 	mov.w	r2, r2, lsr #16
    e8fc:	e029      	b.n	e952 <strcmp+0x2aa>
    e8fe:	ea4f 4212 	mov.w	r2, r2, lsr #16
    e902:	ea03 431c 	and.w	r3, r3, ip, lsr #16
    e906:	e024      	b.n	e952 <strcmp+0x2aa>
    e908:	f002 04ff 	and.w	r4, r2, #255	; 0xff
    e90c:	fa82 f54c 	uadd8	r5, r2, ip
    e910:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
    e914:	faa5 f58c 	sel	r5, r5, ip
    e918:	d10a      	bne.n	e930 <strcmp+0x288>
    e91a:	b965      	cbnz	r5, e936 <strcmp+0x28e>
    e91c:	f851 3b04 	ldr.w	r3, [r1], #4
    e920:	ea84 0402 	eor.w	r4, r4, r2
    e924:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
    e928:	d109      	bne.n	e93e <strcmp+0x296>
    e92a:	f850 2b04 	ldr.w	r2, [r0], #4
    e92e:	e7eb      	b.n	e908 <strcmp+0x260>
    e930:	ea4f 6313 	mov.w	r3, r3, lsr #24
    e934:	e00d      	b.n	e952 <strcmp+0x2aa>
    e936:	f015 0fff 	tst.w	r5, #255	; 0xff
    e93a:	d105      	bne.n	e948 <strcmp+0x2a0>
    e93c:	680b      	ldr	r3, [r1, #0]
    e93e:	ea4f 2212 	mov.w	r2, r2, lsr #8
    e942:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    e946:	e004      	b.n	e952 <strcmp+0x2aa>
    e948:	f04f 0000 	mov.w	r0, #0
    e94c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    e950:	4770      	bx	lr
    e952:	ba12      	rev	r2, r2
    e954:	ba1b      	rev	r3, r3
    e956:	fa82 f44c 	uadd8	r4, r2, ip
    e95a:	ea82 0403 	eor.w	r4, r2, r3
    e95e:	faa4 f58c 	sel	r5, r4, ip
    e962:	fab5 f485 	clz	r4, r5
    e966:	fa02 f204 	lsl.w	r2, r2, r4
    e96a:	fa03 f304 	lsl.w	r3, r3, r4
    e96e:	ea4f 6012 	mov.w	r0, r2, lsr #24
    e972:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    e976:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
    e97a:	4770      	bx	lr

0000e97c <strcpy>:
    e97c:	ea80 0201 	eor.w	r2, r0, r1
    e980:	4684      	mov	ip, r0
    e982:	f012 0f03 	tst.w	r2, #3
    e986:	d14f      	bne.n	ea28 <strcpy+0xac>
    e988:	f011 0f03 	tst.w	r1, #3
    e98c:	d132      	bne.n	e9f4 <strcpy+0x78>
    e98e:	f84d 4d04 	str.w	r4, [sp, #-4]!
    e992:	f011 0f04 	tst.w	r1, #4
    e996:	f851 3b04 	ldr.w	r3, [r1], #4
    e99a:	d00b      	beq.n	e9b4 <strcpy+0x38>
    e99c:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    e9a0:	439a      	bics	r2, r3
    e9a2:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    e9a6:	bf04      	itt	eq
    e9a8:	f84c 3b04 	streq.w	r3, [ip], #4
    e9ac:	f851 3b04 	ldreq.w	r3, [r1], #4
    e9b0:	d116      	bne.n	e9e0 <strcpy+0x64>
    e9b2:	bf00      	nop
    e9b4:	f851 4b04 	ldr.w	r4, [r1], #4
    e9b8:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    e9bc:	439a      	bics	r2, r3
    e9be:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    e9c2:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
    e9c6:	d10b      	bne.n	e9e0 <strcpy+0x64>
    e9c8:	f84c 3b04 	str.w	r3, [ip], #4
    e9cc:	43a2      	bics	r2, r4
    e9ce:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    e9d2:	bf04      	itt	eq
    e9d4:	f851 3b04 	ldreq.w	r3, [r1], #4
    e9d8:	f84c 4b04 	streq.w	r4, [ip], #4
    e9dc:	d0ea      	beq.n	e9b4 <strcpy+0x38>
    e9de:	4623      	mov	r3, r4
    e9e0:	f80c 3b01 	strb.w	r3, [ip], #1
    e9e4:	f013 0fff 	tst.w	r3, #255	; 0xff
    e9e8:	ea4f 2333 	mov.w	r3, r3, ror #8
    e9ec:	d1f8      	bne.n	e9e0 <strcpy+0x64>
    e9ee:	f85d 4b04 	ldr.w	r4, [sp], #4
    e9f2:	4770      	bx	lr
    e9f4:	f011 0f01 	tst.w	r1, #1
    e9f8:	d006      	beq.n	ea08 <strcpy+0x8c>
    e9fa:	f811 2b01 	ldrb.w	r2, [r1], #1
    e9fe:	f80c 2b01 	strb.w	r2, [ip], #1
    ea02:	2a00      	cmp	r2, #0
    ea04:	bf08      	it	eq
    ea06:	4770      	bxeq	lr
    ea08:	f011 0f02 	tst.w	r1, #2
    ea0c:	d0bf      	beq.n	e98e <strcpy+0x12>
    ea0e:	f831 2b02 	ldrh.w	r2, [r1], #2
    ea12:	f012 0fff 	tst.w	r2, #255	; 0xff
    ea16:	bf16      	itet	ne
    ea18:	f82c 2b02 	strhne.w	r2, [ip], #2
    ea1c:	f88c 2000 	strbeq.w	r2, [ip]
    ea20:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
    ea24:	d1b3      	bne.n	e98e <strcpy+0x12>
    ea26:	4770      	bx	lr
    ea28:	f811 2b01 	ldrb.w	r2, [r1], #1
    ea2c:	f80c 2b01 	strb.w	r2, [ip], #1
    ea30:	2a00      	cmp	r2, #0
    ea32:	d1f9      	bne.n	ea28 <strcpy+0xac>
    ea34:	4770      	bx	lr
    ea36:	bf00      	nop
    ea38:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff
    ea3c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

0000ea40 <strlen>:
    ea40:	f890 f000 	pld	[r0]
    ea44:	e96d 4502 	strd	r4, r5, [sp, #-8]!
    ea48:	f020 0107 	bic.w	r1, r0, #7
    ea4c:	f06f 0c00 	mvn.w	ip, #0
    ea50:	f010 0407 	ands.w	r4, r0, #7
    ea54:	f891 f020 	pld	[r1, #32]
    ea58:	f040 8049 	bne.w	eaee <strlen+0xae>
    ea5c:	f04f 0400 	mov.w	r4, #0
    ea60:	f06f 0007 	mvn.w	r0, #7
    ea64:	e9d1 2300 	ldrd	r2, r3, [r1]
    ea68:	f891 f040 	pld	[r1, #64]	; 0x40
    ea6c:	f100 0008 	add.w	r0, r0, #8
    ea70:	fa82 f24c 	uadd8	r2, r2, ip
    ea74:	faa4 f28c 	sel	r2, r4, ip
    ea78:	fa83 f34c 	uadd8	r3, r3, ip
    ea7c:	faa2 f38c 	sel	r3, r2, ip
    ea80:	bb4b      	cbnz	r3, ead6 <strlen+0x96>
    ea82:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
    ea86:	fa82 f24c 	uadd8	r2, r2, ip
    ea8a:	f100 0008 	add.w	r0, r0, #8
    ea8e:	faa4 f28c 	sel	r2, r4, ip
    ea92:	fa83 f34c 	uadd8	r3, r3, ip
    ea96:	faa2 f38c 	sel	r3, r2, ip
    ea9a:	b9e3      	cbnz	r3, ead6 <strlen+0x96>
    ea9c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
    eaa0:	fa82 f24c 	uadd8	r2, r2, ip
    eaa4:	f100 0008 	add.w	r0, r0, #8
    eaa8:	faa4 f28c 	sel	r2, r4, ip
    eaac:	fa83 f34c 	uadd8	r3, r3, ip
    eab0:	faa2 f38c 	sel	r3, r2, ip
    eab4:	b97b      	cbnz	r3, ead6 <strlen+0x96>
    eab6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
    eaba:	f101 0120 	add.w	r1, r1, #32
    eabe:	fa82 f24c 	uadd8	r2, r2, ip
    eac2:	f100 0008 	add.w	r0, r0, #8
    eac6:	faa4 f28c 	sel	r2, r4, ip
    eaca:	fa83 f34c 	uadd8	r3, r3, ip
    eace:	faa2 f38c 	sel	r3, r2, ip
    ead2:	2b00      	cmp	r3, #0
    ead4:	d0c6      	beq.n	ea64 <strlen+0x24>
    ead6:	2a00      	cmp	r2, #0
    ead8:	bf04      	itt	eq
    eada:	3004      	addeq	r0, #4
    eadc:	461a      	moveq	r2, r3
    eade:	ba12      	rev	r2, r2
    eae0:	fab2 f282 	clz	r2, r2
    eae4:	e8fd 4502 	ldrd	r4, r5, [sp], #8
    eae8:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
    eaec:	4770      	bx	lr
    eaee:	e9d1 2300 	ldrd	r2, r3, [r1]
    eaf2:	f004 0503 	and.w	r5, r4, #3
    eaf6:	f1c4 0000 	rsb	r0, r4, #0
    eafa:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    eafe:	f014 0f04 	tst.w	r4, #4
    eb02:	f891 f040 	pld	[r1, #64]	; 0x40
    eb06:	fa0c f505 	lsl.w	r5, ip, r5
    eb0a:	ea62 0205 	orn	r2, r2, r5
    eb0e:	bf1c      	itt	ne
    eb10:	ea63 0305 	ornne	r3, r3, r5
    eb14:	4662      	movne	r2, ip
    eb16:	f04f 0400 	mov.w	r4, #0
    eb1a:	e7a9      	b.n	ea70 <strlen+0x30>

0000eb1c <strncpy>:
    eb1c:	ea40 0301 	orr.w	r3, r0, r1
    eb20:	079b      	lsls	r3, r3, #30
    eb22:	b470      	push	{r4, r5, r6}
    eb24:	d12b      	bne.n	eb7e <strncpy+0x62>
    eb26:	2a03      	cmp	r2, #3
    eb28:	d929      	bls.n	eb7e <strncpy+0x62>
    eb2a:	460c      	mov	r4, r1
    eb2c:	4603      	mov	r3, r0
    eb2e:	4621      	mov	r1, r4
    eb30:	f854 6b04 	ldr.w	r6, [r4], #4
    eb34:	f1a6 3501 	sub.w	r5, r6, #16843009	; 0x1010101
    eb38:	ea25 0506 	bic.w	r5, r5, r6
    eb3c:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
    eb40:	d106      	bne.n	eb50 <strncpy+0x34>
    eb42:	3a04      	subs	r2, #4
    eb44:	2a03      	cmp	r2, #3
    eb46:	f843 6b04 	str.w	r6, [r3], #4
    eb4a:	4621      	mov	r1, r4
    eb4c:	d8ef      	bhi.n	eb2e <strncpy+0x12>
    eb4e:	b1a2      	cbz	r2, eb7a <strncpy+0x5e>
    eb50:	780c      	ldrb	r4, [r1, #0]
    eb52:	701c      	strb	r4, [r3, #0]
    eb54:	3a01      	subs	r2, #1
    eb56:	3301      	adds	r3, #1
    eb58:	3101      	adds	r1, #1
    eb5a:	b13c      	cbz	r4, eb6c <strncpy+0x50>
    eb5c:	b16a      	cbz	r2, eb7a <strncpy+0x5e>
    eb5e:	f811 4b01 	ldrb.w	r4, [r1], #1
    eb62:	f803 4b01 	strb.w	r4, [r3], #1
    eb66:	3a01      	subs	r2, #1
    eb68:	2c00      	cmp	r4, #0
    eb6a:	d1f7      	bne.n	eb5c <strncpy+0x40>
    eb6c:	b12a      	cbz	r2, eb7a <strncpy+0x5e>
    eb6e:	441a      	add	r2, r3
    eb70:	2100      	movs	r1, #0
    eb72:	f803 1b01 	strb.w	r1, [r3], #1
    eb76:	429a      	cmp	r2, r3
    eb78:	d1fb      	bne.n	eb72 <strncpy+0x56>
    eb7a:	bc70      	pop	{r4, r5, r6}
    eb7c:	4770      	bx	lr
    eb7e:	4603      	mov	r3, r0
    eb80:	e7e5      	b.n	eb4e <strncpy+0x32>
    eb82:	bf00      	nop

0000eb84 <__register_exitproc>:
    eb84:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    eb88:	4c25      	ldr	r4, [pc, #148]	; (ec20 <__register_exitproc+0x9c>)
    eb8a:	6825      	ldr	r5, [r4, #0]
    eb8c:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
    eb90:	4606      	mov	r6, r0
    eb92:	4688      	mov	r8, r1
    eb94:	4692      	mov	sl, r2
    eb96:	4699      	mov	r9, r3
    eb98:	b3c4      	cbz	r4, ec0c <__register_exitproc+0x88>
    eb9a:	6860      	ldr	r0, [r4, #4]
    eb9c:	281f      	cmp	r0, #31
    eb9e:	dc17      	bgt.n	ebd0 <__register_exitproc+0x4c>
    eba0:	1c43      	adds	r3, r0, #1
    eba2:	b176      	cbz	r6, ebc2 <__register_exitproc+0x3e>
    eba4:	eb04 0580 	add.w	r5, r4, r0, lsl #2
    eba8:	2201      	movs	r2, #1
    ebaa:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
    ebae:	f8d4 1188 	ldr.w	r1, [r4, #392]	; 0x188
    ebb2:	4082      	lsls	r2, r0
    ebb4:	4311      	orrs	r1, r2
    ebb6:	2e02      	cmp	r6, #2
    ebb8:	f8c4 1188 	str.w	r1, [r4, #392]	; 0x188
    ebbc:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
    ebc0:	d01e      	beq.n	ec00 <__register_exitproc+0x7c>
    ebc2:	3002      	adds	r0, #2
    ebc4:	6063      	str	r3, [r4, #4]
    ebc6:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
    ebca:	2000      	movs	r0, #0
    ebcc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ebd0:	4b14      	ldr	r3, [pc, #80]	; (ec24 <__register_exitproc+0xa0>)
    ebd2:	b303      	cbz	r3, ec16 <__register_exitproc+0x92>
    ebd4:	f44f 70c8 	mov.w	r0, #400	; 0x190
    ebd8:	f7fe ffd0 	bl	db7c <malloc>
    ebdc:	4604      	mov	r4, r0
    ebde:	b1d0      	cbz	r0, ec16 <__register_exitproc+0x92>
    ebe0:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
    ebe4:	2700      	movs	r7, #0
    ebe6:	e880 0088 	stmia.w	r0, {r3, r7}
    ebea:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    ebee:	4638      	mov	r0, r7
    ebf0:	2301      	movs	r3, #1
    ebf2:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
    ebf6:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
    ebfa:	2e00      	cmp	r6, #0
    ebfc:	d0e1      	beq.n	ebc2 <__register_exitproc+0x3e>
    ebfe:	e7d1      	b.n	eba4 <__register_exitproc+0x20>
    ec00:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
    ec04:	430a      	orrs	r2, r1
    ec06:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
    ec0a:	e7da      	b.n	ebc2 <__register_exitproc+0x3e>
    ec0c:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
    ec10:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    ec14:	e7c1      	b.n	eb9a <__register_exitproc+0x16>
    ec16:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    ec1a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ec1e:	bf00      	nop
    ec20:	00021ef0 	.word	0x00021ef0
    ec24:	0000db7d 	.word	0x0000db7d

0000ec28 <register_fini>:
    ec28:	4b02      	ldr	r3, [pc, #8]	; (ec34 <register_fini+0xc>)
    ec2a:	b113      	cbz	r3, ec32 <register_fini+0xa>
    ec2c:	4802      	ldr	r0, [pc, #8]	; (ec38 <register_fini+0x10>)
    ec2e:	f000 b805 	b.w	ec3c <atexit>
    ec32:	4770      	bx	lr
    ec34:	00000000 	.word	0x00000000
    ec38:	0000ed35 	.word	0x0000ed35

0000ec3c <atexit>:
    ec3c:	2300      	movs	r3, #0
    ec3e:	4601      	mov	r1, r0
    ec40:	461a      	mov	r2, r3
    ec42:	4618      	mov	r0, r3
    ec44:	f7ff bf9e 	b.w	eb84 <__register_exitproc>

0000ec48 <fcvtbuf>:
    ec48:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ec4c:	b088      	sub	sp, #32
    ec4e:	4c36      	ldr	r4, [pc, #216]	; (ed28 <fcvtbuf+0xe0>)
    ec50:	9d11      	ldr	r5, [sp, #68]	; 0x44
    ec52:	f8d4 9000 	ldr.w	r9, [r4]
    ec56:	4606      	mov	r6, r0
    ec58:	460f      	mov	r7, r1
    ec5a:	4614      	mov	r4, r2
    ec5c:	4698      	mov	r8, r3
    ec5e:	2d00      	cmp	r5, #0
    ec60:	d043      	beq.n	ecea <fcvtbuf+0xa2>
    ec62:	2200      	movs	r2, #0
    ec64:	4b31      	ldr	r3, [pc, #196]	; (ed2c <fcvtbuf+0xe4>)
    ec66:	4630      	mov	r0, r6
    ec68:	4639      	mov	r1, r7
    ec6a:	f7fe f993 	bl	cf94 <__aeabi_dcmplt>
    ec6e:	bb80      	cbnz	r0, ecd2 <fcvtbuf+0x8a>
    ec70:	f10d 0e1c 	add.w	lr, sp, #28
    ec74:	2103      	movs	r1, #3
    ec76:	9b10      	ldr	r3, [sp, #64]	; 0x40
    ec78:	9303      	str	r3, [sp, #12]
    ec7a:	9100      	str	r1, [sp, #0]
    ec7c:	463b      	mov	r3, r7
    ec7e:	f8cd 8008 	str.w	r8, [sp, #8]
    ec82:	9401      	str	r4, [sp, #4]
    ec84:	4632      	mov	r2, r6
    ec86:	4648      	mov	r0, r9
    ec88:	f8cd e010 	str.w	lr, [sp, #16]
    ec8c:	f000 fd70 	bl	f770 <_dtoa_r>
    ec90:	9b07      	ldr	r3, [sp, #28]
    ec92:	f8d8 1000 	ldr.w	r1, [r8]
    ec96:	4298      	cmp	r0, r3
    ec98:	f1c1 0100 	rsb	r1, r1, #0
    ec9c:	d22e      	bcs.n	ecfc <fcvtbuf+0xb4>
    ec9e:	1b49      	subs	r1, r1, r5
    eca0:	462b      	mov	r3, r5
    eca2:	f810 2b01 	ldrb.w	r2, [r0], #1
    eca6:	f803 2b01 	strb.w	r2, [r3], #1
    ecaa:	9a07      	ldr	r2, [sp, #28]
    ecac:	4282      	cmp	r2, r0
    ecae:	eb03 0601 	add.w	r6, r3, r1
    ecb2:	d8f6      	bhi.n	eca2 <fcvtbuf+0x5a>
    ecb4:	42b4      	cmp	r4, r6
    ecb6:	dd24      	ble.n	ed02 <fcvtbuf+0xba>
    ecb8:	1ba2      	subs	r2, r4, r6
    ecba:	441a      	add	r2, r3
    ecbc:	2130      	movs	r1, #48	; 0x30
    ecbe:	f803 1b01 	strb.w	r1, [r3], #1
    ecc2:	429a      	cmp	r2, r3
    ecc4:	d1fb      	bne.n	ecbe <fcvtbuf+0x76>
    ecc6:	2300      	movs	r3, #0
    ecc8:	7013      	strb	r3, [r2, #0]
    ecca:	4628      	mov	r0, r5
    eccc:	b008      	add	sp, #32
    ecce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ecd2:	2200      	movs	r2, #0
    ecd4:	4b16      	ldr	r3, [pc, #88]	; (ed30 <fcvtbuf+0xe8>)
    ecd6:	4630      	mov	r0, r6
    ecd8:	4639      	mov	r1, r7
    ecda:	f7fe f979 	bl	cfd0 <__aeabi_dcmpgt>
    ecde:	2800      	cmp	r0, #0
    ece0:	d0c6      	beq.n	ec70 <fcvtbuf+0x28>
    ece2:	f10d 0e1c 	add.w	lr, sp, #28
    ece6:	2102      	movs	r1, #2
    ece8:	e7c5      	b.n	ec76 <fcvtbuf+0x2e>
    ecea:	f8d9 2050 	ldr.w	r2, [r9, #80]	; 0x50
    ecee:	f104 0323 	add.w	r3, r4, #35	; 0x23
    ecf2:	429a      	cmp	r2, r3
    ecf4:	dd07      	ble.n	ed06 <fcvtbuf+0xbe>
    ecf6:	f8d9 5054 	ldr.w	r5, [r9, #84]	; 0x54
    ecfa:	e7b2      	b.n	ec62 <fcvtbuf+0x1a>
    ecfc:	460e      	mov	r6, r1
    ecfe:	462b      	mov	r3, r5
    ed00:	e7d8      	b.n	ecb4 <fcvtbuf+0x6c>
    ed02:	461a      	mov	r2, r3
    ed04:	e7df      	b.n	ecc6 <fcvtbuf+0x7e>
    ed06:	f104 0a24 	add.w	sl, r4, #36	; 0x24
    ed0a:	4652      	mov	r2, sl
    ed0c:	f8d9 1054 	ldr.w	r1, [r9, #84]	; 0x54
    ed10:	4648      	mov	r0, r9
    ed12:	f7ff fab9 	bl	e288 <_realloc_r>
    ed16:	4605      	mov	r5, r0
    ed18:	2800      	cmp	r0, #0
    ed1a:	d0d6      	beq.n	ecca <fcvtbuf+0x82>
    ed1c:	f8c9 a050 	str.w	sl, [r9, #80]	; 0x50
    ed20:	f8c9 0054 	str.w	r0, [r9, #84]	; 0x54
    ed24:	e79d      	b.n	ec62 <fcvtbuf+0x1a>
    ed26:	bf00      	nop
    ed28:	1fffc0f8 	.word	0x1fffc0f8
    ed2c:	3ff00000 	.word	0x3ff00000
    ed30:	bff00000 	.word	0xbff00000

0000ed34 <__libc_fini_array>:
    ed34:	b538      	push	{r3, r4, r5, lr}
    ed36:	4d07      	ldr	r5, [pc, #28]	; (ed54 <__libc_fini_array+0x20>)
    ed38:	4c07      	ldr	r4, [pc, #28]	; (ed58 <__libc_fini_array+0x24>)
    ed3a:	1b2c      	subs	r4, r5, r4
    ed3c:	10a4      	asrs	r4, r4, #2
    ed3e:	d005      	beq.n	ed4c <__libc_fini_array+0x18>
    ed40:	3c01      	subs	r4, #1
    ed42:	f855 3d04 	ldr.w	r3, [r5, #-4]!
    ed46:	4798      	blx	r3
    ed48:	2c00      	cmp	r4, #0
    ed4a:	d1f9      	bne.n	ed40 <__libc_fini_array+0xc>
    ed4c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ed50:	f013 b986 	b.w	22060 <__init_array_end>
	...

0000ed5c <_malloc_trim_r>:
    ed5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ed5e:	4f23      	ldr	r7, [pc, #140]	; (edec <_malloc_trim_r+0x90>)
    ed60:	460c      	mov	r4, r1
    ed62:	4606      	mov	r6, r0
    ed64:	f7ff fa84 	bl	e270 <__malloc_lock>
    ed68:	68bb      	ldr	r3, [r7, #8]
    ed6a:	685d      	ldr	r5, [r3, #4]
    ed6c:	f025 0503 	bic.w	r5, r5, #3
    ed70:	1b29      	subs	r1, r5, r4
    ed72:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
    ed76:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
    ed7a:	f021 010f 	bic.w	r1, r1, #15
    ed7e:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
    ed82:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    ed86:	db07      	blt.n	ed98 <_malloc_trim_r+0x3c>
    ed88:	2100      	movs	r1, #0
    ed8a:	4630      	mov	r0, r6
    ed8c:	f7ff fc6c 	bl	e668 <_sbrk_r>
    ed90:	68bb      	ldr	r3, [r7, #8]
    ed92:	442b      	add	r3, r5
    ed94:	4298      	cmp	r0, r3
    ed96:	d004      	beq.n	eda2 <_malloc_trim_r+0x46>
    ed98:	4630      	mov	r0, r6
    ed9a:	f7ff fa6b 	bl	e274 <__malloc_unlock>
    ed9e:	2000      	movs	r0, #0
    eda0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    eda2:	4261      	negs	r1, r4
    eda4:	4630      	mov	r0, r6
    eda6:	f7ff fc5f 	bl	e668 <_sbrk_r>
    edaa:	3001      	adds	r0, #1
    edac:	d00d      	beq.n	edca <_malloc_trim_r+0x6e>
    edae:	4b10      	ldr	r3, [pc, #64]	; (edf0 <_malloc_trim_r+0x94>)
    edb0:	68ba      	ldr	r2, [r7, #8]
    edb2:	6819      	ldr	r1, [r3, #0]
    edb4:	1b2d      	subs	r5, r5, r4
    edb6:	f045 0501 	orr.w	r5, r5, #1
    edba:	4630      	mov	r0, r6
    edbc:	1b09      	subs	r1, r1, r4
    edbe:	6055      	str	r5, [r2, #4]
    edc0:	6019      	str	r1, [r3, #0]
    edc2:	f7ff fa57 	bl	e274 <__malloc_unlock>
    edc6:	2001      	movs	r0, #1
    edc8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    edca:	2100      	movs	r1, #0
    edcc:	4630      	mov	r0, r6
    edce:	f7ff fc4b 	bl	e668 <_sbrk_r>
    edd2:	68ba      	ldr	r2, [r7, #8]
    edd4:	1a83      	subs	r3, r0, r2
    edd6:	2b0f      	cmp	r3, #15
    edd8:	ddde      	ble.n	ed98 <_malloc_trim_r+0x3c>
    edda:	4c06      	ldr	r4, [pc, #24]	; (edf4 <_malloc_trim_r+0x98>)
    eddc:	4904      	ldr	r1, [pc, #16]	; (edf0 <_malloc_trim_r+0x94>)
    edde:	6824      	ldr	r4, [r4, #0]
    ede0:	f043 0301 	orr.w	r3, r3, #1
    ede4:	1b00      	subs	r0, r0, r4
    ede6:	6053      	str	r3, [r2, #4]
    ede8:	6008      	str	r0, [r1, #0]
    edea:	e7d5      	b.n	ed98 <_malloc_trim_r+0x3c>
    edec:	1fffc0fc 	.word	0x1fffc0fc
    edf0:	20004900 	.word	0x20004900
    edf4:	1fffc508 	.word	0x1fffc508

0000edf8 <_free_r>:
    edf8:	2900      	cmp	r1, #0
    edfa:	d045      	beq.n	ee88 <_free_r+0x90>
    edfc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ee00:	460d      	mov	r5, r1
    ee02:	4680      	mov	r8, r0
    ee04:	f7ff fa34 	bl	e270 <__malloc_lock>
    ee08:	f855 7c04 	ldr.w	r7, [r5, #-4]
    ee0c:	496a      	ldr	r1, [pc, #424]	; (efb8 <_free_r+0x1c0>)
    ee0e:	f027 0301 	bic.w	r3, r7, #1
    ee12:	f1a5 0408 	sub.w	r4, r5, #8
    ee16:	18e2      	adds	r2, r4, r3
    ee18:	688e      	ldr	r6, [r1, #8]
    ee1a:	6850      	ldr	r0, [r2, #4]
    ee1c:	42b2      	cmp	r2, r6
    ee1e:	f020 0003 	bic.w	r0, r0, #3
    ee22:	d062      	beq.n	eeea <_free_r+0xf2>
    ee24:	07fe      	lsls	r6, r7, #31
    ee26:	6050      	str	r0, [r2, #4]
    ee28:	d40b      	bmi.n	ee42 <_free_r+0x4a>
    ee2a:	f855 7c08 	ldr.w	r7, [r5, #-8]
    ee2e:	1be4      	subs	r4, r4, r7
    ee30:	f101 0e08 	add.w	lr, r1, #8
    ee34:	68a5      	ldr	r5, [r4, #8]
    ee36:	4575      	cmp	r5, lr
    ee38:	443b      	add	r3, r7
    ee3a:	d06f      	beq.n	ef1c <_free_r+0x124>
    ee3c:	68e7      	ldr	r7, [r4, #12]
    ee3e:	60ef      	str	r7, [r5, #12]
    ee40:	60bd      	str	r5, [r7, #8]
    ee42:	1815      	adds	r5, r2, r0
    ee44:	686d      	ldr	r5, [r5, #4]
    ee46:	07ed      	lsls	r5, r5, #31
    ee48:	d542      	bpl.n	eed0 <_free_r+0xd8>
    ee4a:	f043 0201 	orr.w	r2, r3, #1
    ee4e:	6062      	str	r2, [r4, #4]
    ee50:	50e3      	str	r3, [r4, r3]
    ee52:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    ee56:	d218      	bcs.n	ee8a <_free_r+0x92>
    ee58:	08db      	lsrs	r3, r3, #3
    ee5a:	1c5a      	adds	r2, r3, #1
    ee5c:	684d      	ldr	r5, [r1, #4]
    ee5e:	f851 7032 	ldr.w	r7, [r1, r2, lsl #3]
    ee62:	60a7      	str	r7, [r4, #8]
    ee64:	2001      	movs	r0, #1
    ee66:	109b      	asrs	r3, r3, #2
    ee68:	fa00 f303 	lsl.w	r3, r0, r3
    ee6c:	eb01 00c2 	add.w	r0, r1, r2, lsl #3
    ee70:	431d      	orrs	r5, r3
    ee72:	3808      	subs	r0, #8
    ee74:	60e0      	str	r0, [r4, #12]
    ee76:	604d      	str	r5, [r1, #4]
    ee78:	f841 4032 	str.w	r4, [r1, r2, lsl #3]
    ee7c:	60fc      	str	r4, [r7, #12]
    ee7e:	4640      	mov	r0, r8
    ee80:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    ee84:	f7ff b9f6 	b.w	e274 <__malloc_unlock>
    ee88:	4770      	bx	lr
    ee8a:	0a5a      	lsrs	r2, r3, #9
    ee8c:	2a04      	cmp	r2, #4
    ee8e:	d853      	bhi.n	ef38 <_free_r+0x140>
    ee90:	099a      	lsrs	r2, r3, #6
    ee92:	f102 0739 	add.w	r7, r2, #57	; 0x39
    ee96:	007f      	lsls	r7, r7, #1
    ee98:	f102 0538 	add.w	r5, r2, #56	; 0x38
    ee9c:	eb01 0087 	add.w	r0, r1, r7, lsl #2
    eea0:	f851 2027 	ldr.w	r2, [r1, r7, lsl #2]
    eea4:	4944      	ldr	r1, [pc, #272]	; (efb8 <_free_r+0x1c0>)
    eea6:	3808      	subs	r0, #8
    eea8:	4290      	cmp	r0, r2
    eeaa:	d04d      	beq.n	ef48 <_free_r+0x150>
    eeac:	6851      	ldr	r1, [r2, #4]
    eeae:	f021 0103 	bic.w	r1, r1, #3
    eeb2:	428b      	cmp	r3, r1
    eeb4:	d202      	bcs.n	eebc <_free_r+0xc4>
    eeb6:	6892      	ldr	r2, [r2, #8]
    eeb8:	4290      	cmp	r0, r2
    eeba:	d1f7      	bne.n	eeac <_free_r+0xb4>
    eebc:	68d0      	ldr	r0, [r2, #12]
    eebe:	60e0      	str	r0, [r4, #12]
    eec0:	60a2      	str	r2, [r4, #8]
    eec2:	6084      	str	r4, [r0, #8]
    eec4:	60d4      	str	r4, [r2, #12]
    eec6:	4640      	mov	r0, r8
    eec8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    eecc:	f7ff b9d2 	b.w	e274 <__malloc_unlock>
    eed0:	6895      	ldr	r5, [r2, #8]
    eed2:	4f3a      	ldr	r7, [pc, #232]	; (efbc <_free_r+0x1c4>)
    eed4:	42bd      	cmp	r5, r7
    eed6:	4403      	add	r3, r0
    eed8:	d03f      	beq.n	ef5a <_free_r+0x162>
    eeda:	68d0      	ldr	r0, [r2, #12]
    eedc:	60e8      	str	r0, [r5, #12]
    eede:	f043 0201 	orr.w	r2, r3, #1
    eee2:	6085      	str	r5, [r0, #8]
    eee4:	6062      	str	r2, [r4, #4]
    eee6:	50e3      	str	r3, [r4, r3]
    eee8:	e7b3      	b.n	ee52 <_free_r+0x5a>
    eeea:	07ff      	lsls	r7, r7, #31
    eeec:	4403      	add	r3, r0
    eeee:	d407      	bmi.n	ef00 <_free_r+0x108>
    eef0:	f855 2c08 	ldr.w	r2, [r5, #-8]
    eef4:	1aa4      	subs	r4, r4, r2
    eef6:	4413      	add	r3, r2
    eef8:	68a0      	ldr	r0, [r4, #8]
    eefa:	68e2      	ldr	r2, [r4, #12]
    eefc:	60c2      	str	r2, [r0, #12]
    eefe:	6090      	str	r0, [r2, #8]
    ef00:	4a2f      	ldr	r2, [pc, #188]	; (efc0 <_free_r+0x1c8>)
    ef02:	6812      	ldr	r2, [r2, #0]
    ef04:	f043 0001 	orr.w	r0, r3, #1
    ef08:	4293      	cmp	r3, r2
    ef0a:	6060      	str	r0, [r4, #4]
    ef0c:	608c      	str	r4, [r1, #8]
    ef0e:	d3b6      	bcc.n	ee7e <_free_r+0x86>
    ef10:	4b2c      	ldr	r3, [pc, #176]	; (efc4 <_free_r+0x1cc>)
    ef12:	4640      	mov	r0, r8
    ef14:	6819      	ldr	r1, [r3, #0]
    ef16:	f7ff ff21 	bl	ed5c <_malloc_trim_r>
    ef1a:	e7b0      	b.n	ee7e <_free_r+0x86>
    ef1c:	1811      	adds	r1, r2, r0
    ef1e:	6849      	ldr	r1, [r1, #4]
    ef20:	07c9      	lsls	r1, r1, #31
    ef22:	d444      	bmi.n	efae <_free_r+0x1b6>
    ef24:	6891      	ldr	r1, [r2, #8]
    ef26:	68d2      	ldr	r2, [r2, #12]
    ef28:	60ca      	str	r2, [r1, #12]
    ef2a:	4403      	add	r3, r0
    ef2c:	f043 0001 	orr.w	r0, r3, #1
    ef30:	6091      	str	r1, [r2, #8]
    ef32:	6060      	str	r0, [r4, #4]
    ef34:	50e3      	str	r3, [r4, r3]
    ef36:	e7a2      	b.n	ee7e <_free_r+0x86>
    ef38:	2a14      	cmp	r2, #20
    ef3a:	d817      	bhi.n	ef6c <_free_r+0x174>
    ef3c:	f102 075c 	add.w	r7, r2, #92	; 0x5c
    ef40:	007f      	lsls	r7, r7, #1
    ef42:	f102 055b 	add.w	r5, r2, #91	; 0x5b
    ef46:	e7a9      	b.n	ee9c <_free_r+0xa4>
    ef48:	10aa      	asrs	r2, r5, #2
    ef4a:	684b      	ldr	r3, [r1, #4]
    ef4c:	2501      	movs	r5, #1
    ef4e:	fa05 f202 	lsl.w	r2, r5, r2
    ef52:	4313      	orrs	r3, r2
    ef54:	604b      	str	r3, [r1, #4]
    ef56:	4602      	mov	r2, r0
    ef58:	e7b1      	b.n	eebe <_free_r+0xc6>
    ef5a:	f043 0201 	orr.w	r2, r3, #1
    ef5e:	614c      	str	r4, [r1, #20]
    ef60:	610c      	str	r4, [r1, #16]
    ef62:	60e5      	str	r5, [r4, #12]
    ef64:	60a5      	str	r5, [r4, #8]
    ef66:	6062      	str	r2, [r4, #4]
    ef68:	50e3      	str	r3, [r4, r3]
    ef6a:	e788      	b.n	ee7e <_free_r+0x86>
    ef6c:	2a54      	cmp	r2, #84	; 0x54
    ef6e:	d806      	bhi.n	ef7e <_free_r+0x186>
    ef70:	0b1a      	lsrs	r2, r3, #12
    ef72:	f102 076f 	add.w	r7, r2, #111	; 0x6f
    ef76:	007f      	lsls	r7, r7, #1
    ef78:	f102 056e 	add.w	r5, r2, #110	; 0x6e
    ef7c:	e78e      	b.n	ee9c <_free_r+0xa4>
    ef7e:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    ef82:	d806      	bhi.n	ef92 <_free_r+0x19a>
    ef84:	0bda      	lsrs	r2, r3, #15
    ef86:	f102 0778 	add.w	r7, r2, #120	; 0x78
    ef8a:	007f      	lsls	r7, r7, #1
    ef8c:	f102 0577 	add.w	r5, r2, #119	; 0x77
    ef90:	e784      	b.n	ee9c <_free_r+0xa4>
    ef92:	f240 5054 	movw	r0, #1364	; 0x554
    ef96:	4282      	cmp	r2, r0
    ef98:	d806      	bhi.n	efa8 <_free_r+0x1b0>
    ef9a:	0c9a      	lsrs	r2, r3, #18
    ef9c:	f102 077d 	add.w	r7, r2, #125	; 0x7d
    efa0:	007f      	lsls	r7, r7, #1
    efa2:	f102 057c 	add.w	r5, r2, #124	; 0x7c
    efa6:	e779      	b.n	ee9c <_free_r+0xa4>
    efa8:	27fe      	movs	r7, #254	; 0xfe
    efaa:	257e      	movs	r5, #126	; 0x7e
    efac:	e776      	b.n	ee9c <_free_r+0xa4>
    efae:	f043 0201 	orr.w	r2, r3, #1
    efb2:	6062      	str	r2, [r4, #4]
    efb4:	50e3      	str	r3, [r4, r3]
    efb6:	e762      	b.n	ee7e <_free_r+0x86>
    efb8:	1fffc0fc 	.word	0x1fffc0fc
    efbc:	1fffc104 	.word	0x1fffc104
    efc0:	1fffc504 	.word	0x1fffc504
    efc4:	200048fc 	.word	0x200048fc

0000efc8 <_Balloc>:
    efc8:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    efca:	b570      	push	{r4, r5, r6, lr}
    efcc:	4605      	mov	r5, r0
    efce:	460c      	mov	r4, r1
    efd0:	b14b      	cbz	r3, efe6 <_Balloc+0x1e>
    efd2:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
    efd6:	b180      	cbz	r0, effa <_Balloc+0x32>
    efd8:	6802      	ldr	r2, [r0, #0]
    efda:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
    efde:	2300      	movs	r3, #0
    efe0:	6103      	str	r3, [r0, #16]
    efe2:	60c3      	str	r3, [r0, #12]
    efe4:	bd70      	pop	{r4, r5, r6, pc}
    efe6:	2221      	movs	r2, #33	; 0x21
    efe8:	2104      	movs	r1, #4
    efea:	f000 fafb 	bl	f5e4 <_calloc_r>
    efee:	64e8      	str	r0, [r5, #76]	; 0x4c
    eff0:	4603      	mov	r3, r0
    eff2:	2800      	cmp	r0, #0
    eff4:	d1ed      	bne.n	efd2 <_Balloc+0xa>
    eff6:	2000      	movs	r0, #0
    eff8:	bd70      	pop	{r4, r5, r6, pc}
    effa:	2101      	movs	r1, #1
    effc:	fa01 f604 	lsl.w	r6, r1, r4
    f000:	1d72      	adds	r2, r6, #5
    f002:	4628      	mov	r0, r5
    f004:	0092      	lsls	r2, r2, #2
    f006:	f000 faed 	bl	f5e4 <_calloc_r>
    f00a:	2800      	cmp	r0, #0
    f00c:	d0f3      	beq.n	eff6 <_Balloc+0x2e>
    f00e:	6044      	str	r4, [r0, #4]
    f010:	6086      	str	r6, [r0, #8]
    f012:	e7e4      	b.n	efde <_Balloc+0x16>

0000f014 <_Bfree>:
    f014:	b131      	cbz	r1, f024 <_Bfree+0x10>
    f016:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    f018:	684a      	ldr	r2, [r1, #4]
    f01a:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
    f01e:	6008      	str	r0, [r1, #0]
    f020:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    f024:	4770      	bx	lr
    f026:	bf00      	nop

0000f028 <__multadd>:
    f028:	b5f0      	push	{r4, r5, r6, r7, lr}
    f02a:	690c      	ldr	r4, [r1, #16]
    f02c:	b083      	sub	sp, #12
    f02e:	460d      	mov	r5, r1
    f030:	4606      	mov	r6, r0
    f032:	f101 0e14 	add.w	lr, r1, #20
    f036:	2700      	movs	r7, #0
    f038:	f8de 0000 	ldr.w	r0, [lr]
    f03c:	b281      	uxth	r1, r0
    f03e:	fb02 3101 	mla	r1, r2, r1, r3
    f042:	0c0b      	lsrs	r3, r1, #16
    f044:	0c00      	lsrs	r0, r0, #16
    f046:	fb02 3300 	mla	r3, r2, r0, r3
    f04a:	b289      	uxth	r1, r1
    f04c:	3701      	adds	r7, #1
    f04e:	eb01 4103 	add.w	r1, r1, r3, lsl #16
    f052:	42bc      	cmp	r4, r7
    f054:	f84e 1b04 	str.w	r1, [lr], #4
    f058:	ea4f 4313 	mov.w	r3, r3, lsr #16
    f05c:	dcec      	bgt.n	f038 <__multadd+0x10>
    f05e:	b13b      	cbz	r3, f070 <__multadd+0x48>
    f060:	68aa      	ldr	r2, [r5, #8]
    f062:	4294      	cmp	r4, r2
    f064:	da07      	bge.n	f076 <__multadd+0x4e>
    f066:	eb05 0284 	add.w	r2, r5, r4, lsl #2
    f06a:	3401      	adds	r4, #1
    f06c:	6153      	str	r3, [r2, #20]
    f06e:	612c      	str	r4, [r5, #16]
    f070:	4628      	mov	r0, r5
    f072:	b003      	add	sp, #12
    f074:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f076:	6869      	ldr	r1, [r5, #4]
    f078:	9301      	str	r3, [sp, #4]
    f07a:	3101      	adds	r1, #1
    f07c:	4630      	mov	r0, r6
    f07e:	f7ff ffa3 	bl	efc8 <_Balloc>
    f082:	692a      	ldr	r2, [r5, #16]
    f084:	3202      	adds	r2, #2
    f086:	f105 010c 	add.w	r1, r5, #12
    f08a:	4607      	mov	r7, r0
    f08c:	0092      	lsls	r2, r2, #2
    f08e:	300c      	adds	r0, #12
    f090:	f7fa fc0e 	bl	98b0 <memcpy>
    f094:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
    f096:	6869      	ldr	r1, [r5, #4]
    f098:	9b01      	ldr	r3, [sp, #4]
    f09a:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
    f09e:	6028      	str	r0, [r5, #0]
    f0a0:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
    f0a4:	463d      	mov	r5, r7
    f0a6:	e7de      	b.n	f066 <__multadd+0x3e>

0000f0a8 <__hi0bits>:
    f0a8:	0c03      	lsrs	r3, r0, #16
    f0aa:	041b      	lsls	r3, r3, #16
    f0ac:	b9b3      	cbnz	r3, f0dc <__hi0bits+0x34>
    f0ae:	0400      	lsls	r0, r0, #16
    f0b0:	2310      	movs	r3, #16
    f0b2:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
    f0b6:	bf04      	itt	eq
    f0b8:	0200      	lsleq	r0, r0, #8
    f0ba:	3308      	addeq	r3, #8
    f0bc:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
    f0c0:	bf04      	itt	eq
    f0c2:	0100      	lsleq	r0, r0, #4
    f0c4:	3304      	addeq	r3, #4
    f0c6:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
    f0ca:	bf04      	itt	eq
    f0cc:	0080      	lsleq	r0, r0, #2
    f0ce:	3302      	addeq	r3, #2
    f0d0:	2800      	cmp	r0, #0
    f0d2:	db07      	blt.n	f0e4 <__hi0bits+0x3c>
    f0d4:	0042      	lsls	r2, r0, #1
    f0d6:	d403      	bmi.n	f0e0 <__hi0bits+0x38>
    f0d8:	2020      	movs	r0, #32
    f0da:	4770      	bx	lr
    f0dc:	2300      	movs	r3, #0
    f0de:	e7e8      	b.n	f0b2 <__hi0bits+0xa>
    f0e0:	1c58      	adds	r0, r3, #1
    f0e2:	4770      	bx	lr
    f0e4:	4618      	mov	r0, r3
    f0e6:	4770      	bx	lr

0000f0e8 <__lo0bits>:
    f0e8:	6803      	ldr	r3, [r0, #0]
    f0ea:	f013 0207 	ands.w	r2, r3, #7
    f0ee:	d007      	beq.n	f100 <__lo0bits+0x18>
    f0f0:	07d9      	lsls	r1, r3, #31
    f0f2:	d420      	bmi.n	f136 <__lo0bits+0x4e>
    f0f4:	079a      	lsls	r2, r3, #30
    f0f6:	d420      	bmi.n	f13a <__lo0bits+0x52>
    f0f8:	089b      	lsrs	r3, r3, #2
    f0fa:	6003      	str	r3, [r0, #0]
    f0fc:	2002      	movs	r0, #2
    f0fe:	4770      	bx	lr
    f100:	b299      	uxth	r1, r3
    f102:	b909      	cbnz	r1, f108 <__lo0bits+0x20>
    f104:	0c1b      	lsrs	r3, r3, #16
    f106:	2210      	movs	r2, #16
    f108:	f013 0fff 	tst.w	r3, #255	; 0xff
    f10c:	bf04      	itt	eq
    f10e:	0a1b      	lsreq	r3, r3, #8
    f110:	3208      	addeq	r2, #8
    f112:	0719      	lsls	r1, r3, #28
    f114:	bf04      	itt	eq
    f116:	091b      	lsreq	r3, r3, #4
    f118:	3204      	addeq	r2, #4
    f11a:	0799      	lsls	r1, r3, #30
    f11c:	bf04      	itt	eq
    f11e:	089b      	lsreq	r3, r3, #2
    f120:	3202      	addeq	r2, #2
    f122:	07d9      	lsls	r1, r3, #31
    f124:	d404      	bmi.n	f130 <__lo0bits+0x48>
    f126:	085b      	lsrs	r3, r3, #1
    f128:	d101      	bne.n	f12e <__lo0bits+0x46>
    f12a:	2020      	movs	r0, #32
    f12c:	4770      	bx	lr
    f12e:	3201      	adds	r2, #1
    f130:	6003      	str	r3, [r0, #0]
    f132:	4610      	mov	r0, r2
    f134:	4770      	bx	lr
    f136:	2000      	movs	r0, #0
    f138:	4770      	bx	lr
    f13a:	085b      	lsrs	r3, r3, #1
    f13c:	6003      	str	r3, [r0, #0]
    f13e:	2001      	movs	r0, #1
    f140:	4770      	bx	lr
    f142:	bf00      	nop

0000f144 <__i2b>:
    f144:	b510      	push	{r4, lr}
    f146:	460c      	mov	r4, r1
    f148:	2101      	movs	r1, #1
    f14a:	f7ff ff3d 	bl	efc8 <_Balloc>
    f14e:	2201      	movs	r2, #1
    f150:	6144      	str	r4, [r0, #20]
    f152:	6102      	str	r2, [r0, #16]
    f154:	bd10      	pop	{r4, pc}
    f156:	bf00      	nop

0000f158 <__multiply>:
    f158:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f15c:	690d      	ldr	r5, [r1, #16]
    f15e:	6917      	ldr	r7, [r2, #16]
    f160:	42bd      	cmp	r5, r7
    f162:	b083      	sub	sp, #12
    f164:	460c      	mov	r4, r1
    f166:	4616      	mov	r6, r2
    f168:	da04      	bge.n	f174 <__multiply+0x1c>
    f16a:	462a      	mov	r2, r5
    f16c:	4634      	mov	r4, r6
    f16e:	463d      	mov	r5, r7
    f170:	460e      	mov	r6, r1
    f172:	4617      	mov	r7, r2
    f174:	68a3      	ldr	r3, [r4, #8]
    f176:	6861      	ldr	r1, [r4, #4]
    f178:	eb05 0807 	add.w	r8, r5, r7
    f17c:	4598      	cmp	r8, r3
    f17e:	bfc8      	it	gt
    f180:	3101      	addgt	r1, #1
    f182:	f7ff ff21 	bl	efc8 <_Balloc>
    f186:	f100 0c14 	add.w	ip, r0, #20
    f18a:	eb0c 0988 	add.w	r9, ip, r8, lsl #2
    f18e:	45cc      	cmp	ip, r9
    f190:	9000      	str	r0, [sp, #0]
    f192:	d205      	bcs.n	f1a0 <__multiply+0x48>
    f194:	4663      	mov	r3, ip
    f196:	2100      	movs	r1, #0
    f198:	f843 1b04 	str.w	r1, [r3], #4
    f19c:	4599      	cmp	r9, r3
    f19e:	d8fb      	bhi.n	f198 <__multiply+0x40>
    f1a0:	f106 0214 	add.w	r2, r6, #20
    f1a4:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
    f1a8:	f104 0314 	add.w	r3, r4, #20
    f1ac:	4552      	cmp	r2, sl
    f1ae:	eb03 0e85 	add.w	lr, r3, r5, lsl #2
    f1b2:	d254      	bcs.n	f25e <__multiply+0x106>
    f1b4:	f8cd 9004 	str.w	r9, [sp, #4]
    f1b8:	4699      	mov	r9, r3
    f1ba:	f852 3b04 	ldr.w	r3, [r2], #4
    f1be:	fa1f fb83 	uxth.w	fp, r3
    f1c2:	f1bb 0f00 	cmp.w	fp, #0
    f1c6:	d020      	beq.n	f20a <__multiply+0xb2>
    f1c8:	2000      	movs	r0, #0
    f1ca:	464f      	mov	r7, r9
    f1cc:	4666      	mov	r6, ip
    f1ce:	4605      	mov	r5, r0
    f1d0:	e000      	b.n	f1d4 <__multiply+0x7c>
    f1d2:	461e      	mov	r6, r3
    f1d4:	f857 4b04 	ldr.w	r4, [r7], #4
    f1d8:	6830      	ldr	r0, [r6, #0]
    f1da:	b2a1      	uxth	r1, r4
    f1dc:	b283      	uxth	r3, r0
    f1de:	fb0b 3101 	mla	r1, fp, r1, r3
    f1e2:	0c24      	lsrs	r4, r4, #16
    f1e4:	0c00      	lsrs	r0, r0, #16
    f1e6:	194b      	adds	r3, r1, r5
    f1e8:	fb0b 0004 	mla	r0, fp, r4, r0
    f1ec:	eb00 4013 	add.w	r0, r0, r3, lsr #16
    f1f0:	b299      	uxth	r1, r3
    f1f2:	4633      	mov	r3, r6
    f1f4:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
    f1f8:	45be      	cmp	lr, r7
    f1fa:	ea4f 4510 	mov.w	r5, r0, lsr #16
    f1fe:	f843 1b04 	str.w	r1, [r3], #4
    f202:	d8e6      	bhi.n	f1d2 <__multiply+0x7a>
    f204:	6075      	str	r5, [r6, #4]
    f206:	f852 3c04 	ldr.w	r3, [r2, #-4]
    f20a:	ea5f 4b13 	movs.w	fp, r3, lsr #16
    f20e:	d020      	beq.n	f252 <__multiply+0xfa>
    f210:	f8dc 3000 	ldr.w	r3, [ip]
    f214:	4667      	mov	r7, ip
    f216:	4618      	mov	r0, r3
    f218:	464d      	mov	r5, r9
    f21a:	2100      	movs	r1, #0
    f21c:	e000      	b.n	f220 <__multiply+0xc8>
    f21e:	4637      	mov	r7, r6
    f220:	882c      	ldrh	r4, [r5, #0]
    f222:	0c00      	lsrs	r0, r0, #16
    f224:	fb0b 0004 	mla	r0, fp, r4, r0
    f228:	4401      	add	r1, r0
    f22a:	b29c      	uxth	r4, r3
    f22c:	463e      	mov	r6, r7
    f22e:	ea44 4301 	orr.w	r3, r4, r1, lsl #16
    f232:	f846 3b04 	str.w	r3, [r6], #4
    f236:	6878      	ldr	r0, [r7, #4]
    f238:	f855 4b04 	ldr.w	r4, [r5], #4
    f23c:	b283      	uxth	r3, r0
    f23e:	0c24      	lsrs	r4, r4, #16
    f240:	fb0b 3404 	mla	r4, fp, r4, r3
    f244:	eb04 4311 	add.w	r3, r4, r1, lsr #16
    f248:	45ae      	cmp	lr, r5
    f24a:	ea4f 4113 	mov.w	r1, r3, lsr #16
    f24e:	d8e6      	bhi.n	f21e <__multiply+0xc6>
    f250:	607b      	str	r3, [r7, #4]
    f252:	4592      	cmp	sl, r2
    f254:	f10c 0c04 	add.w	ip, ip, #4
    f258:	d8af      	bhi.n	f1ba <__multiply+0x62>
    f25a:	f8dd 9004 	ldr.w	r9, [sp, #4]
    f25e:	f1b8 0f00 	cmp.w	r8, #0
    f262:	dd0b      	ble.n	f27c <__multiply+0x124>
    f264:	f859 3c04 	ldr.w	r3, [r9, #-4]
    f268:	f1a9 0904 	sub.w	r9, r9, #4
    f26c:	b11b      	cbz	r3, f276 <__multiply+0x11e>
    f26e:	e005      	b.n	f27c <__multiply+0x124>
    f270:	f859 3d04 	ldr.w	r3, [r9, #-4]!
    f274:	b913      	cbnz	r3, f27c <__multiply+0x124>
    f276:	f1b8 0801 	subs.w	r8, r8, #1
    f27a:	d1f9      	bne.n	f270 <__multiply+0x118>
    f27c:	9800      	ldr	r0, [sp, #0]
    f27e:	f8c0 8010 	str.w	r8, [r0, #16]
    f282:	b003      	add	sp, #12
    f284:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000f288 <__pow5mult>:
    f288:	f012 0303 	ands.w	r3, r2, #3
    f28c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f290:	4614      	mov	r4, r2
    f292:	4607      	mov	r7, r0
    f294:	d12e      	bne.n	f2f4 <__pow5mult+0x6c>
    f296:	460e      	mov	r6, r1
    f298:	10a4      	asrs	r4, r4, #2
    f29a:	d01c      	beq.n	f2d6 <__pow5mult+0x4e>
    f29c:	6cbd      	ldr	r5, [r7, #72]	; 0x48
    f29e:	b395      	cbz	r5, f306 <__pow5mult+0x7e>
    f2a0:	07e3      	lsls	r3, r4, #31
    f2a2:	f04f 0800 	mov.w	r8, #0
    f2a6:	d406      	bmi.n	f2b6 <__pow5mult+0x2e>
    f2a8:	1064      	asrs	r4, r4, #1
    f2aa:	d014      	beq.n	f2d6 <__pow5mult+0x4e>
    f2ac:	6828      	ldr	r0, [r5, #0]
    f2ae:	b1a8      	cbz	r0, f2dc <__pow5mult+0x54>
    f2b0:	4605      	mov	r5, r0
    f2b2:	07e3      	lsls	r3, r4, #31
    f2b4:	d5f8      	bpl.n	f2a8 <__pow5mult+0x20>
    f2b6:	462a      	mov	r2, r5
    f2b8:	4631      	mov	r1, r6
    f2ba:	4638      	mov	r0, r7
    f2bc:	f7ff ff4c 	bl	f158 <__multiply>
    f2c0:	b1b6      	cbz	r6, f2f0 <__pow5mult+0x68>
    f2c2:	6872      	ldr	r2, [r6, #4]
    f2c4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    f2c6:	1064      	asrs	r4, r4, #1
    f2c8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    f2cc:	6031      	str	r1, [r6, #0]
    f2ce:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
    f2d2:	4606      	mov	r6, r0
    f2d4:	d1ea      	bne.n	f2ac <__pow5mult+0x24>
    f2d6:	4630      	mov	r0, r6
    f2d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f2dc:	462a      	mov	r2, r5
    f2de:	4629      	mov	r1, r5
    f2e0:	4638      	mov	r0, r7
    f2e2:	f7ff ff39 	bl	f158 <__multiply>
    f2e6:	6028      	str	r0, [r5, #0]
    f2e8:	f8c0 8000 	str.w	r8, [r0]
    f2ec:	4605      	mov	r5, r0
    f2ee:	e7e0      	b.n	f2b2 <__pow5mult+0x2a>
    f2f0:	4606      	mov	r6, r0
    f2f2:	e7d9      	b.n	f2a8 <__pow5mult+0x20>
    f2f4:	1e5a      	subs	r2, r3, #1
    f2f6:	4d0b      	ldr	r5, [pc, #44]	; (f324 <__pow5mult+0x9c>)
    f2f8:	2300      	movs	r3, #0
    f2fa:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
    f2fe:	f7ff fe93 	bl	f028 <__multadd>
    f302:	4606      	mov	r6, r0
    f304:	e7c8      	b.n	f298 <__pow5mult+0x10>
    f306:	2101      	movs	r1, #1
    f308:	4638      	mov	r0, r7
    f30a:	f7ff fe5d 	bl	efc8 <_Balloc>
    f30e:	f240 2171 	movw	r1, #625	; 0x271
    f312:	2201      	movs	r2, #1
    f314:	2300      	movs	r3, #0
    f316:	6141      	str	r1, [r0, #20]
    f318:	6102      	str	r2, [r0, #16]
    f31a:	4605      	mov	r5, r0
    f31c:	64b8      	str	r0, [r7, #72]	; 0x48
    f31e:	6003      	str	r3, [r0, #0]
    f320:	e7be      	b.n	f2a0 <__pow5mult+0x18>
    f322:	bf00      	nop
    f324:	00021fc0 	.word	0x00021fc0

0000f328 <__lshift>:
    f328:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    f32c:	4691      	mov	r9, r2
    f32e:	690a      	ldr	r2, [r1, #16]
    f330:	688b      	ldr	r3, [r1, #8]
    f332:	ea4f 1469 	mov.w	r4, r9, asr #5
    f336:	eb04 0802 	add.w	r8, r4, r2
    f33a:	f108 0501 	add.w	r5, r8, #1
    f33e:	429d      	cmp	r5, r3
    f340:	460e      	mov	r6, r1
    f342:	4682      	mov	sl, r0
    f344:	6849      	ldr	r1, [r1, #4]
    f346:	dd04      	ble.n	f352 <__lshift+0x2a>
    f348:	005b      	lsls	r3, r3, #1
    f34a:	429d      	cmp	r5, r3
    f34c:	f101 0101 	add.w	r1, r1, #1
    f350:	dcfa      	bgt.n	f348 <__lshift+0x20>
    f352:	4650      	mov	r0, sl
    f354:	f7ff fe38 	bl	efc8 <_Balloc>
    f358:	2c00      	cmp	r4, #0
    f35a:	f100 0214 	add.w	r2, r0, #20
    f35e:	dd38      	ble.n	f3d2 <__lshift+0xaa>
    f360:	eb02 0384 	add.w	r3, r2, r4, lsl #2
    f364:	2100      	movs	r1, #0
    f366:	f842 1b04 	str.w	r1, [r2], #4
    f36a:	4293      	cmp	r3, r2
    f36c:	d1fb      	bne.n	f366 <__lshift+0x3e>
    f36e:	6934      	ldr	r4, [r6, #16]
    f370:	f106 0114 	add.w	r1, r6, #20
    f374:	f019 091f 	ands.w	r9, r9, #31
    f378:	eb01 0e84 	add.w	lr, r1, r4, lsl #2
    f37c:	d021      	beq.n	f3c2 <__lshift+0x9a>
    f37e:	f1c9 0220 	rsb	r2, r9, #32
    f382:	2400      	movs	r4, #0
    f384:	680f      	ldr	r7, [r1, #0]
    f386:	fa07 fc09 	lsl.w	ip, r7, r9
    f38a:	ea4c 0404 	orr.w	r4, ip, r4
    f38e:	469c      	mov	ip, r3
    f390:	f843 4b04 	str.w	r4, [r3], #4
    f394:	f851 4b04 	ldr.w	r4, [r1], #4
    f398:	458e      	cmp	lr, r1
    f39a:	fa24 f402 	lsr.w	r4, r4, r2
    f39e:	d8f1      	bhi.n	f384 <__lshift+0x5c>
    f3a0:	f8cc 4004 	str.w	r4, [ip, #4]
    f3a4:	b10c      	cbz	r4, f3aa <__lshift+0x82>
    f3a6:	f108 0502 	add.w	r5, r8, #2
    f3aa:	f8da 304c 	ldr.w	r3, [sl, #76]	; 0x4c
    f3ae:	6872      	ldr	r2, [r6, #4]
    f3b0:	3d01      	subs	r5, #1
    f3b2:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    f3b6:	6105      	str	r5, [r0, #16]
    f3b8:	6031      	str	r1, [r6, #0]
    f3ba:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
    f3be:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f3c2:	3b04      	subs	r3, #4
    f3c4:	f851 2b04 	ldr.w	r2, [r1], #4
    f3c8:	f843 2f04 	str.w	r2, [r3, #4]!
    f3cc:	458e      	cmp	lr, r1
    f3ce:	d8f9      	bhi.n	f3c4 <__lshift+0x9c>
    f3d0:	e7eb      	b.n	f3aa <__lshift+0x82>
    f3d2:	4613      	mov	r3, r2
    f3d4:	e7cb      	b.n	f36e <__lshift+0x46>
    f3d6:	bf00      	nop

0000f3d8 <__mcmp>:
    f3d8:	6902      	ldr	r2, [r0, #16]
    f3da:	690b      	ldr	r3, [r1, #16]
    f3dc:	1ad2      	subs	r2, r2, r3
    f3de:	d112      	bne.n	f406 <__mcmp+0x2e>
    f3e0:	009b      	lsls	r3, r3, #2
    f3e2:	3014      	adds	r0, #20
    f3e4:	3114      	adds	r1, #20
    f3e6:	4419      	add	r1, r3
    f3e8:	b410      	push	{r4}
    f3ea:	4403      	add	r3, r0
    f3ec:	e001      	b.n	f3f2 <__mcmp+0x1a>
    f3ee:	4298      	cmp	r0, r3
    f3f0:	d20b      	bcs.n	f40a <__mcmp+0x32>
    f3f2:	f853 4d04 	ldr.w	r4, [r3, #-4]!
    f3f6:	f851 2d04 	ldr.w	r2, [r1, #-4]!
    f3fa:	4294      	cmp	r4, r2
    f3fc:	d0f7      	beq.n	f3ee <__mcmp+0x16>
    f3fe:	d307      	bcc.n	f410 <__mcmp+0x38>
    f400:	2001      	movs	r0, #1
    f402:	bc10      	pop	{r4}
    f404:	4770      	bx	lr
    f406:	4610      	mov	r0, r2
    f408:	4770      	bx	lr
    f40a:	2000      	movs	r0, #0
    f40c:	bc10      	pop	{r4}
    f40e:	4770      	bx	lr
    f410:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    f414:	e7f5      	b.n	f402 <__mcmp+0x2a>
    f416:	bf00      	nop

0000f418 <__mdiff>:
    f418:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    f41c:	690b      	ldr	r3, [r1, #16]
    f41e:	460f      	mov	r7, r1
    f420:	6911      	ldr	r1, [r2, #16]
    f422:	1a5b      	subs	r3, r3, r1
    f424:	2b00      	cmp	r3, #0
    f426:	4690      	mov	r8, r2
    f428:	d117      	bne.n	f45a <__mdiff+0x42>
    f42a:	0089      	lsls	r1, r1, #2
    f42c:	f107 0214 	add.w	r2, r7, #20
    f430:	f108 0514 	add.w	r5, r8, #20
    f434:	1853      	adds	r3, r2, r1
    f436:	4429      	add	r1, r5
    f438:	e001      	b.n	f43e <__mdiff+0x26>
    f43a:	429a      	cmp	r2, r3
    f43c:	d25e      	bcs.n	f4fc <__mdiff+0xe4>
    f43e:	f853 6d04 	ldr.w	r6, [r3, #-4]!
    f442:	f851 4d04 	ldr.w	r4, [r1, #-4]!
    f446:	42a6      	cmp	r6, r4
    f448:	d0f7      	beq.n	f43a <__mdiff+0x22>
    f44a:	d260      	bcs.n	f50e <__mdiff+0xf6>
    f44c:	463b      	mov	r3, r7
    f44e:	4614      	mov	r4, r2
    f450:	4647      	mov	r7, r8
    f452:	f04f 0901 	mov.w	r9, #1
    f456:	4698      	mov	r8, r3
    f458:	e006      	b.n	f468 <__mdiff+0x50>
    f45a:	db5d      	blt.n	f518 <__mdiff+0x100>
    f45c:	f107 0514 	add.w	r5, r7, #20
    f460:	f102 0414 	add.w	r4, r2, #20
    f464:	f04f 0900 	mov.w	r9, #0
    f468:	6879      	ldr	r1, [r7, #4]
    f46a:	f7ff fdad 	bl	efc8 <_Balloc>
    f46e:	f8d8 3010 	ldr.w	r3, [r8, #16]
    f472:	693e      	ldr	r6, [r7, #16]
    f474:	f8c0 900c 	str.w	r9, [r0, #12]
    f478:	eb04 0c83 	add.w	ip, r4, r3, lsl #2
    f47c:	46a6      	mov	lr, r4
    f47e:	eb05 0786 	add.w	r7, r5, r6, lsl #2
    f482:	f100 0414 	add.w	r4, r0, #20
    f486:	2300      	movs	r3, #0
    f488:	f85e 1b04 	ldr.w	r1, [lr], #4
    f48c:	f855 8b04 	ldr.w	r8, [r5], #4
    f490:	b28a      	uxth	r2, r1
    f492:	fa13 f388 	uxtah	r3, r3, r8
    f496:	0c09      	lsrs	r1, r1, #16
    f498:	1a9a      	subs	r2, r3, r2
    f49a:	ebc1 4318 	rsb	r3, r1, r8, lsr #16
    f49e:	eb03 4322 	add.w	r3, r3, r2, asr #16
    f4a2:	b292      	uxth	r2, r2
    f4a4:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
    f4a8:	45f4      	cmp	ip, lr
    f4aa:	f844 2b04 	str.w	r2, [r4], #4
    f4ae:	ea4f 4323 	mov.w	r3, r3, asr #16
    f4b2:	d8e9      	bhi.n	f488 <__mdiff+0x70>
    f4b4:	42af      	cmp	r7, r5
    f4b6:	d917      	bls.n	f4e8 <__mdiff+0xd0>
    f4b8:	46a4      	mov	ip, r4
    f4ba:	4629      	mov	r1, r5
    f4bc:	f851 eb04 	ldr.w	lr, [r1], #4
    f4c0:	fa13 f28e 	uxtah	r2, r3, lr
    f4c4:	1413      	asrs	r3, r2, #16
    f4c6:	eb03 431e 	add.w	r3, r3, lr, lsr #16
    f4ca:	b292      	uxth	r2, r2
    f4cc:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
    f4d0:	428f      	cmp	r7, r1
    f4d2:	f84c 2b04 	str.w	r2, [ip], #4
    f4d6:	ea4f 4323 	mov.w	r3, r3, asr #16
    f4da:	d8ef      	bhi.n	f4bc <__mdiff+0xa4>
    f4dc:	43ed      	mvns	r5, r5
    f4de:	443d      	add	r5, r7
    f4e0:	f025 0503 	bic.w	r5, r5, #3
    f4e4:	3504      	adds	r5, #4
    f4e6:	442c      	add	r4, r5
    f4e8:	3c04      	subs	r4, #4
    f4ea:	b922      	cbnz	r2, f4f6 <__mdiff+0xde>
    f4ec:	f854 3d04 	ldr.w	r3, [r4, #-4]!
    f4f0:	3e01      	subs	r6, #1
    f4f2:	2b00      	cmp	r3, #0
    f4f4:	d0fa      	beq.n	f4ec <__mdiff+0xd4>
    f4f6:	6106      	str	r6, [r0, #16]
    f4f8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    f4fc:	2100      	movs	r1, #0
    f4fe:	f7ff fd63 	bl	efc8 <_Balloc>
    f502:	2201      	movs	r2, #1
    f504:	2300      	movs	r3, #0
    f506:	6102      	str	r2, [r0, #16]
    f508:	6143      	str	r3, [r0, #20]
    f50a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    f50e:	462c      	mov	r4, r5
    f510:	f04f 0900 	mov.w	r9, #0
    f514:	4615      	mov	r5, r2
    f516:	e7a7      	b.n	f468 <__mdiff+0x50>
    f518:	463b      	mov	r3, r7
    f51a:	f107 0414 	add.w	r4, r7, #20
    f51e:	f108 0514 	add.w	r5, r8, #20
    f522:	4647      	mov	r7, r8
    f524:	f04f 0901 	mov.w	r9, #1
    f528:	4698      	mov	r8, r3
    f52a:	e79d      	b.n	f468 <__mdiff+0x50>

0000f52c <__d2b>:
    f52c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f530:	b082      	sub	sp, #8
    f532:	2101      	movs	r1, #1
    f534:	461c      	mov	r4, r3
    f536:	f3c3 570a 	ubfx	r7, r3, #20, #11
    f53a:	4615      	mov	r5, r2
    f53c:	9e08      	ldr	r6, [sp, #32]
    f53e:	f7ff fd43 	bl	efc8 <_Balloc>
    f542:	f3c4 0413 	ubfx	r4, r4, #0, #20
    f546:	4680      	mov	r8, r0
    f548:	b10f      	cbz	r7, f54e <__d2b+0x22>
    f54a:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
    f54e:	9401      	str	r4, [sp, #4]
    f550:	b31d      	cbz	r5, f59a <__d2b+0x6e>
    f552:	a802      	add	r0, sp, #8
    f554:	f840 5d08 	str.w	r5, [r0, #-8]!
    f558:	f7ff fdc6 	bl	f0e8 <__lo0bits>
    f55c:	2800      	cmp	r0, #0
    f55e:	d134      	bne.n	f5ca <__d2b+0x9e>
    f560:	e89d 000c 	ldmia.w	sp, {r2, r3}
    f564:	f8c8 2014 	str.w	r2, [r8, #20]
    f568:	2b00      	cmp	r3, #0
    f56a:	bf0c      	ite	eq
    f56c:	2101      	moveq	r1, #1
    f56e:	2102      	movne	r1, #2
    f570:	f8c8 3018 	str.w	r3, [r8, #24]
    f574:	f8c8 1010 	str.w	r1, [r8, #16]
    f578:	b9df      	cbnz	r7, f5b2 <__d2b+0x86>
    f57a:	eb08 0381 	add.w	r3, r8, r1, lsl #2
    f57e:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
    f582:	6030      	str	r0, [r6, #0]
    f584:	6918      	ldr	r0, [r3, #16]
    f586:	f7ff fd8f 	bl	f0a8 <__hi0bits>
    f58a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    f58c:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
    f590:	6018      	str	r0, [r3, #0]
    f592:	4640      	mov	r0, r8
    f594:	b002      	add	sp, #8
    f596:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f59a:	a801      	add	r0, sp, #4
    f59c:	f7ff fda4 	bl	f0e8 <__lo0bits>
    f5a0:	9b01      	ldr	r3, [sp, #4]
    f5a2:	f8c8 3014 	str.w	r3, [r8, #20]
    f5a6:	2101      	movs	r1, #1
    f5a8:	3020      	adds	r0, #32
    f5aa:	f8c8 1010 	str.w	r1, [r8, #16]
    f5ae:	2f00      	cmp	r7, #0
    f5b0:	d0e3      	beq.n	f57a <__d2b+0x4e>
    f5b2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    f5b4:	f2a7 4733 	subw	r7, r7, #1075	; 0x433
    f5b8:	4407      	add	r7, r0
    f5ba:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
    f5be:	6037      	str	r7, [r6, #0]
    f5c0:	6018      	str	r0, [r3, #0]
    f5c2:	4640      	mov	r0, r8
    f5c4:	b002      	add	sp, #8
    f5c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f5ca:	e89d 000c 	ldmia.w	sp, {r2, r3}
    f5ce:	f1c0 0120 	rsb	r1, r0, #32
    f5d2:	fa03 f101 	lsl.w	r1, r3, r1
    f5d6:	430a      	orrs	r2, r1
    f5d8:	40c3      	lsrs	r3, r0
    f5da:	9301      	str	r3, [sp, #4]
    f5dc:	f8c8 2014 	str.w	r2, [r8, #20]
    f5e0:	e7c2      	b.n	f568 <__d2b+0x3c>
    f5e2:	bf00      	nop

0000f5e4 <_calloc_r>:
    f5e4:	b510      	push	{r4, lr}
    f5e6:	fb02 f101 	mul.w	r1, r2, r1
    f5ea:	f7fe fad7 	bl	db9c <_malloc_r>
    f5ee:	4604      	mov	r4, r0
    f5f0:	b1d8      	cbz	r0, f62a <_calloc_r+0x46>
    f5f2:	f850 2c04 	ldr.w	r2, [r0, #-4]
    f5f6:	f022 0203 	bic.w	r2, r2, #3
    f5fa:	3a04      	subs	r2, #4
    f5fc:	2a24      	cmp	r2, #36	; 0x24
    f5fe:	d818      	bhi.n	f632 <_calloc_r+0x4e>
    f600:	2a13      	cmp	r2, #19
    f602:	d914      	bls.n	f62e <_calloc_r+0x4a>
    f604:	2300      	movs	r3, #0
    f606:	2a1b      	cmp	r2, #27
    f608:	6003      	str	r3, [r0, #0]
    f60a:	6043      	str	r3, [r0, #4]
    f60c:	d916      	bls.n	f63c <_calloc_r+0x58>
    f60e:	2a24      	cmp	r2, #36	; 0x24
    f610:	6083      	str	r3, [r0, #8]
    f612:	60c3      	str	r3, [r0, #12]
    f614:	bf11      	iteee	ne
    f616:	f100 0210 	addne.w	r2, r0, #16
    f61a:	6103      	streq	r3, [r0, #16]
    f61c:	6143      	streq	r3, [r0, #20]
    f61e:	f100 0218 	addeq.w	r2, r0, #24
    f622:	2300      	movs	r3, #0
    f624:	6013      	str	r3, [r2, #0]
    f626:	6053      	str	r3, [r2, #4]
    f628:	6093      	str	r3, [r2, #8]
    f62a:	4620      	mov	r0, r4
    f62c:	bd10      	pop	{r4, pc}
    f62e:	4602      	mov	r2, r0
    f630:	e7f7      	b.n	f622 <_calloc_r+0x3e>
    f632:	2100      	movs	r1, #0
    f634:	f7fe fdce 	bl	e1d4 <memset>
    f638:	4620      	mov	r0, r4
    f63a:	bd10      	pop	{r4, pc}
    f63c:	f100 0208 	add.w	r2, r0, #8
    f640:	e7ef      	b.n	f622 <_calloc_r+0x3e>
    f642:	bf00      	nop

0000f644 <quorem>:
    f644:	6902      	ldr	r2, [r0, #16]
    f646:	690b      	ldr	r3, [r1, #16]
    f648:	4293      	cmp	r3, r2
    f64a:	f300 808d 	bgt.w	f768 <quorem+0x124>
    f64e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f652:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
    f656:	f101 0714 	add.w	r7, r1, #20
    f65a:	f100 0b14 	add.w	fp, r0, #20
    f65e:	f857 2028 	ldr.w	r2, [r7, r8, lsl #2]
    f662:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
    f666:	ea4f 0488 	mov.w	r4, r8, lsl #2
    f66a:	b083      	sub	sp, #12
    f66c:	3201      	adds	r2, #1
    f66e:	fbb3 f9f2 	udiv	r9, r3, r2
    f672:	eb0b 0304 	add.w	r3, fp, r4
    f676:	9400      	str	r4, [sp, #0]
    f678:	eb07 0a04 	add.w	sl, r7, r4
    f67c:	9301      	str	r3, [sp, #4]
    f67e:	f1b9 0f00 	cmp.w	r9, #0
    f682:	d039      	beq.n	f6f8 <quorem+0xb4>
    f684:	2500      	movs	r5, #0
    f686:	46bc      	mov	ip, r7
    f688:	46de      	mov	lr, fp
    f68a:	462b      	mov	r3, r5
    f68c:	f85c 6b04 	ldr.w	r6, [ip], #4
    f690:	f8de 2000 	ldr.w	r2, [lr]
    f694:	b2b4      	uxth	r4, r6
    f696:	fb09 5504 	mla	r5, r9, r4, r5
    f69a:	0c36      	lsrs	r6, r6, #16
    f69c:	0c2c      	lsrs	r4, r5, #16
    f69e:	fb09 4406 	mla	r4, r9, r6, r4
    f6a2:	b2ad      	uxth	r5, r5
    f6a4:	1b5b      	subs	r3, r3, r5
    f6a6:	b2a6      	uxth	r6, r4
    f6a8:	fa13 f382 	uxtah	r3, r3, r2
    f6ac:	ebc6 4612 	rsb	r6, r6, r2, lsr #16
    f6b0:	eb06 4623 	add.w	r6, r6, r3, asr #16
    f6b4:	b29b      	uxth	r3, r3
    f6b6:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
    f6ba:	45e2      	cmp	sl, ip
    f6bc:	f84e 3b04 	str.w	r3, [lr], #4
    f6c0:	ea4f 4514 	mov.w	r5, r4, lsr #16
    f6c4:	ea4f 4326 	mov.w	r3, r6, asr #16
    f6c8:	d2e0      	bcs.n	f68c <quorem+0x48>
    f6ca:	9b00      	ldr	r3, [sp, #0]
    f6cc:	f85b 3003 	ldr.w	r3, [fp, r3]
    f6d0:	b993      	cbnz	r3, f6f8 <quorem+0xb4>
    f6d2:	9c01      	ldr	r4, [sp, #4]
    f6d4:	1f23      	subs	r3, r4, #4
    f6d6:	459b      	cmp	fp, r3
    f6d8:	d20c      	bcs.n	f6f4 <quorem+0xb0>
    f6da:	f854 3c04 	ldr.w	r3, [r4, #-4]
    f6de:	b94b      	cbnz	r3, f6f4 <quorem+0xb0>
    f6e0:	f1a4 0308 	sub.w	r3, r4, #8
    f6e4:	e002      	b.n	f6ec <quorem+0xa8>
    f6e6:	681a      	ldr	r2, [r3, #0]
    f6e8:	3b04      	subs	r3, #4
    f6ea:	b91a      	cbnz	r2, f6f4 <quorem+0xb0>
    f6ec:	459b      	cmp	fp, r3
    f6ee:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    f6f2:	d3f8      	bcc.n	f6e6 <quorem+0xa2>
    f6f4:	f8c0 8010 	str.w	r8, [r0, #16]
    f6f8:	4604      	mov	r4, r0
    f6fa:	f7ff fe6d 	bl	f3d8 <__mcmp>
    f6fe:	2800      	cmp	r0, #0
    f700:	db2e      	blt.n	f760 <quorem+0x11c>
    f702:	f109 0901 	add.w	r9, r9, #1
    f706:	465d      	mov	r5, fp
    f708:	2300      	movs	r3, #0
    f70a:	f857 1b04 	ldr.w	r1, [r7], #4
    f70e:	6828      	ldr	r0, [r5, #0]
    f710:	b28a      	uxth	r2, r1
    f712:	1a9a      	subs	r2, r3, r2
    f714:	0c09      	lsrs	r1, r1, #16
    f716:	fa12 f280 	uxtah	r2, r2, r0
    f71a:	ebc1 4310 	rsb	r3, r1, r0, lsr #16
    f71e:	eb03 4322 	add.w	r3, r3, r2, asr #16
    f722:	b291      	uxth	r1, r2
    f724:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    f728:	45ba      	cmp	sl, r7
    f72a:	f845 1b04 	str.w	r1, [r5], #4
    f72e:	ea4f 4323 	mov.w	r3, r3, asr #16
    f732:	d2ea      	bcs.n	f70a <quorem+0xc6>
    f734:	f85b 2028 	ldr.w	r2, [fp, r8, lsl #2]
    f738:	eb0b 0388 	add.w	r3, fp, r8, lsl #2
    f73c:	b982      	cbnz	r2, f760 <quorem+0x11c>
    f73e:	1f1a      	subs	r2, r3, #4
    f740:	4593      	cmp	fp, r2
    f742:	d20b      	bcs.n	f75c <quorem+0x118>
    f744:	f853 2c04 	ldr.w	r2, [r3, #-4]
    f748:	b942      	cbnz	r2, f75c <quorem+0x118>
    f74a:	3b08      	subs	r3, #8
    f74c:	e002      	b.n	f754 <quorem+0x110>
    f74e:	681a      	ldr	r2, [r3, #0]
    f750:	3b04      	subs	r3, #4
    f752:	b91a      	cbnz	r2, f75c <quorem+0x118>
    f754:	459b      	cmp	fp, r3
    f756:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    f75a:	d3f8      	bcc.n	f74e <quorem+0x10a>
    f75c:	f8c4 8010 	str.w	r8, [r4, #16]
    f760:	4648      	mov	r0, r9
    f762:	b003      	add	sp, #12
    f764:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f768:	2000      	movs	r0, #0
    f76a:	4770      	bx	lr
    f76c:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

0000f770 <_dtoa_r>:
    f770:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f774:	6c01      	ldr	r1, [r0, #64]	; 0x40
    f776:	b097      	sub	sp, #92	; 0x5c
    f778:	4681      	mov	r9, r0
    f77a:	9c23      	ldr	r4, [sp, #140]	; 0x8c
    f77c:	4692      	mov	sl, r2
    f77e:	469b      	mov	fp, r3
    f780:	b149      	cbz	r1, f796 <_dtoa_r+0x26>
    f782:	6c42      	ldr	r2, [r0, #68]	; 0x44
    f784:	604a      	str	r2, [r1, #4]
    f786:	2301      	movs	r3, #1
    f788:	4093      	lsls	r3, r2
    f78a:	608b      	str	r3, [r1, #8]
    f78c:	f7ff fc42 	bl	f014 <_Bfree>
    f790:	2300      	movs	r3, #0
    f792:	f8c9 3040 	str.w	r3, [r9, #64]	; 0x40
    f796:	f1bb 0f00 	cmp.w	fp, #0
    f79a:	46d8      	mov	r8, fp
    f79c:	db33      	blt.n	f806 <_dtoa_r+0x96>
    f79e:	2300      	movs	r3, #0
    f7a0:	6023      	str	r3, [r4, #0]
    f7a2:	4ba5      	ldr	r3, [pc, #660]	; (fa38 <_dtoa_r+0x2c8>)
    f7a4:	461a      	mov	r2, r3
    f7a6:	ea08 0303 	and.w	r3, r8, r3
    f7aa:	4293      	cmp	r3, r2
    f7ac:	d014      	beq.n	f7d8 <_dtoa_r+0x68>
    f7ae:	4650      	mov	r0, sl
    f7b0:	4659      	mov	r1, fp
    f7b2:	2200      	movs	r2, #0
    f7b4:	2300      	movs	r3, #0
    f7b6:	f7fd fbe3 	bl	cf80 <__aeabi_dcmpeq>
    f7ba:	4605      	mov	r5, r0
    f7bc:	b348      	cbz	r0, f812 <_dtoa_r+0xa2>
    f7be:	9a22      	ldr	r2, [sp, #136]	; 0x88
    f7c0:	2301      	movs	r3, #1
    f7c2:	6013      	str	r3, [r2, #0]
    f7c4:	9b24      	ldr	r3, [sp, #144]	; 0x90
    f7c6:	2b00      	cmp	r3, #0
    f7c8:	f000 80c5 	beq.w	f956 <_dtoa_r+0x1e6>
    f7cc:	489b      	ldr	r0, [pc, #620]	; (fa3c <_dtoa_r+0x2cc>)
    f7ce:	6018      	str	r0, [r3, #0]
    f7d0:	3801      	subs	r0, #1
    f7d2:	b017      	add	sp, #92	; 0x5c
    f7d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f7d8:	9a22      	ldr	r2, [sp, #136]	; 0x88
    f7da:	f242 730f 	movw	r3, #9999	; 0x270f
    f7de:	6013      	str	r3, [r2, #0]
    f7e0:	f1ba 0f00 	cmp.w	sl, #0
    f7e4:	f000 80a2 	beq.w	f92c <_dtoa_r+0x1bc>
    f7e8:	4895      	ldr	r0, [pc, #596]	; (fa40 <_dtoa_r+0x2d0>)
    f7ea:	9b24      	ldr	r3, [sp, #144]	; 0x90
    f7ec:	2b00      	cmp	r3, #0
    f7ee:	d0f0      	beq.n	f7d2 <_dtoa_r+0x62>
    f7f0:	78c3      	ldrb	r3, [r0, #3]
    f7f2:	2b00      	cmp	r3, #0
    f7f4:	f000 80b1 	beq.w	f95a <_dtoa_r+0x1ea>
    f7f8:	f100 0308 	add.w	r3, r0, #8
    f7fc:	9a24      	ldr	r2, [sp, #144]	; 0x90
    f7fe:	6013      	str	r3, [r2, #0]
    f800:	b017      	add	sp, #92	; 0x5c
    f802:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f806:	2301      	movs	r3, #1
    f808:	f02b 4800 	bic.w	r8, fp, #2147483648	; 0x80000000
    f80c:	6023      	str	r3, [r4, #0]
    f80e:	46c3      	mov	fp, r8
    f810:	e7c7      	b.n	f7a2 <_dtoa_r+0x32>
    f812:	aa14      	add	r2, sp, #80	; 0x50
    f814:	ab15      	add	r3, sp, #84	; 0x54
    f816:	9201      	str	r2, [sp, #4]
    f818:	9300      	str	r3, [sp, #0]
    f81a:	4652      	mov	r2, sl
    f81c:	465b      	mov	r3, fp
    f81e:	4648      	mov	r0, r9
    f820:	f7ff fe84 	bl	f52c <__d2b>
    f824:	ea5f 5418 	movs.w	r4, r8, lsr #20
    f828:	9008      	str	r0, [sp, #32]
    f82a:	f040 8088 	bne.w	f93e <_dtoa_r+0x1ce>
    f82e:	9d14      	ldr	r5, [sp, #80]	; 0x50
    f830:	9c15      	ldr	r4, [sp, #84]	; 0x54
    f832:	442c      	add	r4, r5
    f834:	f204 4332 	addw	r3, r4, #1074	; 0x432
    f838:	2b20      	cmp	r3, #32
    f83a:	f340 8291 	ble.w	fd60 <_dtoa_r+0x5f0>
    f83e:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
    f842:	f204 4012 	addw	r0, r4, #1042	; 0x412
    f846:	fa08 f803 	lsl.w	r8, r8, r3
    f84a:	fa2a f000 	lsr.w	r0, sl, r0
    f84e:	ea40 0008 	orr.w	r0, r0, r8
    f852:	f7fd f8b7 	bl	c9c4 <__aeabi_ui2d>
    f856:	2301      	movs	r3, #1
    f858:	3c01      	subs	r4, #1
    f85a:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
    f85e:	9310      	str	r3, [sp, #64]	; 0x40
    f860:	2200      	movs	r2, #0
    f862:	4b78      	ldr	r3, [pc, #480]	; (fa44 <_dtoa_r+0x2d4>)
    f864:	f7fc ff70 	bl	c748 <__aeabi_dsub>
    f868:	a36d      	add	r3, pc, #436	; (adr r3, fa20 <_dtoa_r+0x2b0>)
    f86a:	e9d3 2300 	ldrd	r2, r3, [r3]
    f86e:	f7fd f91f 	bl	cab0 <__aeabi_dmul>
    f872:	a36d      	add	r3, pc, #436	; (adr r3, fa28 <_dtoa_r+0x2b8>)
    f874:	e9d3 2300 	ldrd	r2, r3, [r3]
    f878:	f7fc ff68 	bl	c74c <__adddf3>
    f87c:	4606      	mov	r6, r0
    f87e:	4620      	mov	r0, r4
    f880:	460f      	mov	r7, r1
    f882:	f7fd f8af 	bl	c9e4 <__aeabi_i2d>
    f886:	a36a      	add	r3, pc, #424	; (adr r3, fa30 <_dtoa_r+0x2c0>)
    f888:	e9d3 2300 	ldrd	r2, r3, [r3]
    f88c:	f7fd f910 	bl	cab0 <__aeabi_dmul>
    f890:	4602      	mov	r2, r0
    f892:	460b      	mov	r3, r1
    f894:	4630      	mov	r0, r6
    f896:	4639      	mov	r1, r7
    f898:	f7fc ff58 	bl	c74c <__adddf3>
    f89c:	4606      	mov	r6, r0
    f89e:	460f      	mov	r7, r1
    f8a0:	f7fd fbb6 	bl	d010 <__aeabi_d2iz>
    f8a4:	2200      	movs	r2, #0
    f8a6:	9004      	str	r0, [sp, #16]
    f8a8:	2300      	movs	r3, #0
    f8aa:	4630      	mov	r0, r6
    f8ac:	4639      	mov	r1, r7
    f8ae:	f7fd fb71 	bl	cf94 <__aeabi_dcmplt>
    f8b2:	2800      	cmp	r0, #0
    f8b4:	f040 8230 	bne.w	fd18 <_dtoa_r+0x5a8>
    f8b8:	9e04      	ldr	r6, [sp, #16]
    f8ba:	2e16      	cmp	r6, #22
    f8bc:	f200 8229 	bhi.w	fd12 <_dtoa_r+0x5a2>
    f8c0:	4b61      	ldr	r3, [pc, #388]	; (fa48 <_dtoa_r+0x2d8>)
    f8c2:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
    f8c6:	e9d3 0100 	ldrd	r0, r1, [r3]
    f8ca:	4652      	mov	r2, sl
    f8cc:	465b      	mov	r3, fp
    f8ce:	f7fd fb7f 	bl	cfd0 <__aeabi_dcmpgt>
    f8d2:	2800      	cmp	r0, #0
    f8d4:	f000 8249 	beq.w	fd6a <_dtoa_r+0x5fa>
    f8d8:	1e73      	subs	r3, r6, #1
    f8da:	9304      	str	r3, [sp, #16]
    f8dc:	2300      	movs	r3, #0
    f8de:	930c      	str	r3, [sp, #48]	; 0x30
    f8e0:	1b2c      	subs	r4, r5, r4
    f8e2:	1e63      	subs	r3, r4, #1
    f8e4:	9302      	str	r3, [sp, #8]
    f8e6:	f100 8232 	bmi.w	fd4e <_dtoa_r+0x5de>
    f8ea:	2300      	movs	r3, #0
    f8ec:	9305      	str	r3, [sp, #20]
    f8ee:	9b04      	ldr	r3, [sp, #16]
    f8f0:	2b00      	cmp	r3, #0
    f8f2:	f2c0 8223 	blt.w	fd3c <_dtoa_r+0x5cc>
    f8f6:	9a02      	ldr	r2, [sp, #8]
    f8f8:	930b      	str	r3, [sp, #44]	; 0x2c
    f8fa:	4611      	mov	r1, r2
    f8fc:	4419      	add	r1, r3
    f8fe:	2300      	movs	r3, #0
    f900:	9102      	str	r1, [sp, #8]
    f902:	930a      	str	r3, [sp, #40]	; 0x28
    f904:	9b20      	ldr	r3, [sp, #128]	; 0x80
    f906:	2b09      	cmp	r3, #9
    f908:	d829      	bhi.n	f95e <_dtoa_r+0x1ee>
    f90a:	2b05      	cmp	r3, #5
    f90c:	f340 8658 	ble.w	105c0 <_dtoa_r+0xe50>
    f910:	3b04      	subs	r3, #4
    f912:	9320      	str	r3, [sp, #128]	; 0x80
    f914:	2500      	movs	r5, #0
    f916:	9b20      	ldr	r3, [sp, #128]	; 0x80
    f918:	3b02      	subs	r3, #2
    f91a:	2b03      	cmp	r3, #3
    f91c:	f200 8635 	bhi.w	1058a <_dtoa_r+0xe1a>
    f920:	e8df f013 	tbh	[pc, r3, lsl #1]
    f924:	0228032c 	.word	0x0228032c
    f928:	04590337 	.word	0x04590337
    f92c:	4b44      	ldr	r3, [pc, #272]	; (fa40 <_dtoa_r+0x2d0>)
    f92e:	4a47      	ldr	r2, [pc, #284]	; (fa4c <_dtoa_r+0x2dc>)
    f930:	f3c8 0013 	ubfx	r0, r8, #0, #20
    f934:	2800      	cmp	r0, #0
    f936:	bf14      	ite	ne
    f938:	4618      	movne	r0, r3
    f93a:	4610      	moveq	r0, r2
    f93c:	e755      	b.n	f7ea <_dtoa_r+0x7a>
    f93e:	f3cb 0313 	ubfx	r3, fp, #0, #20
    f942:	f043 517f 	orr.w	r1, r3, #1069547520	; 0x3fc00000
    f946:	9510      	str	r5, [sp, #64]	; 0x40
    f948:	4650      	mov	r0, sl
    f94a:	f2a4 34ff 	subw	r4, r4, #1023	; 0x3ff
    f94e:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
    f952:	9d14      	ldr	r5, [sp, #80]	; 0x50
    f954:	e784      	b.n	f860 <_dtoa_r+0xf0>
    f956:	483e      	ldr	r0, [pc, #248]	; (fa50 <_dtoa_r+0x2e0>)
    f958:	e73b      	b.n	f7d2 <_dtoa_r+0x62>
    f95a:	1cc3      	adds	r3, r0, #3
    f95c:	e74e      	b.n	f7fc <_dtoa_r+0x8c>
    f95e:	2100      	movs	r1, #0
    f960:	f8c9 1044 	str.w	r1, [r9, #68]	; 0x44
    f964:	4648      	mov	r0, r9
    f966:	9120      	str	r1, [sp, #128]	; 0x80
    f968:	f7ff fb2e 	bl	efc8 <_Balloc>
    f96c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    f970:	9306      	str	r3, [sp, #24]
    f972:	9a20      	ldr	r2, [sp, #128]	; 0x80
    f974:	930d      	str	r3, [sp, #52]	; 0x34
    f976:	2301      	movs	r3, #1
    f978:	9007      	str	r0, [sp, #28]
    f97a:	9221      	str	r2, [sp, #132]	; 0x84
    f97c:	f8c9 0040 	str.w	r0, [r9, #64]	; 0x40
    f980:	9309      	str	r3, [sp, #36]	; 0x24
    f982:	9b15      	ldr	r3, [sp, #84]	; 0x54
    f984:	2b00      	cmp	r3, #0
    f986:	f2c0 80d1 	blt.w	fb2c <_dtoa_r+0x3bc>
    f98a:	9a04      	ldr	r2, [sp, #16]
    f98c:	2a0e      	cmp	r2, #14
    f98e:	f300 80cd 	bgt.w	fb2c <_dtoa_r+0x3bc>
    f992:	4b2d      	ldr	r3, [pc, #180]	; (fa48 <_dtoa_r+0x2d8>)
    f994:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    f998:	e9d3 3400 	ldrd	r3, r4, [r3]
    f99c:	e9cd 3402 	strd	r3, r4, [sp, #8]
    f9a0:	9b21      	ldr	r3, [sp, #132]	; 0x84
    f9a2:	2b00      	cmp	r3, #0
    f9a4:	f2c0 8300 	blt.w	ffa8 <_dtoa_r+0x838>
    f9a8:	4656      	mov	r6, sl
    f9aa:	465f      	mov	r7, fp
    f9ac:	4650      	mov	r0, sl
    f9ae:	4659      	mov	r1, fp
    f9b0:	e9dd ab02 	ldrd	sl, fp, [sp, #8]
    f9b4:	4652      	mov	r2, sl
    f9b6:	465b      	mov	r3, fp
    f9b8:	f7fd f9a4 	bl	cd04 <__aeabi_ddiv>
    f9bc:	f7fd fb28 	bl	d010 <__aeabi_d2iz>
    f9c0:	4604      	mov	r4, r0
    f9c2:	f7fd f80f 	bl	c9e4 <__aeabi_i2d>
    f9c6:	4652      	mov	r2, sl
    f9c8:	465b      	mov	r3, fp
    f9ca:	f7fd f871 	bl	cab0 <__aeabi_dmul>
    f9ce:	460b      	mov	r3, r1
    f9d0:	4602      	mov	r2, r0
    f9d2:	4639      	mov	r1, r7
    f9d4:	4630      	mov	r0, r6
    f9d6:	f7fc feb7 	bl	c748 <__aeabi_dsub>
    f9da:	9d07      	ldr	r5, [sp, #28]
    f9dc:	f104 0330 	add.w	r3, r4, #48	; 0x30
    f9e0:	702b      	strb	r3, [r5, #0]
    f9e2:	9b06      	ldr	r3, [sp, #24]
    f9e4:	2b01      	cmp	r3, #1
    f9e6:	4606      	mov	r6, r0
    f9e8:	460f      	mov	r7, r1
    f9ea:	f105 0501 	add.w	r5, r5, #1
    f9ee:	d062      	beq.n	fab6 <_dtoa_r+0x346>
    f9f0:	2200      	movs	r2, #0
    f9f2:	4b18      	ldr	r3, [pc, #96]	; (fa54 <_dtoa_r+0x2e4>)
    f9f4:	f7fd f85c 	bl	cab0 <__aeabi_dmul>
    f9f8:	2200      	movs	r2, #0
    f9fa:	2300      	movs	r3, #0
    f9fc:	4606      	mov	r6, r0
    f9fe:	460f      	mov	r7, r1
    fa00:	f7fd fabe 	bl	cf80 <__aeabi_dcmpeq>
    fa04:	2800      	cmp	r0, #0
    fa06:	d17e      	bne.n	fb06 <_dtoa_r+0x396>
    fa08:	f8cd 9014 	str.w	r9, [sp, #20]
    fa0c:	f8dd a018 	ldr.w	sl, [sp, #24]
    fa10:	f8dd b01c 	ldr.w	fp, [sp, #28]
    fa14:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
    fa18:	e029      	b.n	fa6e <_dtoa_r+0x2fe>
    fa1a:	bf00      	nop
    fa1c:	f3af 8000 	nop.w
    fa20:	636f4361 	.word	0x636f4361
    fa24:	3fd287a7 	.word	0x3fd287a7
    fa28:	8b60c8b3 	.word	0x8b60c8b3
    fa2c:	3fc68a28 	.word	0x3fc68a28
    fa30:	509f79fb 	.word	0x509f79fb
    fa34:	3fd34413 	.word	0x3fd34413
    fa38:	7ff00000 	.word	0x7ff00000
    fa3c:	00010fa9 	.word	0x00010fa9
    fa40:	00022004 	.word	0x00022004
    fa44:	3ff80000 	.word	0x3ff80000
    fa48:	00021ef8 	.word	0x00021ef8
    fa4c:	00021ff8 	.word	0x00021ff8
    fa50:	00010fa8 	.word	0x00010fa8
    fa54:	40240000 	.word	0x40240000
    fa58:	f7fd f82a 	bl	cab0 <__aeabi_dmul>
    fa5c:	2200      	movs	r2, #0
    fa5e:	2300      	movs	r3, #0
    fa60:	4606      	mov	r6, r0
    fa62:	460f      	mov	r7, r1
    fa64:	f7fd fa8c 	bl	cf80 <__aeabi_dcmpeq>
    fa68:	2800      	cmp	r0, #0
    fa6a:	f040 83b7 	bne.w	101dc <_dtoa_r+0xa6c>
    fa6e:	4642      	mov	r2, r8
    fa70:	464b      	mov	r3, r9
    fa72:	4630      	mov	r0, r6
    fa74:	4639      	mov	r1, r7
    fa76:	f7fd f945 	bl	cd04 <__aeabi_ddiv>
    fa7a:	f7fd fac9 	bl	d010 <__aeabi_d2iz>
    fa7e:	4604      	mov	r4, r0
    fa80:	f7fc ffb0 	bl	c9e4 <__aeabi_i2d>
    fa84:	4642      	mov	r2, r8
    fa86:	464b      	mov	r3, r9
    fa88:	f7fd f812 	bl	cab0 <__aeabi_dmul>
    fa8c:	4602      	mov	r2, r0
    fa8e:	460b      	mov	r3, r1
    fa90:	4630      	mov	r0, r6
    fa92:	4639      	mov	r1, r7
    fa94:	f7fc fe58 	bl	c748 <__aeabi_dsub>
    fa98:	f104 0e30 	add.w	lr, r4, #48	; 0x30
    fa9c:	f805 eb01 	strb.w	lr, [r5], #1
    faa0:	ebcb 0e05 	rsb	lr, fp, r5
    faa4:	45d6      	cmp	lr, sl
    faa6:	4606      	mov	r6, r0
    faa8:	460f      	mov	r7, r1
    faaa:	f04f 0200 	mov.w	r2, #0
    faae:	4bb0      	ldr	r3, [pc, #704]	; (fd70 <_dtoa_r+0x600>)
    fab0:	d1d2      	bne.n	fa58 <_dtoa_r+0x2e8>
    fab2:	f8dd 9014 	ldr.w	r9, [sp, #20]
    fab6:	4632      	mov	r2, r6
    fab8:	463b      	mov	r3, r7
    faba:	4630      	mov	r0, r6
    fabc:	4639      	mov	r1, r7
    fabe:	f7fc fe45 	bl	c74c <__adddf3>
    fac2:	4606      	mov	r6, r0
    fac4:	460f      	mov	r7, r1
    fac6:	4602      	mov	r2, r0
    fac8:	460b      	mov	r3, r1
    faca:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    face:	f7fd fa61 	bl	cf94 <__aeabi_dcmplt>
    fad2:	b940      	cbnz	r0, fae6 <_dtoa_r+0x376>
    fad4:	4632      	mov	r2, r6
    fad6:	463b      	mov	r3, r7
    fad8:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    fadc:	f7fd fa50 	bl	cf80 <__aeabi_dcmpeq>
    fae0:	b188      	cbz	r0, fb06 <_dtoa_r+0x396>
    fae2:	07e3      	lsls	r3, r4, #31
    fae4:	d50f      	bpl.n	fb06 <_dtoa_r+0x396>
    fae6:	f815 4c01 	ldrb.w	r4, [r5, #-1]
    faea:	9a07      	ldr	r2, [sp, #28]
    faec:	1e6b      	subs	r3, r5, #1
    faee:	e004      	b.n	fafa <_dtoa_r+0x38a>
    faf0:	429a      	cmp	r2, r3
    faf2:	f000 842c 	beq.w	1034e <_dtoa_r+0xbde>
    faf6:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
    fafa:	2c39      	cmp	r4, #57	; 0x39
    fafc:	f103 0501 	add.w	r5, r3, #1
    fb00:	d0f6      	beq.n	faf0 <_dtoa_r+0x380>
    fb02:	3401      	adds	r4, #1
    fb04:	701c      	strb	r4, [r3, #0]
    fb06:	9908      	ldr	r1, [sp, #32]
    fb08:	4648      	mov	r0, r9
    fb0a:	f7ff fa83 	bl	f014 <_Bfree>
    fb0e:	2200      	movs	r2, #0
    fb10:	9b04      	ldr	r3, [sp, #16]
    fb12:	702a      	strb	r2, [r5, #0]
    fb14:	9a22      	ldr	r2, [sp, #136]	; 0x88
    fb16:	3301      	adds	r3, #1
    fb18:	6013      	str	r3, [r2, #0]
    fb1a:	9b24      	ldr	r3, [sp, #144]	; 0x90
    fb1c:	2b00      	cmp	r3, #0
    fb1e:	f000 83a7 	beq.w	10270 <_dtoa_r+0xb00>
    fb22:	9807      	ldr	r0, [sp, #28]
    fb24:	601d      	str	r5, [r3, #0]
    fb26:	b017      	add	sp, #92	; 0x5c
    fb28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fb2c:	9a09      	ldr	r2, [sp, #36]	; 0x24
    fb2e:	2a00      	cmp	r2, #0
    fb30:	f000 8112 	beq.w	fd58 <_dtoa_r+0x5e8>
    fb34:	9a20      	ldr	r2, [sp, #128]	; 0x80
    fb36:	2a01      	cmp	r2, #1
    fb38:	f340 8258 	ble.w	ffec <_dtoa_r+0x87c>
    fb3c:	9b06      	ldr	r3, [sp, #24]
    fb3e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    fb40:	1e5f      	subs	r7, r3, #1
    fb42:	42ba      	cmp	r2, r7
    fb44:	f2c0 8397 	blt.w	10276 <_dtoa_r+0xb06>
    fb48:	1bd7      	subs	r7, r2, r7
    fb4a:	9b06      	ldr	r3, [sp, #24]
    fb4c:	2b00      	cmp	r3, #0
    fb4e:	f2c0 848a 	blt.w	10466 <_dtoa_r+0xcf6>
    fb52:	9d05      	ldr	r5, [sp, #20]
    fb54:	9b06      	ldr	r3, [sp, #24]
    fb56:	9a05      	ldr	r2, [sp, #20]
    fb58:	441a      	add	r2, r3
    fb5a:	9205      	str	r2, [sp, #20]
    fb5c:	9a02      	ldr	r2, [sp, #8]
    fb5e:	2101      	movs	r1, #1
    fb60:	441a      	add	r2, r3
    fb62:	4648      	mov	r0, r9
    fb64:	9202      	str	r2, [sp, #8]
    fb66:	f7ff faed 	bl	f144 <__i2b>
    fb6a:	4606      	mov	r6, r0
    fb6c:	b165      	cbz	r5, fb88 <_dtoa_r+0x418>
    fb6e:	9902      	ldr	r1, [sp, #8]
    fb70:	2900      	cmp	r1, #0
    fb72:	460b      	mov	r3, r1
    fb74:	dd08      	ble.n	fb88 <_dtoa_r+0x418>
    fb76:	42a9      	cmp	r1, r5
    fb78:	9a05      	ldr	r2, [sp, #20]
    fb7a:	bfa8      	it	ge
    fb7c:	462b      	movge	r3, r5
    fb7e:	1ad2      	subs	r2, r2, r3
    fb80:	1aed      	subs	r5, r5, r3
    fb82:	1acb      	subs	r3, r1, r3
    fb84:	9205      	str	r2, [sp, #20]
    fb86:	9302      	str	r3, [sp, #8]
    fb88:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fb8a:	2b00      	cmp	r3, #0
    fb8c:	f340 82fc 	ble.w	10188 <_dtoa_r+0xa18>
    fb90:	9a09      	ldr	r2, [sp, #36]	; 0x24
    fb92:	2a00      	cmp	r2, #0
    fb94:	f000 8201 	beq.w	ff9a <_dtoa_r+0x82a>
    fb98:	2f00      	cmp	r7, #0
    fb9a:	f000 81fe 	beq.w	ff9a <_dtoa_r+0x82a>
    fb9e:	4631      	mov	r1, r6
    fba0:	463a      	mov	r2, r7
    fba2:	4648      	mov	r0, r9
    fba4:	f7ff fb70 	bl	f288 <__pow5mult>
    fba8:	f8dd 8020 	ldr.w	r8, [sp, #32]
    fbac:	4601      	mov	r1, r0
    fbae:	4642      	mov	r2, r8
    fbb0:	4606      	mov	r6, r0
    fbb2:	4648      	mov	r0, r9
    fbb4:	f7ff fad0 	bl	f158 <__multiply>
    fbb8:	4641      	mov	r1, r8
    fbba:	4604      	mov	r4, r0
    fbbc:	4648      	mov	r0, r9
    fbbe:	f7ff fa29 	bl	f014 <_Bfree>
    fbc2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fbc4:	1bdb      	subs	r3, r3, r7
    fbc6:	930a      	str	r3, [sp, #40]	; 0x28
    fbc8:	f040 81e6 	bne.w	ff98 <_dtoa_r+0x828>
    fbcc:	2101      	movs	r1, #1
    fbce:	4648      	mov	r0, r9
    fbd0:	f7ff fab8 	bl	f144 <__i2b>
    fbd4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    fbd6:	4680      	mov	r8, r0
    fbd8:	2b00      	cmp	r3, #0
    fbda:	f000 8219 	beq.w	10010 <_dtoa_r+0x8a0>
    fbde:	4601      	mov	r1, r0
    fbe0:	461a      	mov	r2, r3
    fbe2:	4648      	mov	r0, r9
    fbe4:	f7ff fb50 	bl	f288 <__pow5mult>
    fbe8:	9b20      	ldr	r3, [sp, #128]	; 0x80
    fbea:	2b01      	cmp	r3, #1
    fbec:	4680      	mov	r8, r0
    fbee:	f340 82f8 	ble.w	101e2 <_dtoa_r+0xa72>
    fbf2:	2700      	movs	r7, #0
    fbf4:	f8d8 3010 	ldr.w	r3, [r8, #16]
    fbf8:	eb08 0383 	add.w	r3, r8, r3, lsl #2
    fbfc:	6918      	ldr	r0, [r3, #16]
    fbfe:	f7ff fa53 	bl	f0a8 <__hi0bits>
    fc02:	f1c0 0020 	rsb	r0, r0, #32
    fc06:	9a02      	ldr	r2, [sp, #8]
    fc08:	4410      	add	r0, r2
    fc0a:	f010 001f 	ands.w	r0, r0, #31
    fc0e:	f000 81f6 	beq.w	fffe <_dtoa_r+0x88e>
    fc12:	f1c0 0320 	rsb	r3, r0, #32
    fc16:	2b04      	cmp	r3, #4
    fc18:	f340 84ca 	ble.w	105b0 <_dtoa_r+0xe40>
    fc1c:	9b05      	ldr	r3, [sp, #20]
    fc1e:	f1c0 001c 	rsb	r0, r0, #28
    fc22:	4403      	add	r3, r0
    fc24:	9305      	str	r3, [sp, #20]
    fc26:	4613      	mov	r3, r2
    fc28:	4403      	add	r3, r0
    fc2a:	4405      	add	r5, r0
    fc2c:	9302      	str	r3, [sp, #8]
    fc2e:	9b05      	ldr	r3, [sp, #20]
    fc30:	2b00      	cmp	r3, #0
    fc32:	dd05      	ble.n	fc40 <_dtoa_r+0x4d0>
    fc34:	4621      	mov	r1, r4
    fc36:	461a      	mov	r2, r3
    fc38:	4648      	mov	r0, r9
    fc3a:	f7ff fb75 	bl	f328 <__lshift>
    fc3e:	4604      	mov	r4, r0
    fc40:	9b02      	ldr	r3, [sp, #8]
    fc42:	2b00      	cmp	r3, #0
    fc44:	dd05      	ble.n	fc52 <_dtoa_r+0x4e2>
    fc46:	4641      	mov	r1, r8
    fc48:	461a      	mov	r2, r3
    fc4a:	4648      	mov	r0, r9
    fc4c:	f7ff fb6c 	bl	f328 <__lshift>
    fc50:	4680      	mov	r8, r0
    fc52:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    fc54:	2b00      	cmp	r3, #0
    fc56:	f040 827c 	bne.w	10152 <_dtoa_r+0x9e2>
    fc5a:	9b06      	ldr	r3, [sp, #24]
    fc5c:	2b00      	cmp	r3, #0
    fc5e:	f340 8295 	ble.w	1018c <_dtoa_r+0xa1c>
    fc62:	9b09      	ldr	r3, [sp, #36]	; 0x24
    fc64:	2b00      	cmp	r3, #0
    fc66:	f040 81f5 	bne.w	10054 <_dtoa_r+0x8e4>
    fc6a:	f8dd b01c 	ldr.w	fp, [sp, #28]
    fc6e:	9f06      	ldr	r7, [sp, #24]
    fc70:	465d      	mov	r5, fp
    fc72:	e002      	b.n	fc7a <_dtoa_r+0x50a>
    fc74:	f7ff f9d8 	bl	f028 <__multadd>
    fc78:	4604      	mov	r4, r0
    fc7a:	4641      	mov	r1, r8
    fc7c:	4620      	mov	r0, r4
    fc7e:	f7ff fce1 	bl	f644 <quorem>
    fc82:	f100 0a30 	add.w	sl, r0, #48	; 0x30
    fc86:	f805 ab01 	strb.w	sl, [r5], #1
    fc8a:	ebcb 0305 	rsb	r3, fp, r5
    fc8e:	42bb      	cmp	r3, r7
    fc90:	f04f 020a 	mov.w	r2, #10
    fc94:	f04f 0300 	mov.w	r3, #0
    fc98:	4621      	mov	r1, r4
    fc9a:	4648      	mov	r0, r9
    fc9c:	dbea      	blt.n	fc74 <_dtoa_r+0x504>
    fc9e:	9b07      	ldr	r3, [sp, #28]
    fca0:	9a06      	ldr	r2, [sp, #24]
    fca2:	2a01      	cmp	r2, #1
    fca4:	bfac      	ite	ge
    fca6:	189b      	addge	r3, r3, r2
    fca8:	3301      	addlt	r3, #1
    fcaa:	461d      	mov	r5, r3
    fcac:	f04f 0b00 	mov.w	fp, #0
    fcb0:	4621      	mov	r1, r4
    fcb2:	2201      	movs	r2, #1
    fcb4:	4648      	mov	r0, r9
    fcb6:	f7ff fb37 	bl	f328 <__lshift>
    fcba:	4641      	mov	r1, r8
    fcbc:	9008      	str	r0, [sp, #32]
    fcbe:	f7ff fb8b 	bl	f3d8 <__mcmp>
    fcc2:	2800      	cmp	r0, #0
    fcc4:	f340 830d 	ble.w	102e2 <_dtoa_r+0xb72>
    fcc8:	f815 2c01 	ldrb.w	r2, [r5, #-1]
    fccc:	9907      	ldr	r1, [sp, #28]
    fcce:	1e6b      	subs	r3, r5, #1
    fcd0:	e004      	b.n	fcdc <_dtoa_r+0x56c>
    fcd2:	428b      	cmp	r3, r1
    fcd4:	f000 8278 	beq.w	101c8 <_dtoa_r+0xa58>
    fcd8:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
    fcdc:	2a39      	cmp	r2, #57	; 0x39
    fcde:	f103 0501 	add.w	r5, r3, #1
    fce2:	d0f6      	beq.n	fcd2 <_dtoa_r+0x562>
    fce4:	3201      	adds	r2, #1
    fce6:	701a      	strb	r2, [r3, #0]
    fce8:	4641      	mov	r1, r8
    fcea:	4648      	mov	r0, r9
    fcec:	f7ff f992 	bl	f014 <_Bfree>
    fcf0:	2e00      	cmp	r6, #0
    fcf2:	f43f af08 	beq.w	fb06 <_dtoa_r+0x396>
    fcf6:	f1bb 0f00 	cmp.w	fp, #0
    fcfa:	d005      	beq.n	fd08 <_dtoa_r+0x598>
    fcfc:	45b3      	cmp	fp, r6
    fcfe:	d003      	beq.n	fd08 <_dtoa_r+0x598>
    fd00:	4659      	mov	r1, fp
    fd02:	4648      	mov	r0, r9
    fd04:	f7ff f986 	bl	f014 <_Bfree>
    fd08:	4631      	mov	r1, r6
    fd0a:	4648      	mov	r0, r9
    fd0c:	f7ff f982 	bl	f014 <_Bfree>
    fd10:	e6f9      	b.n	fb06 <_dtoa_r+0x396>
    fd12:	2301      	movs	r3, #1
    fd14:	930c      	str	r3, [sp, #48]	; 0x30
    fd16:	e5e3      	b.n	f8e0 <_dtoa_r+0x170>
    fd18:	f8dd 8010 	ldr.w	r8, [sp, #16]
    fd1c:	4640      	mov	r0, r8
    fd1e:	f7fc fe61 	bl	c9e4 <__aeabi_i2d>
    fd22:	4602      	mov	r2, r0
    fd24:	460b      	mov	r3, r1
    fd26:	4630      	mov	r0, r6
    fd28:	4639      	mov	r1, r7
    fd2a:	f7fd f929 	bl	cf80 <__aeabi_dcmpeq>
    fd2e:	2800      	cmp	r0, #0
    fd30:	f47f adc2 	bne.w	f8b8 <_dtoa_r+0x148>
    fd34:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
    fd38:	9304      	str	r3, [sp, #16]
    fd3a:	e5bd      	b.n	f8b8 <_dtoa_r+0x148>
    fd3c:	9a05      	ldr	r2, [sp, #20]
    fd3e:	9b04      	ldr	r3, [sp, #16]
    fd40:	1ad2      	subs	r2, r2, r3
    fd42:	425b      	negs	r3, r3
    fd44:	930a      	str	r3, [sp, #40]	; 0x28
    fd46:	2300      	movs	r3, #0
    fd48:	9205      	str	r2, [sp, #20]
    fd4a:	930b      	str	r3, [sp, #44]	; 0x2c
    fd4c:	e5da      	b.n	f904 <_dtoa_r+0x194>
    fd4e:	425b      	negs	r3, r3
    fd50:	9305      	str	r3, [sp, #20]
    fd52:	2300      	movs	r3, #0
    fd54:	9302      	str	r3, [sp, #8]
    fd56:	e5ca      	b.n	f8ee <_dtoa_r+0x17e>
    fd58:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    fd5a:	9d05      	ldr	r5, [sp, #20]
    fd5c:	9e09      	ldr	r6, [sp, #36]	; 0x24
    fd5e:	e705      	b.n	fb6c <_dtoa_r+0x3fc>
    fd60:	f1c3 0820 	rsb	r8, r3, #32
    fd64:	fa0a f008 	lsl.w	r0, sl, r8
    fd68:	e573      	b.n	f852 <_dtoa_r+0xe2>
    fd6a:	900c      	str	r0, [sp, #48]	; 0x30
    fd6c:	e5b8      	b.n	f8e0 <_dtoa_r+0x170>
    fd6e:	bf00      	nop
    fd70:	40240000 	.word	0x40240000
    fd74:	2300      	movs	r3, #0
    fd76:	9309      	str	r3, [sp, #36]	; 0x24
    fd78:	9b04      	ldr	r3, [sp, #16]
    fd7a:	9a21      	ldr	r2, [sp, #132]	; 0x84
    fd7c:	4413      	add	r3, r2
    fd7e:	930d      	str	r3, [sp, #52]	; 0x34
    fd80:	3301      	adds	r3, #1
    fd82:	2b00      	cmp	r3, #0
    fd84:	9306      	str	r3, [sp, #24]
    fd86:	f340 8283 	ble.w	10290 <_dtoa_r+0xb20>
    fd8a:	9c06      	ldr	r4, [sp, #24]
    fd8c:	4626      	mov	r6, r4
    fd8e:	2100      	movs	r1, #0
    fd90:	2e17      	cmp	r6, #23
    fd92:	f8c9 1044 	str.w	r1, [r9, #68]	; 0x44
    fd96:	d90b      	bls.n	fdb0 <_dtoa_r+0x640>
    fd98:	2201      	movs	r2, #1
    fd9a:	2304      	movs	r3, #4
    fd9c:	005b      	lsls	r3, r3, #1
    fd9e:	f103 0014 	add.w	r0, r3, #20
    fda2:	42b0      	cmp	r0, r6
    fda4:	4611      	mov	r1, r2
    fda6:	f102 0201 	add.w	r2, r2, #1
    fdaa:	d9f7      	bls.n	fd9c <_dtoa_r+0x62c>
    fdac:	f8c9 1044 	str.w	r1, [r9, #68]	; 0x44
    fdb0:	4648      	mov	r0, r9
    fdb2:	f7ff f909 	bl	efc8 <_Balloc>
    fdb6:	2c0e      	cmp	r4, #14
    fdb8:	9007      	str	r0, [sp, #28]
    fdba:	f8c9 0040 	str.w	r0, [r9, #64]	; 0x40
    fdbe:	f63f ade0 	bhi.w	f982 <_dtoa_r+0x212>
    fdc2:	2d00      	cmp	r5, #0
    fdc4:	f43f addd 	beq.w	f982 <_dtoa_r+0x212>
    fdc8:	9904      	ldr	r1, [sp, #16]
    fdca:	4657      	mov	r7, sl
    fdcc:	46d8      	mov	r8, fp
    fdce:	2900      	cmp	r1, #0
    fdd0:	e9cd 780e 	strd	r7, r8, [sp, #56]	; 0x38
    fdd4:	f340 8292 	ble.w	102fc <_dtoa_r+0xb8c>
    fdd8:	4b91      	ldr	r3, [pc, #580]	; (10020 <_dtoa_r+0x8b0>)
    fdda:	f001 020f 	and.w	r2, r1, #15
    fdde:	110e      	asrs	r6, r1, #4
    fde0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    fde4:	06f0      	lsls	r0, r6, #27
    fde6:	e9d3 4500 	ldrd	r4, r5, [r3]
    fdea:	f140 824c 	bpl.w	10286 <_dtoa_r+0xb16>
    fdee:	4b8d      	ldr	r3, [pc, #564]	; (10024 <_dtoa_r+0x8b4>)
    fdf0:	4650      	mov	r0, sl
    fdf2:	4659      	mov	r1, fp
    fdf4:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
    fdf8:	f7fc ff84 	bl	cd04 <__aeabi_ddiv>
    fdfc:	f006 060f 	and.w	r6, r6, #15
    fe00:	4682      	mov	sl, r0
    fe02:	468b      	mov	fp, r1
    fe04:	f04f 0803 	mov.w	r8, #3
    fe08:	b186      	cbz	r6, fe2c <_dtoa_r+0x6bc>
    fe0a:	4f86      	ldr	r7, [pc, #536]	; (10024 <_dtoa_r+0x8b4>)
    fe0c:	07f1      	lsls	r1, r6, #31
    fe0e:	d509      	bpl.n	fe24 <_dtoa_r+0x6b4>
    fe10:	4620      	mov	r0, r4
    fe12:	4629      	mov	r1, r5
    fe14:	e9d7 2300 	ldrd	r2, r3, [r7]
    fe18:	f7fc fe4a 	bl	cab0 <__aeabi_dmul>
    fe1c:	f108 0801 	add.w	r8, r8, #1
    fe20:	4604      	mov	r4, r0
    fe22:	460d      	mov	r5, r1
    fe24:	1076      	asrs	r6, r6, #1
    fe26:	f107 0708 	add.w	r7, r7, #8
    fe2a:	d1ef      	bne.n	fe0c <_dtoa_r+0x69c>
    fe2c:	4622      	mov	r2, r4
    fe2e:	462b      	mov	r3, r5
    fe30:	4650      	mov	r0, sl
    fe32:	4659      	mov	r1, fp
    fe34:	f7fc ff66 	bl	cd04 <__aeabi_ddiv>
    fe38:	4606      	mov	r6, r0
    fe3a:	460f      	mov	r7, r1
    fe3c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    fe3e:	b143      	cbz	r3, fe52 <_dtoa_r+0x6e2>
    fe40:	2200      	movs	r2, #0
    fe42:	4b79      	ldr	r3, [pc, #484]	; (10028 <_dtoa_r+0x8b8>)
    fe44:	4630      	mov	r0, r6
    fe46:	4639      	mov	r1, r7
    fe48:	f7fd f8a4 	bl	cf94 <__aeabi_dcmplt>
    fe4c:	2800      	cmp	r0, #0
    fe4e:	f040 8320 	bne.w	10492 <_dtoa_r+0xd22>
    fe52:	4640      	mov	r0, r8
    fe54:	f7fc fdc6 	bl	c9e4 <__aeabi_i2d>
    fe58:	4632      	mov	r2, r6
    fe5a:	463b      	mov	r3, r7
    fe5c:	f7fc fe28 	bl	cab0 <__aeabi_dmul>
    fe60:	4b72      	ldr	r3, [pc, #456]	; (1002c <_dtoa_r+0x8bc>)
    fe62:	2200      	movs	r2, #0
    fe64:	f7fc fc72 	bl	c74c <__adddf3>
    fe68:	9b06      	ldr	r3, [sp, #24]
    fe6a:	4604      	mov	r4, r0
    fe6c:	f1a1 7550 	sub.w	r5, r1, #54525952	; 0x3400000
    fe70:	2b00      	cmp	r3, #0
    fe72:	f000 81df 	beq.w	10234 <_dtoa_r+0xac4>
    fe76:	9b04      	ldr	r3, [sp, #16]
    fe78:	f8dd 8018 	ldr.w	r8, [sp, #24]
    fe7c:	9311      	str	r3, [sp, #68]	; 0x44
    fe7e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    fe80:	2b00      	cmp	r3, #0
    fe82:	f000 8297 	beq.w	103b4 <_dtoa_r+0xc44>
    fe86:	4b66      	ldr	r3, [pc, #408]	; (10020 <_dtoa_r+0x8b0>)
    fe88:	4969      	ldr	r1, [pc, #420]	; (10030 <_dtoa_r+0x8c0>)
    fe8a:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
    fe8e:	e953 2302 	ldrd	r2, r3, [r3, #-8]
    fe92:	2000      	movs	r0, #0
    fe94:	f7fc ff36 	bl	cd04 <__aeabi_ddiv>
    fe98:	4622      	mov	r2, r4
    fe9a:	462b      	mov	r3, r5
    fe9c:	f7fc fc54 	bl	c748 <__aeabi_dsub>
    fea0:	4682      	mov	sl, r0
    fea2:	468b      	mov	fp, r1
    fea4:	4630      	mov	r0, r6
    fea6:	4639      	mov	r1, r7
    fea8:	f7fd f8b2 	bl	d010 <__aeabi_d2iz>
    feac:	4604      	mov	r4, r0
    feae:	f7fc fd99 	bl	c9e4 <__aeabi_i2d>
    feb2:	4602      	mov	r2, r0
    feb4:	460b      	mov	r3, r1
    feb6:	4630      	mov	r0, r6
    feb8:	4639      	mov	r1, r7
    feba:	f7fc fc45 	bl	c748 <__aeabi_dsub>
    febe:	3430      	adds	r4, #48	; 0x30
    fec0:	9d07      	ldr	r5, [sp, #28]
    fec2:	b2e4      	uxtb	r4, r4
    fec4:	4606      	mov	r6, r0
    fec6:	460f      	mov	r7, r1
    fec8:	702c      	strb	r4, [r5, #0]
    feca:	4602      	mov	r2, r0
    fecc:	460b      	mov	r3, r1
    fece:	4650      	mov	r0, sl
    fed0:	4659      	mov	r1, fp
    fed2:	3501      	adds	r5, #1
    fed4:	f7fd f87c 	bl	cfd0 <__aeabi_dcmpgt>
    fed8:	2800      	cmp	r0, #0
    feda:	d14c      	bne.n	ff76 <_dtoa_r+0x806>
    fedc:	4632      	mov	r2, r6
    fede:	463b      	mov	r3, r7
    fee0:	2000      	movs	r0, #0
    fee2:	4951      	ldr	r1, [pc, #324]	; (10028 <_dtoa_r+0x8b8>)
    fee4:	f7fc fc30 	bl	c748 <__aeabi_dsub>
    fee8:	4602      	mov	r2, r0
    feea:	460b      	mov	r3, r1
    feec:	4650      	mov	r0, sl
    feee:	4659      	mov	r1, fp
    fef0:	f7fd f86e 	bl	cfd0 <__aeabi_dcmpgt>
    fef4:	2800      	cmp	r0, #0
    fef6:	f040 830d 	bne.w	10514 <_dtoa_r+0xda4>
    fefa:	f1b8 0f01 	cmp.w	r8, #1
    fefe:	f340 81b3 	ble.w	10268 <_dtoa_r+0xaf8>
    ff02:	9b07      	ldr	r3, [sp, #28]
    ff04:	4498      	add	r8, r3
    ff06:	e00d      	b.n	ff24 <_dtoa_r+0x7b4>
    ff08:	2000      	movs	r0, #0
    ff0a:	4947      	ldr	r1, [pc, #284]	; (10028 <_dtoa_r+0x8b8>)
    ff0c:	f7fc fc1c 	bl	c748 <__aeabi_dsub>
    ff10:	4652      	mov	r2, sl
    ff12:	465b      	mov	r3, fp
    ff14:	f7fd f83e 	bl	cf94 <__aeabi_dcmplt>
    ff18:	2800      	cmp	r0, #0
    ff1a:	f040 82fb 	bne.w	10514 <_dtoa_r+0xda4>
    ff1e:	4545      	cmp	r5, r8
    ff20:	f000 81a2 	beq.w	10268 <_dtoa_r+0xaf8>
    ff24:	4650      	mov	r0, sl
    ff26:	4659      	mov	r1, fp
    ff28:	2200      	movs	r2, #0
    ff2a:	4b42      	ldr	r3, [pc, #264]	; (10034 <_dtoa_r+0x8c4>)
    ff2c:	f7fc fdc0 	bl	cab0 <__aeabi_dmul>
    ff30:	2200      	movs	r2, #0
    ff32:	4b40      	ldr	r3, [pc, #256]	; (10034 <_dtoa_r+0x8c4>)
    ff34:	4682      	mov	sl, r0
    ff36:	468b      	mov	fp, r1
    ff38:	4630      	mov	r0, r6
    ff3a:	4639      	mov	r1, r7
    ff3c:	f7fc fdb8 	bl	cab0 <__aeabi_dmul>
    ff40:	460f      	mov	r7, r1
    ff42:	4606      	mov	r6, r0
    ff44:	f7fd f864 	bl	d010 <__aeabi_d2iz>
    ff48:	4604      	mov	r4, r0
    ff4a:	f7fc fd4b 	bl	c9e4 <__aeabi_i2d>
    ff4e:	4602      	mov	r2, r0
    ff50:	460b      	mov	r3, r1
    ff52:	4630      	mov	r0, r6
    ff54:	4639      	mov	r1, r7
    ff56:	f7fc fbf7 	bl	c748 <__aeabi_dsub>
    ff5a:	3430      	adds	r4, #48	; 0x30
    ff5c:	b2e4      	uxtb	r4, r4
    ff5e:	4652      	mov	r2, sl
    ff60:	465b      	mov	r3, fp
    ff62:	f805 4b01 	strb.w	r4, [r5], #1
    ff66:	4606      	mov	r6, r0
    ff68:	460f      	mov	r7, r1
    ff6a:	f7fd f813 	bl	cf94 <__aeabi_dcmplt>
    ff6e:	4632      	mov	r2, r6
    ff70:	463b      	mov	r3, r7
    ff72:	2800      	cmp	r0, #0
    ff74:	d0c8      	beq.n	ff08 <_dtoa_r+0x798>
    ff76:	9b11      	ldr	r3, [sp, #68]	; 0x44
    ff78:	9304      	str	r3, [sp, #16]
    ff7a:	e5c4      	b.n	fb06 <_dtoa_r+0x396>
    ff7c:	2300      	movs	r3, #0
    ff7e:	9309      	str	r3, [sp, #36]	; 0x24
    ff80:	9b21      	ldr	r3, [sp, #132]	; 0x84
    ff82:	2b00      	cmp	r3, #0
    ff84:	f340 8189 	ble.w	1029a <_dtoa_r+0xb2a>
    ff88:	461e      	mov	r6, r3
    ff8a:	461c      	mov	r4, r3
    ff8c:	930d      	str	r3, [sp, #52]	; 0x34
    ff8e:	9306      	str	r3, [sp, #24]
    ff90:	e6fd      	b.n	fd8e <_dtoa_r+0x61e>
    ff92:	2301      	movs	r3, #1
    ff94:	9309      	str	r3, [sp, #36]	; 0x24
    ff96:	e7f3      	b.n	ff80 <_dtoa_r+0x810>
    ff98:	9408      	str	r4, [sp, #32]
    ff9a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    ff9c:	9908      	ldr	r1, [sp, #32]
    ff9e:	4648      	mov	r0, r9
    ffa0:	f7ff f972 	bl	f288 <__pow5mult>
    ffa4:	4604      	mov	r4, r0
    ffa6:	e611      	b.n	fbcc <_dtoa_r+0x45c>
    ffa8:	9b06      	ldr	r3, [sp, #24]
    ffaa:	2b00      	cmp	r3, #0
    ffac:	f73f acfc 	bgt.w	f9a8 <_dtoa_r+0x238>
    ffb0:	f040 82da 	bne.w	10568 <_dtoa_r+0xdf8>
    ffb4:	2200      	movs	r2, #0
    ffb6:	4b20      	ldr	r3, [pc, #128]	; (10038 <_dtoa_r+0x8c8>)
    ffb8:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    ffbc:	f7fc fd78 	bl	cab0 <__aeabi_dmul>
    ffc0:	4652      	mov	r2, sl
    ffc2:	465b      	mov	r3, fp
    ffc4:	f7fc fffa 	bl	cfbc <__aeabi_dcmpge>
    ffc8:	f8dd 8018 	ldr.w	r8, [sp, #24]
    ffcc:	4646      	mov	r6, r8
    ffce:	2800      	cmp	r0, #0
    ffd0:	f000 80f2 	beq.w	101b8 <_dtoa_r+0xa48>
    ffd4:	9b21      	ldr	r3, [sp, #132]	; 0x84
    ffd6:	9d07      	ldr	r5, [sp, #28]
    ffd8:	43db      	mvns	r3, r3
    ffda:	9304      	str	r3, [sp, #16]
    ffdc:	4641      	mov	r1, r8
    ffde:	4648      	mov	r0, r9
    ffe0:	f7ff f818 	bl	f014 <_Bfree>
    ffe4:	2e00      	cmp	r6, #0
    ffe6:	f43f ad8e 	beq.w	fb06 <_dtoa_r+0x396>
    ffea:	e68d      	b.n	fd08 <_dtoa_r+0x598>
    ffec:	9a10      	ldr	r2, [sp, #64]	; 0x40
    ffee:	2a00      	cmp	r2, #0
    fff0:	f000 8241 	beq.w	10476 <_dtoa_r+0xd06>
    fff4:	f203 4333 	addw	r3, r3, #1075	; 0x433
    fff8:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    fffa:	9d05      	ldr	r5, [sp, #20]
    fffc:	e5ab      	b.n	fb56 <_dtoa_r+0x3e6>
    fffe:	201c      	movs	r0, #28
   10000:	9b05      	ldr	r3, [sp, #20]
   10002:	4403      	add	r3, r0
   10004:	9305      	str	r3, [sp, #20]
   10006:	9b02      	ldr	r3, [sp, #8]
   10008:	4403      	add	r3, r0
   1000a:	4405      	add	r5, r0
   1000c:	9302      	str	r3, [sp, #8]
   1000e:	e60e      	b.n	fc2e <_dtoa_r+0x4be>
   10010:	9b20      	ldr	r3, [sp, #128]	; 0x80
   10012:	2b01      	cmp	r3, #1
   10014:	f340 8282 	ble.w	1051c <_dtoa_r+0xdac>
   10018:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
   1001a:	2001      	movs	r0, #1
   1001c:	e5f3      	b.n	fc06 <_dtoa_r+0x496>
   1001e:	bf00      	nop
   10020:	00021ef8 	.word	0x00021ef8
   10024:	00021fd0 	.word	0x00021fd0
   10028:	3ff00000 	.word	0x3ff00000
   1002c:	401c0000 	.word	0x401c0000
   10030:	3fe00000 	.word	0x3fe00000
   10034:	40240000 	.word	0x40240000
   10038:	40140000 	.word	0x40140000
   1003c:	4631      	mov	r1, r6
   1003e:	2300      	movs	r3, #0
   10040:	220a      	movs	r2, #10
   10042:	4648      	mov	r0, r9
   10044:	f7fe fff0 	bl	f028 <__multadd>
   10048:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1004a:	2b00      	cmp	r3, #0
   1004c:	4606      	mov	r6, r0
   1004e:	f340 8297 	ble.w	10580 <_dtoa_r+0xe10>
   10052:	9306      	str	r3, [sp, #24]
   10054:	2d00      	cmp	r5, #0
   10056:	dd05      	ble.n	10064 <_dtoa_r+0x8f4>
   10058:	4631      	mov	r1, r6
   1005a:	462a      	mov	r2, r5
   1005c:	4648      	mov	r0, r9
   1005e:	f7ff f963 	bl	f328 <__lshift>
   10062:	4606      	mov	r6, r0
   10064:	2f00      	cmp	r7, #0
   10066:	f040 817c 	bne.w	10362 <_dtoa_r+0xbf2>
   1006a:	9605      	str	r6, [sp, #20]
   1006c:	9b06      	ldr	r3, [sp, #24]
   1006e:	9a07      	ldr	r2, [sp, #28]
   10070:	f8dd b014 	ldr.w	fp, [sp, #20]
   10074:	3b01      	subs	r3, #1
   10076:	18d3      	adds	r3, r2, r3
   10078:	9308      	str	r3, [sp, #32]
   1007a:	f00a 0301 	and.w	r3, sl, #1
   1007e:	9309      	str	r3, [sp, #36]	; 0x24
   10080:	4617      	mov	r7, r2
   10082:	46c2      	mov	sl, r8
   10084:	4651      	mov	r1, sl
   10086:	4620      	mov	r0, r4
   10088:	f7ff fadc 	bl	f644 <quorem>
   1008c:	4631      	mov	r1, r6
   1008e:	4605      	mov	r5, r0
   10090:	4620      	mov	r0, r4
   10092:	f7ff f9a1 	bl	f3d8 <__mcmp>
   10096:	465a      	mov	r2, fp
   10098:	9002      	str	r0, [sp, #8]
   1009a:	4651      	mov	r1, sl
   1009c:	4648      	mov	r0, r9
   1009e:	f7ff f9bb 	bl	f418 <__mdiff>
   100a2:	68c2      	ldr	r2, [r0, #12]
   100a4:	4680      	mov	r8, r0
   100a6:	f105 0330 	add.w	r3, r5, #48	; 0x30
   100aa:	2a00      	cmp	r2, #0
   100ac:	d149      	bne.n	10142 <_dtoa_r+0x9d2>
   100ae:	4601      	mov	r1, r0
   100b0:	4620      	mov	r0, r4
   100b2:	9306      	str	r3, [sp, #24]
   100b4:	f7ff f990 	bl	f3d8 <__mcmp>
   100b8:	4641      	mov	r1, r8
   100ba:	9005      	str	r0, [sp, #20]
   100bc:	4648      	mov	r0, r9
   100be:	f7fe ffa9 	bl	f014 <_Bfree>
   100c2:	9a05      	ldr	r2, [sp, #20]
   100c4:	9b06      	ldr	r3, [sp, #24]
   100c6:	b92a      	cbnz	r2, 100d4 <_dtoa_r+0x964>
   100c8:	9920      	ldr	r1, [sp, #128]	; 0x80
   100ca:	b919      	cbnz	r1, 100d4 <_dtoa_r+0x964>
   100cc:	9909      	ldr	r1, [sp, #36]	; 0x24
   100ce:	2900      	cmp	r1, #0
   100d0:	f000 8236 	beq.w	10540 <_dtoa_r+0xdd0>
   100d4:	9902      	ldr	r1, [sp, #8]
   100d6:	2900      	cmp	r1, #0
   100d8:	f2c0 80e4 	blt.w	102a4 <_dtoa_r+0xb34>
   100dc:	d105      	bne.n	100ea <_dtoa_r+0x97a>
   100de:	9920      	ldr	r1, [sp, #128]	; 0x80
   100e0:	b919      	cbnz	r1, 100ea <_dtoa_r+0x97a>
   100e2:	9909      	ldr	r1, [sp, #36]	; 0x24
   100e4:	2900      	cmp	r1, #0
   100e6:	f000 80dd 	beq.w	102a4 <_dtoa_r+0xb34>
   100ea:	2a00      	cmp	r2, #0
   100ec:	f300 814d 	bgt.w	1038a <_dtoa_r+0xc1a>
   100f0:	9a08      	ldr	r2, [sp, #32]
   100f2:	703b      	strb	r3, [r7, #0]
   100f4:	f107 0801 	add.w	r8, r7, #1
   100f8:	4297      	cmp	r7, r2
   100fa:	4645      	mov	r5, r8
   100fc:	f000 8154 	beq.w	103a8 <_dtoa_r+0xc38>
   10100:	4621      	mov	r1, r4
   10102:	2300      	movs	r3, #0
   10104:	220a      	movs	r2, #10
   10106:	4648      	mov	r0, r9
   10108:	f7fe ff8e 	bl	f028 <__multadd>
   1010c:	455e      	cmp	r6, fp
   1010e:	4604      	mov	r4, r0
   10110:	4631      	mov	r1, r6
   10112:	f04f 0300 	mov.w	r3, #0
   10116:	f04f 020a 	mov.w	r2, #10
   1011a:	4648      	mov	r0, r9
   1011c:	d00b      	beq.n	10136 <_dtoa_r+0x9c6>
   1011e:	f7fe ff83 	bl	f028 <__multadd>
   10122:	4659      	mov	r1, fp
   10124:	4606      	mov	r6, r0
   10126:	2300      	movs	r3, #0
   10128:	220a      	movs	r2, #10
   1012a:	4648      	mov	r0, r9
   1012c:	f7fe ff7c 	bl	f028 <__multadd>
   10130:	4647      	mov	r7, r8
   10132:	4683      	mov	fp, r0
   10134:	e7a6      	b.n	10084 <_dtoa_r+0x914>
   10136:	f7fe ff77 	bl	f028 <__multadd>
   1013a:	4647      	mov	r7, r8
   1013c:	4606      	mov	r6, r0
   1013e:	4683      	mov	fp, r0
   10140:	e7a0      	b.n	10084 <_dtoa_r+0x914>
   10142:	4601      	mov	r1, r0
   10144:	4648      	mov	r0, r9
   10146:	9305      	str	r3, [sp, #20]
   10148:	f7fe ff64 	bl	f014 <_Bfree>
   1014c:	2201      	movs	r2, #1
   1014e:	9b05      	ldr	r3, [sp, #20]
   10150:	e7c0      	b.n	100d4 <_dtoa_r+0x964>
   10152:	4641      	mov	r1, r8
   10154:	4620      	mov	r0, r4
   10156:	f7ff f93f 	bl	f3d8 <__mcmp>
   1015a:	2800      	cmp	r0, #0
   1015c:	f6bf ad7d 	bge.w	fc5a <_dtoa_r+0x4ea>
   10160:	4621      	mov	r1, r4
   10162:	9c04      	ldr	r4, [sp, #16]
   10164:	2300      	movs	r3, #0
   10166:	3c01      	subs	r4, #1
   10168:	220a      	movs	r2, #10
   1016a:	4648      	mov	r0, r9
   1016c:	9404      	str	r4, [sp, #16]
   1016e:	f7fe ff5b 	bl	f028 <__multadd>
   10172:	9b09      	ldr	r3, [sp, #36]	; 0x24
   10174:	4604      	mov	r4, r0
   10176:	2b00      	cmp	r3, #0
   10178:	f47f af60 	bne.w	1003c <_dtoa_r+0x8cc>
   1017c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1017e:	2b00      	cmp	r3, #0
   10180:	f340 81f6 	ble.w	10570 <_dtoa_r+0xe00>
   10184:	9306      	str	r3, [sp, #24]
   10186:	e570      	b.n	fc6a <_dtoa_r+0x4fa>
   10188:	9c08      	ldr	r4, [sp, #32]
   1018a:	e51f      	b.n	fbcc <_dtoa_r+0x45c>
   1018c:	9b20      	ldr	r3, [sp, #128]	; 0x80
   1018e:	2b02      	cmp	r3, #2
   10190:	f77f ad67 	ble.w	fc62 <_dtoa_r+0x4f2>
   10194:	9b06      	ldr	r3, [sp, #24]
   10196:	2b00      	cmp	r3, #0
   10198:	f040 8179 	bne.w	1048e <_dtoa_r+0xd1e>
   1019c:	4641      	mov	r1, r8
   1019e:	2205      	movs	r2, #5
   101a0:	4648      	mov	r0, r9
   101a2:	f7fe ff41 	bl	f028 <__multadd>
   101a6:	4601      	mov	r1, r0
   101a8:	4680      	mov	r8, r0
   101aa:	4620      	mov	r0, r4
   101ac:	f7ff f914 	bl	f3d8 <__mcmp>
   101b0:	2800      	cmp	r0, #0
   101b2:	9408      	str	r4, [sp, #32]
   101b4:	f77f af0e 	ble.w	ffd4 <_dtoa_r+0x864>
   101b8:	9a04      	ldr	r2, [sp, #16]
   101ba:	9907      	ldr	r1, [sp, #28]
   101bc:	2331      	movs	r3, #49	; 0x31
   101be:	3201      	adds	r2, #1
   101c0:	9204      	str	r2, [sp, #16]
   101c2:	700b      	strb	r3, [r1, #0]
   101c4:	1c4d      	adds	r5, r1, #1
   101c6:	e709      	b.n	ffdc <_dtoa_r+0x86c>
   101c8:	9a04      	ldr	r2, [sp, #16]
   101ca:	3201      	adds	r2, #1
   101cc:	9204      	str	r2, [sp, #16]
   101ce:	9a07      	ldr	r2, [sp, #28]
   101d0:	2331      	movs	r3, #49	; 0x31
   101d2:	7013      	strb	r3, [r2, #0]
   101d4:	e588      	b.n	fce8 <_dtoa_r+0x578>
   101d6:	2301      	movs	r3, #1
   101d8:	9309      	str	r3, [sp, #36]	; 0x24
   101da:	e5cd      	b.n	fd78 <_dtoa_r+0x608>
   101dc:	f8dd 9014 	ldr.w	r9, [sp, #20]
   101e0:	e491      	b.n	fb06 <_dtoa_r+0x396>
   101e2:	f1ba 0f00 	cmp.w	sl, #0
   101e6:	f47f ad04 	bne.w	fbf2 <_dtoa_r+0x482>
   101ea:	f3cb 0313 	ubfx	r3, fp, #0, #20
   101ee:	2b00      	cmp	r3, #0
   101f0:	f040 813f 	bne.w	10472 <_dtoa_r+0xd02>
   101f4:	f02b 4700 	bic.w	r7, fp, #2147483648	; 0x80000000
   101f8:	0d3f      	lsrs	r7, r7, #20
   101fa:	053f      	lsls	r7, r7, #20
   101fc:	b137      	cbz	r7, 1020c <_dtoa_r+0xa9c>
   101fe:	9b05      	ldr	r3, [sp, #20]
   10200:	3301      	adds	r3, #1
   10202:	9305      	str	r3, [sp, #20]
   10204:	9b02      	ldr	r3, [sp, #8]
   10206:	3301      	adds	r3, #1
   10208:	9302      	str	r3, [sp, #8]
   1020a:	2701      	movs	r7, #1
   1020c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1020e:	2001      	movs	r0, #1
   10210:	2b00      	cmp	r3, #0
   10212:	f43f acf8 	beq.w	fc06 <_dtoa_r+0x496>
   10216:	e4ed      	b.n	fbf4 <_dtoa_r+0x484>
   10218:	4640      	mov	r0, r8
   1021a:	f7fc fbe3 	bl	c9e4 <__aeabi_i2d>
   1021e:	4632      	mov	r2, r6
   10220:	463b      	mov	r3, r7
   10222:	f7fc fc45 	bl	cab0 <__aeabi_dmul>
   10226:	2200      	movs	r2, #0
   10228:	4bbf      	ldr	r3, [pc, #764]	; (10528 <_dtoa_r+0xdb8>)
   1022a:	f7fc fa8f 	bl	c74c <__adddf3>
   1022e:	4604      	mov	r4, r0
   10230:	f1a1 7550 	sub.w	r5, r1, #54525952	; 0x3400000
   10234:	4630      	mov	r0, r6
   10236:	4639      	mov	r1, r7
   10238:	2200      	movs	r2, #0
   1023a:	4bbc      	ldr	r3, [pc, #752]	; (1052c <_dtoa_r+0xdbc>)
   1023c:	f7fc fa84 	bl	c748 <__aeabi_dsub>
   10240:	4622      	mov	r2, r4
   10242:	462b      	mov	r3, r5
   10244:	4606      	mov	r6, r0
   10246:	460f      	mov	r7, r1
   10248:	f7fc fec2 	bl	cfd0 <__aeabi_dcmpgt>
   1024c:	4680      	mov	r8, r0
   1024e:	2800      	cmp	r0, #0
   10250:	f040 8105 	bne.w	1045e <_dtoa_r+0xcee>
   10254:	4622      	mov	r2, r4
   10256:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
   1025a:	4630      	mov	r0, r6
   1025c:	4639      	mov	r1, r7
   1025e:	f7fc fe99 	bl	cf94 <__aeabi_dcmplt>
   10262:	b108      	cbz	r0, 10268 <_dtoa_r+0xaf8>
   10264:	4646      	mov	r6, r8
   10266:	e6b5      	b.n	ffd4 <_dtoa_r+0x864>
   10268:	e9dd ab0e 	ldrd	sl, fp, [sp, #56]	; 0x38
   1026c:	f7ff bb89 	b.w	f982 <_dtoa_r+0x212>
   10270:	9807      	ldr	r0, [sp, #28]
   10272:	f7ff baae 	b.w	f7d2 <_dtoa_r+0x62>
   10276:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   10278:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1027a:	970a      	str	r7, [sp, #40]	; 0x28
   1027c:	1afb      	subs	r3, r7, r3
   1027e:	441a      	add	r2, r3
   10280:	920b      	str	r2, [sp, #44]	; 0x2c
   10282:	2700      	movs	r7, #0
   10284:	e461      	b.n	fb4a <_dtoa_r+0x3da>
   10286:	e9dd ab0e 	ldrd	sl, fp, [sp, #56]	; 0x38
   1028a:	f04f 0802 	mov.w	r8, #2
   1028e:	e5bb      	b.n	fe08 <_dtoa_r+0x698>
   10290:	461c      	mov	r4, r3
   10292:	2100      	movs	r1, #0
   10294:	f8c9 1044 	str.w	r1, [r9, #68]	; 0x44
   10298:	e58a      	b.n	fdb0 <_dtoa_r+0x640>
   1029a:	2401      	movs	r4, #1
   1029c:	9421      	str	r4, [sp, #132]	; 0x84
   1029e:	940d      	str	r4, [sp, #52]	; 0x34
   102a0:	9406      	str	r4, [sp, #24]
   102a2:	e7f6      	b.n	10292 <_dtoa_r+0xb22>
   102a4:	2a00      	cmp	r2, #0
   102a6:	46d0      	mov	r8, sl
   102a8:	f8cd b014 	str.w	fp, [sp, #20]
   102ac:	469a      	mov	sl, r3
   102ae:	dd11      	ble.n	102d4 <_dtoa_r+0xb64>
   102b0:	4621      	mov	r1, r4
   102b2:	2201      	movs	r2, #1
   102b4:	4648      	mov	r0, r9
   102b6:	f7ff f837 	bl	f328 <__lshift>
   102ba:	4641      	mov	r1, r8
   102bc:	4604      	mov	r4, r0
   102be:	f7ff f88b 	bl	f3d8 <__mcmp>
   102c2:	2800      	cmp	r0, #0
   102c4:	f340 8149 	ble.w	1055a <_dtoa_r+0xdea>
   102c8:	f1ba 0f39 	cmp.w	sl, #57	; 0x39
   102cc:	f000 8106 	beq.w	104dc <_dtoa_r+0xd6c>
   102d0:	f105 0a31 	add.w	sl, r5, #49	; 0x31
   102d4:	46b3      	mov	fp, r6
   102d6:	f887 a000 	strb.w	sl, [r7]
   102da:	1c7d      	adds	r5, r7, #1
   102dc:	9e05      	ldr	r6, [sp, #20]
   102de:	9408      	str	r4, [sp, #32]
   102e0:	e502      	b.n	fce8 <_dtoa_r+0x578>
   102e2:	d104      	bne.n	102ee <_dtoa_r+0xb7e>
   102e4:	f01a 0f01 	tst.w	sl, #1
   102e8:	d001      	beq.n	102ee <_dtoa_r+0xb7e>
   102ea:	e4ed      	b.n	fcc8 <_dtoa_r+0x558>
   102ec:	4615      	mov	r5, r2
   102ee:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   102f2:	2b30      	cmp	r3, #48	; 0x30
   102f4:	f105 32ff 	add.w	r2, r5, #4294967295	; 0xffffffff
   102f8:	d0f8      	beq.n	102ec <_dtoa_r+0xb7c>
   102fa:	e4f5      	b.n	fce8 <_dtoa_r+0x578>
   102fc:	9b04      	ldr	r3, [sp, #16]
   102fe:	425c      	negs	r4, r3
   10300:	2c00      	cmp	r4, #0
   10302:	f000 80bf 	beq.w	10484 <_dtoa_r+0xd14>
   10306:	4b8a      	ldr	r3, [pc, #552]	; (10530 <_dtoa_r+0xdc0>)
   10308:	f004 020f 	and.w	r2, r4, #15
   1030c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   10310:	e9d3 2300 	ldrd	r2, r3, [r3]
   10314:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
   10318:	f7fc fbca 	bl	cab0 <__aeabi_dmul>
   1031c:	1124      	asrs	r4, r4, #4
   1031e:	4606      	mov	r6, r0
   10320:	460f      	mov	r7, r1
   10322:	f000 812a 	beq.w	1057a <_dtoa_r+0xe0a>
   10326:	4d83      	ldr	r5, [pc, #524]	; (10534 <_dtoa_r+0xdc4>)
   10328:	f04f 0802 	mov.w	r8, #2
   1032c:	07e2      	lsls	r2, r4, #31
   1032e:	d509      	bpl.n	10344 <_dtoa_r+0xbd4>
   10330:	4630      	mov	r0, r6
   10332:	4639      	mov	r1, r7
   10334:	e9d5 2300 	ldrd	r2, r3, [r5]
   10338:	f7fc fbba 	bl	cab0 <__aeabi_dmul>
   1033c:	f108 0801 	add.w	r8, r8, #1
   10340:	4606      	mov	r6, r0
   10342:	460f      	mov	r7, r1
   10344:	1064      	asrs	r4, r4, #1
   10346:	f105 0508 	add.w	r5, r5, #8
   1034a:	d1ef      	bne.n	1032c <_dtoa_r+0xbbc>
   1034c:	e576      	b.n	fe3c <_dtoa_r+0x6cc>
   1034e:	9907      	ldr	r1, [sp, #28]
   10350:	2230      	movs	r2, #48	; 0x30
   10352:	700a      	strb	r2, [r1, #0]
   10354:	9a04      	ldr	r2, [sp, #16]
   10356:	f815 4c01 	ldrb.w	r4, [r5, #-1]
   1035a:	3201      	adds	r2, #1
   1035c:	9204      	str	r2, [sp, #16]
   1035e:	f7ff bbd0 	b.w	fb02 <_dtoa_r+0x392>
   10362:	6871      	ldr	r1, [r6, #4]
   10364:	4648      	mov	r0, r9
   10366:	f7fe fe2f 	bl	efc8 <_Balloc>
   1036a:	6933      	ldr	r3, [r6, #16]
   1036c:	1c9a      	adds	r2, r3, #2
   1036e:	4605      	mov	r5, r0
   10370:	0092      	lsls	r2, r2, #2
   10372:	f106 010c 	add.w	r1, r6, #12
   10376:	300c      	adds	r0, #12
   10378:	f7f9 fa9a 	bl	98b0 <memcpy>
   1037c:	4629      	mov	r1, r5
   1037e:	2201      	movs	r2, #1
   10380:	4648      	mov	r0, r9
   10382:	f7fe ffd1 	bl	f328 <__lshift>
   10386:	9005      	str	r0, [sp, #20]
   10388:	e670      	b.n	1006c <_dtoa_r+0x8fc>
   1038a:	2b39      	cmp	r3, #57	; 0x39
   1038c:	f8cd b014 	str.w	fp, [sp, #20]
   10390:	46d0      	mov	r8, sl
   10392:	f000 80a3 	beq.w	104dc <_dtoa_r+0xd6c>
   10396:	f103 0a01 	add.w	sl, r3, #1
   1039a:	46b3      	mov	fp, r6
   1039c:	f887 a000 	strb.w	sl, [r7]
   103a0:	1c7d      	adds	r5, r7, #1
   103a2:	9e05      	ldr	r6, [sp, #20]
   103a4:	9408      	str	r4, [sp, #32]
   103a6:	e49f      	b.n	fce8 <_dtoa_r+0x578>
   103a8:	465a      	mov	r2, fp
   103aa:	46d0      	mov	r8, sl
   103ac:	46b3      	mov	fp, r6
   103ae:	469a      	mov	sl, r3
   103b0:	4616      	mov	r6, r2
   103b2:	e47d      	b.n	fcb0 <_dtoa_r+0x540>
   103b4:	495e      	ldr	r1, [pc, #376]	; (10530 <_dtoa_r+0xdc0>)
   103b6:	f108 3aff 	add.w	sl, r8, #4294967295	; 0xffffffff
   103ba:	eb01 01ca 	add.w	r1, r1, sl, lsl #3
   103be:	4622      	mov	r2, r4
   103c0:	462b      	mov	r3, r5
   103c2:	e9d1 0100 	ldrd	r0, r1, [r1]
   103c6:	f7fc fb73 	bl	cab0 <__aeabi_dmul>
   103ca:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
   103ce:	4639      	mov	r1, r7
   103d0:	4630      	mov	r0, r6
   103d2:	f7fc fe1d 	bl	d010 <__aeabi_d2iz>
   103d6:	4604      	mov	r4, r0
   103d8:	f7fc fb04 	bl	c9e4 <__aeabi_i2d>
   103dc:	4602      	mov	r2, r0
   103de:	460b      	mov	r3, r1
   103e0:	4630      	mov	r0, r6
   103e2:	4639      	mov	r1, r7
   103e4:	f7fc f9b0 	bl	c748 <__aeabi_dsub>
   103e8:	9a07      	ldr	r2, [sp, #28]
   103ea:	3430      	adds	r4, #48	; 0x30
   103ec:	f1b8 0f01 	cmp.w	r8, #1
   103f0:	4606      	mov	r6, r0
   103f2:	460f      	mov	r7, r1
   103f4:	7014      	strb	r4, [r2, #0]
   103f6:	f102 0501 	add.w	r5, r2, #1
   103fa:	d01e      	beq.n	1043a <_dtoa_r+0xcca>
   103fc:	9b07      	ldr	r3, [sp, #28]
   103fe:	eb03 0b08 	add.w	fp, r3, r8
   10402:	46a8      	mov	r8, r5
   10404:	2200      	movs	r2, #0
   10406:	4b4c      	ldr	r3, [pc, #304]	; (10538 <_dtoa_r+0xdc8>)
   10408:	4630      	mov	r0, r6
   1040a:	4639      	mov	r1, r7
   1040c:	f7fc fb50 	bl	cab0 <__aeabi_dmul>
   10410:	460f      	mov	r7, r1
   10412:	4606      	mov	r6, r0
   10414:	f7fc fdfc 	bl	d010 <__aeabi_d2iz>
   10418:	4604      	mov	r4, r0
   1041a:	f7fc fae3 	bl	c9e4 <__aeabi_i2d>
   1041e:	3430      	adds	r4, #48	; 0x30
   10420:	4602      	mov	r2, r0
   10422:	460b      	mov	r3, r1
   10424:	4630      	mov	r0, r6
   10426:	4639      	mov	r1, r7
   10428:	f7fc f98e 	bl	c748 <__aeabi_dsub>
   1042c:	f808 4b01 	strb.w	r4, [r8], #1
   10430:	45c3      	cmp	fp, r8
   10432:	4606      	mov	r6, r0
   10434:	460f      	mov	r7, r1
   10436:	d1e5      	bne.n	10404 <_dtoa_r+0xc94>
   10438:	4455      	add	r5, sl
   1043a:	2200      	movs	r2, #0
   1043c:	4b3f      	ldr	r3, [pc, #252]	; (1053c <_dtoa_r+0xdcc>)
   1043e:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
   10442:	f7fc f983 	bl	c74c <__adddf3>
   10446:	4632      	mov	r2, r6
   10448:	463b      	mov	r3, r7
   1044a:	f7fc fda3 	bl	cf94 <__aeabi_dcmplt>
   1044e:	2800      	cmp	r0, #0
   10450:	d04c      	beq.n	104ec <_dtoa_r+0xd7c>
   10452:	9b11      	ldr	r3, [sp, #68]	; 0x44
   10454:	9304      	str	r3, [sp, #16]
   10456:	f815 4c01 	ldrb.w	r4, [r5, #-1]
   1045a:	f7ff bb46 	b.w	faea <_dtoa_r+0x37a>
   1045e:	f04f 0800 	mov.w	r8, #0
   10462:	4646      	mov	r6, r8
   10464:	e6a8      	b.n	101b8 <_dtoa_r+0xa48>
   10466:	9b05      	ldr	r3, [sp, #20]
   10468:	9a06      	ldr	r2, [sp, #24]
   1046a:	1a9d      	subs	r5, r3, r2
   1046c:	2300      	movs	r3, #0
   1046e:	f7ff bb72 	b.w	fb56 <_dtoa_r+0x3e6>
   10472:	2700      	movs	r7, #0
   10474:	e6ca      	b.n	1020c <_dtoa_r+0xa9c>
   10476:	9b14      	ldr	r3, [sp, #80]	; 0x50
   10478:	9f0a      	ldr	r7, [sp, #40]	; 0x28
   1047a:	9d05      	ldr	r5, [sp, #20]
   1047c:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
   10480:	f7ff bb69 	b.w	fb56 <_dtoa_r+0x3e6>
   10484:	e9dd 670e 	ldrd	r6, r7, [sp, #56]	; 0x38
   10488:	f04f 0802 	mov.w	r8, #2
   1048c:	e4d6      	b.n	fe3c <_dtoa_r+0x6cc>
   1048e:	9408      	str	r4, [sp, #32]
   10490:	e5a0      	b.n	ffd4 <_dtoa_r+0x864>
   10492:	9b06      	ldr	r3, [sp, #24]
   10494:	2b00      	cmp	r3, #0
   10496:	f43f aebf 	beq.w	10218 <_dtoa_r+0xaa8>
   1049a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1049c:	2b00      	cmp	r3, #0
   1049e:	f77f aee3 	ble.w	10268 <_dtoa_r+0xaf8>
   104a2:	2200      	movs	r2, #0
   104a4:	4b24      	ldr	r3, [pc, #144]	; (10538 <_dtoa_r+0xdc8>)
   104a6:	4630      	mov	r0, r6
   104a8:	4639      	mov	r1, r7
   104aa:	f7fc fb01 	bl	cab0 <__aeabi_dmul>
   104ae:	4606      	mov	r6, r0
   104b0:	460f      	mov	r7, r1
   104b2:	f108 0001 	add.w	r0, r8, #1
   104b6:	f7fc fa95 	bl	c9e4 <__aeabi_i2d>
   104ba:	4632      	mov	r2, r6
   104bc:	463b      	mov	r3, r7
   104be:	f7fc faf7 	bl	cab0 <__aeabi_dmul>
   104c2:	2200      	movs	r2, #0
   104c4:	4b18      	ldr	r3, [pc, #96]	; (10528 <_dtoa_r+0xdb8>)
   104c6:	f7fc f941 	bl	c74c <__adddf3>
   104ca:	9a04      	ldr	r2, [sp, #16]
   104cc:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
   104d0:	3a01      	subs	r2, #1
   104d2:	4604      	mov	r4, r0
   104d4:	f1a1 7550 	sub.w	r5, r1, #54525952	; 0x3400000
   104d8:	9211      	str	r2, [sp, #68]	; 0x44
   104da:	e4d0      	b.n	fe7e <_dtoa_r+0x70e>
   104dc:	2239      	movs	r2, #57	; 0x39
   104de:	46b3      	mov	fp, r6
   104e0:	9408      	str	r4, [sp, #32]
   104e2:	9e05      	ldr	r6, [sp, #20]
   104e4:	703a      	strb	r2, [r7, #0]
   104e6:	1c7d      	adds	r5, r7, #1
   104e8:	f7ff bbf0 	b.w	fccc <_dtoa_r+0x55c>
   104ec:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
   104f0:	2000      	movs	r0, #0
   104f2:	4912      	ldr	r1, [pc, #72]	; (1053c <_dtoa_r+0xdcc>)
   104f4:	f7fc f928 	bl	c748 <__aeabi_dsub>
   104f8:	4632      	mov	r2, r6
   104fa:	463b      	mov	r3, r7
   104fc:	f7fc fd68 	bl	cfd0 <__aeabi_dcmpgt>
   10500:	b908      	cbnz	r0, 10506 <_dtoa_r+0xd96>
   10502:	e6b1      	b.n	10268 <_dtoa_r+0xaf8>
   10504:	4615      	mov	r5, r2
   10506:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   1050a:	2b30      	cmp	r3, #48	; 0x30
   1050c:	f105 32ff 	add.w	r2, r5, #4294967295	; 0xffffffff
   10510:	d0f8      	beq.n	10504 <_dtoa_r+0xd94>
   10512:	e530      	b.n	ff76 <_dtoa_r+0x806>
   10514:	9b11      	ldr	r3, [sp, #68]	; 0x44
   10516:	9304      	str	r3, [sp, #16]
   10518:	f7ff bae7 	b.w	faea <_dtoa_r+0x37a>
   1051c:	f1ba 0f00 	cmp.w	sl, #0
   10520:	f47f ad7a 	bne.w	10018 <_dtoa_r+0x8a8>
   10524:	e661      	b.n	101ea <_dtoa_r+0xa7a>
   10526:	bf00      	nop
   10528:	401c0000 	.word	0x401c0000
   1052c:	40140000 	.word	0x40140000
   10530:	00021ef8 	.word	0x00021ef8
   10534:	00021fd0 	.word	0x00021fd0
   10538:	40240000 	.word	0x40240000
   1053c:	3fe00000 	.word	0x3fe00000
   10540:	2b39      	cmp	r3, #57	; 0x39
   10542:	f8cd b014 	str.w	fp, [sp, #20]
   10546:	46d0      	mov	r8, sl
   10548:	f8dd b008 	ldr.w	fp, [sp, #8]
   1054c:	469a      	mov	sl, r3
   1054e:	d0c5      	beq.n	104dc <_dtoa_r+0xd6c>
   10550:	f1bb 0f00 	cmp.w	fp, #0
   10554:	f73f aebc 	bgt.w	102d0 <_dtoa_r+0xb60>
   10558:	e6bc      	b.n	102d4 <_dtoa_r+0xb64>
   1055a:	f47f aebb 	bne.w	102d4 <_dtoa_r+0xb64>
   1055e:	f01a 0f01 	tst.w	sl, #1
   10562:	f43f aeb7 	beq.w	102d4 <_dtoa_r+0xb64>
   10566:	e6af      	b.n	102c8 <_dtoa_r+0xb58>
   10568:	f04f 0800 	mov.w	r8, #0
   1056c:	4646      	mov	r6, r8
   1056e:	e531      	b.n	ffd4 <_dtoa_r+0x864>
   10570:	9b20      	ldr	r3, [sp, #128]	; 0x80
   10572:	2b02      	cmp	r3, #2
   10574:	dc21      	bgt.n	105ba <_dtoa_r+0xe4a>
   10576:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   10578:	e604      	b.n	10184 <_dtoa_r+0xa14>
   1057a:	f04f 0802 	mov.w	r8, #2
   1057e:	e45d      	b.n	fe3c <_dtoa_r+0x6cc>
   10580:	9b20      	ldr	r3, [sp, #128]	; 0x80
   10582:	2b02      	cmp	r3, #2
   10584:	dc19      	bgt.n	105ba <_dtoa_r+0xe4a>
   10586:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   10588:	e563      	b.n	10052 <_dtoa_r+0x8e2>
   1058a:	2400      	movs	r4, #0
   1058c:	f8c9 4044 	str.w	r4, [r9, #68]	; 0x44
   10590:	4621      	mov	r1, r4
   10592:	4648      	mov	r0, r9
   10594:	f7fe fd18 	bl	efc8 <_Balloc>
   10598:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1059c:	9306      	str	r3, [sp, #24]
   1059e:	930d      	str	r3, [sp, #52]	; 0x34
   105a0:	2301      	movs	r3, #1
   105a2:	9007      	str	r0, [sp, #28]
   105a4:	9421      	str	r4, [sp, #132]	; 0x84
   105a6:	f8c9 0040 	str.w	r0, [r9, #64]	; 0x40
   105aa:	9309      	str	r3, [sp, #36]	; 0x24
   105ac:	f7ff b9e9 	b.w	f982 <_dtoa_r+0x212>
   105b0:	f43f ab3d 	beq.w	fc2e <_dtoa_r+0x4be>
   105b4:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
   105b8:	e522      	b.n	10000 <_dtoa_r+0x890>
   105ba:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   105bc:	9306      	str	r3, [sp, #24]
   105be:	e5e9      	b.n	10194 <_dtoa_r+0xa24>
   105c0:	2501      	movs	r5, #1
   105c2:	f7ff b9a8 	b.w	f916 <_dtoa_r+0x1a6>
   105c6:	bf00      	nop

000105c8 <vtable for AudioStream>:
	...
   105d0:	9a71 0000 6e69 6263 7479 2065 203a 0000     q...incbyte : ..
   105e0:	7420 6e6f 5f65 656c 6576 206c 093a 0000      tone_level :...
   105f0:	694c 6b6e 6465 6120 206e 7561 6964 206f     Linked an audio 
   10600:	6d61 6c70 6669 6569 2072 0000 6e09 746f     amplifier ...not
   10610:	5f65 7266 7165 7020 6f72 2f62 7266 7165     e_freq prob/freq
   10620:	093a 0000 5220 534d 7620 6c61 0973 0000     :... RMS vals...
   10630:	6564 746c 0961 0000 6120 6576 6172 6567     delta... average
   10640:	0009 0000 5020 6165 206b 6176 736c 0009     .... Peak vals..
   10650:	4620 6f72 746e 0020 5220 6165 2072 0000      Front . Rear ..
   10660:	202d 202d 202d 202d 202d 202d 202d 202d     - - - - - - - - 
   10670:	202d 0000 2d20 2d20 2d20 2d20 2d20 2d20     - .. - - - - - -
   10680:	2d20 2d20 2d20 2d20 000a 0000 2d2d 2d2d      - - - -....----
   10690:	2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 202d 0000     ------------- ..
   106a0:	2d20 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d      ---------------
   106b0:	2d2d 2d2d 0a2d 0000 7c7c 7c7c 7c7c 7c7c     -----...||||||||
   106c0:	7c7c 7c7c 7c7c 7c7c 207c 0000 7c20 7c7c     ||||||||| .. |||
   106d0:	7c7c 7c7c 7c7c 7c7c 7c7c 7c7c 7c7c 7c7c     ||||||||||||||||
   106e0:	0a7c 0000 202d 202d 202d 202d 202d 202d     |...- - - - - - 
   106f0:	202d 202d 202d 202d 202d 202d 202d 202d     - - - - - - - - 
   10700:	202d 202d 202d 202d 0a2d 0000 2d2d 2d2d     - - - - -...----
   10710:	2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     ----------------
   10720:	2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     ----------------
   10730:	0a2d 0000 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     -...------------
   10740:	2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     ----------------
   10750:	2d2d 2d2d 2d2d 2d2d 002d 0000 7c7c 7c7c     ---------...||||
   10760:	7c7c 7c7c 7c7c 7c7c 7c7c 7c7c 7c7c 7c7c     ||||||||||||||||
   10770:	7c7c 7c7c 7c7c 7c7c 7c7c 7c7c 7c7c 7c7c     ||||||||||||||||
   10780:	0a7c 0000 202d 202d 202d 202d 202d 202d     |...- - - - - - 
   10790:	202d 202d 202d 202d 202d 202d 202d 202d     - - - - - - - - 
   107a0:	202d 202d 202d 202d 002d 0000 7c7c 7c7c     - - - - -...||||
   107b0:	7c7c 7c7c 7c7c 7c7c 7c7c 7c7c 7c7c 7c7c     ||||||||||||||||
   107c0:	7c7c 7c7c 7c7c 7c7c 7c7c 7c7c 7c7c 7c7c     ||||||||||||||||
   107d0:	007c 0000 4f4e 4920 2044 5341 4953 4e47     |...NO ID ASSIGN
   107e0:	4445 5920 5445 0000 7243 6165 6574 2064     ED YET..Created 
   107f0:	2061 656e 2077 6f6c 676e 6420 7461 6c61     a new long datal
   10800:	676f 7720 7469 2068 2061 7473 7261 6974     og with a starti
   10810:	676e 7620 6c61 6575 6f20 2066 203a 0000     ng value of : ..
   10820:	6e20 746f 6120 7463 7669 2c65 6e20 746f      not active, not
   10830:	7520 6470 7461 6e69 0067 0000 7520 6470      updating... upd
   10840:	7461 6465 0020 0000 7541 6f74 6f6c 2067     ated ...Autolog 
   10850:	6564 6361 6974 6176 6574 2c64 6120 6c6c     deactivated, all
   10860:	636f 7461 6465 6d20 6d65 726f 2079 6168     ocated memory ha
   10870:	2073 6562 6e65 7520 6573 2064 7075 0000     s been used up..
   10880:	6c43 6165 6572 2064 6874 2065 0000 0000     Cleared the ....
   10890:	4420 7461 6c61 676f 0000 0000 7250 6e69      Datalog....Prin
   108a0:	6974 676e 7420 6568 0020 0000 6620 6f72     ting the ... fro
   108b0:	206d 7473 7261 2f74 6e65 2064 6461 7264     m start/end addr
   108c0:	3a20 0020 6469 3a78 0000 0000 6c6f 2f64      : .idx:....old/
   108d0:	656e 2077 0000 0000 5245 4f52 2052 202d     new ....ERROR - 
   108e0:	6f53 7272 2079 6163 276e 2074 7263 6165     Sorry can't crea
   108f0:	6574 6120 796e 6d20 726f 2065 6e6f 2d65     te any more one-
   10900:	666f 2066 6f6c 7367 202c 6874 7265 2065     off logs, there 
   10910:	7369 6e20 746f 6520 6f6e 6775 2068 6c61     is not enough al
   10920:	6f6c 6163 6574 2064 7073 6361 2065 6e6f     located space on
   10930:	7420 6568 4520 5045 4f52 204d 6f66 2072      the EEPROM for 
   10940:	6e6f 2d65 666f 2066 6f6c 6767 6e69 0067     one-off logging.
   10950:	6441 6964 676e 6120 6e20 7765 7320 6174     Adding a new sta
   10960:	6974 2063 6f6c 2067 6977 6874 7320 7a69     tic log with siz
   10970:	2065 2020 2020 2020 093a 0000 6572 616d     e       :...rema
   10980:	6e69 6e69 2067 7473 7461 6369 6c20 676f     ining static log
   10990:	2820 7561 6f74 6f6c 2967 7320 6170 6563      (autolog) space
   109a0:	2020 2020 093a 0000 7473 7261 6974 676e         :...starting
   109b0:	4520 5045 4f52 204d 6469 2078 2020 2020      EEPROM idx     
   109c0:	2020 2020 2020 2020 2020 2020 2020 2020                     
   109d0:	093a 0000 5245 4f52 2c52 4420 7461 6c61     :...ERROR, Datal
   109e0:	676f 4d20 6e61 6761 7265 6320 6e61 6f20     og Manager can o
   109f0:	6c6e 2079 6168 646e 656c 0020 6c20 676f     nly handle . log
   10a00:	2073 7461 6120 7420 6d69 2c65 7220 7365     s at a time, res
   10a10:	7465 6974 676e 6920 646e 7865 7420 206f     etting index to 
   10a20:	0030 0000 6441 6564 2064 6f6c 2067 6f74     0...Added log to
   10a30:	7420 6568 6420 7461 6d61 6e61 6761 7265      the datamanager
   10a40:	7520 646e 7265 7420 6d69 7265 0020 0000      under timer ...
   10a50:	6120 7463 7669 5f65 6f6c 7367 6e20 776f      active_logs now
   10a60:	203a 0000 6f6c 2067 7277 7469 6574 206e     : ..log written 
   10a70:	6e75 6564 2072 6e69 6564 2078 003a 0000     under index :...
   10a80:	6120 646e 7420 6568 6320 6e6f 6574 746e      and the content
   10a90:	2073 666f 7420 6568 6c20 676f 2820 7266     s of the log (fr
   10aa0:	6d6f 7420 6568 6c20 7361 2074 7572 746e     om the last runt
   10ab0:	6d69 2965 6920 2073 7361 6620 6c6f 6f6c     ime) is as follo
   10ac0:	7377 203a 0000 0000 5245 4f52 2052 202d     ws: ....ERROR - 
   10ad0:	6f73 7272 2079 6874 2065 7561 6f74 6f6c     sorry the autolo
   10ae0:	2067 7369 6e20 746f 6920 696e 6974 7461     g is not initiat
   10af0:	6465 6420 6575 7420 206f 2061 616c 6b63     ed due to a lack
   10b00:	6f20 2066 6572 616d 6e69 6e69 2067 4545      of remaining EE
   10b10:	5250 4d4f 7320 6170 6563 002e 6441 6964     PROM space..Addi
   10b20:	676e 6120 6e20 7765 4120 7475 4c6f 676f     ng a new AutoLog
   10b30:	0020 0000 7720 7469 2068 6973 657a 093a      ... with size:.
   10b40:	0000 0000 6572 616d 6e69 6e69 2067 7561     ....remaining au
   10b50:	6f74 6f6c 2067 7073 6361 2065 2020 2020     tolog space     
   10b60:	2020 093a 0000 0000 7473 7261 6974 676e       :.....starting
   10b70:	4520 5045 4f52 204d 6469 2078 2020 2020      EEPROM idx     
   10b80:	2020 2020 2020 093a 0000 0000 7277 7469           :.....writ
   10b90:	6574 206e 203d 0000 6f4c 2067 6469 2078     ten = ..Log idx 
   10ba0:	0000 0000 0970 0000 6c41 206c 6f4c 7367     ....p...All Logs
   10bb0:	5320 6f74 6572 2064 6e69 4520 5045 4f52      Stored in EEPRO
   10bc0:	004d 0000 2d2d 2d2d 2d2d 2d2d 2d2d 202d     M...----------- 
   10bd0:	7250 6e69 6974 676e 4f20 656e 6f2d 6666     Printing One-off
   10be0:	4c20 676f 2073 2d2d 2d2d 2d2d 2d2d 2d2d      Logs ----------
   10bf0:	2d2d 2d2d 0000 0000 2d2d 2d2d 2d2d 2d2d     ----....--------
   10c00:	2d2d 202d 7250 6e69 6974 676e 4120 7475     --- Printing Aut
   10c10:	206f 6e61 2064 7453 7461 6369 4c20 676f     o and Static Log
   10c20:	2073 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     s --------------
   10c30:	0000 0000 6946 696e 6873 6465 5020 6972     ....Finished Pri
   10c40:	746e 6e69 2067 4545 5250 4d4f 4320 6e6f     nting EEPROM Con
   10c50:	6574 746e 0073 0000 7250 6e69 6974 676e     tents...Printing
   10c60:	7420 6568 5420 6d69 7265 4320 6e6f 6966      the Timer Confi
   10c70:	7567 6172 6974 6e6f 2073 6f66 2072 6874     gurations for th
   10c80:	2065 6144 6174 6f6c 2067 614d 616e 6567     e Datalog Manage
   10c90:	0072 0000 6320 7275 6572 746e 203a 0000     r... current: ..
   10ca0:	6d09 7861 0009 0000 7473 7261 5f74 6564     .max....start_de
   10cb0:	616c 7379 2020 2020 2020 2020 2020 3a20     lays           :
   10cc0:	0009 0000 6572 616d 6e69 6e69 5f67 6f6c     ....remaining_lo
   10cd0:	7367 2020 2020 2020 2020 093a 0000 0000     gs        :.....
   10ce0:	6f6c 5f67 6572 7266 7365 5f68 656c 676e     log_refresh_leng
   10cf0:	6874 2020 3a20 0009 6f6c 5f67 6974 656d     th   :..log_time
   10d00:	5f72 616d 2070 2020 2020 2020 093a 0000     r_map       :...
   10d10:	2020 6572 2064 0020 6709 6572 6e65 2020       red  ..green  
   10d20:	0000 0000 6209 756c 2065 0020 2020 203d     .....blue  .  = 
   10d30:	0020 0000 6809 6575 0020 0000 7309 7461      ....hue ....sat
   10d40:	0020 0000 6209 7467 0020 0000 4f50 4557      ....bgt ...POWE
   10d50:	2052 4e4f 4d20 5345 4153 4547 5220 4345     R ON MESSAGE REC
   10d60:	4945 4556 0044 0000 6572 6573 2074 6874     EIVED...reset th
   10d70:	2065 656c 2064 6e6f 6f2f 6666 7220 7461     e led on/off rat
   10d80:	6f69 6320 756f 746e 7265 0073 7075 6164     io counters.upda
   10d90:	6574 2064 656c 2064 6e6f 6f2f 6666 7220     ted led on/off r
   10da0:	7461 6f69 0020 0000 3d09 0009 6320 6c6f     atio ....=.. col
   10db0:	726f 6957 6570 7220 7465 7275 696e 676e     orWipe returning
   10dc0:	6420 6575 6520 7478 6572 656d 6c20 7875      due extreme lux
   10dd0:	6320 6e6f 6964 6974 6e6f 0073 6320 6c6f      conditions. col
   10de0:	726f 6957 6570 7220 7465 7275 696e 676e     orWipe returning
   10df0:	6420 6575 7420 206f 6873 6e64 745f 6d69      due to shdn_tim
   10e00:	7265 3a20 0020 0000 4620 616c 6873 6220     er : ... Flash b
   10e10:	6f6c 6b63 6465 6320 6c6f 726f 6957 6570     locked colorWipe
   10e20:	0000 0000 5320 6174 7472 6e69 2067 6f63     .... Starting co
   10e30:	6f6c 5772 7069 2065 6e69 4e20 6f65 7247     lorWipe in NeoGr
   10e40:	756f 2070 202d 0000 6e20 6d75 705f 7869     oup - .. num_pix
   10e50:	6c65 3a73 0020 0000 2d20 0020 6620 6e69     els: ... - . fin
   10e60:	7369 6568 2064 7075 6164 6974 676e 7420     ished updating t
   10e70:	6568 6e20 6f65 6970 6578 736c 0000 0000     he neopixels....
   10e80:	7320 7465 6974 676e 6c20 6465 5f73 6e6f      setting leds_on
   10e90:	7420 206f 6166 736c 0065 0000 7320 7465      to false... set
   10ea0:	6974 676e 6c20 6465 5f73 6e6f 7420 206f     ting leds_on to 
   10eb0:	7274 6575 0000 0000 4620 616c 6873 664f     true.... FlashOf
   10ec0:	2066 203a 0000 0000 4620 414c 4853 4f20     f : .... FLASH O
   10ed0:	204e 0023 4620 616c 6873 6465 0020 0000     N #. Flashed ...
   10ee0:	4620 4d50 0020 0000 6c46 7361 2068 6b73      FPM ...Flash sk
   10ef0:	7069 6570 2064 7564 2065 6f74 4620 414c     ipped due to FLA
   10f00:	4853 445f 4245 554f 434e 5f45 4954 454d     SH_DEBOUNCE_TIME
   10f10:	3a20 0020 6c66 7361 2068 6564 616c 2079      : .flash delay 
   10f20:	0000 0000 2d2d 5420 7275 696e 676e 7420     ....-- Turning t
   10f30:	6568 4620 616c 6873 4f20 204e 2d2d 0000     he Flash ON --..
   10f40:	616c 7473 665f 616c 6873 3a20 0009 0000     last_flash :....
   10f50:	6572 616d 6e69 6e69 5f67 6c66 7361 5f68     remaining_flash_
   10f60:	6564 616c 2079 0000 6c43 6369 206b 6974     delay ..Click ti
   10f70:	656d 6f20 6576 2c72 7420 7275 696e 676e     me over, turning
   10f80:	6f20 6666 6620 616c 6873 0020 7075 6164      off flash .upda
   10f90:	6574 2064 616c 7473 665f 616c 6873 755f     ted last_flash_u
   10fa0:	6170 6574 7420 206f 0030 0000 5309 5548     pate to 0....SHU
   10fb0:	5454 4e49 2047 4f44 4e57 4720 4f52 5055     TTING DOWN GROUP
   10fc0:	0020 0000 4157 4e52 4e49 2047 4f43 4f4c      ...WARNING COLO
   10fd0:	2052 4957 4550 4420 454f 2053 4f4e 2054     R WIPE DOES NOT 
   10fe0:	4f44 4920 5354 4f20 4e57 4220 4952 4847     DO ITS OWN BRIGH
   10ff0:	4e54 5345 2053 4353 4c41 4e49 2047 4857     TNESS SCALING WH
   11000:	4e45 5320 4e49 4c47 2045 4e49 2054 5349     EN SINGLE INT IS
   11010:	5020 5341 4553 2044 4f54 4920 0054 0000      PASSED TO IT...
   11020:	6572 6573 2074 756c 5f78 6f74 6174 206c     reset lux_total 
   11030:	6e61 2064 756c 5f78 6572 6461 6e69 7367     and lux_readings
   11040:	0000 0000 756c 2078 0000 0000 7220 6165     ....lux .... rea
   11050:	6964 676e 6520 7272 726f 203a 0000 0000     ding error: ....
   11060:	4e20 6f65 6970 6578 206c 7262 6769 7468      Neopixel bright
   11070:	656e 7373 7320 6163 656c 2072 6573 2074     ness scaler set 
   11080:	6f74 3020 302e 6420 6575 7420 206f 7865     to 0.0 due to ex
   11090:	7274 6d65 2065 756c 0078 0000 6920 2073     treme lux... is 
   110a0:	7267 6165 6574 2072 6874 6e61 7420 6568     greater than the
   110b0:	4d20 5841 4c5f 5855 545f 5248 5345 4f48      MAX_LUX_THRESHO
   110c0:	444c 202c 6573 7474 6e69 2067 7262 6769     LD, setting brig
   110d0:	7468 656e 7373 7320 6163 656c 2072 6f74     htness scaler to
   110e0:	4220 4952 4847 4e54 5345 5f53 4353 4c41      BRIGHTNESS_SCAL
   110f0:	5245 4d5f 5841 0000 6920 2073 7267 6165     ER_MAX.. is grea
   11100:	6574 2072 6874 6e61 7420 6568 4d20 4449     ter than the MID
   11110:	4c5f 5855 545f 5248 5345 4f48 444c 202c     _LUX_THRESHOLD, 
   11120:	6573 7474 6e69 2067 7262 6769 7468 656e     setting brightne
   11130:	7373 7320 6163 656c 2072 6f74 6120 7620     ss scaler to a v
   11140:	6c61 6575 3e20 3120 302e 0000 6920 2073     alue > 1.0.. is 
   11150:	7267 6165 6574 2072 6874 6e61 7420 6568     greater than the
   11160:	4d20 4e49 4c5f 5855 545f 5248 5345 4f48      MIN_LUX_THRESHO
   11170:	444c 202c 6573 7474 6e69 2067 7262 6769     LD, setting brig
   11180:	7468 656e 7373 7320 6163 656c 2072 6f74     htness scaler to
   11190:	6120 7620 6c61 6575 3c20 3120 302e 0000      a value < 1.0..
   111a0:	6920 2073 6f6c 6577 2072 6874 6e61 7420      is lower than t
   111b0:	6568 4d20 4e49 4c5f 5855 545f 5248 5345     he MIN_LUX_THRES
   111c0:	4f48 444c 202c 6573 7474 6e69 2067 7262     HOLD, setting br
   111d0:	6769 7468 656e 7373 7320 6163 656c 2072     ightness scaler 
   111e0:	6f74 4220 4952 4847 4e54 5345 5f53 4353     to BRIGHTNESS_SC
   111f0:	4c41 5245 4d5f 4e49 0000 0000 756c 3a78     ALER_MIN....lux:
   11200:	0009 0000 6209 6972 6867 6e74 7365 5f73     .....brightness_
   11210:	6373 6c61 7265 093a 0000 0000 460a 726f     scaler:......For
   11220:	6563 6c20 7875 7220 6165 6964 676e 0000     ce lux reading..
   11230:	7220 6165 4c64 7875 0028 0000 0929 0000      readLux(...)...
   11240:	6209 3a73 0020 0000 5245 4f52 2c52 6320     .bs: ...ERROR, c
   11250:	6e61 7427 6c20 6e69 206b 7561 6964 206f     an't link audio 
   11260:	6d61 6c70 6669 6569 2c72 7420 6568 6572     amplifier, there
   11270:	6120 6572 6e20 746f 6520 6f6e 6775 2068      are not enough 
   11280:	7661 6961 616c 6c62 2065 6c73 746f 0073     available slots.
   11290:	6554 7473 6e69 2067 0000 0000 4d20 6369     Testing .... Mic
   112a0:	6f72 6870 6e6f 2065 7375 6e69 2067 4d52     rophone using RM
   112b0:	0053 0000 202e 0000 4d20 6369 6f72 6870     S.... .. Microph
   112c0:	6e6f 2065 7369 6720 6f6f 0064 450a 5252     one is good..ERR
   112d0:	524f 202c 0000 0000 4d20 6369 6f72 6870     OR, .... Microph
   112e0:	6e6f 2065 6f64 7365 6e20 746f 7720 726f     one does not wor
   112f0:	006b 0000 4d20 6369 6f72 6870 6e6f 2065     k... Microphone 
   11300:	7375 6e69 2067 6550 6b61 0000 6f53 7272     using Peak..Sorr
   11310:	2079 6e75 6261 656c 7420 206f 6574 7473     y unable to test
   11320:	6d20 6369 6f72 6870 6e6f 2065 7361 6e20      microphone as n
   11330:	6965 6874 7265 7420 6568 5220 534d 6f20     either the RMS o
   11340:	2072 6550 6b61 6620 6165 7574 6572 6920     r Peak feature i
   11350:	2073 6361 6974 6576 0000 0000 616c 7473     s active....last
   11360:	665f 7466 765f 6c61 5b73 5d30 6920 2073     _fft_vals[0] is 
   11370:	7165 6175 206c 6f74 7a20 7265 006f 0000     equal to zero...
   11380:	6c66 7875 203a 0000 6563 746e 6f72 6469     flux: ..centroid
   11390:	3a20 0020 6d73 6f6f 6874 6465 6320 6e65      : .smoothed cen
   113a0:	7274 696f 2064 203a 0000 0000 4646 2054     troid : ....FFT 
   113b0:	7641 6961 616c 6c62 2065 202d 0000 0000     Available - ....
   113c0:	6353 6c61 6e69 2067 4646 2054 614d 6e67     Scaling FFT Magn
   113d0:	7469 6475 7365 7420 206f 6874 2065 7573     itudes to the su
   113e0:	206d 666f 3120 302e 6f20 6576 2072 6962     m of 1.0 over bi
   113f0:	206e 6172 676e 0065 5020 6165 736b 2820     n range. Peaks (
   11400:	6f6e 6d72 6c61 202c 6373 6c61 6465 202c     normal, scaled, 
   11410:	6f70 5f73 6564 746c 2961 093a 0000 0000     pos_delta):.....
   11420:	4157 4e52 4e49 2047 4d52 2053 7369 6520     WARNING RMS is e
   11430:	7571 6c61 7420 206f 0030 0000 5245 4f52     qual to 0...ERRO
   11440:	2052 2d20 5220 534d 4920 2053 4f4e 2054     R  - RMS IS NOT 
   11450:	4e41 4120 5443 5649 2045 5541 4944 204f     AN ACTIVE AUDIO 
   11460:	4546 5441 5255 2045 203a 0000 5245 4f52     FEATURE : ..ERRO
   11470:	2052 2d20 5020 6165 206b 5349 4e20 544f     R  - Peak IS NOT
   11480:	4120 204e 4341 4954 4556 4120 4455 4f49      AN ACTIVE AUDIO
   11490:	4620 4145 5554 4552 3a20 0020 5245 4f52      FEATURE : .ERRO
   114a0:	2052 2d20 4620 6572 2071 5349 4e20 544f     R  - Freq IS NOT
   114b0:	4120 204e 4341 4954 4556 4120 4455 4f49      AN ACTIVE AUDIO
   114c0:	4620 4145 5554 4552 3a20 0020 5245 4f52      FEATURE : .ERRO
   114d0:	2052 2d20 4620 5446 4920 2053 4f4e 2054     R  - FFT IS NOT 
   114e0:	4e41 4120 5443 5649 2045 5541 4944 204f     AN ACTIVE AUDIO 
   114f0:	4546 5441 5255 2045 203a 0000 4620 5446     FEATURE : .. FFT
   11500:	7620 6c61 0973 0000 7320 726f 7972 7420      vals... sorry t
   11510:	6568 6d20 6369 6f72 6870 6e6f 2065 6f64     he microphone do
   11520:	7365 6e20 746f 7720 726f 2c6b 6e20 746f     es not work, not
   11530:	7520 6470 7461 6e69 2067 6874 2065 6566      updating the fe
   11540:	7461 7275 2065 6f63 6c6c 6365 6f74 0072     ature collector.
   11550:	4157 4e52 4e49 2047 202d 2020 2020 2020     WARNING -       
   11560:	2020 2020 2020 2020 2020 6874 2065 6170               the pa
   11570:	7373 6465 6620 6165 7574 6572 6320 6c6f     ssed feature col
   11580:	656c 7463 726f 6420 656f 2073 6f6e 2074     lector does not 
   11590:	6168 6576 6120 706d 696c 6966 7265 2073     have amplifiers 
   115a0:	6361 6974 6576 0000 6e49 7263 6165 6973     active..Increasi
   115b0:	676e 0020 6120 7475 676f 6961 206e 7962     ng . autogain by
   115c0:	7420 6568 6d20 7861 6120 6f6d 6e75 2074      the max amount 
   115d0:	7564 2065 6f74 6520 7478 7265 616e 206c     due to external 
   115e0:	7075 6164 6574 0000 6544 7263 6165 6973     update..Decreasi
   115f0:	676e 0000 7075 6164 6974 676e 0020 0000     ng..updating ...
   11600:	6720 6961 206e 7266 6d6f 0020 7420 206f      gain from . to 
   11610:	0000 0000 7720 7469 2068 2061 6f63 7473     .... with a cost
   11620:	6f20 2066 0000 0000 4157 4e52 4e49 2047      of ....WARNING 
   11630:	5055 4144 4554 4920 2053 4f4e 2054 4d49     UPDATE IS NOT IM
   11640:	4c50 4d45 4e45 4554 2044 4e49 5420 4548     PLEMENTED IN THE
   11650:	4120 5455 474f 4e41 2049 4c43 5341 0053      AUTOGANI CLASS.
   11660:	654c 2064 4e4f 5220 7461 6f69 0000 0000     Led ON Ratio....
   11670:	5046 004d 202d 202d 202d 202d 202d 202d     FPM.- - - - - - 
   11680:	202d 202d 202d 202d 202d 202d 202d 202d     - - - - - - - - 
   11690:	202d 202d 202d 202d 202d 002d 6553 7474     - - - - - -.Sett
   116a0:	6e69 2067 7075 7420 6568 6120 6475 6f69     ing up the audio
   116b0:	6320 6168 6e6e 6c65 7320 7465 6974 676e      channel setting
   116c0:	2073 203a 000a 0000 6946 7372 2074 6c43     s : ....First Cl
   116d0:	6369 206b 6942 7551 6461 2073 5048 482d     ick BiQuads HP-H
   116e0:	2d50 5048 4c2d 2053 2020 2020 2020 093a     P-HP-LS       :.
   116f0:	0000 0000 6874 6572 6873 093a 0000 0000     ....thresh:.....
   11700:	5109 0009 6409 0042 6553 6f63 646e 4320     .Q...dB.Second C
   11710:	696c 6b63 4220 5169 6175 7364 4820 2d50     lick BiQuads HP-
   11720:	5048 482d 2d50 534c 2020 2020 2020 093a     HP-HP-LS      :.
   11730:	0000 0000 460a 7269 7473 5320 6e6f 2067     .....First Song 
   11740:	6942 7551 6461 2073 5048 482d 2d50 5048     BiQuads HP-HP-HP
   11750:	4c2d 2053 2020 2020 2020 3a20 0009 0000     -LS        :....
   11760:	6553 6f63 646e 5320 6e6f 2067 6942 7551     Second Song BiQu
   11770:	6461 2073 5048 482d 2d50 5048 4c2d 2053     ads HP-HP-HP-LS 
   11780:	2020 2020 2020 093a 0000 0000 6554 7473           :.....Test
   11790:	6e69 2067 694d 7263 706f 6f68 656e 0073     ing Microphones.
   117a0:	6f63 666e 6769 7275 6e69 2067 6164 6174     configuring data
   117b0:	6f6c 5f67 616d 616e 6567 2072 6974 656d     log_manager time
   117c0:	7372 0000 6148 6472 6177 6572 5620 7265     rs..Hardware Ver
   117d0:	6973 6e6f 6d20 6a61 726f 2020 2020 2020     sion major      
   117e0:	203a 0000 6148 6472 6177 6572 5620 7265     : ..Hardware Ver
   117f0:	6973 6e6f 6d20 6e69 726f 2020 2020 2020     sion minor      
   11800:	203a 0000 6f53 7466 6177 6572 5620 7265     : ..Software Ver
   11810:	6973 6e6f 6d20 6a61 726f 2020 2020 2020     sion major      
   11820:	203a 0000 6f42 2074 4449 4e20 6d75 6562     : ..Bot ID Numbe
   11830:	2072 2020 2020 2020 2020 2020 2020 2020     r               
   11840:	203a 0000 6144 6174 6f6c 2067 6341 6974     : ..Datalog Acti
   11850:	6576 2020 2020 2020 2020 2020 2020 2020     ve              
   11860:	203a 0000 6946 6d72 6177 6572 4d20 646f     : ..Firmware Mod
   11870:	2065 2020 2020 2020 2020 2020 2020 2020     e               
   11880:	203a 0000 6d53 6f6f 6874 4c20 7875 5220     : ..Smooth Lux R
   11890:	6165 6964 676e 2073 2020 2020 2020 2020     eadings         
   118a0:	203a 0000 754c 2078 6f4c 2077 6854 6572     : ..Lux Low Thre
   118b0:	6873 6c6f 2064 2020 2020 2020 2020 2020     shold           
   118c0:	203a 0000 754c 2078 694d 2064 6854 6572     : ..Lux Mid Thre
   118d0:	6873 6c6f 2064 2020 2020 2020 2020 2020     shold           
   118e0:	203a 0000 754c 2078 6948 6867 5420 7268     : ..Lux High Thr
   118f0:	7365 6f68 646c 2020 2020 2020 2020 2020     eshold          
   11900:	203a 0000 7242 6769 7468 656e 7373 5320     : ..Brightness S
   11910:	6163 656c 2072 694d 206e 2020 2020 2020     caler Min       
   11920:	203a 0000 7242 6769 7468 656e 7373 5320     : ..Brightness S
   11930:	6163 656c 2072 614d 2078 2020 2020 2020     caler Max       
   11940:	203a 0000 694d 206e 7242 6769 7468 656e     : ..Min Brightne
   11950:	7373 2020 2020 2020 2020 2020 2020 2020     ss              
   11960:	203a 0000 614d 2078 7242 6769 7468 656e     : ..Max Brightne
   11970:	7373 2020 2020 2020 2020 2020 2020 2020     ss              
   11980:	203a 0000 7541 6f74 6167 6e69 4120 7463     : ..Autogain Act
   11990:	7669 2065 2020 2020 2020 2020 2020 2020     ive             
   119a0:	203a 0000 614d 2078 7541 6f74 6167 6e69     : ..Max Autogain
   119b0:	4120 6a64 7375 6d74 6e65 2074 2020 2020      Adjustment     
   119c0:	203a 0000 7541 6f74 6167 6e69 4620 6572     : ..Autogain Fre
   119d0:	7571 6e65 7963 2020 2020 2020 2020 2020     quency          
   119e0:	203a 0000 6954 656d 2072 2030 7453 7261     : ..Timer 0 Star
   119f0:	2074 6954 656d 2020 2020 2020 2020 2020     t Time          
   11a00:	203a 0000 6954 656d 2072 2030 6e45 2064     : ..Timer 0 End 
   11a10:	6954 656d 2020 2020 2020 2020 2020 2020     Time            
   11a20:	203a 0000 6954 656d 2072 2030 6f4c 6767     : ..Timer 0 Logg
   11a30:	6e69 2067 6152 6574 2020 2020 2020 2020     ing Rate        
   11a40:	203a 0000 6954 656d 2072 2031 7453 7261     : ..Timer 1 Star
   11a50:	2074 6954 656d 2020 2020 2020 2020 2020     t Time          
   11a60:	203a 0000 6954 656d 2072 2031 6e45 2064     : ..Timer 1 End 
   11a70:	6954 656d 2020 2020 2020 2020 2020 2020     Time            
   11a80:	203a 0000 6954 656d 2072 2031 6f4c 6767     : ..Timer 1 Logg
   11a90:	6e69 2067 6152 6574 2020 2020 2020 2020     ing Rate        
   11aa0:	203a 0000 6954 656d 2072 2032 7453 7261     : ..Timer 2 Star
   11ab0:	2074 6954 656d 2020 2020 2020 2020 2020     t Time          
   11ac0:	203a 0000 6954 656d 2072 2032 6e45 2064     : ..Timer 2 End 
   11ad0:	6954 656d 2020 2020 2020 2020 2020 2020     Time            
   11ae0:	203a 0000 6954 656d 2072 2032 6f4c 6767     : ..Timer 2 Logg
   11af0:	6e69 2067 6152 6574 2020 2020 2020 2020     ing Rate        
   11b00:	203a 0000 6954 656d 2072 2033 7453 7261     : ..Timer 3 Star
   11b10:	2074 6954 656d 2020 2020 2020 2020 2020     t Time          
   11b20:	203a 0000 6954 656d 2072 2033 6e45 2064     : ..Timer 3 End 
   11b30:	6954 656d 2020 2020 2020 2020 2020 2020     Time            
   11b40:	203a 0000 6954 656d 2072 2033 6f4c 6767     : ..Timer 3 Logg
   11b50:	6e69 2067 6152 6574 2020 2020 2020 2020     ing Rate        
   11b60:	203a 0000 6f4e 2074 6c63 6165 6972 676e     : ..Not clearing
   11b70:	7420 6568 4520 5045 4f52 204d 6144 6174      the EEPROM Data
   11b80:	6f6c 2067 6f43 746e 6e65 7374 0000 0000     log Contents....
   11b90:	6572 6573 2074 6566 7461 7275 2065 696d     reset feature mi
   11ba0:	206e 6e61 2064 616d 0078 0000 7262 6769     n and max...brig
   11bb0:	7468 656e 7373 2d20 0020 0000 7209 003a     htness - ....r:.
   11bc0:	6709 003a 6566 7461 7275 2065 2020 2020     .g:.feature     
   11bd0:	3a20 0020 6c66 7875 2020 2020 2020 2020      : .flux        
   11be0:	3a20 0020 6570 6b61 2020 2020 2020 2020      : .peak        
   11bf0:	3a20 0020 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d      : .------------
   11c00:	2d2d 2d2d 2d2d 2d2d 2d2d 0000 5f5f 5f5f     ----------..____
   11c10:	5f5f 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f     ________________
   11c20:	4320 494c 4b43 5f20 5f5f 5f5f 5f5f 5f5f      CLICK _________
   11c30:	5f5f 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f 205f     _______________ 
   11c40:	2e33 0030 6c63 6369 206b 6566 7461 7275     3.0.click featur
   11c50:	2065 7369 6120 6f62 6576 7420 7268 7365     e is above thres
   11c60:	6f68 646c 203a 0000 6554 7473 6e69 2067     hold: ..Testing 
   11c70:	6874 2065 4350 2042 6f66 2072 756a 706d     the PCB for jump
   11c80:	7265 0073 4d4a 3150 505f 4e49 7220 7465     ers.JMP1_PIN ret
   11c90:	7275 656e 2064 756d 746c 7069 656c 7620     urned multiple v
   11ca0:	6c61 6575 0073 0000 4d4a 3250 505f 4e49     alues...JMP2_PIN
   11cb0:	7220 7465 7275 656e 2064 756d 746c 7069      returned multip
   11cc0:	656c 7620 6c61 6575 0073 0000 4d4a 3350     le values...JMP3
   11cd0:	505f 4e49 7220 7465 7275 656e 2064 756d     _PIN returned mu
   11ce0:	746c 7069 656c 7620 6c61 6575 0073 0000     ltiple values...
   11cf0:	4d4a 3450 505f 4e49 7220 7465 7275 656e     JMP4_PIN returne
   11d00:	2064 756d 746c 7069 656c 7620 6c61 6575     d multiple value
   11d10:	0073 0000 4d4a 3550 505f 4e49 7220 7465     s...JMP5_PIN ret
   11d20:	7275 656e 2064 756d 746c 7069 656c 7620     urned multiple v
   11d30:	6c61 6575 0073 0000 4d4a 3650 505f 4e49     alues...JMP6_PIN
   11d40:	7220 7465 7275 656e 2064 756d 746c 7069      returned multip
   11d50:	656c 7620 6c61 6575 0073 0000 754a 706d     le values...Jump
   11d60:	7265 2073 6170 7373 6465 6320 6e6f 6974     ers passed conti
   11d70:	756e 7469 2079 6574 7473 2e2e 002e 0000     nuity test......
   11d80:	7028 6e69 2931 4520 636e 6f6c 7573 6572     (pin1) Enclosure
   11d90:	2020 2020 2020 2020 2020 2020 2020 2020                     
   11da0:	2020 2020 2020 203a 0000 0000 7028 6e69           : ....(pin
   11db0:	2936 4d20 5341 4554 5f52 4147 4e49 535f     6) MASTER_GAIN_S
   11dc0:	4143 454c 2052 6e69 7263 6165 6573 2064     CALER increased 
   11dd0:	7962 3520 2530 3a20 0020 0000 5245 4f52     by 50% : ...ERRO
   11de0:	2052 202d 6874 7369 5020 4243 6420 656f     R - this PCB doe
   11df0:	2073 6f6e 2074 6f63 746e 6961 206e 756a     s not contain ju
   11e00:	706d 7265 2c73 6f20 2072 756a 706d 7265     mpers, or jumper
   11e10:	7020 6e69 2073 7261 2065 6f6e 2074 6f70      pins are not po
   11e20:	7570 616c 6574 0064 7246 6e6f 0074 0000     pulated.Front...
   11e30:	6552 7261 0000 0000 6552 7261 0020 0000     Rear....Rear ...
   11e40:	6144 6174 6f6c 2067 614d 616e 6567 0072     Datalog Manager.
   11e50:	7266 6e6f 2074 6f73 676e 0000 6572 7261     front song..rear
   11e60:	7320 6e6f 0067 0000 7266 6e6f 2074 6c63      song...front cl
   11e70:	6369 006b 6572 7261 6320 696c 6b63 0000     ick.rear click..
   11e80:	6f53 676e 0000 0000 6c43 6369 006b 0000     Song....Click...
   11e90:	7461 6574 706d 6974 676e 7420 206f 7473     attempting to st
   11ea0:	7261 2074 756c 2078 6573 736e 726f 2e2e     art lux sensor..
   11eb0:	002e 0000 5245 4f52 2052 2d2d 2d2d 5620     ....ERROR ---- V
   11ec0:	4d45 204c 0000 0000 6e20 746f 6620 756f     EML .... not fou
   11ed0:	646e 0000 4556 4c4d 0020 0000 7453 7261     nd..VEML ...Star
   11ee0:	6974 676e 4c20 7875 4320 6c61 6269 6172     ting Lux Calibra
   11ef0:	6974 6e6f 0000 0000 2020 0000 410a 6576     tion....  ...Ave
   11f00:	6172 6567 6c20 7875 7220 6165 6964 676e     rage lux reading
   11f10:	2073 203a 0000 0000 4c0a 7875 6320 6c61     s : .....Lux cal
   11f20:	6269 6172 6974 6e6f 6620 6e69 7369 6568     ibration finishe
   11f30:	0064 0000 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     d...------------
   11f40:	2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 000a 0000     ------------....
   11f50:	6553 6972 6c61 6220 6765 6e75 0000 0000     Serial begun....
   11f60:	454c 5344 6820 7661 2065 6562 6e65 6920     LEDS have been i
   11f70:	696e 6174 696c 6573 0064 0000 6553 7574     nitalised...Setu
   11f80:	2070 6f4c 706f 6820 7361 7320 6174 7472     p Loop has start
   11f90:	6465 0000 7574 6e72 6e69 2067 666f 2066     ed..turning off 
   11fa0:	454c 7344 6620 726f 4c20 7875 4320 6c61     LEDs for Lux Cal
   11fb0:	6269 6172 6974 6e6f 0000 0000 6553 7574     ibration....Setu
   11fc0:	2070 6f4c 706f 4620 6e69 7369 6568 0064     p Loop Finished.
   11fd0:	5551 4349 204b 5055 4144 4554 6420 6575     QUICK UPDATE due
   11fe0:	7420 206f 7865 7274 6d65 2065 756c 2078      to extreme lux 
   11ff0:	6572 6461 6e69 0067 6320 6d6f 6962 656e     reading. combine
   12000:	5f64 756c 2078 6176 756c 2065 7369 3a20     d_lux value is :
   12010:	0020 0000 6c20 7875 7220 6165 6964 676e      ... lux reading
   12020:	3a20 0020                                    : .

00012024 <vtable for AudioAnalyzeFFT256>:
	...
   1202c:	6205 0000                                   .b..

00012030 <vtable for AudioAnalyzePeak>:
	...
   12038:	6371 0000                                   qc..

0001203c <vtable for AudioAnalyzeRMS>:
	...
   12044:	63b1 0000                                   .c..

00012048 <AudioWindowHanning256>:
   12048:	0000 0005 0014 002d 0050 007c 00b3 00f3     ......-.P.|.....
   12058:	013d 0191 01ef 0256 02c7 0341 03c5 0452     =.....V...A...R.
   12068:	04e9 0588 0631 06e3 079d 0861 092d 0a01     ....1.....a.-...
   12078:	0ade 0bc3 0cb1 0da6 0ea3 0fa8 10b4 11c8     ................
   12088:	12e2 1404 152d 165c 1792 18ce 1a10 1b58     ....-.\.......X.
   12098:	1ca6 1df9 1f52 20af 2212 2379 24e5 2654     ....R.. ."y#.$T&
   120a8:	27c8 2940 2abb 2c39 2dbb 2f3f 30c6 324f     .'@).*9,.-?/.0O2
   120b8:	33da 3568 36f6 3887 3a18 3bab 3d3e 3ed1     .3h5.6.8.:.;>=.>
   120c8:	4065 41f9 438c 451f 46b1 4842 49d1 4b5f     e@.A.C.E.FBH.I_K
   120d8:	4cec 4e76 4ffe 5184 5307 5487 5603 577d     .LvN.O.Q.S.T.V}W
   120e8:	58f2 5a64 5bd2 5d3b 5ea0 6000 615b 62b1     .XdZ.[;].^.`[a.b
   120f8:	6402 654c 6692 67d1 690a 6a3c 6b68 6c8d     .dLe.f.g.i<jhk.l
   12108:	6dac 6ec3 6fd3 70dc 71dc 72d6 73c7 74b0     .m.n.o.p.q.r.s.t
   12118:	7591 766a 773a 7802 78c1 7977 7a24 7ac8     .ujv:w.x.xwy$z.z
   12128:	7b64 7bf5 7c7e 7cfd 7d73 7ddf 7e41 7e9a     d{.{~|.|s}.}A~.~
   12138:	7ee9 7f2e 7f6a 7f9b 7fc3 7fe1 7ff5 7fff     .~..j...........
   12148:	7fff 7ff5 7fe1 7fc3 7f9b 7f6a 7f2e 7ee9     ..........j....~
   12158:	7e9a 7e41 7ddf 7d73 7cfd 7c7e 7bf5 7b64     .~A~.}s}.|~|.{d{
   12168:	7ac8 7a24 7977 78c1 7802 773a 766a 7591     .z$zwy.x.x:wjv.u
   12178:	74b0 73c7 72d6 71dc 70dc 6fd3 6ec3 6dac     .t.s.r.q.p.o.n.m
   12188:	6c8d 6b68 6a3c 690a 67d1 6692 654c 6402     .lhk<j.i.g.fLe.d
   12198:	62b1 615b 6000 5ea0 5d3b 5bd2 5a64 58f2     .b[a.`.^;].[dZ.X
   121a8:	577d 5603 5487 5307 5184 4ffe 4e76 4cec     }W.V.T.S.Q.OvN.L
   121b8:	4b5f 49d1 4842 46b1 451f 438c 41f9 4065     _K.IBH.F.E.C.Ae@
   121c8:	3ed1 3d3e 3bab 3a18 3887 36f6 3568 33da     .>>=.;.:.8.6h5.3
   121d8:	324f 30c6 2f3f 2dbb 2c39 2abb 2940 27c8     O2.0?/.-9,.*@).'
   121e8:	2654 24e5 2379 2212 20af 1f52 1df9 1ca6     T&.$y#.". R.....
   121f8:	1b58 1a10 18ce 1792 165c 152d 1404 12e2     X.......\.-.....
   12208:	11c8 10b4 0fa8 0ea3 0da6 0cb1 0bc3 0ade     ................
   12218:	0a01 092d 0861 079d 06e3 0631 0588 04e9     ..-.a.....1.....
   12228:	0452 03c5 0341 02c7 0256 01ef 0191 013d     R...A...V.....=.
   12238:	00f3 00b3 007c 0050 002d 0014 0005 0000     ....|.P.-.......

00012248 <vtable for AudioFilterBiquad>:
	...
   12250:	64a5 0000                                   .d..

00012254 <vtable for AudioInputI2S>:
	...
   1225c:	66a9 0000                                   .f..

00012260 <vtable for AudioAmplifier>:
	...
   12268:	687d 0000                                   }h..

0001226c <sqrt_integer_guess_table>:
   1226c:	d745 9838 6ba3 4c1c 35d2 260e 1ae9 1307     E.8..k.L.5.&....
   1227c:	0d75 0984 06bb 04c2 035e 0261 01af 0131     u.......^.a...1.
   1228c:	00d8 0099 006c 004d 0036 0027 001b 0014     ....l.M.6.'.....
   1229c:	000e 000a 0007 0005 0004 0003 0002 0001     ................
   122ac:	0000 ffff                                   ....

000122b0 <SPIClass::spi0_hardware>:
   122b0:	803c 4004 1000 0000 1a04 0000 7fff 0000     <..@............
   122c0:	1011 0000 6cc1 0000 080c 0000 0200 0000     .....l..........
   122d0:	0200 0000 070b 0000 0240 0000 0200 0000     ........@.......
   122e0:	0e0d 0000 0240 0000 0200 0000 020a 0609     ....@...........
   122f0:	1714 1615 000f 0000 0200 0000 0200 0000     ................
   12300:	0200 0000 0200 0000 0200 0000 0200 0000     ................
   12310:	0200 0000 0200 0000 0200 0000 0101 0202     ................
   12320:	0404 0808 0010 0000                         ........

00012328 <vtable for SdFile>:
	...
   12330:	7585 0000 91fd 0000 6dfd 0000 6e01 0000     .u.......m...n..

00012340 <TwoWire::i2c0_hardware>:
   12340:	8034 4004 0040 0000 1112 ffff 02ff 0002     4..@@...........
   12350:	0000 1013 ffff 02ff 0002 0000 0018 0000     ................

00012360 <TwoWire::i2c1_hardware>:
   12360:	8034 4004 0080 0000 ff1e ffff 02ff 0000     4..@............
   12370:	0000 ff1d ffff 02ff 0000 0000 0019 0000     ................

00012380 <vtable for TwoWire>:
	...
   12388:	7e15 0000 7dd9 0000 6dfd 0000 7dd5 0000     .~...}...m...}..
   12398:	7d91 0000 7d9d 0000 7dbd 0000 0a0d ffff     .}...}...}......
   123a8:	616e 006e 766f 0066 6e69 0066 f06f 037f     nan.ovf.inf.o...
   123b8:	7003 7803 f013 0f80 d0fb 4770 0031 ffff     .p.x......pG1...

000123c8 <digital_pin_to_info_PGM>:
   123c8:	0840 43fe a040 4004 0844 43fe a044 4004     @..C@..@D..CD..@
   123d8:	1800 43fe c000 4004 0030 43fe 9030 4004     ...C...@0..C0..@
   123e8:	0034 43fe 9034 4004 181c 43fe c01c 4004     4..C4..@...C...@
   123f8:	1810 43fe c010 4004 1808 43fe c008 4004     ...C...@...C...@
   12408:	180c 43fe c00c 4004 100c 43fe b00c 4004     ...C...@...C...@
   12418:	1010 43fe b010 4004 1018 43fe b018 4004     ...C...@...C...@
   12428:	101c 43fe b01c 4004 1014 43fe b014 4004     ...C...@...C...@
   12438:	1804 43fe c004 4004 1000 43fe b000 4004     ...C...@...C...@
   12448:	0800 43fe a000 4004 0804 43fe a004 4004     ...C...@...C...@
   12458:	080c 43fe a00c 4004 0808 43fe a008 4004     ...C...@...C...@
   12468:	1814 43fe c014 4004 1818 43fe c018 4004     ...C...@...C...@
   12478:	1004 43fe b004 4004 1008 43fe b008 4004     ...C...@...C...@
   12488:	0014 43fe 9014 4004 084c 43fe a04c 4004     ...C...@L..CL..@
   12498:	2004 43fe d004 4004 1024 43fe b024 4004     . .C...@$..C$..@
   124a8:	1020 43fe b020 4004 1028 43fe b028 4004      ..C ..@(..C(..@
   124b8:	102c 43fe b02c 4004 2000 43fe d000 4004     ,..C,..@. .C...@
   124c8:	0848 43fe a048 4004 0010 43fe 9010 4004     H..CH..@...C...@

000124d8 <vtable for AudioOutputUSB>:
	...
   124e0:	a301 0000                                   ....

000124e4 <vtable for usb_serial_class>:
	...
   124ec:	b471 0000 b469 0000 b465 0000 b461 0000     q...i...e...a...
   124fc:	b45d 0000 b459 0000 b455 0000 b451 0000     ]...Y...U...Q...

0001250c <usb_endpoint_config_table>:
   1250c:	1915 1515 1419 1418                         ........

00012514 <usb_descriptor_list>:
   12514:	0100 0000 bb08 1fff 0012 0000 0200 0000     ................
   12524:	bb34 1fff 0155 0000 0300 0000 bcb0 1fff     4...U...........
   12534:	0000 0000 0301 0409 bb1c 1fff 0000 0000     ................
   12544:	0302 0409 bc8c 1fff 0000 0000 0303 0409     ................
   12554:	bcb4 1fff 0000 0000 0000 0000 0000 0000     ................
   12564:	0000 0000                                   ....

00012568 <armRecipTableQ31>:
   12568:	f03f 7f03 7420 7d13 e739 7b31 9f94 795e     ?... t.}9.1{..^y
   12578:	fd29 7798 6928 75e0 554d 7434 3b4b 7294     )..w(i.uMU4tK;.r
   12588:	9c40 70ff 0031 6f76 f593 6df6 10e3 6c82     @..p1.vo...m...l
   12598:	ec3a 6b16 26f6 69b5 655f 685c 505d 670c     :..k.&.i_e\h]P.g
   125a8:	952d 65c4 e519 6484 f53e 634c 7e4f 621c     -..e...d>.LcO~.b
   125b8:	3c61 60f3 eeb3 5fd0 5785 5eb5 3beb 5da0     a<.`..._.W.^.;.]
   125c8:	63a1 5c91 98e6 5b88 a85a 5a85 60df 5988     .c.\...[Z..Z.`.Y
   125d8:	9373 5890 1318 579e b4b8 56b0 4f0b 55c8     s..X...W...V.O.U
   125e8:	ba80 54e4 d124 5405 6e8f 532b 6fd0 5255     ...T$..T.n+S.oUR
   125f8:	b35a 5183 18f3 50b6 81a2 4fec cfa2 4f26     Z..Q...P...O..&O
   12608:	e64e 4e64 aa1d 4da6 008b 4cec d010 4c34     N.dN...M...L..4L
   12618:	0016 4b81 78ef 4ad0 23c4 4a23 ea96 4978     ...K.x.J.##J..xI
   12628:	b827 48d1 77fe 482d 1657 478c 801d 46ed     '..H.w-HW..G...F
   12638:	a2e5 4651 6ce2 45b8 cce1 4521 b244 448d     ..QF.l.E..!ED..D
   12648:	0cfa 43fc cd78 436c e4b4 42df 4426 4255     ...Cx.lC...B&DUB
   12658:	ddb6 41cc a3c6 4146 8923 40c2 8102 4040     ...A..FA#..@..@@

00012668 <armRecipTableQ15>:
   12668:	7f03 7d13 7b31 795e 7798 75e0 7434 7294     ...}1{^y.w.u4t.r
   12678:	70ff 6f76 6df6 6c82 6b16 69b5 685c 670c     .pvo.m.l.k.i\h.g
   12688:	65c4 6484 634c 621c 60f3 5fd0 5eb5 5da0     .e.dLc.b.`._.^.]
   12698:	5c91 5b88 5a85 5988 5890 579e 56b0 55c8     .\.[.Z.Y.X.W.V.U
   126a8:	54e4 5405 532b 5255 5183 50b6 4fec 4f26     .T.T+SUR.Q.P.O&O
   126b8:	4e64 4da6 4cec 4c34 4b81 4ad0 4a23 4978     dN.M.L4L.K.J#JxI
   126c8:	48d1 482d 478c 46ed 4651 45b8 4521 448d     .H-H.G.FQF.E!E.D
   126d8:	43fc 436c 42df 4255 41cc 4146 40c2 4040     .ClC.BUB.AFA.@@@

000126e8 <twiddleCoefQ15>:
   126e8:	7fff 0000 7fff 0032 7fff 0065 7fff 0097     ......2...e.....
   126f8:	7fff 00c9 7fff 00fb 7fff 012e 7ffe 0160     ..............`.
   12708:	7ffe 0192 7ffd 01c4 7ffc 01f7 7ffb 0229     ..............).
   12718:	7ffa 025b 7ff9 028d 7ff8 02c0 7ff7 02f2     ..[.............
   12728:	7ff6 0324 7ff5 0356 7ff4 0389 7ff2 03bb     ..$...V.........
   12738:	7ff1 03ed 7fef 041f 7fed 0452 7fec 0484     ..........R.....
   12748:	7fea 04b6 7fe8 04e8 7fe6 051b 7fe4 054d     ..............M.
   12758:	7fe2 057f 7fe0 05b1 7fdd 05e3 7fdb 0616     ................
   12768:	7fd9 0648 7fd6 067a 7fd3 06ac 7fd1 06de     ..H...z.........
   12778:	7fce 0711 7fcb 0743 7fc8 0775 7fc5 07a7     ......C...u.....
   12788:	7fc2 07d9 7fbf 080c 7fbc 083e 7fb9 0870     ..........>...p.
   12798:	7fb5 08a2 7fb2 08d4 7fae 0906 7fab 0938     ..............8.
   127a8:	7fa7 096b 7fa3 099d 7fa0 09cf 7f9c 0a01     ..k.............
   127b8:	7f98 0a33 7f94 0a65 7f90 0a97 7f8b 0ac9     ..3...e.........
   127c8:	7f87 0afb 7f83 0b2d 7f7e 0b60 7f7a 0b92     ......-.~.`.z...
   127d8:	7f75 0bc4 7f71 0bf6 7f6c 0c28 7f67 0c5a     u...q...l.(.g.Z.
   127e8:	7f62 0c8c 7f5d 0cbe 7f58 0cf0 7f53 0d22     b...]...X...S.".
   127f8:	7f4e 0d54 7f49 0d86 7f43 0db8 7f3e 0dea     N.T.I...C...>...
   12808:	7f38 0e1c 7f33 0e4e 7f2d 0e80 7f27 0eb2     8...3.N.-...'...
   12818:	7f22 0ee4 7f1c 0f15 7f16 0f47 7f10 0f79     ".........G...y.
   12828:	7f0a 0fab 7f03 0fdd 7efd 100f 7ef7 1041     .........~...~A.
   12838:	7ef0 1073 7eea 10a4 7ee3 10d6 7edd 1108     .~s..~...~...~..
   12848:	7ed6 113a 7ecf 116c 7ec8 119e 7ec1 11cf     .~:..~l..~...~..
   12858:	7eba 1201 7eb3 1233 7eac 1265 7ea5 1296     .~...~3..~e..~..
   12868:	7e9d 12c8 7e96 12fa 7e8e 132b 7e87 135d     .~...~...~+..~].
   12878:	7e7f 138f 7e78 13c1 7e70 13f2 7e68 1424     .~..x~..p~..h~$.
   12888:	7e60 1455 7e58 1487 7e50 14b9 7e48 14ea     `~U.X~..P~..H~..
   12898:	7e3f 151c 7e37 154d 7e2f 157f 7e26 15b1     ?~..7~M./~..&~..
   128a8:	7e1e 15e2 7e15 1614 7e0c 1645 7e03 1677     .~...~...~E..~w.
   128b8:	7dfb 16a8 7df2 16da 7de9 170b 7de0 173c     .}...}...}...}<.
   128c8:	7dd6 176e 7dcd 179f 7dc4 17d1 7dba 1802     .}n..}...}...}..
   128d8:	7db1 1833 7da7 1865 7d9e 1896 7d94 18c7     .}3..}e..}...}..
   128e8:	7d8a 18f9 7d81 192a 7d77 195b 7d6d 198d     .}...}*.w}[.m}..
   128f8:	7d63 19be 7d58 19ef 7d4e 1a20 7d44 1a51     c}..X}..N} .D}Q.
   12908:	7d3a 1a83 7d2f 1ab4 7d25 1ae5 7d1a 1b16     :}../}..%}...}..
   12918:	7d0f 1b47 7d05 1b78 7cfa 1ba9 7cef 1bda     .}G..}x..|...|..
   12928:	7ce4 1c0c 7cd9 1c3d 7cce 1c6e 7cc2 1c9f     .|...|=..|n..|..
   12938:	7cb7 1cd0 7cac 1d01 7ca0 1d31 7c95 1d62     .|...|...|1..|b.
   12948:	7c89 1d93 7c7e 1dc4 7c72 1df5 7c66 1e26     .|..~|..r|..f|&.
   12958:	7c5a 1e57 7c4e 1e88 7c42 1eb8 7c36 1ee9     Z|W.N|..B|..6|..
   12968:	7c2a 1f1a 7c1e 1f4b 7c11 1f7b 7c05 1fac     *|...|K..|{..|..
   12978:	7bf9 1fdd 7bec 200e 7bdf 203e 7bd3 206f     .{...{. .{> .{o 
   12988:	7bc6 209f 7bb9 20d0 7bac 2101 7b9f 2131     .{. .{. .{.!.{1!
   12998:	7b92 2162 7b85 2192 7b78 21c3 7b6a 21f3     .{b!.{.!x{.!j{.!
   129a8:	7b5d 2224 7b50 2254 7b42 2284 7b34 22b5     ]{$"P{T"B{."4{."
   129b8:	7b27 22e5 7b19 2316 7b0b 2346 7afd 2376     '{.".{.#.{F#.zv#
   129c8:	7aef 23a7 7ae1 23d7 7ad3 2407 7ac5 2437     .z.#.z.#.z.$.z7$
   129d8:	7ab7 2467 7aa8 2498 7a9a 24c8 7a8c 24f8     .zg$.z.$.z.$.z.$
   129e8:	7a7d 2528 7a6e 2558 7a60 2588 7a51 25b8     }z(%nzX%`z.%Qz.%
   129f8:	7a42 25e8 7a33 2618 7a24 2648 7a15 2678     Bz.%3z.&$zH&.zx&
   12a08:	7a06 26a8 79f7 26d8 79e7 2708 79d8 2738     .z.&.y.&.y.'.y8'
   12a18:	79c9 2768 79b9 2797 79aa 27c7 799a 27f7     .yh'.y.'.y.'.y.'
   12a28:	798a 2827 797a 2856 796a 2886 795b 28b6     .y'(zyV(jy.([y.(
   12a38:	794a 28e5 793a 2915 792a 2945 791a 2974     Jy.(:y.)*yE).yt)
   12a48:	790a 29a4 78f9 29d3 78e9 2a03 78d8 2a32     .y.).x.).x.*.x2*
   12a58:	78c8 2a62 78b7 2a91 78a6 2ac1 7895 2af0     .xb*.x.*.x.*.x.*
   12a68:	7885 2b1f 7874 2b4f 7863 2b7e 7851 2bad     .x.+txO+cx~+Qx.+
   12a78:	7840 2bdc 782f 2c0c 781e 2c3b 780c 2c6a     @x.+/x.,.x;,.xj,
   12a88:	77fb 2c99 77e9 2cc8 77d8 2cf7 77c6 2d26     .w.,.w.,.w.,.w&-
   12a98:	77b4 2d55 77a2 2d84 7790 2db3 777e 2de2     .wU-.w.-.w.-~w.-
   12aa8:	776c 2e11 775a 2e40 7748 2e6f 7736 2e9e     lw..Zw@.Hwo.6w..
   12ab8:	7723 2ecc 7711 2efb 76fe 2f2a 76ec 2f59     #w...w...v*/.vY/
   12ac8:	76d9 2f87 76c7 2fb6 76b4 2fe5 76a1 3013     .v./.v./.v./.v.0
   12ad8:	768e 3042 767b 3070 7668 309f 7655 30cd     .vB0{vp0hv.0Uv.0
   12ae8:	7642 30fc 762e 312a 761b 3159 7608 3187     Bv.0.v*1.vY1.v.1
   12af8:	75f4 31b5 75e1 31e4 75cd 3212 75b9 3240     .u.1.u.1.u.2.u@2
   12b08:	75a6 326e 7592 329d 757e 32cb 756a 32f9     .un2.u.2~u.2ju.2
   12b18:	7556 3327 7542 3355 752d 3383 7519 33b1     Vu'3BuU3-u.3.u.3
   12b28:	7505 33df 74f0 340d 74dc 343b 74c7 3469     .u.3.t.4.t;4.ti4
   12b38:	74b3 3497 749e 34c4 7489 34f2 7475 3520     .t.4.t.4.t.4ut 5
   12b48:	7460 354e 744b 357b 7436 35a9 7421 35d7     `tN5Kt{56t.5!t.5
   12b58:	740b 3604 73f6 3632 73e1 365f 73cb 368d     .t.6.s26.s_6.s.6
   12b68:	73b6 36ba 73a0 36e8 738b 3715 7375 3742     .s.6.s.6.s.7usB7
   12b78:	735f 3770 734a 379d 7334 37ca 731e 37f7     _sp7Js.74s.7.s.7
   12b88:	7308 3825 72f2 3852 72dc 387f 72c5 38ac     .s%8.rR8.r.8.r.8
   12b98:	72af 38d9 7299 3906 7282 3933 726c 3960     .r.8.r.9.r39lr`9
   12ba8:	7255 398d 723f 39ba 7228 39e7 7211 3a13     Ur.9?r.9(r.9.r.:
   12bb8:	71fa 3a40 71e3 3a6d 71cc 3a9a 71b5 3ac6     .q@:.qm:.q.:.q.:
   12bc8:	719e 3af3 7187 3b20 7170 3b4c 7158 3b79     .q.:.q ;pqL;Xqy;
   12bd8:	7141 3ba5 712a 3bd2 7112 3bfe 70fa 3c2a     Aq.;*q.;.q.;.p*<
   12be8:	70e3 3c57 70cb 3c83 70b3 3caf 709b 3cdc     .pW<.p.<.p.<.p.<
   12bf8:	7083 3d08 706b 3d34 7053 3d60 703b 3d8c     .p.=kp4=Sp`=;p.=
   12c08:	7023 3db8 700b 3de4 6ff2 3e10 6fda 3e3c     #p.=.p.=.o.>.o<>
   12c18:	6fc2 3e68 6fa9 3e94 6f90 3ec0 6f78 3eec     .oh>.o.>.o.>xo.>
   12c28:	6f5f 3f17 6f46 3f43 6f2d 3f6f 6f14 3f9a     _o.?FoC?-oo?.o.?
   12c38:	6efb 3fc6 6ee2 3ff1 6ec9 401d 6eb0 4048     .n.?.n.?.n.@.nH@
   12c48:	6e97 4074 6e7d 409f 6e64 40cb 6e4a 40f6     .nt@}n.@dn.@Jn.@
   12c58:	6e31 4121 6e17 414d 6dfe 4178 6de4 41a3     1n!A.nMA.mxA.m.A
   12c68:	6dca 41ce 6db0 41f9 6d96 4224 6d7c 424f     .m.A.m.A.m$B|mOB
   12c78:	6d62 427a 6d48 42a5 6d2e 42d0 6d14 42fb     bmzBHm.B.m.B.m.B
   12c88:	6cf9 4326 6cdf 4351 6cc4 437b 6caa 43a6     .l&C.lQC.l{C.l.C
   12c98:	6c8f 43d1 6c75 43fb 6c5a 4426 6c3f 4450     .l.Cul.CZl&D?lPD
   12ca8:	6c24 447b 6c09 44a5 6bee 44d0 6bd3 44fa     $l{D.l.D.k.D.k.D
   12cb8:	6bb8 4524 6b9d 454f 6b82 4579 6b66 45a3     .k$E.kOE.kyEfk.E
   12cc8:	6b4b 45cd 6b30 45f7 6b14 4621 6af8 464b     Kk.E0k.E.k!F.jKF
   12cd8:	6add 4675 6ac1 469f 6aa5 46c9 6a89 46f3     .juF.j.F.j.F.j.F
   12ce8:	6a6e 471d 6a52 4747 6a36 4770 6a1a 479a     nj.GRjGG6jpG.j.G
   12cf8:	69fd 47c4 69e1 47ed 69c5 4817 69a9 4840     .i.G.i.G.i.H.i@H
   12d08:	698c 486a 6970 4893 6953 48bd 6937 48e6     .ijHpi.HSi.H7i.H
   12d18:	691a 490f 68fd 4939 68e0 4962 68c4 498b     .i.I.h9I.hbI.h.I
   12d28:	68a7 49b4 688a 49dd 686d 4a06 6850 4a2f     .h.I.h.Imh.JPh/J
   12d38:	6832 4a58 6815 4a81 67f8 4aaa 67da 4ad3     2hXJ.h.J.g.J.g.J
   12d48:	67bd 4afb 67a0 4b24 6782 4b4d 6764 4b75     .g.J.g$K.gMKdguK
   12d58:	6747 4b9e 6729 4bc7 670b 4bef 66ed 4c17     Gg.K)g.K.g.K.f.L
   12d68:	66d0 4c40 66b2 4c68 6693 4c91 6675 4cb9     .f@L.fhL.f.Luf.L
   12d78:	6657 4ce1 6639 4d09 661b 4d31 65fc 4d59     Wf.L9f.M.f1M.eYM
   12d88:	65de 4d81 65c0 4da9 65a1 4dd1 6582 4df9     .e.M.e.M.e.M.e.M
   12d98:	6564 4e21 6545 4e49 6526 4e71 6507 4e98     de!NEeIN&eqN.e.N
   12da8:	64e9 4ec0 64ca 4ee8 64ab 4f0f 648b 4f37     .d.N.d.N.d.O.d7O
   12db8:	646c 4f5e 644d 4f85 642e 4fad 640f 4fd4     ld^OMd.O.d.O.d.O
   12dc8:	63ef 4ffb 63d0 5023 63b0 504a 6391 5071     .c.O.c#P.cJP.cqP
   12dd8:	6371 5098 6351 50bf 6332 50e6 6312 510d     qc.PQc.P2c.P.c.Q
   12de8:	62f2 5134 62d2 515b 62b2 5181 6292 51a8     .b4Q.b[Q.b.Q.b.Q
   12df8:	6272 51cf 6252 51f5 6232 521c 6211 5243     rb.QRb.Q2b.R.bCR
   12e08:	61f1 5269 61d1 5290 61b0 52b6 6190 52dc     .aiR.a.R.a.R.a.R
   12e18:	616f 5303 614e 5329 612e 534f 610d 5375     oa.SNa)S.aOS.auS
   12e28:	60ec 539b 60cb 53c1 60aa 53e7 6089 540d     .`.S.`.S.`.S.`.T
   12e38:	6068 5433 6047 5459 6026 547f 6005 54a4     h`3TG`YT&`.T.`.T
   12e48:	5fe4 54ca 5fc2 54f0 5fa1 5515 5f80 553b     ._.T._.T._.U._;U
   12e58:	5f5e 5560 5f3c 5586 5f1b 55ab 5ef9 55d0     ^_`U<_.U._.U.^.U
   12e68:	5ed7 55f6 5eb6 561b 5e94 5640 5e72 5665     .^.U.^.V.^@Vr^eV
   12e78:	5e50 568a 5e2e 56af 5e0c 56d4 5dea 56f9     P^.V.^.V.^.V.].V
   12e88:	5dc8 571e 5da5 5743 5d83 5767 5d61 578c     .].W.]CW.]gWa].W
   12e98:	5d3e 57b1 5d1c 57d5 5cf9 57fa 5cd7 581e     >].W.].W.\.W.\.X
   12ea8:	5cb4 5843 5c91 5867 5c6f 588c 5c4c 58b0     .\CX.\gXo\.XL\.X
   12eb8:	5c29 58d4 5c06 58f8 5be3 591c 5bc0 5940     )\.X.\.X.[.Y.[@Y
   12ec8:	5b9d 5964 5b7a 5988 5b57 59ac 5b34 59d0     .[dYz[.YW[.Y4[.Y
   12ed8:	5b10 59f4 5aed 5a18 5ac9 5a3b 5aa6 5a5f     .[.Y.Z.Z.Z;Z.Z_Z
   12ee8:	5a82 5a82 5a5f 5aa6 5a3b 5ac9 5a18 5aed     .Z.Z_Z.Z;Z.Z.Z.Z
   12ef8:	59f4 5b10 59d0 5b34 59ac 5b57 5988 5b7a     .Y.[.Y4[.YW[.Yz[
   12f08:	5964 5b9d 5940 5bc0 591c 5be3 58f8 5c06     dY.[@Y.[.Y.[.X.\
   12f18:	58d4 5c29 58b0 5c4c 588c 5c6f 5867 5c91     .X)\.XL\.Xo\gX.\
   12f28:	5843 5cb4 581e 5cd7 57fa 5cf9 57d5 5d1c     CX.\.X.\.W.\.W.]
   12f38:	57b1 5d3e 578c 5d61 5767 5d83 5743 5da5     .W>].Wa]gW.]CW.]
   12f48:	571e 5dc8 56f9 5dea 56d4 5e0c 56af 5e2e     .W.].V.].V.^.V.^
   12f58:	568a 5e50 5665 5e72 5640 5e94 561b 5eb6     .VP^eVr^@V.^.V.^
   12f68:	55f6 5ed7 55d0 5ef9 55ab 5f1b 5586 5f3c     .U.^.U.^.U._.U<_
   12f78:	5560 5f5e 553b 5f80 5515 5fa1 54f0 5fc2     `U^_;U._.U._.T._
   12f88:	54ca 5fe4 54a4 6005 547f 6026 5459 6047     .T._.T.`.T&`YTG`
   12f98:	5433 6068 540d 6089 53e7 60aa 53c1 60cb     3Th`.T.`.S.`.S.`
   12fa8:	539b 60ec 5375 610d 534f 612e 5329 614e     .S.`uS.aOS.a)SNa
   12fb8:	5303 616f 52dc 6190 52b6 61b0 5290 61d1     .Soa.R.a.R.a.R.a
   12fc8:	5269 61f1 5243 6211 521c 6232 51f5 6252     iR.aCR.b.R2b.QRb
   12fd8:	51cf 6272 51a8 6292 5181 62b2 515b 62d2     .Qrb.Q.b.Q.b[Q.b
   12fe8:	5134 62f2 510d 6312 50e6 6332 50bf 6351     4Q.b.Q.c.P2c.PQc
   12ff8:	5098 6371 5071 6391 504a 63b0 5023 63d0     .PqcqP.cJP.c#P.c
   13008:	4ffb 63ef 4fd4 640f 4fad 642e 4f85 644d     .O.c.O.d.O.d.OMd
   13018:	4f5e 646c 4f37 648b 4f0f 64ab 4ee8 64ca     ^Old7O.d.O.d.N.d
   13028:	4ec0 64e9 4e98 6507 4e71 6526 4e49 6545     .N.d.N.eqN&eINEe
   13038:	4e21 6564 4df9 6582 4dd1 65a1 4da9 65c0     !Nde.M.e.M.e.M.e
   13048:	4d81 65de 4d59 65fc 4d31 661b 4d09 6639     .M.eYM.e1M.f.M9f
   13058:	4ce1 6657 4cb9 6675 4c91 6693 4c68 66b2     .LWf.Luf.L.fhL.f
   13068:	4c40 66d0 4c17 66ed 4bef 670b 4bc7 6729     @L.f.L.f.K.g.K)g
   13078:	4b9e 6747 4b75 6764 4b4d 6782 4b24 67a0     .KGguKdgMK.g$K.g
   13088:	4afb 67bd 4ad3 67da 4aaa 67f8 4a81 6815     .J.g.J.g.J.g.J.h
   13098:	4a58 6832 4a2f 6850 4a06 686d 49dd 688a     XJ2h/JPh.Jmh.I.h
   130a8:	49b4 68a7 498b 68c4 4962 68e0 4939 68fd     .I.h.I.hbI.h9I.h
   130b8:	490f 691a 48e6 6937 48bd 6953 4893 6970     .I.i.H7i.HSi.Hpi
   130c8:	486a 698c 4840 69a9 4817 69c5 47ed 69e1     jH.i@H.i.H.i.G.i
   130d8:	47c4 69fd 479a 6a1a 4770 6a36 4747 6a52     .G.i.G.jpG6jGGRj
   130e8:	471d 6a6e 46f3 6a89 46c9 6aa5 469f 6ac1     .Gnj.F.j.F.j.F.j
   130f8:	4675 6add 464b 6af8 4621 6b14 45f7 6b30     uF.jKF.j!F.k.E0k
   13108:	45cd 6b4b 45a3 6b66 4579 6b82 454f 6b9d     .EKk.EfkyE.kOE.k
   13118:	4524 6bb8 44fa 6bd3 44d0 6bee 44a5 6c09     $E.k.D.k.D.k.D.l
   13128:	447b 6c24 4450 6c3f 4426 6c5a 43fb 6c75     {D$lPD?l&DZl.Cul
   13138:	43d1 6c8f 43a6 6caa 437b 6cc4 4351 6cdf     .C.l.C.l{C.lQC.l
   13148:	4326 6cf9 42fb 6d14 42d0 6d2e 42a5 6d48     &C.l.B.m.B.m.BHm
   13158:	427a 6d62 424f 6d7c 4224 6d96 41f9 6db0     zBbmOB|m$B.m.A.m
   13168:	41ce 6dca 41a3 6de4 4178 6dfe 414d 6e17     .A.m.A.mxA.mMA.n
   13178:	4121 6e31 40f6 6e4a 40cb 6e64 409f 6e7d     !A1n.@Jn.@dn.@}n
   13188:	4074 6e97 4048 6eb0 401d 6ec9 3ff1 6ee2     t@.nH@.n.@.n.?.n
   13198:	3fc6 6efb 3f9a 6f14 3f6f 6f2d 3f43 6f46     .?.n.?.oo?-oC?Fo
   131a8:	3f17 6f5f 3eec 6f78 3ec0 6f90 3e94 6fa9     .?_o.>xo.>.o.>.o
   131b8:	3e68 6fc2 3e3c 6fda 3e10 6ff2 3de4 700b     h>.o<>.o.>.o.=.p
   131c8:	3db8 7023 3d8c 703b 3d60 7053 3d34 706b     .=#p.=;p`=Sp4=kp
   131d8:	3d08 7083 3cdc 709b 3caf 70b3 3c83 70cb     .=.p.<.p.<.p.<.p
   131e8:	3c57 70e3 3c2a 70fa 3bfe 7112 3bd2 712a     W<.p*<.p.;.q.;*q
   131f8:	3ba5 7141 3b79 7158 3b4c 7170 3b20 7187     .;Aqy;XqL;pq ;.q
   13208:	3af3 719e 3ac6 71b5 3a9a 71cc 3a6d 71e3     .:.q.:.q.:.qm:.q
   13218:	3a40 71fa 3a13 7211 39e7 7228 39ba 723f     @:.q.:.r.9(r.9?r
   13228:	398d 7255 3960 726c 3933 7282 3906 7299     .9Ur`9lr39.r.9.r
   13238:	38d9 72af 38ac 72c5 387f 72dc 3852 72f2     .8.r.8.r.8.rR8.r
   13248:	3825 7308 37f7 731e 37ca 7334 379d 734a     %8.s.7.s.74s.7Js
   13258:	3770 735f 3742 7375 3715 738b 36e8 73a0     p7_sB7us.7.s.6.s
   13268:	36ba 73b6 368d 73cb 365f 73e1 3632 73f6     .6.s.6.s_6.s26.s
   13278:	3604 740b 35d7 7421 35a9 7436 357b 744b     .6.t.5!t.56t{5Kt
   13288:	354e 7460 3520 7475 34f2 7489 34c4 749e     N5`t 5ut.4.t.4.t
   13298:	3497 74b3 3469 74c7 343b 74dc 340d 74f0     .4.ti4.t;4.t.4.t
   132a8:	33df 7505 33b1 7519 3383 752d 3355 7542     .3.u.3.u.3-uU3Bu
   132b8:	3327 7556 32f9 756a 32cb 757e 329d 7592     '3Vu.2ju.2~u.2.u
   132c8:	326e 75a6 3240 75b9 3212 75cd 31e4 75e1     n2.u@2.u.2.u.1.u
   132d8:	31b5 75f4 3187 7608 3159 761b 312a 762e     .1.u.1.vY1.v*1.v
   132e8:	30fc 7642 30cd 7655 309f 7668 3070 767b     .0Bv.0Uv.0hvp0{v
   132f8:	3042 768e 3013 76a1 2fe5 76b4 2fb6 76c7     B0.v.0.v./.v./.v
   13308:	2f87 76d9 2f59 76ec 2f2a 76fe 2efb 7711     ./.vY/.v*/.v...w
   13318:	2ecc 7723 2e9e 7736 2e6f 7748 2e40 775a     ..#w..6wo.Hw@.Zw
   13328:	2e11 776c 2de2 777e 2db3 7790 2d84 77a2     ..lw.-~w.-.w.-.w
   13338:	2d55 77b4 2d26 77c6 2cf7 77d8 2cc8 77e9     U-.w&-.w.,.w.,.w
   13348:	2c99 77fb 2c6a 780c 2c3b 781e 2c0c 782f     .,.wj,.x;,.x.,/x
   13358:	2bdc 7840 2bad 7851 2b7e 7863 2b4f 7874     .+@x.+Qx~+cxO+tx
   13368:	2b1f 7885 2af0 7895 2ac1 78a6 2a91 78b7     .+.x.*.x.*.x.*.x
   13378:	2a62 78c8 2a32 78d8 2a03 78e9 29d3 78f9     b*.x2*.x.*.x.).x
   13388:	29a4 790a 2974 791a 2945 792a 2915 793a     .).yt).yE)*y.):y
   13398:	28e5 794a 28b6 795b 2886 796a 2856 797a     .(Jy.([y.(jyV(zy
   133a8:	2827 798a 27f7 799a 27c7 79aa 2797 79b9     '(.y.'.y.'.y.'.y
   133b8:	2768 79c9 2738 79d8 2708 79e7 26d8 79f7     h'.y8'.y.'.y.&.y
   133c8:	26a8 7a06 2678 7a15 2648 7a24 2618 7a33     .&.zx&.zH&$z.&3z
   133d8:	25e8 7a42 25b8 7a51 2588 7a60 2558 7a6e     .%Bz.%Qz.%`zX%nz
   133e8:	2528 7a7d 24f8 7a8c 24c8 7a9a 2498 7aa8     (%}z.$.z.$.z.$.z
   133f8:	2467 7ab7 2437 7ac5 2407 7ad3 23d7 7ae1     g$.z7$.z.$.z.#.z
   13408:	23a7 7aef 2376 7afd 2346 7b0b 2316 7b19     .#.zv#.zF#.{.#.{
   13418:	22e5 7b27 22b5 7b34 2284 7b42 2254 7b50     ."'{."4{."B{T"P{
   13428:	2224 7b5d 21f3 7b6a 21c3 7b78 2192 7b85     $"]{.!j{.!x{.!.{
   13438:	2162 7b92 2131 7b9f 2101 7bac 20d0 7bb9     b!.{1!.{.!.{. .{
   13448:	209f 7bc6 206f 7bd3 203e 7bdf 200e 7bec     . .{o .{> .{. .{
   13458:	1fdd 7bf9 1fac 7c05 1f7b 7c11 1f4b 7c1e     ...{...|{..|K..|
   13468:	1f1a 7c2a 1ee9 7c36 1eb8 7c42 1e88 7c4e     ..*|..6|..B|..N|
   13478:	1e57 7c5a 1e26 7c66 1df5 7c72 1dc4 7c7e     W.Z|&.f|..r|..~|
   13488:	1d93 7c89 1d62 7c95 1d31 7ca0 1d01 7cac     ...|b..|1..|...|
   13498:	1cd0 7cb7 1c9f 7cc2 1c6e 7cce 1c3d 7cd9     ...|...|n..|=..|
   134a8:	1c0c 7ce4 1bda 7cef 1ba9 7cfa 1b78 7d05     ...|...|...|x..}
   134b8:	1b47 7d0f 1b16 7d1a 1ae5 7d25 1ab4 7d2f     G..}...}..%}../}
   134c8:	1a83 7d3a 1a51 7d44 1a20 7d4e 19ef 7d58     ..:}Q.D} .N}..X}
   134d8:	19be 7d63 198d 7d6d 195b 7d77 192a 7d81     ..c}..m}[.w}*..}
   134e8:	18f9 7d8a 18c7 7d94 1896 7d9e 1865 7da7     ...}...}...}e..}
   134f8:	1833 7db1 1802 7dba 17d1 7dc4 179f 7dcd     3..}...}...}...}
   13508:	176e 7dd6 173c 7de0 170b 7de9 16da 7df2     n..}<..}...}...}
   13518:	16a8 7dfb 1677 7e03 1645 7e0c 1614 7e15     ...}w..~E..~...~
   13528:	15e2 7e1e 15b1 7e26 157f 7e2f 154d 7e37     ...~..&~../~M.7~
   13538:	151c 7e3f 14ea 7e48 14b9 7e50 1487 7e58     ..?~..H~..P~..X~
   13548:	1455 7e60 1424 7e68 13f2 7e70 13c1 7e78     U.`~$.h~..p~..x~
   13558:	138f 7e7f 135d 7e87 132b 7e8e 12fa 7e96     ...~]..~+..~...~
   13568:	12c8 7e9d 1296 7ea5 1265 7eac 1233 7eb3     ...~...~e..~3..~
   13578:	1201 7eba 11cf 7ec1 119e 7ec8 116c 7ecf     ...~...~...~l..~
   13588:	113a 7ed6 1108 7edd 10d6 7ee3 10a4 7eea     :..~...~...~...~
   13598:	1073 7ef0 1041 7ef7 100f 7efd 0fdd 7f03     s..~A..~...~....
   135a8:	0fab 7f0a 0f79 7f10 0f47 7f16 0f15 7f1c     ....y...G.......
   135b8:	0ee4 7f22 0eb2 7f27 0e80 7f2d 0e4e 7f33     .."...'...-.N.3.
   135c8:	0e1c 7f38 0dea 7f3e 0db8 7f43 0d86 7f49     ..8...>...C...I.
   135d8:	0d54 7f4e 0d22 7f53 0cf0 7f58 0cbe 7f5d     T.N.".S...X...].
   135e8:	0c8c 7f62 0c5a 7f67 0c28 7f6c 0bf6 7f71     ..b.Z.g.(.l...q.
   135f8:	0bc4 7f75 0b92 7f7a 0b60 7f7e 0b2d 7f83     ..u...z.`.~.-...
   13608:	0afb 7f87 0ac9 7f8b 0a97 7f90 0a65 7f94     ............e...
   13618:	0a33 7f98 0a01 7f9c 09cf 7fa0 099d 7fa3     3...............
   13628:	096b 7fa7 0938 7fab 0906 7fae 08d4 7fb2     k...8...........
   13638:	08a2 7fb5 0870 7fb9 083e 7fbc 080c 7fbf     ....p...>.......
   13648:	07d9 7fc2 07a7 7fc5 0775 7fc8 0743 7fcb     ........u...C...
   13658:	0711 7fce 06de 7fd1 06ac 7fd3 067a 7fd6     ............z...
   13668:	0648 7fd9 0616 7fdb 05e3 7fdd 05b1 7fe0     H...............
   13678:	057f 7fe2 054d 7fe4 051b 7fe6 04e8 7fe8     ....M...........
   13688:	04b6 7fea 0484 7fec 0452 7fed 041f 7fef     ........R.......
   13698:	03ed 7ff1 03bb 7ff2 0389 7ff4 0356 7ff5     ............V...
   136a8:	0324 7ff6 02f2 7ff7 02c0 7ff8 028d 7ff9     $...............
   136b8:	025b 7ffa 0229 7ffb 01f7 7ffc 01c4 7ffd     [...)...........
   136c8:	0192 7ffe 0160 7ffe 012e 7fff 00fb 7fff     ....`...........
   136d8:	00c9 7fff 0097 7fff 0065 7fff 0032 7fff     ........e...2...
   136e8:	0000 7fff ffce 7fff ff9b 7fff ff69 7fff     ............i...
   136f8:	ff37 7fff ff05 7fff fed2 7fff fea0 7ffe     7...............
   13708:	fe6e 7ffe fe3c 7ffd fe09 7ffc fdd7 7ffb     n...<...........
   13718:	fda5 7ffa fd73 7ff9 fd40 7ff8 fd0e 7ff7     ....s...@.......
   13728:	fcdc 7ff6 fcaa 7ff5 fc77 7ff4 fc45 7ff2     ........w...E...
   13738:	fc13 7ff1 fbe1 7fef fbae 7fed fb7c 7fec     ............|...
   13748:	fb4a 7fea fb18 7fe8 fae5 7fe6 fab3 7fe4     J...............
   13758:	fa81 7fe2 fa4f 7fe0 fa1d 7fdd f9ea 7fdb     ....O...........
   13768:	f9b8 7fd9 f986 7fd6 f954 7fd3 f922 7fd1     ........T..."...
   13778:	f8ef 7fce f8bd 7fcb f88b 7fc8 f859 7fc5     ............Y...
   13788:	f827 7fc2 f7f4 7fbf f7c2 7fbc f790 7fb9     '...............
   13798:	f75e 7fb5 f72c 7fb2 f6fa 7fae f6c8 7fab     ^...,...........
   137a8:	f695 7fa7 f663 7fa3 f631 7fa0 f5ff 7f9c     ....c...1.......
   137b8:	f5cd 7f98 f59b 7f94 f569 7f90 f537 7f8b     ........i...7...
   137c8:	f505 7f87 f4d3 7f83 f4a0 7f7e f46e 7f7a     ..........~.n.z.
   137d8:	f43c 7f75 f40a 7f71 f3d8 7f6c f3a6 7f67     <.u...q...l...g.
   137e8:	f374 7f62 f342 7f5d f310 7f58 f2de 7f53     t.b.B.]...X...S.
   137f8:	f2ac 7f4e f27a 7f49 f248 7f43 f216 7f3e     ..N.z.I.H.C...>.
   13808:	f1e4 7f38 f1b2 7f33 f180 7f2d f14e 7f27     ..8...3...-.N.'.
   13818:	f11c 7f22 f0eb 7f1c f0b9 7f16 f087 7f10     ..".............
   13828:	f055 7f0a f023 7f03 eff1 7efd efbf 7ef7     U...#......~...~
   13838:	ef8d 7ef0 ef5c 7eea ef2a 7ee3 eef8 7edd     ...~\..~*..~...~
   13848:	eec6 7ed6 ee94 7ecf ee62 7ec8 ee31 7ec1     ...~...~b..~1..~
   13858:	edff 7eba edcd 7eb3 ed9b 7eac ed6a 7ea5     ...~...~...~j..~
   13868:	ed38 7e9d ed06 7e96 ecd5 7e8e eca3 7e87     8..~...~...~...~
   13878:	ec71 7e7f ec3f 7e78 ec0e 7e70 ebdc 7e68     q..~?.x~..p~..h~
   13888:	ebab 7e60 eb79 7e58 eb47 7e50 eb16 7e48     ..`~y.X~G.P~..H~
   13898:	eae4 7e3f eab3 7e37 ea81 7e2f ea4f 7e26     ..?~..7~../~O.&~
   138a8:	ea1e 7e1e e9ec 7e15 e9bb 7e0c e989 7e03     ...~...~...~...~
   138b8:	e958 7dfb e926 7df2 e8f5 7de9 e8c4 7de0     X..}&..}...}...}
   138c8:	e892 7dd6 e861 7dcd e82f 7dc4 e7fe 7dba     ...}a..}/..}...}
   138d8:	e7cd 7db1 e79b 7da7 e76a 7d9e e739 7d94     ...}...}j..}9..}
   138e8:	e707 7d8a e6d6 7d81 e6a5 7d77 e673 7d6d     ...}...}..w}s.m}
   138f8:	e642 7d63 e611 7d58 e5e0 7d4e e5af 7d44     B.c}..X}..N}..D}
   13908:	e57d 7d3a e54c 7d2f e51b 7d25 e4ea 7d1a     }.:}L./}..%}...}
   13918:	e4b9 7d0f e488 7d05 e457 7cfa e426 7cef     ...}...}W..|&..|
   13928:	e3f4 7ce4 e3c3 7cd9 e392 7cce e361 7cc2     ...|...|...|a..|
   13938:	e330 7cb7 e2ff 7cac e2cf 7ca0 e29e 7c95     0..|...|...|...|
   13948:	e26d 7c89 e23c 7c7e e20b 7c72 e1da 7c66     m..|<.~|..r|..f|
   13958:	e1a9 7c5a e178 7c4e e148 7c42 e117 7c36     ..Z|x.N|H.B|..6|
   13968:	e0e6 7c2a e0b5 7c1e e085 7c11 e054 7c05     ..*|...|...|T..|
   13978:	e023 7bf9 dff2 7bec dfc2 7bdf df91 7bd3     #..{...{...{...{
   13988:	df61 7bc6 df30 7bb9 deff 7bac decf 7b9f     a..{0..{...{...{
   13998:	de9e 7b92 de6e 7b85 de3d 7b78 de0d 7b6a     ...{n..{=.x{..j{
   139a8:	dddc 7b5d ddac 7b50 dd7c 7b42 dd4b 7b34     ..]{..P{|.B{K.4{
   139b8:	dd1b 7b27 dcea 7b19 dcba 7b0b dc8a 7afd     ..'{...{...{...z
   139c8:	dc59 7aef dc29 7ae1 dbf9 7ad3 dbc9 7ac5     Y..z)..z...z...z
   139d8:	db99 7ab7 db68 7aa8 db38 7a9a db08 7a8c     ...zh..z8..z...z
   139e8:	dad8 7a7d daa8 7a6e da78 7a60 da48 7a51     ..}z..nzx.`zH.Qz
   139f8:	da18 7a42 d9e8 7a33 d9b8 7a24 d988 7a15     ..Bz..3z..$z...z
   13a08:	d958 7a06 d928 79f7 d8f8 79e7 d8c8 79d8     X..z(..y...y...y
   13a18:	d898 79c9 d869 79b9 d839 79aa d809 799a     ...yi..y9..y...y
   13a28:	d7d9 798a d7aa 797a d77a 796a d74a 795b     ...y..zyz.jyJ.[y
   13a38:	d71b 794a d6eb 793a d6bb 792a d68c 791a     ..Jy..:y..*y...y
   13a48:	d65c 790a d62d 78f9 d5fd 78e9 d5ce 78d8     \..y-..x...x...x
   13a58:	d59e 78c8 d56f 78b7 d53f 78a6 d510 7895     ...xo..x?..x...x
   13a68:	d4e1 7885 d4b1 7874 d482 7863 d453 7851     ...x..tx..cxS.Qx
   13a78:	d424 7840 d3f4 782f d3c5 781e d396 780c     $.@x../x...x...x
   13a88:	d367 77fb d338 77e9 d309 77d8 d2da 77c6     g..w8..w...w...w
   13a98:	d2ab 77b4 d27c 77a2 d24d 7790 d21e 777e     ...w|..wM..w..~w
   13aa8:	d1ef 776c d1c0 775a d191 7748 d162 7736     ..lw..Zw..Hwb.6w
   13ab8:	d134 7723 d105 7711 d0d6 76fe d0a7 76ec     4.#w...w...v...v
   13ac8:	d079 76d9 d04a 76c7 d01b 76b4 cfed 76a1     y..vJ..v...v...v
   13ad8:	cfbe 768e cf90 767b cf61 7668 cf33 7655     ...v..{va.hv3.Uv
   13ae8:	cf04 7642 ced6 762e cea7 761b ce79 7608     ..Bv...v...vy..v
   13af8:	ce4b 75f4 ce1c 75e1 cdee 75cd cdc0 75b9     K..u...u...u...u
   13b08:	cd92 75a6 cd63 7592 cd35 757e cd07 756a     ...uc..u5.~u..ju
   13b18:	ccd9 7556 ccab 7542 cc7d 752d cc4f 7519     ..Vu..Bu}.-uO..u
   13b28:	cc21 7505 cbf3 74f0 cbc5 74dc cb97 74c7     !..u...t...t...t
   13b38:	cb69 74b3 cb3c 749e cb0e 7489 cae0 7475     i..t<..t...t..ut
   13b48:	cab2 7460 ca85 744b ca57 7436 ca29 7421     ..`t..KtW.6t).!t
   13b58:	c9fc 740b c9ce 73f6 c9a1 73e1 c973 73cb     ...t...s...ss..s
   13b68:	c946 73b6 c918 73a0 c8eb 738b c8be 7375     F..s...s...s..us
   13b78:	c890 735f c863 734a c836 7334 c809 731e     .._sc.Js6.4s...s
   13b88:	c7db 7308 c7ae 72f2 c781 72dc c754 72c5     ...s...r...rT..r
   13b98:	c727 72af c6fa 7299 c6cd 7282 c6a0 726c     '..r...r...r..lr
   13ba8:	c673 7255 c646 723f c619 7228 c5ed 7211     s.UrF.?r..(r...r
   13bb8:	c5c0 71fa c593 71e3 c566 71cc c53a 71b5     ...q...qf..q:..q
   13bc8:	c50d 719e c4e0 7187 c4b4 7170 c487 7158     ...q...q..pq..Xq
   13bd8:	c45b 7141 c42e 712a c402 7112 c3d6 70fa     [.Aq..*q...q...p
   13be8:	c3a9 70e3 c37d 70cb c351 70b3 c324 709b     ...p}..pQ..p$..p
   13bf8:	c2f8 7083 c2cc 706b c2a0 7053 c274 703b     ...p..kp..Spt.;p
   13c08:	c248 7023 c21c 700b c1f0 6ff2 c1c4 6fda     H.#p...p...o...o
   13c18:	c198 6fc2 c16c 6fa9 c140 6f90 c114 6f78     ...ol..o@..o..xo
   13c28:	c0e9 6f5f c0bd 6f46 c091 6f2d c066 6f14     .._o..Fo..-of..o
   13c38:	c03a 6efb c00f 6ee2 bfe3 6ec9 bfb8 6eb0     :..n...n...n...n
   13c48:	bf8c 6e97 bf61 6e7d bf35 6e64 bf0a 6e4a     ...na.}n5.dn..Jn
   13c58:	bedf 6e31 beb3 6e17 be88 6dfe be5d 6de4     ..1n...n...m]..m
   13c68:	be32 6dca be07 6db0 bddc 6d96 bdb1 6d7c     2..m...m...m..|m
   13c78:	bd86 6d62 bd5b 6d48 bd30 6d2e bd05 6d14     ..bm[.Hm0..m...m
   13c88:	bcda 6cf9 bcaf 6cdf bc85 6cc4 bc5a 6caa     ...l...l...lZ..l
   13c98:	bc2f 6c8f bc05 6c75 bbda 6c5a bbb0 6c3f     /..l..ul..Zl..?l
   13ca8:	bb85 6c24 bb5b 6c09 bb30 6bee bb06 6bd3     ..$l[..l0..k...k
   13cb8:	badc 6bb8 bab1 6b9d ba87 6b82 ba5d 6b66     ...k...k...k].fk
   13cc8:	ba33 6b4b ba09 6b30 b9df 6b14 b9b5 6af8     3.Kk..0k...k...j
   13cd8:	b98b 6add b961 6ac1 b937 6aa5 b90d 6a89     ...ja..j7..j...j
   13ce8:	b8e3 6a6e b8b9 6a52 b890 6a36 b866 6a1a     ..nj..Rj..6jf..j
   13cf8:	b83c 69fd b813 69e1 b7e9 69c5 b7c0 69a9     <..i...i...i...i
   13d08:	b796 698c b76d 6970 b743 6953 b71a 6937     ...im.piC.Si..7i
   13d18:	b6f1 691a b6c7 68fd b69e 68e0 b675 68c4     ...i...h...hu..h
   13d28:	b64c 68a7 b623 688a b5fa 686d b5d1 6850     L..h#..h..mh..Ph
   13d38:	b5a8 6832 b57f 6815 b556 67f8 b52d 67da     ..2h...hV..g-..g
   13d48:	b505 67bd b4dc 67a0 b4b3 6782 b48b 6764     ...g...g...g..dg
   13d58:	b462 6747 b439 6729 b411 670b b3e9 66ed     b.Gg9.)g...g...f
   13d68:	b3c0 66d0 b398 66b2 b36f 6693 b347 6675     ...f...fo..fG.uf
   13d78:	b31f 6657 b2f7 6639 b2cf 661b b2a7 65fc     ..Wf..9f...f...e
   13d88:	b27f 65de b257 65c0 b22f 65a1 b207 6582     ...eW..e/..e...e
   13d98:	b1df 6564 b1b7 6545 b18f 6526 b168 6507     ..de..Ee..&eh..e
   13da8:	b140 64e9 b118 64ca b0f1 64ab b0c9 648b     @..d...d...d...d
   13db8:	b0a2 646c b07b 644d b053 642e b02c 640f     ..ld{.MdS..d,..d
   13dc8:	b005 63ef afdd 63d0 afb6 63b0 af8f 6391     ...c...c...c...c
   13dd8:	af68 6371 af41 6351 af1a 6332 aef3 6312     h.qcA.Qc..2c...c
   13de8:	aecc 62f2 aea5 62d2 ae7f 62b2 ae58 6292     ...b...b...bX..b
   13df8:	ae31 6272 ae0b 6252 ade4 6232 adbd 6211     1.rb..Rb..2b...b
   13e08:	ad97 61f1 ad70 61d1 ad4a 61b0 ad24 6190     ...ap..aJ..a$..a
   13e18:	acfd 616f acd7 614e acb1 612e ac8b 610d     ..oa..Na...a...a
   13e28:	ac65 60ec ac3f 60cb ac19 60aa abf3 6089     e..`?..`...`...`
   13e38:	abcd 6068 aba7 6047 ab81 6026 ab5c 6005     ..h`..G`..&`\..`
   13e48:	ab36 5fe4 ab10 5fc2 aaeb 5fa1 aac5 5f80     6.._..._..._..._
   13e58:	aaa0 5f5e aa7a 5f3c aa55 5f1b aa30 5ef9     ..^_z.<_U.._0..^
   13e68:	aa0a 5ed7 a9e5 5eb6 a9c0 5e94 a99b 5e72     ...^...^...^..r^
   13e78:	a976 5e50 a951 5e2e a92c 5e0c a907 5dea     v.P^Q..^,..^...]
   13e88:	a8e2 5dc8 a8bd 5da5 a899 5d83 a874 5d61     ...]...]...]t.a]
   13e98:	a84f 5d3e a82b 5d1c a806 5cf9 a7e2 5cd7     O.>]+..]...\...\
   13ea8:	a7bd 5cb4 a799 5c91 a774 5c6f a750 5c4c     ...\...\t.o\P.L\
   13eb8:	a72c 5c29 a708 5c06 a6e4 5be3 a6c0 5bc0     ,.)\...\...[...[
   13ec8:	a69c 5b9d a678 5b7a a654 5b57 a630 5b34     ...[x.z[T.W[0.4[
   13ed8:	a60c 5b10 a5e8 5aed a5c5 5ac9 a5a1 5aa6     ...[...Z...Z...Z
   13ee8:	a57e 5a82 a55a 5a5f a537 5a3b a513 5a18     ~..ZZ._Z7.;Z...Z
   13ef8:	a4f0 59f4 a4cc 59d0 a4a9 59ac a486 5988     ...Y...Y...Y...Y
   13f08:	a463 5964 a440 5940 a41d 591c a3fa 58f8     c.dY@.@Y...Y...X
   13f18:	a3d7 58d4 a3b4 58b0 a391 588c a36f 5867     ...X...X...Xo.gX
   13f28:	a34c 5843 a329 581e a307 57fa a2e4 57d5     L.CX)..X...W...W
   13f38:	a2c2 57b1 a29f 578c a27d 5767 a25b 5743     ...W...W}.gW[.CW
   13f48:	a238 571e a216 56f9 a1f4 56d4 a1d2 56af     8..W...V...V...V
   13f58:	a1b0 568a a18e 5665 a16c 5640 a14a 561b     ...V..eVl.@VJ..V
   13f68:	a129 55f6 a107 55d0 a0e5 55ab a0c4 5586     )..U...U...U...U
   13f78:	a0a2 5560 a080 553b a05f 5515 a03e 54f0     ..`U..;U_..U>..T
   13f88:	a01c 54ca 9ffb 54a4 9fda 547f 9fb9 5459     ...T...T...T..YT
   13f98:	9f98 5433 9f77 540d 9f56 53e7 9f35 53c1     ..3Tw..TV..S5..S
   13fa8:	9f14 539b 9ef3 5375 9ed2 534f 9eb2 5329     ...S..uS..OS..)S
   13fb8:	9e91 5303 9e70 52dc 9e50 52b6 9e2f 5290     ...Sp..RP..R/..R
   13fc8:	9e0f 5269 9def 5243 9dce 521c 9dae 51f5     ..iR..CR...R...Q
   13fd8:	9d8e 51cf 9d6e 51a8 9d4e 5181 9d2e 515b     ...Qn..QN..Q..[Q
   13fe8:	9d0e 5134 9cee 510d 9cce 50e6 9caf 50bf     ..4Q...Q...P...P
   13ff8:	9c8f 5098 9c6f 5071 9c50 504a 9c30 5023     ...Po.qPP.JP0.#P
   14008:	9c11 4ffb 9bf1 4fd4 9bd2 4fad 9bb3 4f85     ...O...O...O...O
   14018:	9b94 4f5e 9b75 4f37 9b55 4f0f 9b36 4ee8     ..^Ou.7OU..O6..N
   14028:	9b17 4ec0 9af9 4e98 9ada 4e71 9abb 4e49     ...N...N..qN..IN
   14038:	9a9c 4e21 9a7e 4df9 9a5f 4dd1 9a40 4da9     ..!N~..M_..M@..M
   14048:	9a22 4d81 9a04 4d59 99e5 4d31 99c7 4d09     "..M..YM..1M...M
   14058:	99a9 4ce1 998b 4cb9 996d 4c91 994e 4c68     ...L...Lm..LN.hL
   14068:	9930 4c40 9913 4c17 98f5 4bef 98d7 4bc7     0.@L...L...K...K
   14078:	98b9 4b9e 989c 4b75 987e 4b4d 9860 4b24     ...K..uK~.MK`.$K
   14088:	9843 4afb 9826 4ad3 9808 4aaa 97eb 4a81     C..J&..J...J...J
   14098:	97ce 4a58 97b0 4a2f 9793 4a06 9776 49dd     ..XJ../J...Jv..I
   140a8:	9759 49b4 973c 498b 9720 4962 9703 4939     Y..I<..I .bI..9I
   140b8:	96e6 490f 96c9 48e6 96ad 48bd 9690 4893     ...I...H...H...H
   140c8:	9674 486a 9657 4840 963b 4817 961f 47ed     t.jHW.@H;..H...G
   140d8:	9603 47c4 95e6 479a 95ca 4770 95ae 4747     ...G...G..pG..GG
   140e8:	9592 471d 9577 46f3 955b 46c9 953f 469f     ...Gw..F[..F?..F
   140f8:	9523 4675 9508 464b 94ec 4621 94d0 45f7     #.uF..KF..!F...E
   14108:	94b5 45cd 949a 45a3 947e 4579 9463 454f     ...E...E~.yEc.OE
   14118:	9448 4524 942d 44fa 9412 44d0 93f7 44a5     H.$E-..D...D...D
   14128:	93dc 447b 93c1 4450 93a6 4426 938b 43fb     ..{D..PD..&D...C
   14138:	9371 43d1 9356 43a6 933c 437b 9321 4351     q..CV..C<.{C!.QC
   14148:	9307 4326 92ec 42fb 92d2 42d0 92b8 42a5     ..&C...B...B...B
   14158:	929e 427a 9284 424f 926a 4224 9250 41f9     ..zB..OBj.$BP..A
   14168:	9236 41ce 921c 41a3 9202 4178 91e9 414d     6..A...A..xA..MA
   14178:	91cf 4121 91b6 40f6 919c 40cb 9183 409f     ..!A...@...@...@
   14188:	9169 4074 9150 4048 9137 401d 911e 3ff1     i.t@P.H@7..@...?
   14198:	9105 3fc6 90ec 3f9a 90d3 3f6f 90ba 3f43     ...?...?..o?..C?
   141a8:	90a1 3f17 9088 3eec 9070 3ec0 9057 3e94     ...?...>p..>W..>
   141b8:	903e 3e68 9026 3e3c 900e 3e10 8ff5 3de4     >.h>&.<>...>...=
   141c8:	8fdd 3db8 8fc5 3d8c 8fad 3d60 8f95 3d34     ...=...=..`=..4=
   141d8:	8f7d 3d08 8f65 3cdc 8f4d 3caf 8f35 3c83     }..=e..<M..<5..<
   141e8:	8f1d 3c57 8f06 3c2a 8eee 3bfe 8ed6 3bd2     ..W<..*<...;...;
   141f8:	8ebf 3ba5 8ea8 3b79 8e90 3b4c 8e79 3b20     ...;..y;..L;y. ;
   14208:	8e62 3af3 8e4b 3ac6 8e34 3a9a 8e1d 3a6d     b..:K..:4..:..m:
   14218:	8e06 3a40 8def 3a13 8dd8 39e7 8dc1 39ba     ..@:...:...9...9
   14228:	8dab 398d 8d94 3960 8d7e 3933 8d67 3906     ...9..`9~.39g..9
   14238:	8d51 38d9 8d3b 38ac 8d24 387f 8d0e 3852     Q..8;..8$..8..R8
   14248:	8cf8 3825 8ce2 37f7 8ccc 37ca 8cb6 379d     ..%8...7...7...7
   14258:	8ca1 3770 8c8b 3742 8c75 3715 8c60 36e8     ..p7..B7u..7`..6
   14268:	8c4a 36ba 8c35 368d 8c1f 365f 8c0a 3632     J..65..6.._6..26
   14278:	8bf5 3604 8bdf 35d7 8bca 35a9 8bb5 357b     ...6...5...5..{5
   14288:	8ba0 354e 8b8b 3520 8b77 34f2 8b62 34c4     ..N5.. 5w..4b..4
   14298:	8b4d 3497 8b39 3469 8b24 343b 8b10 340d     M..49.i4$.;4...4
   142a8:	8afb 33df 8ae7 33b1 8ad3 3383 8abe 3355     ...3...3...3..U3
   142b8:	8aaa 3327 8a96 32f9 8a82 32cb 8a6e 329d     ..'3...2...2n..2
   142c8:	8a5a 326e 8a47 3240 8a33 3212 8a1f 31e4     Z.n2G.@23..2...1
   142d8:	8a0c 31b5 89f8 3187 89e5 3159 89d2 312a     ...1...1..Y1..*1
   142e8:	89be 30fc 89ab 30cd 8998 309f 8985 3070     ...0...0...0..p0
   142f8:	8972 3042 895f 3013 894c 2fe5 8939 2fb6     r.B0_..0L../9../
   14308:	8927 2f87 8914 2f59 8902 2f2a 88ef 2efb     '../..Y/..*/....
   14318:	88dd 2ecc 88ca 2e9e 88b8 2e6f 88a6 2e40     ..........o...@.
   14328:	8894 2e11 8882 2de2 8870 2db3 885e 2d84     .......-p..-^..-
   14338:	884c 2d55 883a 2d26 8828 2cf7 8817 2cc8     L.U-:.&-(..,...,
   14348:	8805 2c99 87f4 2c6a 87e2 2c3b 87d1 2c0c     ...,..j,..;,...,
   14358:	87c0 2bdc 87af 2bad 879d 2b7e 878c 2b4f     ...+...+..~+..O+
   14368:	877b 2b1f 876b 2af0 875a 2ac1 8749 2a91     {..+k..*Z..*I..*
   14378:	8738 2a62 8728 2a32 8717 2a03 8707 29d3     8.b*(.2*...*...)
   14388:	86f6 29a4 86e6 2974 86d6 2945 86c6 2915     ...)..t)..E)...)
   14398:	86b6 28e5 86a5 28b6 8696 2886 8686 2856     ...(...(...(..V(
   143a8:	8676 2827 8666 27f7 8656 27c7 8647 2797     v.'(f..'V..'G..'
   143b8:	8637 2768 8628 2738 8619 2708 8609 26d8     7.h'(.8'...'...&
   143c8:	85fa 26a8 85eb 2678 85dc 2648 85cd 2618     ...&..x&..H&...&
   143d8:	85be 25e8 85af 25b8 85a0 2588 8592 2558     ...%...%...%..X%
   143e8:	8583 2528 8574 24f8 8566 24c8 8558 2498     ..(%t..$f..$X..$
   143f8:	8549 2467 853b 2437 852d 2407 851f 23d7     I.g$;.7$-..$...#
   14408:	8511 23a7 8503 2376 84f5 2346 84e7 2316     ...#..v#..F#...#
   14418:	84d9 22e5 84cc 22b5 84be 2284 84b0 2254     ..."..."..."..T"
   14428:	84a3 2224 8496 21f3 8488 21c3 847b 2192     ..$"...!...!{..!
   14438:	846e 2162 8461 2131 8454 2101 8447 20d0     n.b!a.1!T..!G.. 
   14448:	843a 209f 842d 206f 8421 203e 8414 200e     :.. -.o !.> ... 
   14458:	8407 1fdd 83fb 1fac 83ef 1f7b 83e2 1f4b     ..........{...K.
   14468:	83d6 1f1a 83ca 1ee9 83be 1eb8 83b2 1e88     ................
   14478:	83a6 1e57 839a 1e26 838e 1df5 8382 1dc4     ..W...&.........
   14488:	8377 1d93 836b 1d62 8360 1d31 8354 1d01     w...k.b.`.1.T...
   14498:	8349 1cd0 833e 1c9f 8332 1c6e 8327 1c3d     I...>...2.n.'.=.
   144a8:	831c 1c0c 8311 1bda 8306 1ba9 82fb 1b78     ..............x.
   144b8:	82f1 1b47 82e6 1b16 82db 1ae5 82d1 1ab4     ..G.............
   144c8:	82c6 1a83 82bc 1a51 82b2 1a20 82a8 19ef     ......Q... .....
   144d8:	829d 19be 8293 198d 8289 195b 827f 192a     ..........[...*.
   144e8:	8276 18f9 826c 18c7 8262 1896 8259 1865     v...l...b...Y.e.
   144f8:	824f 1833 8246 1802 823c 17d1 8233 179f     O.3.F...<...3...
   14508:	822a 176e 8220 173c 8217 170b 820e 16da     *.n. .<.........
   14518:	8205 16a8 81fd 1677 81f4 1645 81eb 1614     ......w...E.....
   14528:	81e2 15e2 81da 15b1 81d1 157f 81c9 154d     ..............M.
   14538:	81c1 151c 81b8 14ea 81b0 14b9 81a8 1487     ................
   14548:	81a0 1455 8198 1424 8190 13f2 8188 13c1     ..U...$.........
   14558:	8181 138f 8179 135d 8172 132b 816a 12fa     ....y.].r.+.j...
   14568:	8163 12c8 815b 1296 8154 1265 814d 1233     c...[...T.e.M.3.
   14578:	8146 1201 813f 11cf 8138 119e 8131 116c     F...?...8...1.l.
   14588:	812a 113a 8123 1108 811d 10d6 8116 10a4     *.:.#...........
   14598:	8110 1073 8109 1041 8103 100f 80fd 0fdd     ..s...A.........
   145a8:	80f6 0fab 80f0 0f79 80ea 0f47 80e4 0f15     ......y...G.....
   145b8:	80de 0ee4 80d9 0eb2 80d3 0e80 80cd 0e4e     ..............N.
   145c8:	80c8 0e1c 80c2 0dea 80bd 0db8 80b7 0d86     ................
   145d8:	80b2 0d54 80ad 0d22 80a8 0cf0 80a3 0cbe     ..T...".........
   145e8:	809e 0c8c 8099 0c5a 8094 0c28 808f 0bf6     ......Z...(.....
   145f8:	808b 0bc4 8086 0b92 8082 0b60 807d 0b2d     ..........`.}.-.
   14608:	8079 0afb 8075 0ac9 8070 0a97 806c 0a65     y...u...p...l.e.
   14618:	8068 0a33 8064 0a01 8060 09cf 805d 099d     h.3.d...`...]...
   14628:	8059 096b 8055 0938 8052 0906 804e 08d4     Y.k.U.8.R...N...
   14638:	804b 08a2 8047 0870 8044 083e 8041 080c     K...G.p.D.>.A...
   14648:	803e 07d9 803b 07a7 8038 0775 8035 0743     >...;...8.u.5.C.
   14658:	8032 0711 802f 06de 802d 06ac 802a 067a     2.../...-...*.z.
   14668:	8027 0648 8025 0616 8023 05e3 8020 05b1     '.H.%...#... ...
   14678:	801e 057f 801c 054d 801a 051b 8018 04e8     ......M.........
   14688:	8016 04b6 8014 0484 8013 0452 8011 041f     ..........R.....
   14698:	800f 03ed 800e 03bb 800c 0389 800b 0356     ..............V.
   146a8:	800a 0324 8009 02f2 8008 02c0 8007 028d     ..$.............
   146b8:	8006 025b 8005 0229 8004 01f7 8003 01c4     ..[...).........
   146c8:	8002 0192 8002 0160 8001 012e 8001 00fb     ......`.........
   146d8:	8001 00c9 8000 0097 8000 0065 8000 0032     ..........e...2.
   146e8:	8000 0000 8000 ffce 8000 ff9b 8000 ff69     ..............i.
   146f8:	8001 ff37 8001 ff05 8001 fed2 8002 fea0     ..7.............
   14708:	8002 fe6e 8003 fe3c 8004 fe09 8005 fdd7     ..n...<.........
   14718:	8006 fda5 8007 fd73 8008 fd40 8009 fd0e     ......s...@.....
   14728:	800a fcdc 800b fcaa 800c fc77 800e fc45     ..........w...E.
   14738:	800f fc13 8011 fbe1 8013 fbae 8014 fb7c     ..............|.
   14748:	8016 fb4a 8018 fb18 801a fae5 801c fab3     ..J.............
   14758:	801e fa81 8020 fa4f 8023 fa1d 8025 f9ea     .... .O.#...%...
   14768:	8027 f9b8 802a f986 802d f954 802f f922     '...*...-.T./.".
   14778:	8032 f8ef 8035 f8bd 8038 f88b 803b f859     2...5...8...;.Y.
   14788:	803e f827 8041 f7f4 8044 f7c2 8047 f790     >.'.A...D...G...
   14798:	804b f75e 804e f72c 8052 f6fa 8055 f6c8     K.^.N.,.R...U...
   147a8:	8059 f695 805d f663 8060 f631 8064 f5ff     Y...].c.`.1.d...
   147b8:	8068 f5cd 806c f59b 8070 f569 8075 f537     h...l...p.i.u.7.
   147c8:	8079 f505 807d f4d3 8082 f4a0 8086 f46e     y...}.........n.
   147d8:	808b f43c 808f f40a 8094 f3d8 8099 f3a6     ..<.............
   147e8:	809e f374 80a3 f342 80a8 f310 80ad f2de     ..t...B.........
   147f8:	80b2 f2ac 80b7 f27a 80bd f248 80c2 f216     ......z...H.....
   14808:	80c8 f1e4 80cd f1b2 80d3 f180 80d9 f14e     ..............N.
   14818:	80de f11c 80e4 f0eb 80ea f0b9 80f0 f087     ................
   14828:	80f6 f055 80fd f023 8103 eff1 8109 efbf     ..U...#.........
   14838:	8110 ef8d 8116 ef5c 811d ef2a 8123 eef8     ......\...*.#...
   14848:	812a eec6 8131 ee94 8138 ee62 813f ee31     *...1...8.b.?.1.
   14858:	8146 edff 814d edcd 8154 ed9b 815b ed6a     F...M...T...[.j.
   14868:	8163 ed38 816a ed06 8172 ecd5 8179 eca3     c.8.j...r...y...
   14878:	8181 ec71 8188 ec3f 8190 ec0e 8198 ebdc     ..q...?.........
   14888:	81a0 ebab 81a8 eb79 81b0 eb47 81b8 eb16     ......y...G.....
   14898:	81c1 eae4 81c9 eab3 81d1 ea81 81da ea4f     ..............O.
   148a8:	81e2 ea1e 81eb e9ec 81f4 e9bb 81fd e989     ................
   148b8:	8205 e958 820e e926 8217 e8f5 8220 e8c4     ..X...&..... ...
   148c8:	822a e892 8233 e861 823c e82f 8246 e7fe     *...3.a.<./.F...
   148d8:	824f e7cd 8259 e79b 8262 e76a 826c e739     O...Y...b.j.l.9.
   148e8:	8276 e707 827f e6d6 8289 e6a5 8293 e673     v.............s.
   148f8:	829d e642 82a8 e611 82b2 e5e0 82bc e5af     ..B.............
   14908:	82c6 e57d 82d1 e54c 82db e51b 82e6 e4ea     ..}...L.........
   14918:	82f1 e4b9 82fb e488 8306 e457 8311 e426     ..........W...&.
   14928:	831c e3f4 8327 e3c3 8332 e392 833e e361     ....'...2...>.a.
   14938:	8349 e330 8354 e2ff 8360 e2cf 836b e29e     I.0.T...`...k...
   14948:	8377 e26d 8382 e23c 838e e20b 839a e1da     w.m...<.........
   14958:	83a6 e1a9 83b2 e178 83be e148 83ca e117     ......x...H.....
   14968:	83d6 e0e6 83e2 e0b5 83ef e085 83fb e054     ..............T.
   14978:	8407 e023 8414 dff2 8421 dfc2 842d df91     ..#.....!...-...
   14988:	843a df61 8447 df30 8454 deff 8461 decf     :.a.G.0.T...a...
   14998:	846e de9e 847b de6e 8488 de3d 8496 de0d     n...{.n...=.....
   149a8:	84a3 dddc 84b0 ddac 84be dd7c 84cc dd4b     ..........|...K.
   149b8:	84d9 dd1b 84e7 dcea 84f5 dcba 8503 dc8a     ................
   149c8:	8511 dc59 851f dc29 852d dbf9 853b dbc9     ..Y...).-...;...
   149d8:	8549 db99 8558 db68 8566 db38 8574 db08     I...X.h.f.8.t...
   149e8:	8583 dad8 8592 daa8 85a0 da78 85af da48     ..........x...H.
   149f8:	85be da18 85cd d9e8 85dc d9b8 85eb d988     ................
   14a08:	85fa d958 8609 d928 8619 d8f8 8628 d8c8     ..X...(.....(...
   14a18:	8637 d898 8647 d869 8656 d839 8666 d809     7...G.i.V.9.f...
   14a28:	8676 d7d9 8686 d7aa 8696 d77a 86a5 d74a     v.........z...J.
   14a38:	86b6 d71b 86c6 d6eb 86d6 d6bb 86e6 d68c     ................
   14a48:	86f6 d65c 8707 d62d 8717 d5fd 8728 d5ce     ..\...-.....(...
   14a58:	8738 d59e 8749 d56f 875a d53f 876b d510     8...I.o.Z.?.k...
   14a68:	877b d4e1 878c d4b1 879d d482 87af d453     {.............S.
   14a78:	87c0 d424 87d1 d3f4 87e2 d3c5 87f4 d396     ..$.............
   14a88:	8805 d367 8817 d338 8828 d309 883a d2da     ..g...8.(...:...
   14a98:	884c d2ab 885e d27c 8870 d24d 8882 d21e     L...^.|.p.M.....
   14aa8:	8894 d1ef 88a6 d1c0 88b8 d191 88ca d162     ..............b.
   14ab8:	88dd d134 88ef d105 8902 d0d6 8914 d0a7     ..4.............
   14ac8:	8927 d079 8939 d04a 894c d01b 895f cfed     '.y.9.J.L..._...
   14ad8:	8972 cfbe 8985 cf90 8998 cf61 89ab cf33     r.........a...3.
   14ae8:	89be cf04 89d2 ced6 89e5 cea7 89f8 ce79     ..............y.
   14af8:	8a0c ce4b 8a1f ce1c 8a33 cdee 8a47 cdc0     ..K.....3...G...
   14b08:	8a5a cd92 8a6e cd63 8a82 cd35 8a96 cd07     Z...n.c...5.....
   14b18:	8aaa ccd9 8abe ccab 8ad3 cc7d 8ae7 cc4f     ..........}...O.
   14b28:	8afb cc21 8b10 cbf3 8b24 cbc5 8b39 cb97     ..!.....$...9...
   14b38:	8b4d cb69 8b62 cb3c 8b77 cb0e 8b8b cae0     M.i.b.<.w.......
   14b48:	8ba0 cab2 8bb5 ca85 8bca ca57 8bdf ca29     ..........W...).
   14b58:	8bf5 c9fc 8c0a c9ce 8c1f c9a1 8c35 c973     ............5.s.
   14b68:	8c4a c946 8c60 c918 8c75 c8eb 8c8b c8be     J.F.`...u.......
   14b78:	8ca1 c890 8cb6 c863 8ccc c836 8ce2 c809     ......c...6.....
   14b88:	8cf8 c7db 8d0e c7ae 8d24 c781 8d3b c754     ........$...;.T.
   14b98:	8d51 c727 8d67 c6fa 8d7e c6cd 8d94 c6a0     Q.'.g...~.......
   14ba8:	8dab c673 8dc1 c646 8dd8 c619 8def c5ed     ..s...F.........
   14bb8:	8e06 c5c0 8e1d c593 8e34 c566 8e4b c53a     ........4.f.K.:.
   14bc8:	8e62 c50d 8e79 c4e0 8e90 c4b4 8ea8 c487     b...y...........
   14bd8:	8ebf c45b 8ed6 c42e 8eee c402 8f06 c3d6     ..[.............
   14be8:	8f1d c3a9 8f35 c37d 8f4d c351 8f65 c324     ....5.}.M.Q.e.$.
   14bf8:	8f7d c2f8 8f95 c2cc 8fad c2a0 8fc5 c274     }.............t.
   14c08:	8fdd c248 8ff5 c21c 900e c1f0 9026 c1c4     ..H.........&...
   14c18:	903e c198 9057 c16c 9070 c140 9088 c114     >...W.l.p.@.....
   14c28:	90a1 c0e9 90ba c0bd 90d3 c091 90ec c066     ..............f.
   14c38:	9105 c03a 911e c00f 9137 bfe3 9150 bfb8     ..:.....7...P...
   14c48:	9169 bf8c 9183 bf61 919c bf35 91b6 bf0a     i.....a...5.....
   14c58:	91cf bedf 91e9 beb3 9202 be88 921c be5d     ..............].
   14c68:	9236 be32 9250 be07 926a bddc 9284 bdb1     6.2.P...j.......
   14c78:	929e bd86 92b8 bd5b 92d2 bd30 92ec bd05     ......[...0.....
   14c88:	9307 bcda 9321 bcaf 933c bc85 9356 bc5a     ....!...<...V.Z.
   14c98:	9371 bc2f 938b bc05 93a6 bbda 93c1 bbb0     q./.............
   14ca8:	93dc bb85 93f7 bb5b 9412 bb30 942d bb06     ......[...0.-...
   14cb8:	9448 badc 9463 bab1 947e ba87 949a ba5d     H...c...~.....].
   14cc8:	94b5 ba33 94d0 ba09 94ec b9df 9508 b9b5     ..3.............
   14cd8:	9523 b98b 953f b961 955b b937 9577 b90d     #...?.a.[.7.w...
   14ce8:	9592 b8e3 95ae b8b9 95ca b890 95e6 b866     ..............f.
   14cf8:	9603 b83c 961f b813 963b b7e9 9657 b7c0     ..<.....;...W...
   14d08:	9674 b796 9690 b76d 96ad b743 96c9 b71a     t.....m...C.....
   14d18:	96e6 b6f1 9703 b6c7 9720 b69e 973c b675     ........ ...<.u.
   14d28:	9759 b64c 9776 b623 9793 b5fa 97b0 b5d1     Y.L.v.#.........
   14d38:	97ce b5a8 97eb b57f 9808 b556 9826 b52d     ..........V.&.-.
   14d48:	9843 b505 9860 b4dc 987e b4b3 989c b48b     C...`...~.......
   14d58:	98b9 b462 98d7 b439 98f5 b411 9913 b3e9     ..b...9.........
   14d68:	9930 b3c0 994e b398 996d b36f 998b b347     0...N...m.o...G.
   14d78:	99a9 b31f 99c7 b2f7 99e5 b2cf 9a04 b2a7     ................
   14d88:	9a22 b27f 9a40 b257 9a5f b22f 9a7e b207     "...@.W._./.~...
   14d98:	9a9c b1df 9abb b1b7 9ada b18f 9af9 b168     ..............h.
   14da8:	9b17 b140 9b36 b118 9b55 b0f1 9b75 b0c9     ..@.6...U...u...
   14db8:	9b94 b0a2 9bb3 b07b 9bd2 b053 9bf1 b02c     ......{...S...,.
   14dc8:	9c11 b005 9c30 afdd 9c50 afb6 9c6f af8f     ....0...P...o...
   14dd8:	9c8f af68 9caf af41 9cce af1a 9cee aef3     ..h...A.........
   14de8:	9d0e aecc 9d2e aea5 9d4e ae7f 9d6e ae58     ........N...n.X.
   14df8:	9d8e ae31 9dae ae0b 9dce ade4 9def adbd     ..1.............
   14e08:	9e0f ad97 9e2f ad70 9e50 ad4a 9e70 ad24     ..../.p.P.J.p.$.
   14e18:	9e91 acfd 9eb2 acd7 9ed2 acb1 9ef3 ac8b     ................
   14e28:	9f14 ac65 9f35 ac3f 9f56 ac19 9f77 abf3     ..e.5.?.V...w...
   14e38:	9f98 abcd 9fb9 aba7 9fda ab81 9ffb ab5c     ..............\.
   14e48:	a01c ab36 a03e ab10 a05f aaeb a080 aac5     ..6.>..._.......
   14e58:	a0a2 aaa0 a0c4 aa7a a0e5 aa55 a107 aa30     ......z...U...0.
   14e68:	a129 aa0a a14a a9e5 a16c a9c0 a18e a99b     )...J...l.......
   14e78:	a1b0 a976 a1d2 a951 a1f4 a92c a216 a907     ..v...Q...,.....
   14e88:	a238 a8e2 a25b a8bd a27d a899 a29f a874     8...[...}.....t.
   14e98:	a2c2 a84f a2e4 a82b a307 a806 a329 a7e2     ..O...+.....)...
   14ea8:	a34c a7bd a36f a799 a391 a774 a3b4 a750     L...o.....t...P.
   14eb8:	a3d7 a72c a3fa a708 a41d a6e4 a440 a6c0     ..,.........@...
   14ec8:	a463 a69c a486 a678 a4a9 a654 a4cc a630     c.....x...T...0.
   14ed8:	a4f0 a60c a513 a5e8 a537 a5c5 a55a a5a1     ........7...Z...
   14ee8:	a57e a57e a5a1 a55a a5c5 a537 a5e8 a513     ~.~...Z...7.....
   14ef8:	a60c a4f0 a630 a4cc a654 a4a9 a678 a486     ....0...T...x...
   14f08:	a69c a463 a6c0 a440 a6e4 a41d a708 a3fa     ..c...@.........
   14f18:	a72c a3d7 a750 a3b4 a774 a391 a799 a36f     ,...P...t.....o.
   14f28:	a7bd a34c a7e2 a329 a806 a307 a82b a2e4     ..L...).....+...
   14f38:	a84f a2c2 a874 a29f a899 a27d a8bd a25b     O...t.....}...[.
   14f48:	a8e2 a238 a907 a216 a92c a1f4 a951 a1d2     ..8.....,...Q...
   14f58:	a976 a1b0 a99b a18e a9c0 a16c a9e5 a14a     v.........l...J.
   14f68:	aa0a a129 aa30 a107 aa55 a0e5 aa7a a0c4     ..).0...U...z...
   14f78:	aaa0 a0a2 aac5 a080 aaeb a05f ab10 a03e     .........._...>.
   14f88:	ab36 a01c ab5c 9ffb ab81 9fda aba7 9fb9     6...\...........
   14f98:	abcd 9f98 abf3 9f77 ac19 9f56 ac3f 9f35     ......w...V.?.5.
   14fa8:	ac65 9f14 ac8b 9ef3 acb1 9ed2 acd7 9eb2     e...............
   14fb8:	acfd 9e91 ad24 9e70 ad4a 9e50 ad70 9e2f     ....$.p.J.P.p./.
   14fc8:	ad97 9e0f adbd 9def ade4 9dce ae0b 9dae     ................
   14fd8:	ae31 9d8e ae58 9d6e ae7f 9d4e aea5 9d2e     1...X.n...N.....
   14fe8:	aecc 9d0e aef3 9cee af1a 9cce af41 9caf     ............A...
   14ff8:	af68 9c8f af8f 9c6f afb6 9c50 afdd 9c30     h.....o...P...0.
   15008:	b005 9c11 b02c 9bf1 b053 9bd2 b07b 9bb3     ....,...S...{...
   15018:	b0a2 9b94 b0c9 9b75 b0f1 9b55 b118 9b36     ......u...U...6.
   15028:	b140 9b17 b168 9af9 b18f 9ada b1b7 9abb     @...h...........
   15038:	b1df 9a9c b207 9a7e b22f 9a5f b257 9a40     ......~./._.W.@.
   15048:	b27f 9a22 b2a7 9a04 b2cf 99e5 b2f7 99c7     ..".............
   15058:	b31f 99a9 b347 998b b36f 996d b398 994e     ....G...o.m...N.
   15068:	b3c0 9930 b3e9 9913 b411 98f5 b439 98d7     ..0.........9...
   15078:	b462 98b9 b48b 989c b4b3 987e b4dc 9860     b.........~...`.
   15088:	b505 9843 b52d 9826 b556 9808 b57f 97eb     ..C.-.&.V.......
   15098:	b5a8 97ce b5d1 97b0 b5fa 9793 b623 9776     ............#.v.
   150a8:	b64c 9759 b675 973c b69e 9720 b6c7 9703     L.Y.u.<... .....
   150b8:	b6f1 96e6 b71a 96c9 b743 96ad b76d 9690     ........C...m...
   150c8:	b796 9674 b7c0 9657 b7e9 963b b813 961f     ..t...W...;.....
   150d8:	b83c 9603 b866 95e6 b890 95ca b8b9 95ae     <...f...........
   150e8:	b8e3 9592 b90d 9577 b937 955b b961 953f     ......w.7.[.a.?.
   150f8:	b98b 9523 b9b5 9508 b9df 94ec ba09 94d0     ..#.............
   15108:	ba33 94b5 ba5d 949a ba87 947e bab1 9463     3...].....~...c.
   15118:	badc 9448 bb06 942d bb30 9412 bb5b 93f7     ..H...-.0...[...
   15128:	bb85 93dc bbb0 93c1 bbda 93a6 bc05 938b     ................
   15138:	bc2f 9371 bc5a 9356 bc85 933c bcaf 9321     /.q.Z.V...<...!.
   15148:	bcda 9307 bd05 92ec bd30 92d2 bd5b 92b8     ........0...[...
   15158:	bd86 929e bdb1 9284 bddc 926a be07 9250     ..........j...P.
   15168:	be32 9236 be5d 921c be88 9202 beb3 91e9     2.6.]...........
   15178:	bedf 91cf bf0a 91b6 bf35 919c bf61 9183     ........5...a...
   15188:	bf8c 9169 bfb8 9150 bfe3 9137 c00f 911e     ..i...P...7.....
   15198:	c03a 9105 c066 90ec c091 90d3 c0bd 90ba     :...f...........
   151a8:	c0e9 90a1 c114 9088 c140 9070 c16c 9057     ........@.p.l.W.
   151b8:	c198 903e c1c4 9026 c1f0 900e c21c 8ff5     ..>...&.........
   151c8:	c248 8fdd c274 8fc5 c2a0 8fad c2cc 8f95     H...t...........
   151d8:	c2f8 8f7d c324 8f65 c351 8f4d c37d 8f35     ..}.$.e.Q.M.}.5.
   151e8:	c3a9 8f1d c3d6 8f06 c402 8eee c42e 8ed6     ................
   151f8:	c45b 8ebf c487 8ea8 c4b4 8e90 c4e0 8e79     [.............y.
   15208:	c50d 8e62 c53a 8e4b c566 8e34 c593 8e1d     ..b.:.K.f.4.....
   15218:	c5c0 8e06 c5ed 8def c619 8dd8 c646 8dc1     ............F...
   15228:	c673 8dab c6a0 8d94 c6cd 8d7e c6fa 8d67     s.........~...g.
   15238:	c727 8d51 c754 8d3b c781 8d24 c7ae 8d0e     '.Q.T.;...$.....
   15248:	c7db 8cf8 c809 8ce2 c836 8ccc c863 8cb6     ........6...c...
   15258:	c890 8ca1 c8be 8c8b c8eb 8c75 c918 8c60     ..........u...`.
   15268:	c946 8c4a c973 8c35 c9a1 8c1f c9ce 8c0a     F.J.s.5.........
   15278:	c9fc 8bf5 ca29 8bdf ca57 8bca ca85 8bb5     ....)...W.......
   15288:	cab2 8ba0 cae0 8b8b cb0e 8b77 cb3c 8b62     ..........w.<.b.
   15298:	cb69 8b4d cb97 8b39 cbc5 8b24 cbf3 8b10     i.M...9...$.....
   152a8:	cc21 8afb cc4f 8ae7 cc7d 8ad3 ccab 8abe     !...O...}.......
   152b8:	ccd9 8aaa cd07 8a96 cd35 8a82 cd63 8a6e     ........5...c.n.
   152c8:	cd92 8a5a cdc0 8a47 cdee 8a33 ce1c 8a1f     ..Z...G...3.....
   152d8:	ce4b 8a0c ce79 89f8 cea7 89e5 ced6 89d2     K...y...........
   152e8:	cf04 89be cf33 89ab cf61 8998 cf90 8985     ....3...a.......
   152f8:	cfbe 8972 cfed 895f d01b 894c d04a 8939     ..r..._...L.J.9.
   15308:	d079 8927 d0a7 8914 d0d6 8902 d105 88ef     y.'.............
   15318:	d134 88dd d162 88ca d191 88b8 d1c0 88a6     4...b...........
   15328:	d1ef 8894 d21e 8882 d24d 8870 d27c 885e     ........M.p.|.^.
   15338:	d2ab 884c d2da 883a d309 8828 d338 8817     ..L...:...(.8...
   15348:	d367 8805 d396 87f4 d3c5 87e2 d3f4 87d1     g...............
   15358:	d424 87c0 d453 87af d482 879d d4b1 878c     $...S...........
   15368:	d4e1 877b d510 876b d53f 875a d56f 8749     ..{...k.?.Z.o.I.
   15378:	d59e 8738 d5ce 8728 d5fd 8717 d62d 8707     ..8...(.....-...
   15388:	d65c 86f6 d68c 86e6 d6bb 86d6 d6eb 86c6     \...............
   15398:	d71b 86b6 d74a 86a5 d77a 8696 d7aa 8686     ....J...z.......
   153a8:	d7d9 8676 d809 8666 d839 8656 d869 8647     ..v...f.9.V.i.G.
   153b8:	d898 8637 d8c8 8628 d8f8 8619 d928 8609     ..7...(.....(...
   153c8:	d958 85fa d988 85eb d9b8 85dc d9e8 85cd     X...............
   153d8:	da18 85be da48 85af da78 85a0 daa8 8592     ....H...x.......
   153e8:	dad8 8583 db08 8574 db38 8566 db68 8558     ......t.8.f.h.X.
   153f8:	db99 8549 dbc9 853b dbf9 852d dc29 851f     ..I...;...-.)...
   15408:	dc59 8511 dc8a 8503 dcba 84f5 dcea 84e7     Y...............
   15418:	dd1b 84d9 dd4b 84cc dd7c 84be ddac 84b0     ....K...|.......
   15428:	dddc 84a3 de0d 8496 de3d 8488 de6e 847b     ........=...n.{.
   15438:	de9e 846e decf 8461 deff 8454 df30 8447     ..n...a...T.0.G.
   15448:	df61 843a df91 842d dfc2 8421 dff2 8414     a.:...-...!.....
   15458:	e023 8407 e054 83fb e085 83ef e0b5 83e2     #...T...........
   15468:	e0e6 83d6 e117 83ca e148 83be e178 83b2     ........H...x...
   15478:	e1a9 83a6 e1da 839a e20b 838e e23c 8382     ............<...
   15488:	e26d 8377 e29e 836b e2cf 8360 e2ff 8354     m.w...k...`...T.
   15498:	e330 8349 e361 833e e392 8332 e3c3 8327     0.I.a.>...2...'.
   154a8:	e3f4 831c e426 8311 e457 8306 e488 82fb     ....&...W.......
   154b8:	e4b9 82f1 e4ea 82e6 e51b 82db e54c 82d1     ............L...
   154c8:	e57d 82c6 e5af 82bc e5e0 82b2 e611 82a8     }...............
   154d8:	e642 829d e673 8293 e6a5 8289 e6d6 827f     B...s...........
   154e8:	e707 8276 e739 826c e76a 8262 e79b 8259     ..v.9.l.j.b...Y.
   154f8:	e7cd 824f e7fe 8246 e82f 823c e861 8233     ..O...F./.<.a.3.
   15508:	e892 822a e8c4 8220 e8f5 8217 e926 820e     ..*... .....&...
   15518:	e958 8205 e989 81fd e9bb 81f4 e9ec 81eb     X...............
   15528:	ea1e 81e2 ea4f 81da ea81 81d1 eab3 81c9     ....O...........
   15538:	eae4 81c1 eb16 81b8 eb47 81b0 eb79 81a8     ........G...y...
   15548:	ebab 81a0 ebdc 8198 ec0e 8190 ec3f 8188     ............?...
   15558:	ec71 8181 eca3 8179 ecd5 8172 ed06 816a     q.....y...r...j.
   15568:	ed38 8163 ed6a 815b ed9b 8154 edcd 814d     8.c.j.[...T...M.
   15578:	edff 8146 ee31 813f ee62 8138 ee94 8131     ..F.1.?.b.8...1.
   15588:	eec6 812a eef8 8123 ef2a 811d ef5c 8116     ..*...#.*...\...
   15598:	ef8d 8110 efbf 8109 eff1 8103 f023 80fd     ............#...
   155a8:	f055 80f6 f087 80f0 f0b9 80ea f0eb 80e4     U...............
   155b8:	f11c 80de f14e 80d9 f180 80d3 f1b2 80cd     ....N...........
   155c8:	f1e4 80c8 f216 80c2 f248 80bd f27a 80b7     ........H...z...
   155d8:	f2ac 80b2 f2de 80ad f310 80a8 f342 80a3     ............B...
   155e8:	f374 809e f3a6 8099 f3d8 8094 f40a 808f     t...............
   155f8:	f43c 808b f46e 8086 f4a0 8082 f4d3 807d     <...n.........}.
   15608:	f505 8079 f537 8075 f569 8070 f59b 806c     ..y.7.u.i.p...l.
   15618:	f5cd 8068 f5ff 8064 f631 8060 f663 805d     ..h...d.1.`.c.].
   15628:	f695 8059 f6c8 8055 f6fa 8052 f72c 804e     ..Y...U...R.,.N.
   15638:	f75e 804b f790 8047 f7c2 8044 f7f4 8041     ^.K...G...D...A.
   15648:	f827 803e f859 803b f88b 8038 f8bd 8035     '.>.Y.;...8...5.
   15658:	f8ef 8032 f922 802f f954 802d f986 802a     ..2."./.T.-...*.
   15668:	f9b8 8027 f9ea 8025 fa1d 8023 fa4f 8020     ..'...%...#.O. .
   15678:	fa81 801e fab3 801c fae5 801a fb18 8018     ................
   15688:	fb4a 8016 fb7c 8014 fbae 8013 fbe1 8011     J...|...........
   15698:	fc13 800f fc45 800e fc77 800c fcaa 800b     ....E...w.......
   156a8:	fcdc 800a fd0e 8009 fd40 8008 fd73 8007     ........@...s...
   156b8:	fda5 8006 fdd7 8005 fe09 8004 fe3c 8003     ............<...
   156c8:	fe6e 8002 fea0 8002 fed2 8001 ff05 8001     n...............
   156d8:	ff37 8001 ff69 8000 ff9b 8000 ffce 8000     7...i...........

000156e8 <twiddleCoefQ31>:
   156e8:	ffff 7fff 0000 0000 f621 7fff 43f5 0032     ........!....C2.
   156f8:	d886 7fff 87e3 0064 a72c 7fff cbc1 0096     ......d.,.......
   15708:	6216 7fff 0f88 00c9 0943 7fff 5330 00fb     .b......C...0S..
   15718:	9cb2 7ffe 96b1 012d 1c65 7ffe da03 015f     ......-.e....._.
   15728:	885a 7ffd 1d20 0192 e093 7ffc 5ffe 01c4     Z... ........_..
   15738:	250f 7ffc a297 01f6 55ce 7ffb e4e2 0228     .%.......U....(.
   15748:	72d1 7ffa 26d7 025b 7c18 7ff9 6870 028d     .r...&[..|..ph..
   15758:	71a2 7ff8 a9a4 02bf 5370 7ff7 ea6c 02f1     .q......pS..l...
   15768:	2182 7ff6 2abf 0324 dbd9 7ff4 6a96 0356     .!...*$......jV.
   15778:	8274 7ff3 a9ea 0388 1553 7ff2 e8b2 03ba     t.......S.......
   15788:	9478 7ff0 26e6 03ed ffe1 7fee 6480 041f     x....&.......d..
   15798:	5791 7fed a177 0451 9b85 7feb ddc3 0483     .W..w.Q.........
   157a8:	cbc0 7fe9 195d 04b6 e841 7fe7 543e 04e8     ....]...A...>T..
   157b8:	f108 7fe5 8e5c 051a e616 7fe3 c7b1 054c     ....\.........L.
   157c8:	c76b 7fe1 0035 057f 9508 7fdf 37df 05b1     k...5........7..
   157d8:	4eec 7fdd 6ea9 05e3 f519 7fda a48b 0615     .N...n..........
   157e8:	878e 7fd8 d97c 0647 064c 7fd6 0d76 067a     ....|.G.L...v.z.
   157f8:	7153 7fd3 406f 06ac c8a3 7fd0 7262 06de     Sq..o@......br..
   15808:	0c3e 7fce a345 0710 3c23 7fcb d311 0742     >...E...#<....B.
   15818:	5854 7fc8 01be 0775 60cf 7fc5 2f45 07a7     TX....u..`..E/..
   15828:	5596 7fc2 5b9e 07d9 36aa 7fbf 86c2 080b     .U...[...6......
   15838:	040a 7fbc b0a7 083d bdb8 7fb8 d947 086f     ......=.....G.o.
   15848:	63b3 7fb5 009a 08a2 f5fc 7fb1 2699 08d4     .c...........&..
   15858:	7495 7fae 4b3a 0906 df7c 7faa 6e78 0938     .t..:K..|...xn8.
   15868:	36b4 7fa7 9049 096a 7a3c 7fa3 b0a7 099c     .6..I.j.<z......
   15878:	aa15 7f9f cf89 09ce c640 7f9b ece8 0a00     ........@.......
   15888:	cebd 7f97 08bd 0a33 c38c 7f93 22fe 0a65     ......3......"e.
   15898:	a4b0 7f8f 3ba5 0a97 7227 7f8b 52aa 0ac9     .....;..'r...R..
   158a8:	2bf3 7f87 6805 0afb d214 7f82 7baf 0b2d     .+...h.......{-.
   158b8:	648c 7f7e 8d9f 0b5f e35a 7f79 9dcf 0b91     .d~..._.Z.y.....
   158c8:	4e80 7f75 ac35 0bc3 a5fe 7f70 b8cb 0bf5     .Nu.5.....p.....
   158d8:	e9d4 7f6b c389 0c27 1a05 7f67 cc68 0c59     ..k...'...g.h.Y.
   158e8:	368f 7f62 d35e 0c8b 3f75 7f5d d865 0cbd     .6b.^...u?].e...
   158f8:	34b7 7f58 db76 0cef 1655 7f53 dc87 0d21     .4X.v...U.S...!.
   15908:	e451 7f4d db92 0d53 9eaa 7f48 d88f 0d85     Q.M...S...H.....
   15918:	4563 7f43 d376 0db7 d87c 7f3d cc40 0de9     cEC.v...|.=.@...
   15928:	57f6 7f38 c2e4 0e1b c3d1 7f32 b75b 0e4d     .W8.......2.[.M.
   15938:	1c0e 7f2d a99e 0e7f 60af 7f27 99a4 0eb1     ..-......`'.....
   15948:	91b4 7f21 8766 0ee3 af1e 7f1b 72dc 0f15     ..!.f........r..
   15958:	b8ee 7f15 5bff 0f47 af25 7f0f 42c7 0f79     .....[G.%....By.
   15968:	91c4 7f09 272b 0fab 60cb 7f03 0926 0fdd     ....+'...`..&...
   15978:	1c3c 7efd e8ad 100e c418 7ef6 c5bb 1040     <..~.......~..@.
   15988:	5860 7ef0 a048 1072 d914 7ee9 784b 10a4     `X.~H.r....~Kx..
   15998:	4636 7ee3 4dbd 10d6 9fc6 7edc 2096 1108     6F.~.M.....~. ..
   159a8:	e5c6 7ed5 f0cf 1139 1837 7ecf be60 116b     ...~..9.7..~`.k.
   159b8:	371a 7ec8 8941 119d 4270 7ec1 516a 11cf     .7.~A...pB.~jQ..
   159c8:	3a39 7eba 16d5 1201 1e78 7eb3 d979 1232     9:.~....x..~y.2.
   159d8:	ef2c 7eab 994e 1264 ac58 7ea4 564d 1296     ,..~N.d.X..~MV..
   159e8:	55fc 7e9d 106f 12c8 ec1a 7e95 c7aa 12f9     .U.~o......~....
   159f8:	6eb2 7e8e 7bf9 132b ddc6 7e86 2d53 135d     .n.~.{+....~S-].
   15a08:	3957 7e7f dbb1 138e 8166 7e77 870a 13c0     W9.~....f.w~....
   15a18:	b5f4 7e6f 2f58 13f2 d703 7e67 d492 1423     ..o~X/....g~..#.
   15a28:	e493 7e5f 76b1 1455 dea7 7e57 15ae 1487     .._~.vU...W~....
   15a38:	c53e 7e4f b17f 14b8 985b 7e47 4a1f 14ea     >.O~....[.G~.J..
   15a48:	57ff 7e3f df86 151b 042a 7e37 71aa 154d     .W?~....*.7~.qM.
   15a58:	9cdf 7e2e 0086 157f 221f 7e26 8c12 15b0     ...~....."&~....
   15a68:	93ea 7e1d 1445 15e2 f242 7e14 9918 1613     ...~E...B..~....
   15a78:	3d29 7e0c 1a83 1645 74a0 7e03 987f 1676     )=.~..E..t.~..v.
   15a88:	98a8 7dfa 1305 16a8 a942 7df1 8a0c 16d9     ...}....B..}....
   15a98:	a670 7de8 fd8d 170a 9034 7ddf 6d80 173c     p..}....4..}.m<.
   15aa8:	668f 7dd6 d9de 176d 2981 7dcd 429f 179f     .f.}..m..).}.B..
   15ab8:	d90d 7dc3 a7bc 17d0 7534 7dba 092c 1802     ...}....4u.},...
   15ac8:	fdf8 7db0 66e9 1833 7359 7da7 c0ea 1864     ...}.f3.Ys.}..d.
   15ad8:	d55a 7d9d 1728 1896 23fc 7d94 699b 18c7     Z..}(....#.}.i..
   15ae8:	5f40 7d8a b83c 18f8 8728 7d80 0304 192a     @_.}<...(..}..*.
   15af8:	9bb5 7d76 49ea 195b 9ce9 7d6c 8ce7 198c     ..v}.I[...l}....
   15b08:	8ac6 7d62 cbf3 19bd 654d 7d58 0707 19ef     ..b}....MeX}....
   15b18:	2c7f 7d4e 3e1b 1a20 e05e 7d43 7128 1a51     .,N}.> .^.C}(qQ.
   15b28:	80ec 7d39 a026 1a82 0e2b 7d2f cb0d 1ab3     ..9}&...+./}....
   15b38:	881b 7d24 f1d6 1ae4 eebf 7d19 1479 1b16     ..$}.......}y...
   15b48:	4218 7d0f 32ef 1b47 8228 7d04 4d30 1b78     .B.}.2G.(..}0Mx.
   15b58:	aef0 7cf9 6335 1ba9 c873 7cee 74f6 1bda     ...|5c..s..|.t..
   15b68:	ceb2 7ce3 826a 1c0b c1ae 7cd8 8b8c 1c3c     ...|j......|..<.
   15b78:	a169 7ccd 9053 1c6d 6de5 7cc2 90b8 1c9e     i..|S.m..m.|....
   15b88:	2724 7cb7 8cb3 1ccf cd28 7cab 843d 1d00     $'.|....(..|=...
   15b98:	5ff1 7ca0 774d 1d31 df83 7c94 65dd 1d62     ._.|Mw1....|.eb.
   15ba8:	4bde 7c89 4fe5 1d93 a505 7c7d 355e 1dc4     .K.|.O....}|^5..
   15bb8:	eaf9 7c71 163f 1df5 1dbc 7c66 f282 1e25     ..q|?.....f|..%.
   15bc8:	3d50 7c5a ca1e 1e56 49b7 7c4e 9d0d 1e87     P=Z|..V..IN|....
   15bd8:	42f2 7c42 6b46 1eb8 2904 7c36 34c3 1ee9     .BB|Fk...)6|.4..
   15be8:	fbee 7c29 f97b 1f19 bbb3 7c1d b968 1f4a     ..)|{......|h.J.
   15bf8:	6853 7c11 7481 1f7b 01d2 7c05 2abf 1fac     Sh.|.t{....|.*..
   15c08:	8830 7bf8 dc1b 1fdc fb70 7beb 888d 200d     0..{....p..{... 
   15c18:	5b94 7bdf 300d 203e a89e 7bd2 d295 206e     .[.{.0> ...{..n 
   15c28:	e290 7bc5 701c 209f 096b 7bb9 089c 20d0     ...{.p. k..{... 
   15c38:	1d31 7bac 9c0c 2100 1de6 7b9f 2a65 2131     1..{...!...{e*1!
   15c48:	0b89 7b92 b3a0 2161 e61f 7b84 37b5 2192     ...{..a!...{.7.!
   15c58:	ada8 7b77 b69c 21c2 6227 7b6a 304f 21f3     ..w{...!'bj{O0.!
   15c68:	039e 7b5d a4c5 2223 920e 7b4f 13f8 2254     ..]{..#"..O{..T"
   15c78:	0d7a 7b42 7de0 2284 75e5 7b34 e274 22b4     z.B{.}.".u4{t.."
   15c88:	cb4f 7b26 41af 22e5 0dbc 7b19 9b88 2315     O.&{.A."...{...#
   15c98:	3d2c 7b0b eff8 2345 59a4 7afd 3ef7 2376     ,=.{..E#.Y.z.>v#
   15ca8:	6323 7aef 887f 23a6 59ae 7ae1 cc87 23d6     #c.z...#.Y.z...#
   15cb8:	3d45 7ad3 0b08 2407 0dec 7ac5 43fa 2437     E=.z...$...z.C7$
   15cc8:	cba4 7ab6 7758 2467 766f 7aa8 a517 2497     ...zXwg$ov.z...$
   15cd8:	0e50 7a9a cd33 24c7 9348 7a8b efa2 24f7     P..z3..$H..z...$
   15ce8:	055b 7a7d 0c5e 2528 648a 7a6e 235f 2558     [.}z^.(%.dnz_#X%
   15cf8:	b0d8 7a5f 349d 2588 ea47 7a50 4012 25b8     .._z.4.%G.Pz.@.%
   15d08:	10d8 7a42 45b6 25e8 2490 7a33 4581 2618     ..Bz.E.%.$3z.E.&
   15d18:	256f 7a24 3f6c 2648 1378 7a15 3370 2678     o%$zl?H&x..zp3x&
   15d28:	eead 7a05 2186 26a8 b711 79f6 09a5 26d8     ...z.!.&...y...&
   15d38:	6ca7 79e7 ebc7 2707 0f6f 79d8 c7e3 2737     .l.y...'o..y..7'
   15d48:	9f6e 79c8 9df4 2767 1ca4 79b9 6df1 2797     n..y..g'...y.m.'
   15d58:	8715 79a9 37d3 27c7 dec4 7999 fb92 27f6     ...y.7.'...y...'
   15d68:	23b1 798a b928 2826 55e0 797a 708d 2856     .#.y(.&(.Uzy.pV(
   15d78:	7554 796a 21b9 2886 820e 795a cca5 28b5     Tujy.!.(..Zy...(
   15d88:	7c12 794a 714b 28e5 6361 793a 0fa1 2915     .|JyKq.(ac:y...)
   15d98:	37fe 792a a7a2 2944 f9ec 7919 3946 2974     .7*y..D)...yF9t)
   15da8:	a92d 7909 c485 29a3 45c3 78f9 4958 29d3     -..y...).E.xXI.)
   15db8:	cfb2 78e8 c7b8 2a02 46fb 78d8 3f9e 2a32     ...x...*.F.x.?2*
   15dc8:	aba2 78c7 b101 2a61 fda8 78b6 1bdc 2a91     ...x..a*...x...*
   15dd8:	3d11 78a6 8026 2ac0 69df 7895 ddd8 2aef     .=.x&..*.i.x...*
   15de8:	8414 7884 34eb 2b1f 8bb3 7873 8558 2b4e     ...x.4.+..sxX.N+
   15df8:	80bf 7862 cf17 2b7d 633b 7851 1221 2bad     ..bx..}+;cQx!..+
   15e08:	3329 7840 4e6f 2bdc f08b 782e 83fa 2c0b     )3@xoN.+...x...,
   15e18:	9b65 781d b2b9 2c3a 33b8 780c daa6 2c69     e..x..:,.3.x..i,
   15e28:	b989 77fa fbba 2c98 2cd9 77e9 15ee 2cc8     ...w...,.,.w...,
   15e38:	8daa 77d7 2939 2cf7 dc01 77c5 3596 2d26     ...w9).,...w.5&-
   15e48:	17df 77b4 3afc 2d55 4148 77a2 3964 2d84     ...w.:U-HA.wd9.-
   15e58:	583e 7790 30c7 2db3 5cc3 777e 211e 2de2     >X.w.0.-.\~w.!.-
   15e68:	4edb 776c 0a62 2e11 2e89 775a ec8b 2e3f     .Nlwb.....Zw..?.
   15e78:	fbce 7747 c792 2e6e b6af 7735 9b70 2e9d     ..Gw..n...5wp...
   15e88:	5f2d 7723 681e 2ecc f54c 7710 2d95 2efb     -_#w.h..L..w.-..
   15e98:	790e 76fe ebcc 2f29 ea77 76eb a2be 2f58     .y.v..)/w..v..X/
   15ea8:	4989 76d9 5262 2f87 9647 76c6 fab2 2fb5     .I.vbR./G..v.../
   15eb8:	d0b4 76b3 9ba7 2fe4 f8d2 76a0 3539 3013     ...v.../...v95.0
   15ec8:	0ea6 768e c761 3041 1231 767b 5217 3070     ...va.A01.{v.Rp0
   15ed8:	0376 7668 d556 309e e279 7654 5115 30cd     v.hvV..0y.Tv.Q.0
   15ee8:	af3d 7641 c54d 30fb 69c4 762e 31f8 312a     =.AvM..0.i.v.1*1
   15ef8:	1211 761b 970e 3158 a828 7607 f487 3186     ...v..X1(..v...1
   15f08:	2c0b 75f4 4a5e 31b5 9dbd 75e0 9889 31e3     .,.u^J.1...u...1
   15f18:	fd42 75cc df04 3211 4a9c 75b9 1dc6 3240     B..u...2.J.u..@2
   15f28:	85cf 75a5 54c7 326e aedd 7591 8402 329c     ...u.Tn2...u...2
   15f38:	c5ca 757d ab6f 32ca ca99 7569 cb07 32f8     ..}uo..2..iu...2
   15f48:	bd4c 7555 e2c3 3326 9de7 7541 f29b 3354     L.Uu..&3..Au..T3
   15f58:	6c6c 752d fa88 3382 28e0 7519 fa84 33b0     ll-u...3.(.u...3
   15f68:	d345 7504 f287 33de 6b9e 74f0 e28b 340c     E..u...3.k.t...4
   15f78:	f1ef 74db ca87 343a 663a 74c7 aa76 3468     ...t..:4:f.tv.h4
   15f88:	c884 74b2 8250 3496 18cd 749e 520d 34c4     ...tP..4...t.R.4
   15f98:	571c 7489 19a8 34f2 8371 7474 d918 351f     .W.t...4q.tt...5
   15fa8:	9dd1 745f 9057 354d a63f 744a 3f5d 357b     .._tW.M5?.Jt]?{5
   15fb8:	9cbd 7435 e625 35a8 8150 7420 84a6 35d6     ..5t%..5P. t...5
   15fc8:	53fb 740b 1ad9 3604 14c0 73f6 a8b8 3631     .S.t...6...s..16
   15fd8:	c3a3 73e0 2e3b 365f 60a8 73cb ab5c 368c     ...s;._6.`.s\..6
   15fe8:	ebd1 73b5 2014 36ba 6522 73a0 8c5b 36e7     ...s. .6"e.s[..6
   15ff8:	cc9e 738a f02a 3714 2249 7375 4b7b 3742     ...s*..7I"us{KB7
   16008:	6626 735f 9e46 376f 9838 7349 e885 379c     &f_sF.o78.Is...7
   16018:	b883 7333 2a30 37ca c70a 731d 6341 37f7     ..3s0*.7...sAc.7
   16028:	c3d0 7307 93b0 3824 aed9 72f1 bb77 3851     ...s..$8...rw.Q8
   16038:	8828 72db da8e 387e 4fc1 72c5 f0ef 38ab     (..r..~8.O.r...8
   16048:	05a7 72af fe93 38d8 a9dd 7298 0373 3906     ...r...8...rs..9
   16058:	3c67 7282 ff87 3932 bd48 726b f2c9 395f     g<.r..29H.kr.._9
   16068:	2c85 7255 dd32 398c 8a20 723e bebc 39b9     .,Ur2..9 .>r...9
   16078:	d61c 7227 975e 39e6 107e 7211 6712 3a13     ..'r^..9~..r.g.:
   16088:	3949 71fa 2dd2 3a40 5080 71e3 eb96 3a6c     I9.q.-@:.P.q..l:
   16098:	5626 71cc a057 3a99 4a41 71b5 4c0f 3ac6     &V.qW..:AJ.q.L.:
   160a8:	2cd2 719e eeb7 3af2 fdde 7186 8848 3b1f     .,.q...:...qH..;
   160b8:	bd68 716f 18ba 3b4c 6b74 7158 a007 3b78     h.oq..L;tkXq..x;
   160c8:	0805 7141 1e29 3ba5 931f 7129 9318 3bd1     ..Aq)..;..)q...;
   160d8:	0cc5 7112 fecd 3bfd 74fc 70fa 6142 3c2a     ...q...;.t.pBa*<
   160e8:	cbc6 70e2 ba70 3c56 1128 70cb 0a50 3c83     ...pp.V<(..pP..<
   160f8:	4525 70b3 50da 3caf 67c0 709b 8e09 3cdb     %E.p.P.<.g.p...<
   16108:	78ff 7083 c1d6 3d07 78e3 706b ec39 3d33     .x.p...=.xkp9.3=
   16118:	6771 7053 0d2c 3d60 44ad 703b 24a8 3d8c     qgSp,.`=.D;p.$.=
   16128:	109a 7023 32a6 3db8 cb3c 700a 371f 3de4     ..#p.2.=<..p.7.=
   16138:	7497 6ff2 320d 3e10 0cae 6fda 2369 3e3c     .t.o.2.>...oi#<>
   16148:	9385 6fc1 0b2c 3e68 0921 6fa9 e950 3e93     ...o,.h>!..oP..>
   16158:	6d84 6f90 bdcd 3ebf c0b3 6f77 889c 3eeb     .m.o...>..wo...>
   16168:	02b2 6f5f 49b8 3f17 3383 6f46 0119 3f43     .._o.I.?.3Fo..C?
   16178:	532c 6f2d aeb8 3f6e 61b0 6f14 5290 3f9a     ,S-o..n?.a.o.R.?
   16188:	5f12 6efb ec98 3fc5 4b57 6ee2 7cca 3ff1     ._.n...?WK.n.|.?
   16198:	2683 6ec9 0321 401d f099 6eaf 7f94 4048     .&.n!..@...n..H@
   161a8:	a99d 6e96 f21d 4073 5193 6e7d 5ab6 409f     ...n..s@.Q}n.Z.@
   161b8:	e87f 6e63 b958 40ca 6e66 6e4a 0dfb 40f6     ..cnX..@fnJn...@
   161c8:	e34a 6e30 589b 4121 4730 6e17 992f 414c     J.0n.X!A0G.n/.LA
   161d8:	9a1c 6dfd cfb1 4177 dc11 6de3 fc1a 41a2     ...m..wA...m...A
   161e8:	0d14 6dca 1e65 41ce 2d29 6db0 3689 41f9     ...me..A)-.m.6.A
   161f8:	3c54 6d96 4481 4224 3a98 6d7c 4845 424f     T<.m.D$B.:|mEHOB
   16208:	27fa 6d62 41d0 427a 047e 6d48 311b 42a5     .'bm.AzB~.Hm.1.B
   16218:	d027 6d2d 161e 42d0 8afb 6d13 f0d4 42fa     '.-m...B...m...B
   16228:	34fc 6cf9 c135 4325 ce2f 6cde 873c 4350     .4.l5.%C/..l<.PC
   16238:	5698 6cc4 42e1 437b ce3b 6ca9 f41e 43a5     .V.l.B{C;..l...C
   16248:	351c 6c8f 9aed 43d0 8b3f 6c74 3746 43fb     .5.l...C?.tlF7.C
   16258:	d0a9 6c59 c923 4425 055d 6c3f 507e 4450     ..Yl#.%D].?l~PPD
   16268:	2960 6c24 cd50 447a 3cb6 6c09 3f93 44a5     `)$lP.zD.<.l.?.D
   16278:	3f62 6bee a740 44cf 316a 6bd3 0450 44fa     b?.k@..Dj1.kP..D
   16288:	12d1 6bb8 56bd 4524 e39b 6b9c 9e80 454e     ...k.V$E...k..NE
   16298:	a3cd 6b81 db93 4578 536b 6b66 0df0 45a3     ...k..xEkSfk...E
   162a8:	f279 6b4a 358f 45cd 80fb 6b2f 526b 45f7     y.Jk.5.E../kkR.E
   162b8:	fef5 6b13 647d 4621 6c6c 6af8 6bbe 464b     ...k}d!Fll.j.kKF
   162c8:	c964 6adc 6828 4675 15e2 6ac1 59b4 469f     d..j(huF...j.Y.F
   162d8:	51e9 6aa5 405c 46c9 7d7d 6a89 1c1a 46f3     .Q.j\@.F}}.j...F
   162e8:	98a4 6a6d ece7 471c a361 6a51 b2bc 4746     ..mj...Ga.Qj..FG
   162f8:	9db9 6a35 6d93 4770 87b0 6a19 1d67 479a     ..5j.mpG...jg..G
   16308:	614a 69fd c22f 47c3 2a8c 69e1 5be6 47ed     Ja.i/..G.*.i.[.G
   16318:	e37a 69c4 ea86 4816 8c19 69a8 6e08 4840     z..i...H...i.n@H
   16328:	246c 698c e665 4869 ac78 696f 5397 4893     l$.ie.iHx.oi.S.H
   16338:	2442 6953 b599 48bc 8bce 6936 0c62 48e6     B$Si...H..6ib..H
   16348:	e320 6919 57ee 490f 2a3d 68fd 9836 4938      ..i.W.I=*.h6.8I
   16358:	6129 68e0 cd33 4961 87e9 68c3 f6df 498a     )a.h3.aI...h...I
   16368:	9e81 68a6 1533 49b4 a4f6 6889 282a 49dd     ...h3..I...h*(.I
   16378:	9b4b 686c 2fbd 4a06 8186 684f 2be6 4a2f     K.lh./.J..Oh.+/J
   16388:	57ab 6832 1c9e 4a58 1dbe 6815 01de 4a81     .W2h..XJ...h...J
   16398:	d3c5 67f7 dba2 4aa9 79c3 67da a9e2 4ad2     ...g...J.y.g...J
   163a8:	0fbd 67bd 6c98 4afb 95b7 679f 23be 4b24     ...g.l.J...g.#$K
   163b8:	0bb7 6782 cf4d 4b4c 71c0 6764 6f40 4b75     ...gM.LK.qdg@ouK
   163c8:	c7d8 6746 0390 4b9e 0e02 6729 8c36 4bc6     ..Fg...K..)g6..K
   163d8:	4444 670b 092d 4bef 6aa1 66ed 7a6e 4c17     DD.g-..K.j.fnz.L
   163e8:	8120 66cf dff4 4c3f 87c3 66b1 39b7 4c68      ..f..?L...f.9hL
   163f8:	7e91 6693 87b1 4c90 658c 6675 c9dd 4cb8     .~.f...L.euf...L
   16408:	3cbb 6657 0034 4ce1 0422 6639 2ab0 4d09     .<Wf4..L".9f.*.M
   16418:	bbc5 661a 494b 4d31 63a9 65fc 5bfe 4d59     ...fKI1M.c.e.[YM
   16428:	fbd3 65dd 62c4 4d81 8447 65bf 5d96 4da9     ...e.b.MG..e.].M
   16438:	fd0b 65a0 4c6e 4dd1 6622 6582 2f46 4df9     ...enL.M"f.eF/.M
   16448:	bf92 6563 0617 4e21 095f 6545 d0dd 4e48     ..ce..!N_.Ee..HN
   16458:	438f 6526 8f8f 4e70 6e25 6507 4229 4e98     .C&e..pN%n.e)B.N
   16468:	8926 64e8 e8a5 4ebf 9498 64c9 82fb 4ee7     &..d...N...d...N
   16478:	907f 64aa 1126 4f0f 7ce0 648b 9320 4f36     ...d&..O.|.d .6O
   16488:	59bf 646c 08e3 4f5e 2722 644d 7269 4f85     .Yld..^O"'Mdir.O
   16498:	e50d 642d cfab 4fac 9386 640e 20a4 4fd4     ..-d...O...d. .O
   164a8:	3290 63ef 654d 4ffb c231 63cf 9da1 5022     .2.cMe.O1..c.."P
   164b8:	426d 63b0 c999 5049 b34a 6390 e92f 5070     mB.c..IPJ..c/.pP
   164c8:	14cc 6371 fc5e 5097 66f9 6351 031f 50bf     ..qc^..P.fQc...P
   164d8:	a9d4 6331 fd6d 50e5 dd64 6311 eb40 510c     ..1cm..Pd..c@..Q
   164e8:	01ac 62f2 cc94 5133 16b3 62d2 a162 515a     ...b..3Q...bb.ZQ
   164f8:	1c7b 62b2 69a5 5181 130c 6292 2555 51a8     {..b.i.Q...bU%.Q
   16508:	fa69 6271 d46e 51ce d298 6251 76ea 51f5     i.qbn..Q..Qb.v.Q
   16518:	9b9d 6231 0cc2 521c 557e 6211 95f0 5242     ..1b...R~U.b..BR
   16528:	003f 61f1 126e 5269 9be5 61d0 8238 528f     ?..an.iR...a8..R
   16538:	2876 61b0 e546 52b5 a5f7 618f 3b92 52dc     v(.aF..R...a.;.R
   16548:	146c 616f 8518 5302 73da 614e c1d0 5328     l.oa...S.sNa..(S
   16558:	c447 612d f1b5 534e 05b7 610d 14c2 5375     G.-a..NS...a..uS
   16568:	3830 60ec 2af0 539b 5bb7 60cb 3439 53c1     08.`.*.S.[.`94.S
   16578:	7050 60aa 3097 53e7 7601 6089 2005 540d     Pp.`.0.S.v.`. .T
   16588:	6ccf 6068 027d 5433 54bf 6047 d7f9 5458     .lh`}.3T.TG`..XT
   16598:	2dd6 6026 a073 547e f819 6004 5be6 54a4     .-&`s.~T...`.[.T
   165a8:	b38d 5fe3 0a4b 54ca 6038 5fc2 ab9c 54ef     ..._K..T8`._...T
   165b8:	fe1f 5fa0 3fd4 5515 8d46 5f7f c6ee 553a     ..._.?.UF.._..:U
   165c8:	0db3 5f5e 40e2 5560 7f6b 5f3c adad 5585     ..^_.@`Uk.<_...U
   165d8:	e274 5f1a 0d46 55ab 36d1 5ef9 5faa 55d0     t.._F..U.6.^._.U
   165e8:	7c8a 5ed7 a4d2 55f5 b3a2 5eb5 dcb9 561a     .|.^...U...^...V
   165f8:	dc1f 5e93 0758 5640 f606 5e71 24aa 5665     ...^X.@V..q^.$eV
   16608:	015d 5e50 34a9 568a fe29 5e2d 3750 56af     ].P^.4.V).-^P7.V
   16618:	ec6e 5e0b 2c99 56d4 cc33 5de9 147e 56f9     n..^.,.V3..]~..V
   16628:	9d7c 5dc7 eefa 571d 604f 5da5 bc06 5742     |..]...WO`.]..BW
   16638:	14b1 5d83 7b9d 5767 baa7 5d60 2dba 578c     ...].{gW..`].-.W
   16648:	5237 5d3e d256 57b0 db65 5d1b 696d 57d5     7R>]V..We..]mi.W
   16658:	5638 5cf9 f2f8 57f9 c2b5 5cd6 6ef1 581e     8V.\...W...\.n.X
   16668:	20e0 5cb4 dd54 5842 70bf 5c91 3e1b 5867     . .\T.BX.p.\.>gX
   16678:	b258 5c6e 9140 588b e5b0 5c4b d6bd 58af     X.n\@..X..K\...X
   16688:	0acc 5c29 0e8c 58d4 21b2 5c06 38a9 58f8     ..)\...X.!.\.8.X
   16698:	2a67 5be3 550e 591c 24f0 5bc0 63b5 5940     g*.[.U.Y.$.[.c@Y
   166a8:	1154 5b9d 6498 5964 ef96 5b79 57b2 5988     T..[.ddY..y[.W.Y
   166b8:	bfbd 5b56 3cfd 59ac 81ce 5b33 1475 59d0     ..V[.<.Y..3[u..Y
   166c8:	35cf 5b10 de12 59f3 dbc5 5aec 99d1 5a17     .5.[...Y...Z...Z
   166d8:	73b5 5ac9 47ab 5a3b fda5 5aa5 e79a 5a5e     .s.Z.G;Z...Z..^Z
   166e8:	799a 5a82 799a 5a82 e79a 5a5e fda5 5aa5     .y.Z.y.Z..^Z...Z
   166f8:	47ab 5a3b 73b5 5ac9 99d1 5a17 dbc5 5aec     .G;Z.s.Z...Z...Z
   16708:	de12 59f3 35cf 5b10 1475 59d0 81ce 5b33     ...Y.5.[u..Y..3[
   16718:	3cfd 59ac bfbd 5b56 57b2 5988 ef96 5b79     .<.Y..V[.W.Y..y[
   16728:	6498 5964 1154 5b9d 63b5 5940 24f0 5bc0     .ddYT..[.c@Y.$.[
   16738:	550e 591c 2a67 5be3 38a9 58f8 21b2 5c06     .U.Yg*.[.8.X.!.\
   16748:	0e8c 58d4 0acc 5c29 d6bd 58af e5b0 5c4b     ...X..)\...X..K\
   16758:	9140 588b b258 5c6e 3e1b 5867 70bf 5c91     @..XX.n\.>gX.p.\
   16768:	dd54 5842 20e0 5cb4 6ef1 581e c2b5 5cd6     T.BX. .\.n.X...\
   16778:	f2f8 57f9 5638 5cf9 696d 57d5 db65 5d1b     ...W8V.\mi.We..]
   16788:	d256 57b0 5237 5d3e 2dba 578c baa7 5d60     V..W7R>].-.W..`]
   16798:	7b9d 5767 14b1 5d83 bc06 5742 604f 5da5     .{gW...]..BWO`.]
   167a8:	eefa 571d 9d7c 5dc7 147e 56f9 cc33 5de9     ...W|..]~..V3..]
   167b8:	2c99 56d4 ec6e 5e0b 3750 56af fe29 5e2d     .,.Vn..^P7.V).-^
   167c8:	34a9 568a 015d 5e50 24aa 5665 f606 5e71     .4.V].P^.$eV..q^
   167d8:	0758 5640 dc1f 5e93 dcb9 561a b3a2 5eb5     X.@V...^...V...^
   167e8:	a4d2 55f5 7c8a 5ed7 5faa 55d0 36d1 5ef9     ...U.|.^._.U.6.^
   167f8:	0d46 55ab e274 5f1a adad 5585 7f6b 5f3c     F..Ut.._...Uk.<_
   16808:	40e2 5560 0db3 5f5e c6ee 553a 8d46 5f7f     .@`U..^_..:UF.._
   16818:	3fd4 5515 fe1f 5fa0 ab9c 54ef 6038 5fc2     .?.U..._...T8`._
   16828:	0a4b 54ca b38d 5fe3 5be6 54a4 f819 6004     K..T..._.[.T...`
   16838:	a073 547e 2dd6 6026 d7f9 5458 54bf 6047     s.~T.-&`..XT.TG`
   16848:	027d 5433 6ccf 6068 2005 540d 7601 6089     }.3T.lh`. .T.v.`
   16858:	3097 53e7 7050 60aa 3439 53c1 5bb7 60cb     .0.SPp.`94.S.[.`
   16868:	2af0 539b 3830 60ec 14c2 5375 05b7 610d     .*.S08.`..uS...a
   16878:	f1b5 534e c447 612d c1d0 5328 73da 614e     ..NSG.-a..(S.sNa
   16888:	8518 5302 146c 616f 3b92 52dc a5f7 618f     ...Sl.oa.;.R...a
   16898:	e546 52b5 2876 61b0 8238 528f 9be5 61d0     F..Rv(.a8..R...a
   168a8:	126e 5269 003f 61f1 95f0 5242 557e 6211     n.iR?..a..BR~U.b
   168b8:	0cc2 521c 9b9d 6231 76ea 51f5 d298 6251     ...R..1b.v.Q..Qb
   168c8:	d46e 51ce fa69 6271 2555 51a8 130c 6292     n..Qi.qbU%.Q...b
   168d8:	69a5 5181 1c7b 62b2 a162 515a 16b3 62d2     .i.Q{..bb.ZQ...b
   168e8:	cc94 5133 01ac 62f2 eb40 510c dd64 6311     ..3Q...b@..Qd..c
   168f8:	fd6d 50e5 a9d4 6331 031f 50bf 66f9 6351     m..P..1c...P.fQc
   16908:	fc5e 5097 14cc 6371 e92f 5070 b34a 6390     ^..P..qc/.pPJ..c
   16918:	c999 5049 426d 63b0 9da1 5022 c231 63cf     ..IPmB.c.."P1..c
   16928:	654d 4ffb 3290 63ef 20a4 4fd4 9386 640e     Me.O.2.c. .O...d
   16938:	cfab 4fac e50d 642d 7269 4f85 2722 644d     ...O..-dir.O"'Md
   16948:	08e3 4f5e 59bf 646c 9320 4f36 7ce0 648b     ..^O.Yld .6O.|.d
   16958:	1126 4f0f 907f 64aa 82fb 4ee7 9498 64c9     &..O...d...N...d
   16968:	e8a5 4ebf 8926 64e8 4229 4e98 6e25 6507     ...N&..d)B.N%n.e
   16978:	8f8f 4e70 438f 6526 d0dd 4e48 095f 6545     ..pN.C&e..HN_.Ee
   16988:	0617 4e21 bf92 6563 2f46 4df9 6622 6582     ..!N..ceF/.M"f.e
   16998:	4c6e 4dd1 fd0b 65a0 5d96 4da9 8447 65bf     nL.M...e.].MG..e
   169a8:	62c4 4d81 fbd3 65dd 5bfe 4d59 63a9 65fc     .b.M...e.[YM.c.e
   169b8:	494b 4d31 bbc5 661a 2ab0 4d09 0422 6639     KI1M...f.*.M".9f
   169c8:	0034 4ce1 3cbb 6657 c9dd 4cb8 658c 6675     4..L.<Wf...L.euf
   169d8:	87b1 4c90 7e91 6693 39b7 4c68 87c3 66b1     ...L.~.f.9hL...f
   169e8:	dff4 4c3f 8120 66cf 7a6e 4c17 6aa1 66ed     ..?L ..fnz.L.j.f
   169f8:	092d 4bef 4444 670b 8c36 4bc6 0e02 6729     -..KDD.g6..K..)g
   16a08:	0390 4b9e c7d8 6746 6f40 4b75 71c0 6764     ...K..Fg@ouK.qdg
   16a18:	cf4d 4b4c 0bb7 6782 23be 4b24 95b7 679f     M.LK...g.#$K...g
   16a28:	6c98 4afb 0fbd 67bd a9e2 4ad2 79c3 67da     .l.J...g...J.y.g
   16a38:	dba2 4aa9 d3c5 67f7 01de 4a81 1dbe 6815     ...J...g...J...h
   16a48:	1c9e 4a58 57ab 6832 2be6 4a2f 8186 684f     ..XJ.W2h.+/J..Oh
   16a58:	2fbd 4a06 9b4b 686c 282a 49dd a4f6 6889     ./.JK.lh*(.I...h
   16a68:	1533 49b4 9e81 68a6 f6df 498a 87e9 68c3     3..I...h...I...h
   16a78:	cd33 4961 6129 68e0 9836 4938 2a3d 68fd     3.aI)a.h6.8I=*.h
   16a88:	57ee 490f e320 6919 0c62 48e6 8bce 6936     .W.I ..ib..H..6i
   16a98:	b599 48bc 2442 6953 5397 4893 ac78 696f     ...HB$Si.S.Hx.oi
   16aa8:	e665 4869 246c 698c 6e08 4840 8c19 69a8     e.iHl$.i.n@H...i
   16ab8:	ea86 4816 e37a 69c4 5be6 47ed 2a8c 69e1     ...Hz..i.[.G.*.i
   16ac8:	c22f 47c3 614a 69fd 1d67 479a 87b0 6a19     /..GJa.ig..G...j
   16ad8:	6d93 4770 9db9 6a35 b2bc 4746 a361 6a51     .mpG..5j..FGa.Qj
   16ae8:	ece7 471c 98a4 6a6d 1c1a 46f3 7d7d 6a89     ...G..mj...F}}.j
   16af8:	405c 46c9 51e9 6aa5 59b4 469f 15e2 6ac1     \@.F.Q.j.Y.F...j
   16b08:	6828 4675 c964 6adc 6bbe 464b 6c6c 6af8     (huFd..j.kKFll.j
   16b18:	647d 4621 fef5 6b13 526b 45f7 80fb 6b2f     }d!F...kkR.E../k
   16b28:	358f 45cd f279 6b4a 0df0 45a3 536b 6b66     .5.Ey.Jk...EkSfk
   16b38:	db93 4578 a3cd 6b81 9e80 454e e39b 6b9c     ..xE...k..NE...k
   16b48:	56bd 4524 12d1 6bb8 0450 44fa 316a 6bd3     .V$E...kP..Dj1.k
   16b58:	a740 44cf 3f62 6bee 3f93 44a5 3cb6 6c09     @..Db?.k.?.D.<.l
   16b68:	cd50 447a 2960 6c24 507e 4450 055d 6c3f     P.zD`)$l~PPD].?l
   16b78:	c923 4425 d0a9 6c59 3746 43fb 8b3f 6c74     #.%D..YlF7.C?.tl
   16b88:	9aed 43d0 351c 6c8f f41e 43a5 ce3b 6ca9     ...C.5.l...C;..l
   16b98:	42e1 437b 5698 6cc4 873c 4350 ce2f 6cde     .B{C.V.l<.PC/..l
   16ba8:	c135 4325 34fc 6cf9 f0d4 42fa 8afb 6d13     5.%C.4.l...B...m
   16bb8:	161e 42d0 d027 6d2d 311b 42a5 047e 6d48     ...B'.-m.1.B~.Hm
   16bc8:	41d0 427a 27fa 6d62 4845 424f 3a98 6d7c     .AzB.'bmEHOB.:|m
   16bd8:	4481 4224 3c54 6d96 3689 41f9 2d29 6db0     .D$BT<.m.6.A)-.m
   16be8:	1e65 41ce 0d14 6dca fc1a 41a2 dc11 6de3     e..A...m...A...m
   16bf8:	cfb1 4177 9a1c 6dfd 992f 414c 4730 6e17     ..wA...m/.LA0G.n
   16c08:	589b 4121 e34a 6e30 0dfb 40f6 6e66 6e4a     .X!AJ.0n...@fnJn
   16c18:	b958 40ca e87f 6e63 5ab6 409f 5193 6e7d     X..@..cn.Z.@.Q}n
   16c28:	f21d 4073 a99d 6e96 7f94 4048 f099 6eaf     ..s@...n..H@...n
   16c38:	0321 401d 2683 6ec9 7cca 3ff1 4b57 6ee2     !..@.&.n.|.?WK.n
   16c48:	ec98 3fc5 5f12 6efb 5290 3f9a 61b0 6f14     ...?._.n.R.?.a.o
   16c58:	aeb8 3f6e 532c 6f2d 0119 3f43 3383 6f46     ..n?,S-o..C?.3Fo
   16c68:	49b8 3f17 02b2 6f5f 889c 3eeb c0b3 6f77     .I.?.._o...>..wo
   16c78:	bdcd 3ebf 6d84 6f90 e950 3e93 0921 6fa9     ...>.m.oP..>!..o
   16c88:	0b2c 3e68 9385 6fc1 2369 3e3c 0cae 6fda     ,.h>...oi#<>...o
   16c98:	320d 3e10 7497 6ff2 371f 3de4 cb3c 700a     .2.>.t.o.7.=<..p
   16ca8:	32a6 3db8 109a 7023 24a8 3d8c 44ad 703b     .2.=..#p.$.=.D;p
   16cb8:	0d2c 3d60 6771 7053 ec39 3d33 78e3 706b     ,.`=qgSp9.3=.xkp
   16cc8:	c1d6 3d07 78ff 7083 8e09 3cdb 67c0 709b     ...=.x.p...<.g.p
   16cd8:	50da 3caf 4525 70b3 0a50 3c83 1128 70cb     .P.<%E.pP..<(..p
   16ce8:	ba70 3c56 cbc6 70e2 6142 3c2a 74fc 70fa     p.V<...pBa*<.t.p
   16cf8:	fecd 3bfd 0cc5 7112 9318 3bd1 931f 7129     ...;...q...;..)q
   16d08:	1e29 3ba5 0805 7141 a007 3b78 6b74 7158     )..;..Aq..x;tkXq
   16d18:	18ba 3b4c bd68 716f 8848 3b1f fdde 7186     ..L;h.oqH..;...q
   16d28:	eeb7 3af2 2cd2 719e 4c0f 3ac6 4a41 71b5     ...:.,.q.L.:AJ.q
   16d38:	a057 3a99 5626 71cc eb96 3a6c 5080 71e3     W..:&V.q..l:.P.q
   16d48:	2dd2 3a40 3949 71fa 6712 3a13 107e 7211     .-@:I9.q.g.:~..r
   16d58:	975e 39e6 d61c 7227 bebc 39b9 8a20 723e     ^..9..'r...9 .>r
   16d68:	dd32 398c 2c85 7255 f2c9 395f bd48 726b     2..9.,Ur.._9H.kr
   16d78:	ff87 3932 3c67 7282 0373 3906 a9dd 7298     ..29g<.rs..9...r
   16d88:	fe93 38d8 05a7 72af f0ef 38ab 4fc1 72c5     ...8...r...8.O.r
   16d98:	da8e 387e 8828 72db bb77 3851 aed9 72f1     ..~8(..rw.Q8...r
   16da8:	93b0 3824 c3d0 7307 6341 37f7 c70a 731d     ..$8...sAc.7...s
   16db8:	2a30 37ca b883 7333 e885 379c 9838 7349     0*.7..3s...78.Is
   16dc8:	9e46 376f 6626 735f 4b7b 3742 2249 7375     F.o7&f_s{KB7I"us
   16dd8:	f02a 3714 cc9e 738a 8c5b 36e7 6522 73a0     *..7...s[..6"e.s
   16de8:	2014 36ba ebd1 73b5 ab5c 368c 60a8 73cb     . .6...s\..6.`.s
   16df8:	2e3b 365f c3a3 73e0 a8b8 3631 14c0 73f6     ;._6...s..16...s
   16e08:	1ad9 3604 53fb 740b 84a6 35d6 8150 7420     ...6.S.t...5P. t
   16e18:	e625 35a8 9cbd 7435 3f5d 357b a63f 744a     %..5..5t]?{5?.Jt
   16e28:	9057 354d 9dd1 745f d918 351f 8371 7474     W.M5.._t...5q.tt
   16e38:	19a8 34f2 571c 7489 520d 34c4 18cd 749e     ...4.W.t.R.4...t
   16e48:	8250 3496 c884 74b2 aa76 3468 663a 74c7     P..4...tv.h4:f.t
   16e58:	ca87 343a f1ef 74db e28b 340c 6b9e 74f0     ..:4...t...4.k.t
   16e68:	f287 33de d345 7504 fa84 33b0 28e0 7519     ...3E..u...3.(.u
   16e78:	fa88 3382 6c6c 752d f29b 3354 9de7 7541     ...3ll-u..T3..Au
   16e88:	e2c3 3326 bd4c 7555 cb07 32f8 ca99 7569     ..&3L.Uu...2..iu
   16e98:	ab6f 32ca c5ca 757d 8402 329c aedd 7591     o..2..}u...2...u
   16ea8:	54c7 326e 85cf 75a5 1dc6 3240 4a9c 75b9     .Tn2...u..@2.J.u
   16eb8:	df04 3211 fd42 75cc 9889 31e3 9dbd 75e0     ...2B..u...1...u
   16ec8:	4a5e 31b5 2c0b 75f4 f487 3186 a828 7607     ^J.1.,.u...1(..v
   16ed8:	970e 3158 1211 761b 31f8 312a 69c4 762e     ..X1...v.1*1.i.v
   16ee8:	c54d 30fb af3d 7641 5115 30cd e279 7654     M..0=.Av.Q.0y.Tv
   16ef8:	d556 309e 0376 7668 5217 3070 1231 767b     V..0v.hv.Rp01.{v
   16f08:	c761 3041 0ea6 768e 3539 3013 f8d2 76a0     a.A0...v95.0...v
   16f18:	9ba7 2fe4 d0b4 76b3 fab2 2fb5 9647 76c6     .../...v.../G..v
   16f28:	5262 2f87 4989 76d9 a2be 2f58 ea77 76eb     bR./.I.v..X/w..v
   16f38:	ebcc 2f29 790e 76fe 2d95 2efb f54c 7710     ..)/.y.v.-..L..w
   16f48:	681e 2ecc 5f2d 7723 9b70 2e9d b6af 7735     .h..-_#wp.....5w
   16f58:	c792 2e6e fbce 7747 ec8b 2e3f 2e89 775a     ..n...Gw..?...Zw
   16f68:	0a62 2e11 4edb 776c 211e 2de2 5cc3 777e     b....Nlw.!.-.\~w
   16f78:	30c7 2db3 583e 7790 3964 2d84 4148 77a2     .0.->X.wd9.-HA.w
   16f88:	3afc 2d55 17df 77b4 3596 2d26 dc01 77c5     .:U-...w.5&-...w
   16f98:	2939 2cf7 8daa 77d7 15ee 2cc8 2cd9 77e9     9).,...w...,.,.w
   16fa8:	fbba 2c98 b989 77fa daa6 2c69 33b8 780c     ...,...w..i,.3.x
   16fb8:	b2b9 2c3a 9b65 781d 83fa 2c0b f08b 782e     ..:,e..x...,...x
   16fc8:	4e6f 2bdc 3329 7840 1221 2bad 633b 7851     oN.+)3@x!..+;cQx
   16fd8:	cf17 2b7d 80bf 7862 8558 2b4e 8bb3 7873     ..}+..bxX.N+..sx
   16fe8:	34eb 2b1f 8414 7884 ddd8 2aef 69df 7895     .4.+...x...*.i.x
   16ff8:	8026 2ac0 3d11 78a6 1bdc 2a91 fda8 78b6     &..*.=.x...*...x
   17008:	b101 2a61 aba2 78c7 3f9e 2a32 46fb 78d8     ..a*...x.?2*.F.x
   17018:	c7b8 2a02 cfb2 78e8 4958 29d3 45c3 78f9     ...*...xXI.).E.x
   17028:	c485 29a3 a92d 7909 3946 2974 f9ec 7919     ...)-..yF9t)...y
   17038:	a7a2 2944 37fe 792a 0fa1 2915 6361 793a     ..D).7*y...)ac:y
   17048:	714b 28e5 7c12 794a cca5 28b5 820e 795a     Kq.(.|Jy...(..Zy
   17058:	21b9 2886 7554 796a 708d 2856 55e0 797a     .!.(Tujy.pV(.Uzy
   17068:	b928 2826 23b1 798a fb92 27f6 dec4 7999     (.&(.#.y...'...y
   17078:	37d3 27c7 8715 79a9 6df1 2797 1ca4 79b9     .7.'...y.m.'...y
   17088:	9df4 2767 9f6e 79c8 c7e3 2737 0f6f 79d8     ..g'n..y..7'o..y
   17098:	ebc7 2707 6ca7 79e7 09a5 26d8 b711 79f6     ...'.l.y...&...y
   170a8:	2186 26a8 eead 7a05 3370 2678 1378 7a15     .!.&...zp3x&x..z
   170b8:	3f6c 2648 256f 7a24 4581 2618 2490 7a33     l?H&o%$z.E.&.$3z
   170c8:	45b6 25e8 10d8 7a42 4012 25b8 ea47 7a50     .E.%..Bz.@.%G.Pz
   170d8:	349d 2588 b0d8 7a5f 235f 2558 648a 7a6e     .4.%.._z_#X%.dnz
   170e8:	0c5e 2528 055b 7a7d efa2 24f7 9348 7a8b     ^.(%[.}z...$H..z
   170f8:	cd33 24c7 0e50 7a9a a517 2497 766f 7aa8     3..$P..z...$ov.z
   17108:	7758 2467 cba4 7ab6 43fa 2437 0dec 7ac5     Xwg$...z.C7$...z
   17118:	0b08 2407 3d45 7ad3 cc87 23d6 59ae 7ae1     ...$E=.z...#.Y.z
   17128:	887f 23a6 6323 7aef 3ef7 2376 59a4 7afd     ...##c.z.>v#.Y.z
   17138:	eff8 2345 3d2c 7b0b 9b88 2315 0dbc 7b19     ..E#,=.{...#...{
   17148:	41af 22e5 cb4f 7b26 e274 22b4 75e5 7b34     .A."O.&{t..".u4{
   17158:	7de0 2284 0d7a 7b42 13f8 2254 920e 7b4f     .}."z.B{..T"..O{
   17168:	a4c5 2223 039e 7b5d 304f 21f3 6227 7b6a     ..#"..]{O0.!'bj{
   17178:	b69c 21c2 ada8 7b77 37b5 2192 e61f 7b84     ...!..w{.7.!...{
   17188:	b3a0 2161 0b89 7b92 2a65 2131 1de6 7b9f     ..a!...{e*1!...{
   17198:	9c0c 2100 1d31 7bac 089c 20d0 096b 7bb9     ...!1..{... k..{
   171a8:	701c 209f e290 7bc5 d295 206e a89e 7bd2     .p. ...{..n ...{
   171b8:	300d 203e 5b94 7bdf 888d 200d fb70 7beb     .0> .[.{... p..{
   171c8:	dc1b 1fdc 8830 7bf8 2abf 1fac 01d2 7c05     ....0..{.*.....|
   171d8:	7481 1f7b 6853 7c11 b968 1f4a bbb3 7c1d     .t{.Sh.|h.J....|
   171e8:	f97b 1f19 fbee 7c29 34c3 1ee9 2904 7c36     {.....)|.4...)6|
   171f8:	6b46 1eb8 42f2 7c42 9d0d 1e87 49b7 7c4e     Fk...BB|.....IN|
   17208:	ca1e 1e56 3d50 7c5a f282 1e25 1dbc 7c66     ..V.P=Z|..%...f|
   17218:	163f 1df5 eaf9 7c71 355e 1dc4 a505 7c7d     ?.....q|^5....}|
   17228:	4fe5 1d93 4bde 7c89 65dd 1d62 df83 7c94     .O...K.|.eb....|
   17238:	774d 1d31 5ff1 7ca0 843d 1d00 cd28 7cab     Mw1.._.|=...(..|
   17248:	8cb3 1ccf 2724 7cb7 90b8 1c9e 6de5 7cc2     ....$'.|.....m.|
   17258:	9053 1c6d a169 7ccd 8b8c 1c3c c1ae 7cd8     S.m.i..|..<....|
   17268:	826a 1c0b ceb2 7ce3 74f6 1bda c873 7cee     j......|.t..s..|
   17278:	6335 1ba9 aef0 7cf9 4d30 1b78 8228 7d04     5c.....|0Mx.(..}
   17288:	32ef 1b47 4218 7d0f 1479 1b16 eebf 7d19     .2G..B.}y......}
   17298:	f1d6 1ae4 881b 7d24 cb0d 1ab3 0e2b 7d2f     ......$}....+./}
   172a8:	a026 1a82 80ec 7d39 7128 1a51 e05e 7d43     &.....9}(qQ.^.C}
   172b8:	3e1b 1a20 2c7f 7d4e 0707 19ef 654d 7d58     .> ..,N}....MeX}
   172c8:	cbf3 19bd 8ac6 7d62 8ce7 198c 9ce9 7d6c     ......b}......l}
   172d8:	49ea 195b 9bb5 7d76 0304 192a 8728 7d80     .I[...v}..*.(..}
   172e8:	b83c 18f8 5f40 7d8a 699b 18c7 23fc 7d94     <...@_.}.i...#.}
   172f8:	1728 1896 d55a 7d9d c0ea 1864 7359 7da7     (...Z..}..d.Ys.}
   17308:	66e9 1833 fdf8 7db0 092c 1802 7534 7dba     .f3....},...4u.}
   17318:	a7bc 17d0 d90d 7dc3 429f 179f 2981 7dcd     .......}.B...).}
   17328:	d9de 176d 668f 7dd6 6d80 173c 9034 7ddf     ..m..f.}.m<.4..}
   17338:	fd8d 170a a670 7de8 8a0c 16d9 a942 7df1     ....p..}....B..}
   17348:	1305 16a8 98a8 7dfa 987f 1676 74a0 7e03     .......}..v..t.~
   17358:	1a83 1645 3d29 7e0c 9918 1613 f242 7e14     ..E.)=.~....B..~
   17368:	1445 15e2 93ea 7e1d 8c12 15b0 221f 7e26     E......~....."&~
   17378:	0086 157f 9cdf 7e2e 71aa 154d 042a 7e37     .......~.qM.*.7~
   17388:	df86 151b 57ff 7e3f 4a1f 14ea 985b 7e47     .....W?~.J..[.G~
   17398:	b17f 14b8 c53e 7e4f 15ae 1487 dea7 7e57     ....>.O~......W~
   173a8:	76b1 1455 e493 7e5f d492 1423 d703 7e67     .vU..._~..#...g~
   173b8:	2f58 13f2 b5f4 7e6f 870a 13c0 8166 7e77     X/....o~....f.w~
   173c8:	dbb1 138e 3957 7e7f 2d53 135d ddc6 7e86     ....W9.~S-]....~
   173d8:	7bf9 132b 6eb2 7e8e c7aa 12f9 ec1a 7e95     .{+..n.~.......~
   173e8:	106f 12c8 55fc 7e9d 564d 1296 ac58 7ea4     o....U.~MV..X..~
   173f8:	994e 1264 ef2c 7eab d979 1232 1e78 7eb3     N.d.,..~y.2.x..~
   17408:	16d5 1201 3a39 7eba 516a 11cf 4270 7ec1     ....9:.~jQ..pB.~
   17418:	8941 119d 371a 7ec8 be60 116b 1837 7ecf     A....7.~`.k.7..~
   17428:	f0cf 1139 e5c6 7ed5 2096 1108 9fc6 7edc     ..9....~. .....~
   17438:	4dbd 10d6 4636 7ee3 784b 10a4 d914 7ee9     .M..6F.~Kx.....~
   17448:	a048 1072 5860 7ef0 c5bb 1040 c418 7ef6     H.r.`X.~..@....~
   17458:	e8ad 100e 1c3c 7efd 0926 0fdd 60cb 7f03     ....<..~&....`..
   17468:	272b 0fab 91c4 7f09 42c7 0f79 af25 7f0f     +'.......By.%...
   17478:	5bff 0f47 b8ee 7f15 72dc 0f15 af1e 7f1b     .[G......r......
   17488:	8766 0ee3 91b4 7f21 99a4 0eb1 60af 7f27     f.....!......`'.
   17498:	a99e 0e7f 1c0e 7f2d b75b 0e4d c3d1 7f32     ......-.[.M...2.
   174a8:	c2e4 0e1b 57f6 7f38 cc40 0de9 d87c 7f3d     .....W8.@...|.=.
   174b8:	d376 0db7 4563 7f43 d88f 0d85 9eaa 7f48     v...cEC.......H.
   174c8:	db92 0d53 e451 7f4d dc87 0d21 1655 7f53     ..S.Q.M...!.U.S.
   174d8:	db76 0cef 34b7 7f58 d865 0cbd 3f75 7f5d     v....4X.e...u?].
   174e8:	d35e 0c8b 368f 7f62 cc68 0c59 1a05 7f67     ^....6b.h.Y...g.
   174f8:	c389 0c27 e9d4 7f6b b8cb 0bf5 a5fe 7f70     ..'...k.......p.
   17508:	ac35 0bc3 4e80 7f75 9dcf 0b91 e35a 7f79     5....Nu.....Z.y.
   17518:	8d9f 0b5f 648c 7f7e 7baf 0b2d d214 7f82     .._..d~..{-.....
   17528:	6805 0afb 2bf3 7f87 52aa 0ac9 7227 7f8b     .h...+...R..'r..
   17538:	3ba5 0a97 a4b0 7f8f 22fe 0a65 c38c 7f93     .;......."e.....
   17548:	08bd 0a33 cebd 7f97 ece8 0a00 c640 7f9b     ..3.........@...
   17558:	cf89 09ce aa15 7f9f b0a7 099c 7a3c 7fa3     ............<z..
   17568:	9049 096a 36b4 7fa7 6e78 0938 df7c 7faa     I.j..6..xn8.|...
   17578:	4b3a 0906 7495 7fae 2699 08d4 f5fc 7fb1     :K...t...&......
   17588:	009a 08a2 63b3 7fb5 d947 086f bdb8 7fb8     .....c..G.o.....
   17598:	b0a7 083d 040a 7fbc 86c2 080b 36aa 7fbf     ..=..........6..
   175a8:	5b9e 07d9 5596 7fc2 2f45 07a7 60cf 7fc5     .[...U..E/...`..
   175b8:	01be 0775 5854 7fc8 d311 0742 3c23 7fcb     ..u.TX....B.#<..
   175c8:	a345 0710 0c3e 7fce 7262 06de c8a3 7fd0     E...>...br......
   175d8:	406f 06ac 7153 7fd3 0d76 067a 064c 7fd6     o@..Sq..v.z.L...
   175e8:	d97c 0647 878e 7fd8 a48b 0615 f519 7fda     |.G.............
   175f8:	6ea9 05e3 4eec 7fdd 37df 05b1 9508 7fdf     .n...N...7......
   17608:	0035 057f c76b 7fe1 c7b1 054c e616 7fe3     5...k.....L.....
   17618:	8e5c 051a f108 7fe5 543e 04e8 e841 7fe7     \.......>T..A...
   17628:	195d 04b6 cbc0 7fe9 ddc3 0483 9b85 7feb     ]...............
   17638:	a177 0451 5791 7fed 6480 041f ffe1 7fee     w.Q..W...d......
   17648:	26e6 03ed 9478 7ff0 e8b2 03ba 1553 7ff2     .&..x.......S...
   17658:	a9ea 0388 8274 7ff3 6a96 0356 dbd9 7ff4     ....t....jV.....
   17668:	2abf 0324 2182 7ff6 ea6c 02f1 5370 7ff7     .*$..!..l...pS..
   17678:	a9a4 02bf 71a2 7ff8 6870 028d 7c18 7ff9     .....q..ph...|..
   17688:	26d7 025b 72d1 7ffa e4e2 0228 55ce 7ffb     .&[..r....(..U..
   17698:	a297 01f6 250f 7ffc 5ffe 01c4 e093 7ffc     .....%..._......
   176a8:	1d20 0192 885a 7ffd da03 015f 1c65 7ffe      ...Z....._.e...
   176b8:	96b1 012d 9cb2 7ffe 5330 00fb 0943 7fff     ..-.....0S..C...
   176c8:	0f88 00c9 6216 7fff cbc1 0096 a72c 7fff     .....b......,...
   176d8:	87e3 0064 d886 7fff 43f5 0032 f621 7fff     ..d......C2.!...
   176e8:	0000 0000 ffff 7fff bc0b ffcd f621 7fff     ............!...
   176f8:	781d ff9b d886 7fff 343f ff69 a72c 7fff     .x......?4i.,...
   17708:	f078 ff36 6216 7fff acd0 ff04 0943 7fff     x.6..b......C...
   17718:	694f fed2 9cb2 7ffe 25fd fea0 1c65 7ffe     Oi.......%..e...
   17728:	e2e0 fe6d 885a 7ffd a002 fe3b e093 7ffc     ..m.Z.....;.....
   17738:	5d69 fe09 250f 7ffc 1b1e fdd7 55ce 7ffb     i]...%.......U..
   17748:	d929 fda4 72d1 7ffa 9790 fd72 7c18 7ff9     )....r....r..|..
   17758:	565c fd40 71a2 7ff8 1594 fd0e 5370 7ff7     \V@..q......pS..
   17768:	d541 fcdb 2182 7ff6 956a fca9 dbd9 7ff4     A....!..j.......
   17778:	5616 fc77 8274 7ff3 174e fc45 1553 7ff2     .Vw.t...N.E.S...
   17788:	d91a fc12 9478 7ff0 9b80 fbe0 ffe1 7fee     ....x...........
   17798:	5e89 fbae 5791 7fed 223d fb7c 9b85 7feb     .^...W..="|.....
   177a8:	e6a3 fb49 cbc0 7fe9 abc2 fb17 e841 7fe7     ..I.........A...
   177b8:	71a4 fae5 f108 7fe5 384f fab3 e616 7fe3     .q......O8......
   177c8:	ffcb fa80 c76b 7fe1 c821 fa4e 9508 7fdf     ....k...!.N.....
   177d8:	9157 fa1c 4eec 7fdd 5b75 f9ea f519 7fda     W....N..u[......
   177e8:	2684 f9b8 878e 7fd8 f28a f985 064c 7fd6     .&..........L...
   177f8:	bf91 f953 7153 7fd3 8d9e f921 c8a3 7fd0     ..S.Sq....!.....
   17808:	5cbb f8ef 0c3e 7fce 2cef f8bd 3c23 7fcb     .\..>....,..#<..
   17818:	fe42 f88a 5854 7fc8 d0bb f858 60cf 7fc5     B...TX....X..`..
   17828:	a462 f826 5596 7fc2 793e f7f4 36aa 7fbf     b.&..U..>y...6..
   17838:	4f59 f7c2 040a 7fbc 26b9 f790 bdb8 7fb8     YO.......&......
   17848:	ff66 f75d 63b3 7fb5 d967 f72b f5fc 7fb1     f.]..c..g.+.....
   17858:	b4c6 f6f9 7495 7fae 9188 f6c7 df7c 7faa     .....t......|...
   17868:	6fb7 f695 36b4 7fa7 4f59 f663 7a3c 7fa3     .o...6..YOc.<z..
   17878:	3077 f631 aa15 7f9f 1318 f5ff c640 7f9b     w01.........@...
   17888:	f743 f5cc cebd 7f97 dd02 f59a c38c 7f93     C...............
   17898:	c45b f568 a4b0 7f8f ad56 f536 7227 7f8b     [.h.....V.6.'r..
   178a8:	97fb f504 2bf3 7f87 8451 f4d2 d214 7f82     .....+..Q.......
   178b8:	7261 f4a0 648c 7f7e 6231 f46e e35a 7f79     ar...d~.1bn.Z.y.
   178c8:	53cb f43c 4e80 7f75 4735 f40a a5fe 7f70     .S<..Nu.5G....p.
   178d8:	3c77 f3d8 e9d4 7f6b 3398 f3a6 1a05 7f67     w<....k..3....g.
   178e8:	2ca2 f374 368f 7f62 279b f342 3f75 7f5d     .,t..6b..'B.u?].
   178f8:	248a f310 34b7 7f58 2379 f2de 1655 7f53     .$...4X.y#..U.S.
   17908:	246e f2ac e451 7f4d 2771 f27a 9eaa 7f48     n$..Q.M.q'z...H.
   17918:	2c8a f248 4563 7f43 33c0 f216 d87c 7f3d     .,H.cEC..3..|.=.
   17928:	3d1c f1e4 57f6 7f38 48a5 f1b2 c3d1 7f32     .=...W8..H....2.
   17938:	5662 f180 1c0e 7f2d 665c f14e 60af 7f27     bV....-.\fN..`'.
   17948:	789a f11c 91b4 7f21 8d24 f0ea af1e 7f1b     .x....!.$.......
   17958:	a401 f0b8 b8ee 7f15 bd39 f086 af25 7f0f     ........9...%...
   17968:	d8d5 f054 91c4 7f09 f6da f022 60cb 7f03     ..T......."..`..
   17978:	1753 eff1 1c3c 7efd 3a45 efbf c418 7ef6     S...<..~E:.....~
   17988:	5fb8 ef8d 5860 7ef0 87b5 ef5b d914 7ee9     ._..`X.~..[....~
   17998:	b243 ef29 4636 7ee3 df6a eef7 9fc6 7edc     C.).6F.~j......~
   179a8:	0f31 eec6 e5c6 7ed5 41a0 ee94 1837 7ecf     1......~.A..7..~
   179b8:	76bf ee62 371a 7ec8 ae96 ee30 4270 7ec1     .vb..7.~..0.pB.~
   179c8:	e92b edfe 3a39 7eba 2687 edcd 1e78 7eb3     +...9:.~.&..x..~
   179d8:	66b2 ed9b ef2c 7eab a9b3 ed69 ac58 7ea4     .f..,..~..i.X..~
   179e8:	ef91 ed37 55fc 7e9d 3856 ed06 ec1a 7e95     ..7..U.~V8.....~
   179f8:	8407 ecd4 6eb2 7e8e d2ad eca2 ddc6 7e86     .....n.~.......~
   17a08:	244f ec71 3957 7e7f 78f6 ec3f 8166 7e77     O$q.W9.~.x?.f.w~
   17a18:	d0a8 ec0d b5f4 7e6f 2b6e ebdc d703 7e67     ......o~n+....g~
   17a28:	894f ebaa e493 7e5f ea52 eb78 dea7 7e57     O....._~R.x...W~
   17a38:	4e81 eb47 c53e 7e4f b5e1 eb15 985b 7e47     .NG.>.O~....[.G~
   17a48:	207a eae4 57ff 7e3f 8e56 eab2 042a 7e37     z ...W?~V...*.7~
   17a58:	ff7a ea80 9cdf 7e2e 73ee ea4f 221f 7e26     z......~.sO.."&~
   17a68:	ebbb ea1d 93ea 7e1d 66e8 e9ec f242 7e14     .......~.f..B..~
   17a78:	e57d e9ba 3d29 7e0c 6781 e989 74a0 7e03     }...)=.~.g...t.~
   17a88:	ecfb e957 98a8 7dfa 75f4 e926 a942 7df1     ..W....}.u&.B..}
   17a98:	0273 e8f5 a670 7de8 9280 e8c3 9034 7ddf     s...p..}....4..}
   17aa8:	2622 e892 668f 7dd6 bd61 e860 2981 7dcd     "&...f.}a.`..).}
   17ab8:	5844 e82f d90d 7dc3 f6d4 e7fd 7534 7dba     DX/....}....4u.}
   17ac8:	9917 e7cc fdf8 7db0 3f16 e79b 7359 7da7     .......}.?..Ys.}
   17ad8:	e8d8 e769 d55a 7d9d 9665 e738 23fc 7d94     ..i.Z..}e.8..#.}
   17ae8:	47c4 e707 5f40 7d8a fcfc e6d5 8728 7d80     .G..@_.}....(..}
   17af8:	b616 e6a4 9bb5 7d76 7319 e673 9ce9 7d6c     ......v}.ss...l}
   17b08:	340d e642 8ac6 7d62 f8f9 e610 654d 7d58     .4B...b}....MeX}
   17b18:	c1e5 e5df 2c7f 7d4e 8ed8 e5ae e05e 7d43     .....,N}....^.C}
   17b28:	5fda e57d 80ec 7d39 34f3 e54c 0e2b 7d2f     ._}...9}.4L.+./}
   17b38:	0e2a e51b 881b 7d24 eb87 e4e9 eebf 7d19     *.....$}.......}
   17b48:	cd11 e4b8 4218 7d0f b2d0 e487 8228 7d04     .....B.}....(..}
   17b58:	9ccb e456 aef0 7cf9 8b0a e425 c873 7cee     ..V....|..%.s..|
   17b68:	7d96 e3f4 ceb2 7ce3 7474 e3c3 c1ae 7cd8     .}.....|tt.....|
   17b78:	6fad e392 a169 7ccd 6f48 e361 6de5 7cc2     .o..i..|Hoa..m.|
   17b88:	734d e330 2724 7cb7 7bc3 e2ff cd28 7cab     Ms0.$'.|.{..(..|
   17b98:	88b3 e2ce 5ff1 7ca0 9a23 e29d df83 7c94     ....._.|#......|
   17ba8:	b01b e26c 4bde 7c89 caa2 e23b a505 7c7d     ..l..K.|..;...}|
   17bb8:	e9c1 e20a eaf9 7c71 0d7e e1da 1dbc 7c66     ......q|~.....f|
   17bc8:	35e2 e1a9 3d50 7c5a 62f3 e178 49b7 7c4e     .5..P=Z|.bx..IN|
   17bd8:	94ba e147 42f2 7c42 cb3d e116 2904 7c36     ..G..BB|=....)6|
   17be8:	0685 e0e6 fbee 7c29 4698 e0b5 bbb3 7c1d     ......)|.F.....|
   17bf8:	8b7f e084 6853 7c11 d541 e053 01d2 7c05     ....Sh.|A.S....|
   17c08:	23e5 e023 8830 7bf8 7773 dff2 fb70 7beb     .##.0..{sw..p..{
   17c18:	cff3 dfc1 5b94 7bdf 2d6b df91 a89e 7bd2     .....[.{k-.....{
   17c28:	8fe4 df60 e290 7bc5 f764 df2f 096b 7bb9     ..`....{d./.k..{
   17c38:	63f4 deff 1d31 7bac d59b dece 1de6 7b9f     .c..1..{.......{
   17c48:	4c60 de9e 0b89 7b92 c84b de6d e61f 7b84     `L.....{K.m....{
   17c58:	4964 de3d ada8 7b77 cfb1 de0c 6227 7b6a     dI=...w{....'bj{
   17c68:	5b3b dddc 039e 7b5d ec08 ddab 920e 7b4f     ;[....]{......O{
   17c78:	8220 dd7b 0d7a 7b42 1d8c dd4b 75e5 7b34      .{.z.B{..K..u4{
   17c88:	be51 dd1a cb4f 7b26 6478 dcea 0dbc 7b19     Q...O.&{xd.....{
   17c98:	1008 dcba 3d2c 7b0b c109 dc89 59a4 7afd     ....,=.{.....Y.z
   17ca8:	7781 dc59 6323 7aef 3379 dc29 59ae 7ae1     .wY.#c.zy3)..Y.z
   17cb8:	f4f8 dbf8 3d45 7ad3 bc06 dbc8 0dec 7ac5     ....E=.z.......z
   17cc8:	88a8 db98 cba4 7ab6 5ae9 db68 766f 7aa8     .......z.Zh.ov.z
   17cd8:	32cd db38 0e50 7a9a 105e db08 9348 7a8b     .28.P..z^...H..z
   17ce8:	f3a2 dad7 055b 7a7d dca1 daa7 648a 7a6e     ....[.}z.....dnz
   17cf8:	cb63 da77 b0d8 7a5f bfee da47 ea47 7a50     c.w..._z..G.G.Pz
   17d08:	ba4a da17 10d8 7a42 ba7f d9e7 2490 7a33     J.....Bz.....$3z
   17d18:	c094 d9b7 256f 7a24 cc90 d987 1378 7a15     ....o%$z....x..z
   17d28:	de7a d957 eead 7a05 f65b d927 b711 79f6     z.W....z[.'....y
   17d38:	1439 d8f8 6ca7 79e7 381d d8c8 0f6f 79d8     9....l.y.8..o..y
   17d48:	620c d898 9f6e 79c8 920f d868 1ca4 79b9     .b..n..y..h....y
   17d58:	c82d d838 8715 79a9 046e d809 dec4 7999     -.8....yn......y
   17d68:	46d8 d7d9 23b1 798a 8f73 d7a9 55e0 797a     .F...#.ys....Uzy
   17d78:	de47 d779 7554 796a 335b d74a 820e 795a     G.y.Tujy[3J...Zy
   17d88:	8eb5 d71a 7c12 794a f05f d6ea 6361 793a     .....|Jy_...ac:y
   17d98:	585e d6bb 37fe 792a c6ba d68b f9ec 7919     ^X...7*y.......y
   17da8:	3b7b d65c a92d 7909 b6a8 d62c 45c3 78f9     {;\.-..y..,..E.x
   17db8:	3848 d5fd cfb2 78e8 c062 d5cd 46fb 78d8     H8.....xb....F.x
   17dc8:	4eff d59e aba2 78c7 e424 d56e fda8 78b6     .N.....x$.n....x
   17dd8:	7fda d53f 3d11 78a6 2228 d510 69df 7895     ..?..=.x("...i.x
   17de8:	cb15 d4e0 8414 7884 7aa8 d4b1 8bb3 7873     .......x.z....sx
   17df8:	30e9 d482 80bf 7862 eddf d452 633b 7851     .0....bx..R.;cQx
   17e08:	b191 d423 3329 7840 7c06 d3f4 f08b 782e     ..#.)3@x.|.....x
   17e18:	4d47 d3c5 9b65 781d 255a d396 33b8 780c     GM..e..xZ%...3.x
   17e28:	0446 d367 b989 77fa ea12 d337 2cd9 77e9     F.g....w..7..,.w
   17e38:	d6c7 d308 8daa 77d7 ca6a d2d9 dc01 77c5     .......wj......w
   17e48:	c504 d2aa 17df 77b4 c69c d27b 4148 77a2     .......w..{.HA.w
   17e58:	cf39 d24c 583e 7790 dee2 d21d 5cc3 777e     9.L.>X.w.....\~w
   17e68:	f59e d1ee 4edb 776c 1375 d1c0 2e89 775a     .....Nlwu.....Zw
   17e78:	386e d191 fbce 7747 6490 d162 b6af 7735     n8....Gw.db...5w
   17e88:	97e2 d133 5f2d 7723 d26b d104 f54c 7710     ..3.-_#wk...L..w
   17e98:	1434 d0d6 790e 76fe 5d42 d0a7 ea77 76eb     4....y.vB]..w..v
   17ea8:	ad9e d078 4989 76d9 054e d04a 9647 76c6     ..x..I.vN.J.G..v
   17eb8:	6459 d01b d0b4 76b3 cac7 cfec f8d2 76a0     Yd.....v.......v
   17ec8:	389f cfbe 0ea6 768e ade9 cf8f 1231 767b     .8.....v....1.{v
   17ed8:	2aaa cf61 0376 7668 aeeb cf32 e279 7654     .*a.v.hv..2.y.Tv
   17ee8:	3ab3 cf04 af3d 7641 ce08 ced5 69c4 762e     .:..=.Av.....i.v
   17ef8:	68f2 cea7 1211 761b 0b79 ce79 a828 7607     .h.....vy.y.(..v
   17f08:	b5a2 ce4a 2c0b 75f4 6777 ce1c 9dbd 75e0     ..J..,.uwg.....u
   17f18:	20fc cdee fd42 75cc e23a cdbf 4a9c 75b9     . ..B..u:....J.u
   17f28:	ab39 cd91 85cf 75a5 7bfe cd63 aedd 7591     9......u.{c....u
   17f38:	5491 cd35 c5ca 757d 34f9 cd07 ca99 7569     .T5...}u.4....iu
   17f48:	1d3d ccd9 bd4c 7555 0d65 ccab 9de7 7541     =...L.Uue.....Au
   17f58:	0578 cc7d 6c6c 752d 057c cc4f 28e0 7519     x.}.ll-u|.O..(.u
   17f68:	0d79 cc21 d345 7504 1d75 cbf3 6b9e 74f0     y.!.E..uu....k.t
   17f78:	3579 cbc5 f1ef 74db 558a cb97 663a 74c7     y5.....t.U..:f.t
   17f88:	7db0 cb69 c884 74b2 adf3 cb3b 18cd 749e     .}i....t..;....t
   17f98:	e658 cb0d 571c 7489 26e8 cae0 8371 7474     X....W.t.&..q.tt
   17fa8:	6fa9 cab2 9dd1 745f c0a3 ca84 a63f 744a     .o...._t....?.Jt
   17fb8:	19db ca57 9cbd 7435 7b5a ca29 8150 7420     ..W...5tZ{).P. t
   17fc8:	e527 c9fb 53fb 740b 5748 c9ce 14c0 73f6     '....S.tHW.....s
   17fd8:	d1c5 c9a0 c3a3 73e0 54a4 c973 60a8 73cb     .......s.Ts..`.s
   17fe8:	dfec c945 ebd1 73b5 73a5 c918 6522 73a0     ..E....s.s.."e.s
   17ff8:	0fd6 c8eb cc9e 738a b485 c8bd 2249 7375     .......s....I"us
   18008:	61ba c890 6626 735f 177b c863 9838 7349     .a..&f_s{.c.8.Is
   18018:	d5d0 c835 b883 7333 9cbf c808 c70a 731d     ..5...3s.......s
   18028:	6c50 c7db c3d0 7307 4489 c7ae aed9 72f1     Pl.....s.D.....r
   18038:	2572 c781 8828 72db 0f11 c754 4fc1 72c5     r%..(..r..T..O.r
   18048:	016d c727 05a7 72af fc8d c6f9 a9dd 7298     m.'....r.......r
   18058:	0079 c6cd 3c67 7282 0d37 c6a0 bd48 726b     y...g<.r7...H.kr
   18068:	22ce c673 2c85 7255 4144 c646 8a20 723e     ."s..,UrDAF. .>r
   18078:	68a2 c619 d61c 7227 98ee c5ec 107e 7211     .h....'r....~..r
   18088:	d22e c5bf 3949 71fa 146a c593 5080 71e3     ....I9.qj....P.q
   18098:	5fa9 c566 5626 71cc b3f1 c539 4a41 71b5     ._f.&V.q..9.AJ.q
   180a8:	1149 c50d 2cd2 719e 77b8 c4e0 fdde 7186     I....,.q.w.....q
   180b8:	e746 c4b3 bd68 716f 5ff9 c487 6b74 7158     F...h.oq._..tkXq
   180c8:	e1d7 c45a 0805 7141 6ce8 c42e 931f 7129     ..Z...Aq.l....)q
   180d8:	0133 c402 0cc5 7112 9ebe c3d5 74fc 70fa     3......q.....t.p
   180e8:	4590 c3a9 cbc6 70e2 f5b0 c37c 1128 70cb     .E.....p..|.(..p
   180f8:	af26 c350 4525 70b3 71f7 c324 67c0 709b     &.P.%E.p.q$..g.p
   18108:	3e2a c2f8 78ff 7083 13c7 c2cc 78e3 706b     *>...x.p.....xkp
   18118:	f2d4 c29f 6771 7053 db58 c273 44ad 703b     ....qgSpX.s..D;p
   18128:	cd5a c247 109a 7023 c8e1 c21b cb3c 700a     Z.G...#p....<..p
   18138:	cdf3 c1ef 7497 6ff2 dc97 c1c3 0cae 6fda     .....t.o.......o
   18148:	f4d4 c197 9385 6fc1 16b0 c16c 0921 6fa9     .......o..l.!..o
   18158:	4233 c140 6d84 6f90 7764 c114 c0b3 6f77     3B@..m.odw....wo
   18168:	b648 c0e8 02b2 6f5f fee7 c0bc 3383 6f46     H....._o.....3Fo
   18178:	5148 c091 532c 6f2d ad70 c065 61b0 6f14     HQ..,S-op.e..a.o
   18188:	1368 c03a 5f12 6efb 8336 c00e 4b57 6ee2     h.:.._.n6...WK.n
   18198:	fcdf bfe2 2683 6ec9 806c bfb7 f099 6eaf     .....&.nl......n
   181a8:	0de3 bf8c a99d 6e96 a54a bf60 5193 6e7d     .......nJ.`..Q}n
   181b8:	46a8 bf35 e87f 6e63 f205 bf09 6e66 6e4a     .F5...cn....fnJn
   181c8:	a765 bede e34a 6e30 66d1 beb3 4730 6e17     e...J.0n.f..0G.n
   181d8:	304f be88 9a1c 6dfd 03e6 be5d dc11 6de3     O0.....m..]....m
   181e8:	e19b be31 0d14 6dca c977 be06 2d29 6db0     ..1....mw...)-.m
   181f8:	bb7f bddb 3c54 6d96 b7bb bdb0 3a98 6d7c     ....T<.m.....:|m
   18208:	be30 bd85 27fa 6d62 cee5 bd5a 047e 6d48     0....'bm..Z.~.Hm
   18218:	e9e2 bd2f d027 6d2d 0f2c bd05 8afb 6d13     ../.'.-m,......m
   18228:	3ecb bcda 34fc 6cf9 78c4 bcaf ce2f 6cde     .>...4.l.x../..l
   18238:	bd1f bc84 5698 6cc4 0be2 bc5a ce3b 6ca9     .....V.l..Z.;..l
   18248:	6513 bc2f 351c 6c8f c8ba bc04 8b3f 6c74     .e/..5.l....?.tl
   18258:	36dd bbda d0a9 6c59 af82 bbaf 055d 6c3f     .6....Yl....].?l
   18268:	32b0 bb85 2960 6c24 c06d bb5a 3cb6 6c09     .2..`)$lm.Z..<.l
   18278:	58c0 bb30 3f62 6bee fbb0 bb05 316a 6bd3     .X0.b?.k....j1.k
   18288:	a943 badb 12d1 6bb8 6180 bab1 e39b 6b9c     C......k.a.....k
   18298:	246d ba87 a3cd 6b81 f210 ba5c 536b 6b66     m$.....k..\.kSfk
   182a8:	ca71 ba32 f279 6b4a ad95 ba08 80fb 6b2f     q.2.y.Jk....../k
   182b8:	9b83 b9de fef5 6b13 9442 b9b4 6c6c 6af8     .......kB...ll.j
   182c8:	97d8 b98a c964 6adc a64c b960 15e2 6ac1     ....d..jL.`....j
   182d8:	bfa4 b936 51e9 6aa5 e3e6 b90c 7d7d 6a89     ..6..Q.j....}}.j
   182e8:	1319 b8e3 98a4 6a6d 4d44 b8b9 a361 6a51     ......mjDM..a.Qj
   182f8:	926d b88f 9db9 6a35 e299 b865 87b0 6a19     m.....5j..e....j
   18308:	3dd1 b83c 614a 69fd a41a b812 2a8c 69e1     .=<.Ja.i.....*.i
   18318:	157a b7e9 e37a 69c4 91f8 b7bf 8c19 69a8     z...z..i.......i
   18328:	199b b796 246c 698c ac69 b76c ac78 696f     ....l$.ii.l.x.oi
   18338:	4a67 b743 2442 6953 f39e b719 8bce 6936     gJC.B$Si......6i
   18348:	a812 b6f0 e320 6919 67ca b6c7 2a3d 68fd     .... ..i.g..=*.h
   18358:	32cd b69e 6129 68e0 0921 b675 87e9 68c3     .2..)a.h!.u....h
   18368:	eacd b64b 9e81 68a6 d7d6 b622 a4f6 6889     ..K....h.."....h
   18378:	d043 b5f9 9b4b 686c d41a b5d0 8186 684f     C...K.lh......Oh
   18388:	e362 b5a7 57ab 6832 fe22 b57e 1dbe 6815     b....W2h".~....h
   18398:	245e b556 d3c5 67f7 561e b52d 79c3 67da     ^$V....g.V-..y.g
   183a8:	9368 b504 0fbd 67bd dc42 b4db 95b7 679f     h......gB......g
   183b8:	30b3 b4b3 0bb7 6782 90c0 b48a 71c0 6764     .0.....g.....qdg
   183c8:	fc70 b461 c7d8 6746 73ca b439 0e02 6729     p.a...Fg.s9...)g
   183d8:	f6d3 b410 4444 670b 8592 b3e8 6aa1 66ed     ....DD.g.....j.f
   183e8:	200c b3c0 8120 66cf c649 b397 87c3 66b1     . .. ..fI......f
   183f8:	784f b36f 7e91 6693 3623 b347 658c 6675     Oxo..~.f#6G..euf
   18408:	ffcc b31e 3cbb 6657 d550 b2f6 0422 6639     .....<WfP...".9f
   18418:	b6b5 b2ce bbc5 661a a402 b2a6 63a9 65fc     .......f.....c.e
   18428:	9d3c b27e fbd3 65dd a26a b256 8447 65bf     <.~....ej.V.G..e
   18438:	b392 b22e fd0b 65a0 d0ba b206 6622 6582     .......e...."f.e
   18448:	f9e9 b1de bf92 6563 2f23 b1b7 095f 6545     ......ce#/.._.Ee
   18458:	7071 b18f 438f 6526 bdd7 b167 6e25 6507     qp...C&e..g.%n.e
   18468:	175b b140 8926 64e8 7d05 b118 9498 64c9     [.@.&..d.}.....d
   18478:	eeda b0f0 907f 64aa 6ce0 b0c9 7ce0 648b     .......d.l...|.d
   18488:	f71d b0a1 59bf 646c 8d97 b07a 2722 644d     .....Yld..z."'Md
   18498:	3055 b053 e50d 642d df5c b02b 9386 640e     U0S...-d\.+....d
   184a8:	9ab3 b004 3290 63ef 625f afdd c231 63cf     .....2.c_b..1..c
   184b8:	3667 afb6 426d 63b0 16d1 af8f b34a 6390     g6..mB.c....J..c
   184c8:	03a2 af68 14cc 6371 fce1 af40 66f9 6351     ..h...qc..@..fQc
   184d8:	0293 af1a a9d4 6331 14c0 aef3 dd64 6311     ......1c....d..c
   184e8:	336c aecc 01ac 62f2 5e9e aea5 16b3 62d2     l3.....b.^.....b
   184f8:	965b ae7e 1c7b 62b2 daab ae57 130c 6292     [.~.{..b..W....b
   18508:	2b92 ae31 fa69 6271 8916 ae0a d298 6251     .+1.i.qb......Qb
   18518:	f33e ade3 9b9d 6231 6a10 adbd 557e 6211     >.....1b.j..~U.b
   18528:	ed92 ad96 003f 61f1 7dc8 ad70 9be5 61d0     ....?..a.}p....a
   18538:	1aba ad4a 2876 61b0 c46e ad23 a5f7 618f     ..J.v(.an.#....a
   18548:	7ae8 acfd 146c 616f 3e30 acd7 73da 614e     .z..l.oa0>...sNa
   18558:	0e4b acb1 c447 612d eb3e ac8a 05b7 610d     K...G.-a>......a
   18568:	d510 ac64 3830 60ec cbc7 ac3e 5bb7 60cb     ..d.08.`..>..[.`
   18578:	cf69 ac18 7050 60aa dffb abf2 7601 6089     i...Pp.`.....v.`
   18588:	fd83 abcc 6ccf 6068 2807 aba7 54bf 6047     .....lh`.(...TG`
   18598:	5f8d ab81 2dd6 6026 a41a ab5b f819 6004     ._...-&`..[....`
   185a8:	f5b5 ab35 b38d 5fe3 5464 ab10 6038 5fc2     ..5...._dT..8`._
   185b8:	c02c aaea fe1f 5fa0 3912 aac5 8d46 5f7f     ,......_.9..F.._
   185c8:	bf1e aa9f 0db3 5f5e 5253 aa7a 7f6b 5f3c     ......^_SRz.k.<_
   185d8:	f2ba aa54 e274 5f1a a056 aa2f 36d1 5ef9     ..T.t.._V./..6.^
   185e8:	5b2e aa0a 7c8a 5ed7 2347 a9e5 b3a2 5eb5     .[...|.^G#.....^
   185f8:	f8a8 a9bf dc1f 5e93 db56 a99a f606 5e71     .......^V.....q^
   18608:	cb57 a975 015d 5e50 c8b0 a950 fe29 5e2d     W.u.].P^..P.).-^
   18618:	d367 a92b ec6e 5e0b eb82 a906 cc33 5de9     g.+.n..^....3..]
   18628:	1106 a8e2 9d7c 5dc7 43fa a8bd 604f 5da5     ....|..].C..O`.]
   18638:	8463 a898 14b1 5d83 d246 a873 baa7 5d60     c......]F.s...`]
   18648:	2daa a84f 5237 5d3e 9693 a82a db65 5d1b     .-O.7R>]..*.e..]
   18658:	0d08 a806 5638 5cf9 910f a7e1 c2b5 5cd6     ....8V.\.......\
   18668:	22ac a7bd 20e0 5cb4 c1e5 a798 70bf 5c91     ."... .\.....p.\
   18678:	6ec0 a774 b258 5c6e 2943 a750 e5b0 5c4b     .nt.X.n\C)P...K\
   18688:	f174 a72b 0acc 5c29 c757 a707 21b2 5c06     t.+...)\W....!.\
   18698:	aaf2 a6e3 2a67 5be3 9c4b a6bf 24f0 5bc0     ....g*.[K....$.[
   186a8:	9b68 a69b 1154 5b9d a84e a677 ef96 5b79     h...T..[N.w...y[
   186b8:	c303 a653 bfbd 5b56 eb8b a62f 81ce 5b33     ..S...V[../...3[
   186c8:	21ee a60c 35cf 5b10 662f a5e8 dbc5 5aec     .!...5.[/f.....Z
   186d8:	b855 a5c4 73b5 5ac9 1866 a5a1 fda5 5aa5     U....s.Zf......Z
   186e8:	8666 a57d 799a 5a82 025b a55a e79a 5a5e     f.}..y.Z[.Z...^Z
   186f8:	8c4b a536 47ab 5a3b 243b a513 99d1 5a17     K.6..G;Z;$.....Z
   18708:	ca31 a4ef de12 59f3 7e32 a4cc 1475 59d0     1......Y2~..u..Y
   18718:	4043 a4a9 3cfd 59ac 106a a486 57b2 5988     C@...<.Yj....W.Y
   18728:	eeac a462 6498 5964 db10 a43f 63b5 5940     ..b..ddY..?..c@Y
   18738:	d599 a41c 550e 591c de4e a3f9 38a9 58f8     .....U.YN....8.X
   18748:	f534 a3d6 0e8c 58d4 1a50 a3b4 d6bd 58af     4......XP......X
   18758:	4da8 a391 9140 588b 8f41 a36e 3e1b 5867     .M..@..XA.n..>gX
   18768:	df20 a34b dd54 5842 3d4b a329 6ef1 581e      .K.T.BXK=)..n.X
   18778:	a9c8 a306 f2f8 57f9 249b a2e4 696d 57d5     .......W.$..mi.W
   18788:	adc9 a2c1 d256 57b0 4559 a29f 2dba 578c     ....V..WYE...-.W
   18798:	eb4f a27c 7b9d 5767 9fb1 a25a bc06 5742     O.|..{gW..Z...BW
   187a8:	6284 a238 eefa 571d 33cd a216 147e 56f9     .b8....W.3..~..V
   187b8:	1392 a1f4 2c99 56d4 01d7 a1d2 3750 56af     .....,.V....P7.V
   187c8:	fea3 a1af 34a9 568a 09fa a18e 24aa 5665     .....4.V.....$eV
   187d8:	23e1 a16c 0758 5640 4c5e a14a dcb9 561a     .#l.X.@V^LJ....V
   187e8:	8376 a128 a4d2 55f5 c92f a106 5faa 55d0     v.(....U/...._.U
   187f8:	1d8c a0e5 0d46 55ab 8095 a0c3 adad 5585     ....F..U.......U
   18808:	f24d a0a1 40e2 5560 72ba a080 c6ee 553a     M....@`U.r....:U
   18818:	01e1 a05f 3fd4 5515 9fc8 a03d ab9c 54ef     .._..?.U..=....T
   18828:	4c73 a01c 0a4b 54ca 07e7 9ffb 5be6 54a4     sL..K..T.....[.T
   18838:	d22a 9fd9 a073 547e ab41 9fb8 d7f9 5458     *...s.~TA.....XT
   18848:	9331 9f97 027d 5433 89ff 9f76 2005 540d     1...}.3T..v.. .T
   18858:	8fb0 9f55 3097 53e7 a449 9f34 3439 53c1     ..U..0.SI.4.94.S
   18868:	c7d0 9f13 2af0 539b fa49 9ef2 14c2 5375     .....*.SI.....uS
   18878:	3bb9 9ed2 f1b5 534e 8c26 9eb1 c1d0 5328     .;....NS&.....(S
   18888:	eb94 9e90 8518 5302 5a09 9e70 3b92 52dc     .......S.Zp..;.R
   18898:	d78a 9e4f e546 52b5 641b 9e2f 8238 528f     ..O.F..R.d/.8..R
   188a8:	ffc1 9e0e 126e 5269 aa82 9dee 95f0 5242     ....n.iR......BR
   188b8:	6463 9dce 0cc2 521c 2d68 9dae 76ea 51f5     cd.....Rh-...v.Q
   188c8:	0597 9d8e d46e 51ce ecf4 9d6d 2555 51a8     ....n..Q..m.U%.Q
   188d8:	e385 9d4d 69a5 5181 e94d 9d2d a162 515a     ..M..i.QM.-.b.ZQ
   188e8:	fe54 9d0d cc94 5133 229c 9cee eb40 510c     T.....3Q."..@..Q
   188f8:	562c 9cce fd6d 50e5 9907 9cae 031f 50bf     ,V..m..P.......P
   18908:	eb34 9c8e fc5e 5097 4cb6 9c6f e92f 5070     4...^..P.Lo./.pP
   18918:	bd93 9c4f c999 5049 3dcf 9c30 9da1 5022     ..O...IP.=0..."P
   18928:	cd70 9c10 654d 4ffb 6c7a 9bf1 20a4 4fd4     p...Me.Ozl... .O
   18938:	1af3 9bd2 cfab 4fac d8de 9bb2 7269 4f85     .......O....ir.O
   18948:	a641 9b93 08e3 4f5e 8320 9b74 9320 4f36     A.....^O .t. .6O
   18958:	6f81 9b55 1126 4f0f 6b68 9b36 82fb 4ee7     .oU.&..Ohk6....N
   18968:	76da 9b17 e8a5 4ebf 91db 9af8 4229 4e98     .v.....N....)B.N
   18978:	bc71 9ad9 8f8f 4e70 f6a1 9aba d0dd 4e48     q.....pN......HN
   18988:	406e 9a9c 0617 4e21 99de 9a7d 2f46 4df9     n@....!N..}.F/.M
   18998:	02f5 9a5f 4c6e 4dd1 7bb9 9a40 5d96 4da9     .._.nL.M.{@..].M
   189a8:	042d 9a22 62c4 4d81 9c57 9a03 5bfe 4d59     -."..b.MW....[YM
   189b8:	443b 99e5 494b 4d31 fbde 99c6 2ab0 4d09     ;D..KI1M.....*.M
   189c8:	c345 99a8 0034 4ce1 9a74 998a c9dd 4cb8     E...4..Lt......L
   189d8:	816f 996c 87b1 4c90 783d 994e 39b7 4c68     o.l....L=xN..9hL
   189e8:	7ee0 9930 dff4 4c3f 955f 9912 7a6e 4c17     .~0...?L_...nz.L
   189f8:	bbbc 98f4 092d 4bef f1fe 98d6 8c36 4bc6     ....-..K....6..K
   18a08:	3828 98b9 0390 4b9e 8e40 989b 6f40 4b75     (8.....K@...@ouK
   18a18:	f449 987d cf4d 4b4c 6a49 9860 23be 4b24     I.}.M.LKIj`..#$K
   18a28:	f043 9842 6c98 4afb 863d 9825 a9e2 4ad2     C.B..l.J=.%....J
   18a38:	2c3b 9808 dba2 4aa9 e242 97ea 01de 4a81     ;,.....JB......J
   18a48:	a855 97cd 1c9e 4a58 7e7a 97b0 2be6 4a2f     U.....XJz~...+/J
   18a58:	64b5 9793 2fbd 4a06 5b0a 9776 282a 49dd     .d.../.J.[v.*(.I
   18a68:	617f 9759 1533 49b4 7817 973c f6df 498a     .aY.3..I.x<....I
   18a78:	9ed7 971f cd33 4961 d5c3 9702 9836 4938     ....3.aI....6.8I
   18a88:	1ce0 96e6 57ee 490f 7432 96c9 0c62 48e6     .....W.I2t..b..H
   18a98:	dbbe 96ac b599 48bc 5388 9690 5397 4893     .......H.S...S.H
   18aa8:	db94 9673 e665 4869 73e7 9657 6e08 4840     ..s.e.iH.sW..n@H
   18ab8:	1c86 963b ea86 4816 d574 961e 5be6 47ed     ..;....Ht....[.G
   18ac8:	9eb6 9602 c22f 47c3 7850 95e6 1d67 479a     ..../..GPx..g..G
   18ad8:	6247 95ca 6d93 4770 5c9f 95ae b2bc 4746     Gb...mpG.\....FG
   18ae8:	675c 9592 ece7 471c 8283 9576 1c1a 46f3     \g.....G..v....F
   18af8:	ae17 955a 405c 46c9 ea1e 953e 59b4 469f     ..Z.\@.F..>..Y.F
   18b08:	369c 9523 6828 4675 9394 9507 6bbe 464b     .6#.(huF.....kKF
   18b18:	010b 94ec 647d 4621 7f05 94d0 526b 45f7     ....}d!F....kR.E
   18b28:	0d87 94b5 358f 45cd ac95 9499 0df0 45a3     .....5.E.......E
   18b38:	5c33 947e db93 4578 1c65 9463 9e80 454e     3\~...xEe.c...NE
   18b48:	ed2f 9447 56bd 4524 ce96 942c 0450 44fa     /.G..V$E..,.P..D
   18b58:	c09e 9411 a740 44cf c34a 93f6 3f93 44a5     ....@..DJ....?.D
   18b68:	d6a0 93db cd50 447a faa3 93c0 507e 4450     ....P.zD....~PPD
   18b78:	2f57 93a6 c923 4425 74c1 938b 3746 43fb     W/..#.%D.t..F7.C
   18b88:	cae4 9370 9aed 43d0 31c5 9356 f41e 43a5     ..p....C.1V....C
   18b98:	a968 933b 42e1 437b 31d1 9321 873c 4350     h.;..B{C.1!.<.PC
   18ba8:	cb04 9306 c135 4325 7505 92ec f0d4 42fa     ....5.%C.u.....B
   18bb8:	2fd9 92d2 161e 42d0 fb82 92b7 311b 42a5     ./.....B.....1.B
   18bc8:	d806 929d 41d0 427a c568 9283 4845 424f     .....AzBh...EHOB
   18bd8:	c3ac 9269 4481 4224 d2d7 924f 3689 41f9     ..i..D$B..O..6.A
   18be8:	f2ec 9235 1e65 41ce 23ef 921c fc1a 41a2     ..5.e..A.#.....A
   18bf8:	65e4 9202 cfb1 4177 b8d0 91e8 992f 414c     .e....wA..../.LA
   18c08:	1cb6 91cf 589b 4121 919a 91b5 0dfb 40f6     .....X!A.......@
   18c18:	1781 919c b958 40ca ae6d 9182 5ab6 409f     ....X..@m....Z.@
   18c28:	5663 9169 f21d 4073 0f67 9150 7f94 4048     cVi...s@g.P...H@
   18c38:	d97d 9136 0321 401d b4a9 911d 7cca 3ff1     }.6.!..@.....|.?
   18c48:	a0ee 9104 ec98 3fc5 9e50 90eb 5290 3f9a     .......?P....R.?
   18c58:	acd4 90d2 aeb8 3f6e cc7d 90b9 0119 3f43     ......n?}.....C?
   18c68:	fd4e 90a0 49b8 3f17 3f4d 9088 889c 3eeb     N....I.?M?.....>
   18c78:	927c 906f bdcd 3ebf f6df 9056 e950 3e93     |.o....>..V.P..>
   18c88:	6c7b 903e 0b2c 3e68 f352 9025 2369 3e3c     {l>.,.h>R.%.i#<>
   18c98:	8b69 900d 320d 3e10 34c4 8ff5 371f 3de4     i....2.>.4...7.=
   18ca8:	ef66 8fdc 32a6 3db8 bb53 8fc4 24a8 3d8c     f....2.=S....$.=
   18cb8:	988f 8fac 0d2c 3d60 871d 8f94 ec39 3d33     ....,.`=....9.3=
   18cc8:	8701 8f7c c1d6 3d07 9840 8f64 8e09 3cdb     ..|....=@.d....<
   18cd8:	badb 8f4c 50da 3caf eed8 8f34 0a50 3c83     ..L..P.<..4.P..<
   18ce8:	343a 8f1d ba70 3c56 8b04 8f05 6142 3c2a     :4..p.V<....Ba*<
   18cf8:	f33b 8eed fecd 3bfd 6ce1 8ed6 9318 3bd1     ;......;.l.....;
   18d08:	f7fb 8ebe 1e29 3ba5 948c 8ea7 a007 3b78     ....)..;......x;
   18d18:	4298 8e90 18ba 3b4c 0222 8e79 8848 3b1f     .B....L;".y.H..;
   18d28:	d32e 8e61 eeb7 3af2 b5bf 8e4a 4c0f 3ac6     ..a....:..J..L.:
   18d38:	a9da 8e33 a057 3a99 af80 8e1c eb96 3a6c     ..3.W..:......l:
   18d48:	c6b7 8e05 2dd2 3a40 ef82 8dee 6712 3a13     .....-@:.....g.:
   18d58:	29e4 8dd8 975e 39e6 75e0 8dc1 bebc 39b9     .)..^..9.u.....9
   18d68:	d37b 8daa dd32 398c 42b8 8d94 f2c9 395f     {...2..9.B...._9
   18d78:	c399 8d7d ff87 3932 5623 8d67 0373 3906     ..}...29#Vg.s..9
   18d88:	fa59 8d50 fe93 38d8 b03f 8d3a f0ef 38ab     Y.P....8?.:....8
   18d98:	77d8 8d24 da8e 387e 5127 8d0e bb77 3851     .w$...~8'Q..w.Q8
   18da8:	3c30 8cf8 93b0 3824 38f6 8ce2 6341 37f7     0<....$8.8..Ac.7
   18db8:	477d 8ccc 2a30 37ca 67c8 8cb6 e885 379c     }G..0*.7.g.....7
   18dc8:	99da 8ca0 9e46 376f ddb7 8c8a 4b7b 3742     ....F.o7....{KB7
   18dd8:	3362 8c75 f02a 3714 9ade 8c5f 8c5b 36e7     b3u.*..7.._.[..6
   18de8:	142f 8c4a 2014 36ba 9f58 8c34 ab5c 368c     /.J.. .6X.4.\..6
   18df8:	3c5d 8c1f 2e3b 365f eb40 8c09 a8b8 3631     ]<..;._6@.....16
   18e08:	ac05 8bf4 1ad9 3604 7eb0 8bdf 84a6 35d6     .......6.~.....5
   18e18:	6343 8bca e625 35a8 59c1 8bb5 3f5d 357b     Cc..%..5.Y..]?{5
   18e28:	622f 8ba0 9057 354d 7c8f 8b8b d918 351f     /b..W.M5.|.....5
   18e38:	a8e4 8b76 19a8 34f2 e733 8b61 520d 34c4     ..v....43.a..R.4
   18e48:	377c 8b4d 8250 3496 99c6 8b38 aa76 3468     |7M.P..4..8.v.h4
   18e58:	0e11 8b24 ca87 343a 9462 8b0f e28b 340c     ..$...:4b......4
   18e68:	2cbb 8afb f287 33de d720 8ae6 fa84 33b0     .,.....3 ......3
   18e78:	9394 8ad2 fa88 3382 6219 8abe f29b 3354     .......3.b....T3
   18e88:	42b4 8aaa e2c3 3326 3567 8a96 cb07 32f8     .B....&3g5.....2
   18e98:	3a36 8a82 ab6f 32ca 5123 8a6e 8402 329c     6:..o..2#Qn....2
   18ea8:	7a31 8a5a 54c7 326e b564 8a46 1dc6 3240     1zZ..Tn2d.F...@2
   18eb8:	02be 8a33 df04 3211 6243 8a1f 9889 31e3     ..3....2Cb.....1
   18ec8:	d3f5 8a0b 4a5e 31b5 57d8 89f8 f487 3186     ....^J.1.W.....1
   18ed8:	edef 89e4 970e 3158 963c 89d1 31f8 312a     ......X1<....1*1
   18ee8:	50c3 89be c54d 30fb 1d87 89ab 5115 30cd     .P..M..0.....Q.0
   18ef8:	fc8a 8997 d556 309e edcf 8984 5217 3070     ....V..0.....Rp0
   18f08:	f15a 8971 c761 3041 072e 895f 3539 3013     Z.q.a.A0.._.95.0
   18f18:	2f4c 894c 9ba7 2fe4 69b9 8939 fab2 2fb5     L/L..../.i9..../
   18f28:	b677 8926 5262 2f87 1589 8914 a2be 2f58     w.&.bR./......X/
   18f38:	86f2 8901 ebcc 2f29 0ab4 88ef 2d95 2efb     ......)/.....-..
   18f48:	a0d3 88dc 681e 2ecc 4951 88ca 9b70 2e9d     .....h..QI..p...
   18f58:	0432 88b8 c792 2e6e d177 88a5 ec8b 2e3f     2.....n.w.....?.
   18f68:	b125 8893 0a62 2e11 a33d 8881 211e 2de2     %...b...=....!.-
   18f78:	a7c2 886f 30c7 2db3 beb8 885d 3964 2d84     ..o..0.-..].d9.-
   18f88:	e821 884b 3afc 2d55 23ff 883a 3596 2d26     !.K..:U-.#:..5&-
   18f98:	7256 8828 2939 2cf7 d327 8816 15ee 2cc8     Vr(.9).,'......,
   18fa8:	4677 8805 fbba 2c98 cc48 87f3 daa6 2c69     wF.....,H.....i,
   18fb8:	649b 87e2 b2b9 2c3a 0f75 87d1 83fa 2c0b     .d....:,u......,
   18fc8:	ccd7 87bf 4e6f 2bdc 9cc5 87ae 1221 2bad     ....oN.+....!..+
   18fd8:	7f41 879d cf17 2b7d 744d 878c 8558 2b4e     A.....}+Mt..X.N+
   18fe8:	7bec 877b 34eb 2b1f 9621 876a ddd8 2aef     .{{..4.+!.j....*
   18ff8:	c2ef 8759 8026 2ac0 0258 8749 1bdc 2a91     ..Y.&..*X.I....*
   19008:	545e 8738 b101 2a61 b905 8727 3f9e 2a32     ^T8...a*..'..?2*
   19018:	304e 8717 c7b8 2a02 ba3d 8706 4958 29d3     N0.....*=...XI.)
   19028:	56d3 86f6 c485 29a3 0614 86e6 3946 2974     .V.....)....F9t)
   19038:	c802 86d5 a7a2 2944 9c9f 86c5 0fa1 2915     ......D).......)
   19048:	83ee 86b5 714b 28e5 7df2 86a5 cca5 28b5     ....Kq.(.}.....(
   19058:	8aac 8695 21b9 2886 aa20 8685 708d 2856     .....!.( ....pV(
   19068:	dc4f 8675 b928 2826 213c 8666 fb92 27f6     O.u.(.&(<!f....'
   19078:	78eb 8656 37d3 27c7 e35c 8646 6df1 2797     .xV..7.'\.F..m.'
   19088:	6092 8637 9df4 2767 f091 8627 c7e3 2737     .`7...g'..'...7'
   19098:	9359 8618 ebc7 2707 48ef 8609 09a5 26d8     Y......'.H.....&
   190a8:	1153 85fa 2186 26a8 ec88 85ea 3370 2678     S....!.&....p3x&
   190b8:	da91 85db 3f6c 2648 db70 85cc 4581 2618     ....l?H&p....E.&
   190c8:	ef28 85bd 45b6 25e8 15b9 85af 4012 25b8     (....E.%.....@.%
   190d8:	4f28 85a0 349d 2588 9b76 8591 235f 2558     (O...4.%v..._#X%
   190e8:	faa5 8582 0c5e 2528 6cb8 8574 efa2 24f7     ....^.(%.lt....$
   190f8:	f1b0 8565 cd33 24c7 8991 8557 a517 2497     ..e.3..$..W....$
   19108:	345c 8549 7758 2467 f214 853a 43fa 2437     \4I.Xwg$..:..C7$
   19118:	c2bb 852c 0b08 2407 a652 851e cc87 23d6     ..,....$R......#
   19128:	9cdd 8510 887f 23a6 a65c 8502 3ef7 2376     .......#\....>v#
   19138:	c2d4 84f4 eff8 2345 f244 84e6 9b88 2315     ......E#D......#
   19148:	34b1 84d9 41af 22e5 8a1b 84cb e274 22b4     .4...A."....t.."
   19158:	f286 84bd 7de0 2284 6df2 84b0 13f8 2254     .....}.".m....T"
   19168:	fc62 84a2 a4c5 2223 9dd9 8495 304f 21f3     b.....#"....O0.!
   19178:	5258 8488 b69c 21c2 19e1 847b 37b5 2192     XR.....!..{..7.!
   19188:	f477 846d b3a0 2161 e21a 8460 2a65 2131     w.m...a!..`.e*1!
   19198:	e2cf 8453 9c0c 2100 f695 8446 089c 20d0     ..S....!..F.... 
   191a8:	1d70 843a 701c 209f 5762 842d d295 206e     p.:..p. bW-...n 
   191b8:	a46c 8420 300d 203e 0490 8414 888d 200d     l. ..0> ....... 
   191c8:	77d0 8407 dc1b 1fdc fe2e 83fa 2abf 1fac     .w...........*..
   191d8:	97ad 83ee 7481 1f7b 444d 83e2 b968 1f4a     .....t{.MD..h.J.
   191e8:	0412 83d6 f97b 1f19 d6fc 83c9 34c3 1ee9     ....{........4..
   191f8:	bd0e 83bd 6b46 1eb8 b649 83b1 9d0d 1e87     ....Fk..I.......
   19208:	c2b0 83a5 ca1e 1e56 e244 8399 f282 1e25     ......V.D.....%.
   19218:	1507 838e 163f 1df5 5afb 8382 355e 1dc4     ....?....Z..^5..
   19228:	b422 8376 4fe5 1d93 207d 836b 65dd 1d62     ".v..O..} k..eb.
   19238:	a00f 835f 774d 1d31 32d8 8354 843d 1d00     .._.Mw1..2T.=...
   19248:	d8dc 8348 8cb3 1ccf 921b 833d 90b8 1c9e     ..H.......=.....
   19258:	5e97 8332 9053 1c6d 3e52 8327 8b8c 1c3c     .^2.S.m.R>'...<.
   19268:	314e 831c 826a 1c0b 378d 8311 74f6 1bda     N1..j....7...t..
   19278:	5110 8306 6335 1ba9 7dd8 82fb 4d30 1b78     .Q..5c...}..0Mx.
   19288:	bde8 82f0 32ef 1b47 1141 82e6 1479 1b16     .....2G.A...y...
   19298:	77e5 82db f1d6 1ae4 f1d5 82d0 cb0d 1ab3     .w..............
   192a8:	7f14 82c6 a026 1a82 1fa2 82bc 7128 1a51     ....&.......(qQ.
   192b8:	d381 82b1 3e1b 1a20 9ab3 82a7 0707 19ef     .....> .........
   192c8:	753a 829d cbf3 19bd 6317 8293 8ce7 198c     :u.......c......
   192d8:	644b 8289 49ea 195b 78d8 827f 0304 192a     Kd...I[..x....*.
   192e8:	a0c0 8275 b83c 18f8 dc04 826b 699b 18c7     ..u.<.....k..i..
   192f8:	2aa6 8262 1728 1896 8ca7 8258 c0ea 1864     .*b.(.....X...d.
   19308:	0208 824f 66e9 1833 8acc 8245 092c 1802     ..O..f3...E.,...
   19318:	26f3 823c a7bc 17d0 d67f 8232 429f 179f     .&<.......2..B..
   19328:	9971 8229 d9de 176d 6fcc 8220 6d80 173c     q.)...m..o ..m<.
   19338:	5990 8217 fd8d 170a 56be 820e 8a0c 16d9     .Y.......V......
   19348:	6758 8205 1305 16a8 8b60 81fc 987f 1676     Xg......`.....v.
   19358:	c2d7 81f3 1a83 1645 0dbe 81eb 9918 1613     ......E.........
   19368:	6c16 81e2 1445 15e2 dde1 81d9 8c12 15b0     .l..E...........
   19378:	6321 81d1 0086 157f fbd6 81c8 71aa 154d     !c...........qM.
   19388:	a801 81c0 df86 151b 67a5 81b8 4a1f 14ea     .........g...J..
   19398:	3ac2 81b0 b17f 14b8 2159 81a8 15ae 1487     .:......Y!......
   193a8:	1b6d 81a0 76b1 1455 28fd 8198 d492 1423     m....vU..(....#.
   193b8:	4a0c 8190 2f58 13f2 7e9a 8188 870a 13c0     .J..X/...~......
   193c8:	c6a9 8180 dbb1 138e 223a 8179 2d53 135d     ........:"y.S-].
   193d8:	914e 8171 7bf9 132b 13e6 816a c7aa 12f9     N.q..{+...j.....
   193e8:	aa04 8162 106f 12c8 53a8 815b 564d 1296     ..b.o....S[.MV..
   193f8:	10d4 8154 994e 1264 e188 814c d979 1232     ..T.N.d...L.y.2.
   19408:	c5c7 8145 16d5 1201 bd90 813e 516a 11cf     ..E.......>.jQ..
   19418:	c8e6 8137 8941 119d e7c9 8130 be60 116b     ..7.A.....0.`.k.
   19428:	1a3a 812a f0cf 1139 603a 8123 2096 1108     :.*...9.:`#.. ..
   19438:	b9ca 811c 4dbd 10d6 26ec 8116 784b 10a4     .....M...&..Kx..
   19448:	a7a0 810f a048 1072 3be8 8109 c5bb 1040     ....H.r..;....@.
   19458:	e3c4 8102 e8ad 100e 9f35 80fc 0926 0fdd     ........5...&...
   19468:	6e3c 80f6 272b 0fab 50db 80f0 42c7 0f79     <n..+'...P...By.
   19478:	4712 80ea 5bff 0f47 50e2 80e4 72dc 0f15     .G...[G..P...r..
   19488:	6e4c 80de 8766 0ee3 9f51 80d8 99a4 0eb1     Ln..f...Q.......
   19498:	e3f2 80d2 a99e 0e7f 3c2f 80cd b75b 0e4d     ......../<..[.M.
   194a8:	a80a 80c7 c2e4 0e1b 2784 80c2 cc40 0de9     .........'..@...
   194b8:	ba9d 80bc d376 0db7 6156 80b7 d88f 0d85     ....v...Va......
   194c8:	1baf 80b2 db92 0d53 e9ab 80ac dc87 0d21     ......S.......!.
   194d8:	cb49 80a7 db76 0cef c08b 80a2 d865 0cbd     I...v.......e...
   194e8:	c971 809d d35e 0c8b e5fb 8098 cc68 0c59     q...^.......h.Y.
   194f8:	162c 8094 c389 0c27 5a02 808f b8cb 0bf5     ,.....'..Z......
   19508:	b180 808a ac35 0bc3 1ca6 8086 9dcf 0b91     ....5...........
   19518:	9b74 8081 8d9f 0b5f 2dec 807d 7baf 0b2d     t....._..-}..{-.
   19528:	d40d 8078 6805 0afb 8dd9 8074 52aa 0ac9     ..x..h....t..R..
   19538:	5b50 8070 3ba5 0a97 3c74 806c 22fe 0a65     P[p..;..t<l.."e.
   19548:	3143 8068 08bd 0a33 39c0 8064 ece8 0a00     C1h...3..9d.....
   19558:	55eb 8060 cf89 09ce 85c4 805c b0a7 099c     .U`.......\.....
   19568:	c94c 8058 9049 096a 2084 8055 6e78 0938     L.X.I.j.. U.xn8.
   19578:	8b6b 8051 4b3a 0906 0a04 804e 2699 08d4     k.Q.:K....N..&..
   19588:	9c4d 804a 009a 08a2 4248 8047 d947 086f     M.J.....HBG.G.o.
   19598:	fbf6 8043 b0a7 083d c956 8040 86c2 080b     ..C...=.V.@.....
   195a8:	aa6a 803d 5b9e 07d9 9f31 803a 2f45 07a7     j.=..[..1.:.E/..
   195b8:	a7ac 8037 01be 0775 c3dd 8034 d311 0742     ..7...u...4...B.
   195c8:	f3c2 8031 a345 0710 375d 802f 7262 06de     ..1.E...]7/.br..
   195d8:	8ead 802c 406f 06ac f9b4 8029 0d76 067a     ..,.o@....).v.z.
   195e8:	7872 8027 d97c 0647 0ae7 8025 a48b 0615     rx'.|.G...%.....
   195f8:	b114 8022 6ea9 05e3 6af8 8020 37df 05b1     .."..n...j ..7..
   19608:	3895 801e 0035 057f 19ea 801c c7b1 054c     .8..5.........L.
   19618:	0ef8 801a 8e5c 051a 17bf 8018 543e 04e8     ....\.......>T..
   19628:	3440 8016 195d 04b6 647b 8014 ddc3 0483     @4..]...{d......
   19638:	a86f 8012 a177 0451 001f 8011 6480 041f     o...w.Q......d..
   19648:	6b88 800f 26e6 03ed eaad 800d e8b2 03ba     .k...&..........
   19658:	7d8c 800c a9ea 0388 2427 800b 6a96 0356     .}......'$...jV.
   19668:	de7e 8009 2abf 0324 ac90 8008 ea6c 02f1     ~....*$.....l...
   19678:	8e5e 8007 a9a4 02bf 83e8 8006 6870 028d     ^...........ph..
   19688:	8d2f 8005 26d7 025b aa32 8004 e4e2 0228     /....&[.2.....(.
   19698:	daf1 8003 a297 01f6 1f6d 8003 5ffe 01c4     ........m...._..
   196a8:	77a6 8002 1d20 0192 e39b 8001 da03 015f     .w.. ........._.
   196b8:	634e 8001 96b1 012d f6bd 8000 5330 00fb     Nc....-.....0S..
   196c8:	9dea 8000 0f88 00c9 58d4 8000 cbc1 0096     .........X......
   196d8:	277a 8000 87e3 0064 09df 8000 43f5 0032     z'....d......C2.
   196e8:	0000 8000 0000 0000 09df 8000 bc0b ffcd     ................
   196f8:	277a 8000 781d ff9b 58d4 8000 343f ff69     z'...x...X..?4i.
   19708:	9dea 8000 f078 ff36 f6bd 8000 acd0 ff04     ....x.6.........
   19718:	634e 8001 694f fed2 e39b 8001 25fd fea0     Nc..Oi.......%..
   19728:	77a6 8002 e2e0 fe6d 1f6d 8003 a002 fe3b     .w....m.m.....;.
   19738:	daf1 8003 5d69 fe09 aa32 8004 1b1e fdd7     ....i]..2.......
   19748:	8d2f 8005 d929 fda4 83e8 8006 9790 fd72     /...).........r.
   19758:	8e5e 8007 565c fd40 ac90 8008 1594 fd0e     ^...\V@.........
   19768:	de7e 8009 d541 fcdb 2427 800b 956a fca9     ~...A...'$..j...
   19778:	7d8c 800c 5616 fc77 eaad 800d 174e fc45     .}...Vw.....N.E.
   19788:	6b88 800f d91a fc12 001f 8011 9b80 fbe0     .k..............
   19798:	a86f 8012 5e89 fbae 647b 8014 223d fb7c     o....^..{d..="|.
   197a8:	3440 8016 e6a3 fb49 17bf 8018 abc2 fb17     @4....I.........
   197b8:	0ef8 801a 71a4 fae5 19ea 801c 384f fab3     .....q......O8..
   197c8:	3895 801e ffcb fa80 6af8 8020 c821 fa4e     .8.......j .!.N.
   197d8:	b114 8022 9157 fa1c 0ae7 8025 5b75 f9ea     ..".W.....%.u[..
   197e8:	7872 8027 2684 f9b8 f9b4 8029 f28a f985     rx'..&....).....
   197f8:	8ead 802c bf91 f953 375d 802f 8d9e f921     ..,...S.]7/...!.
   19808:	f3c2 8031 5cbb f8ef c3dd 8034 2cef f8bd     ..1..\....4..,..
   19818:	a7ac 8037 fe42 f88a 9f31 803a d0bb f858     ..7.B...1.:...X.
   19828:	aa6a 803d a462 f826 c956 8040 793e f7f4     j.=.b.&.V.@.>y..
   19838:	fbf6 8043 4f59 f7c2 4248 8047 26b9 f790     ..C.YO..HBG..&..
   19848:	9c4d 804a ff66 f75d 0a04 804e d967 f72b     M.J.f.]...N.g.+.
   19858:	8b6b 8051 b4c6 f6f9 2084 8055 9188 f6c7     k.Q...... U.....
   19868:	c94c 8058 6fb7 f695 85c4 805c 4f59 f663     L.X..o....\.YOc.
   19878:	55eb 8060 3077 f631 39c0 8064 1318 f5ff     .U`.w01..9d.....
   19888:	3143 8068 f743 f5cc 3c74 806c dd02 f59a     C1h.C...t<l.....
   19898:	5b50 8070 c45b f568 8dd9 8074 ad56 f536     P[p.[.h...t.V.6.
   198a8:	d40d 8078 97fb f504 2dec 807d 8451 f4d2     ..x......-}.Q...
   198b8:	9b74 8081 7261 f4a0 1ca6 8086 6231 f46e     t...ar......1bn.
   198c8:	b180 808a 53cb f43c 5a02 808f 4735 f40a     .....S<..Z..5G..
   198d8:	162c 8094 3c77 f3d8 e5fb 8098 3398 f3a6     ,...w<.......3..
   198e8:	c971 809d 2ca2 f374 c08b 80a2 279b f342     q....,t......'B.
   198f8:	cb49 80a7 248a f310 e9ab 80ac 2379 f2de     I....$......y#..
   19908:	1baf 80b2 246e f2ac 6156 80b7 2771 f27a     ....n$..Va..q'z.
   19918:	ba9d 80bc 2c8a f248 2784 80c2 33c0 f216     .....,H..'...3..
   19928:	a80a 80c7 3d1c f1e4 3c2f 80cd 48a5 f1b2     .....=../<...H..
   19938:	e3f2 80d2 5662 f180 9f51 80d8 665c f14e     ....bV..Q...\fN.
   19948:	6e4c 80de 789a f11c 50e2 80e4 8d24 f0ea     Ln...x...P..$...
   19958:	4712 80ea a401 f0b8 50db 80f0 bd39 f086     .G.......P..9...
   19968:	6e3c 80f6 d8d5 f054 9f35 80fc f6da f022     <n....T.5.....".
   19978:	e3c4 8102 1753 eff1 3be8 8109 3a45 efbf     ....S....;..E:..
   19988:	a7a0 810f 5fb8 ef8d 26ec 8116 87b5 ef5b     ....._...&....[.
   19998:	b9ca 811c b243 ef29 603a 8123 df6a eef7     ....C.).:`#.j...
   199a8:	1a3a 812a 0f31 eec6 e7c9 8130 41a0 ee94     :.*.1.....0..A..
   199b8:	c8e6 8137 76bf ee62 bd90 813e ae96 ee30     ..7..vb...>...0.
   199c8:	c5c7 8145 e92b edfe e188 814c 2687 edcd     ..E.+.....L..&..
   199d8:	10d4 8154 66b2 ed9b 53a8 815b a9b3 ed69     ..T..f...S[...i.
   199e8:	aa04 8162 ef91 ed37 13e6 816a 3856 ed06     ..b...7...j.V8..
   199f8:	914e 8171 8407 ecd4 223a 8179 d2ad eca2     N.q.....:"y.....
   19a08:	c6a9 8180 244f ec71 7e9a 8188 78f6 ec3f     ....O$q..~...x?.
   19a18:	4a0c 8190 d0a8 ec0d 28fd 8198 2b6e ebdc     .J.......(..n+..
   19a28:	1b6d 81a0 894f ebaa 2159 81a8 ea52 eb78     m...O...Y!..R.x.
   19a38:	3ac2 81b0 4e81 eb47 67a5 81b8 b5e1 eb15     .:...NG..g......
   19a48:	a801 81c0 207a eae4 fbd6 81c8 8e56 eab2     ....z ......V...
   19a58:	6321 81d1 ff7a ea80 dde1 81d9 73ee ea4f     !c..z........sO.
   19a68:	6c16 81e2 ebbb ea1d 0dbe 81eb 66e8 e9ec     .l...........f..
   19a78:	c2d7 81f3 e57d e9ba 8b60 81fc 6781 e989     ....}...`....g..
   19a88:	6758 8205 ecfb e957 56be 820e 75f4 e926     Xg....W..V...u&.
   19a98:	5990 8217 0273 e8f5 6fcc 8220 9280 e8c3     .Y..s....o .....
   19aa8:	9971 8229 2622 e892 d67f 8232 bd61 e860     q.)."&....2.a.`.
   19ab8:	26f3 823c 5844 e82f 8acc 8245 f6d4 e7fd     .&<.DX/...E.....
   19ac8:	0208 824f 9917 e7cc 8ca7 8258 3f16 e79b     ..O.......X..?..
   19ad8:	2aa6 8262 e8d8 e769 dc04 826b 9665 e738     .*b...i...k.e.8.
   19ae8:	a0c0 8275 47c4 e707 78d8 827f fcfc e6d5     ..u..G...x......
   19af8:	644b 8289 b616 e6a4 6317 8293 7319 e673     Kd.......c...ss.
   19b08:	753a 829d 340d e642 9ab3 82a7 f8f9 e610     :u...4B.........
   19b18:	d381 82b1 c1e5 e5df 1fa2 82bc 8ed8 e5ae     ................
   19b28:	7f14 82c6 5fda e57d f1d5 82d0 34f3 e54c     ....._}......4L.
   19b38:	77e5 82db 0e2a e51b 1141 82e6 eb87 e4e9     .w..*...A.......
   19b48:	bde8 82f0 cd11 e4b8 7dd8 82fb b2d0 e487     .........}......
   19b58:	5110 8306 9ccb e456 378d 8311 8b0a e425     .Q....V..7....%.
   19b68:	314e 831c 7d96 e3f4 3e52 8327 7474 e3c3     N1...}..R>'.tt..
   19b78:	5e97 8332 6fad e392 921b 833d 6f48 e361     .^2..o....=.Hoa.
   19b88:	d8dc 8348 734d e330 32d8 8354 7bc3 e2ff     ..H.Ms0..2T..{..
   19b98:	a00f 835f 88b3 e2ce 207d 836b 9a23 e29d     .._.....} k.#...
   19ba8:	b422 8376 b01b e26c 5afb 8382 caa2 e23b     ".v...l..Z....;.
   19bb8:	1507 838e e9c1 e20a e244 8399 0d7e e1da     ........D...~...
   19bc8:	c2b0 83a5 35e2 e1a9 b649 83b1 62f3 e178     .....5..I....bx.
   19bd8:	bd0e 83bd 94ba e147 d6fc 83c9 cb3d e116     ......G.....=...
   19be8:	0412 83d6 0685 e0e6 444d 83e2 4698 e0b5     ........MD...F..
   19bf8:	97ad 83ee 8b7f e084 fe2e 83fa d541 e053     ............A.S.
   19c08:	77d0 8407 23e5 e023 0490 8414 7773 dff2     .w...##.....sw..
   19c18:	a46c 8420 cff3 dfc1 5762 842d 2d6b df91     l. .....bW-.k-..
   19c28:	1d70 843a 8fe4 df60 f695 8446 f764 df2f     p.:...`...F.d./.
   19c38:	e2cf 8453 63f4 deff e21a 8460 d59b dece     ..S..c....`.....
   19c48:	f477 846d 4c60 de9e 19e1 847b c84b de6d     w.m.`L....{.K.m.
   19c58:	5258 8488 4964 de3d 9dd9 8495 cfb1 de0c     XR..dI=.........
   19c68:	fc62 84a2 5b3b dddc 6df2 84b0 ec08 ddab     b...;[...m......
   19c78:	f286 84bd 8220 dd7b 8a1b 84cb 1d8c dd4b     .... .{.......K.
   19c88:	34b1 84d9 be51 dd1a f244 84e6 6478 dcea     .4..Q...D...xd..
   19c98:	c2d4 84f4 1008 dcba a65c 8502 c109 dc89     ........\.......
   19ca8:	9cdd 8510 7781 dc59 a652 851e 3379 dc29     .....wY.R...y3).
   19cb8:	c2bb 852c f4f8 dbf8 f214 853a bc06 dbc8     ..,.......:.....
   19cc8:	345c 8549 88a8 db98 8991 8557 5ae9 db68     \4I.......W..Zh.
   19cd8:	f1b0 8565 32cd db38 6cb8 8574 105e db08     ..e..28..lt.^...
   19ce8:	faa5 8582 f3a2 dad7 9b76 8591 dca1 daa7     ........v.......
   19cf8:	4f28 85a0 cb63 da77 15b9 85af bfee da47     (O..c.w.......G.
   19d08:	ef28 85bd ba4a da17 db70 85cc ba7f d9e7     (...J...p.......
   19d18:	da91 85db c094 d9b7 ec88 85ea cc90 d987     ................
   19d28:	1153 85fa de7a d957 48ef 8609 f65b d927     S...z.W..H..[.'.
   19d38:	9359 8618 1439 d8f8 f091 8627 381d d8c8     Y...9.....'..8..
   19d48:	6092 8637 620c d898 e35c 8646 920f d868     .`7..b..\.F...h.
   19d58:	78eb 8656 c82d d838 213c 8666 046e d809     .xV.-.8.<!f.n...
   19d68:	dc4f 8675 46d8 d7d9 aa20 8685 8f73 d7a9     O.u..F.. ...s...
   19d78:	8aac 8695 de47 d779 7df2 86a5 335b d74a     ....G.y..}..[3J.
   19d88:	83ee 86b5 8eb5 d71a 9c9f 86c5 f05f d6ea     ............_...
   19d98:	c802 86d5 585e d6bb 0614 86e6 c6ba d68b     ....^X..........
   19da8:	56d3 86f6 3b7b d65c ba3d 8706 b6a8 d62c     .V..{;\.=.....,.
   19db8:	304e 8717 3848 d5fd b905 8727 c062 d5cd     N0..H8....'.b...
   19dc8:	545e 8738 4eff d59e 0258 8749 e424 d56e     ^T8..N..X.I.$.n.
   19dd8:	c2ef 8759 7fda d53f 9621 876a 2228 d510     ..Y...?.!.j.("..
   19de8:	7bec 877b cb15 d4e0 744d 878c 7aa8 d4b1     .{{.....Mt...z..
   19df8:	7f41 879d 30e9 d482 9cc5 87ae eddf d452     A....0........R.
   19e08:	ccd7 87bf b191 d423 0f75 87d1 7c06 d3f4     ......#.u....|..
   19e18:	649b 87e2 4d47 d3c5 cc48 87f3 255a d396     .d..GM..H...Z%..
   19e28:	4677 8805 0446 d367 d327 8816 ea12 d337     wF..F.g.'.....7.
   19e38:	7256 8828 d6c7 d308 23ff 883a ca6a d2d9     Vr(......#:.j...
   19e48:	e821 884b c504 d2aa beb8 885d c69c d27b     !.K.......]...{.
   19e58:	a7c2 886f cf39 d24c a33d 8881 dee2 d21d     ..o.9.L.=.......
   19e68:	b125 8893 f59e d1ee d177 88a5 1375 d1c0     %.......w...u...
   19e78:	0432 88b8 386e d191 4951 88ca 6490 d162     2...n8..QI...db.
   19e88:	a0d3 88dc 97e2 d133 0ab4 88ef d26b d104     ......3.....k...
   19e98:	86f2 8901 1434 d0d6 1589 8914 5d42 d0a7     ....4.......B]..
   19ea8:	b677 8926 ad9e d078 69b9 8939 054e d04a     w.&...x..i9.N.J.
   19eb8:	2f4c 894c 6459 d01b 072e 895f cac7 cfec     L/L.Yd...._.....
   19ec8:	f15a 8971 389f cfbe edcf 8984 ade9 cf8f     Z.q..8..........
   19ed8:	fc8a 8997 2aaa cf61 1d87 89ab aeeb cf32     .....*a.......2.
   19ee8:	50c3 89be 3ab3 cf04 963c 89d1 ce08 ced5     .P...:..<.......
   19ef8:	edef 89e4 68f2 cea7 57d8 89f8 0b79 ce79     .....h...W..y.y.
   19f08:	d3f5 8a0b b5a2 ce4a 6243 8a1f 6777 ce1c     ......J.Cb..wg..
   19f18:	02be 8a33 20fc cdee b564 8a46 e23a cdbf     ..3.. ..d.F.:...
   19f28:	7a31 8a5a ab39 cd91 5123 8a6e 7bfe cd63     1zZ.9...#Qn..{c.
   19f38:	3a36 8a82 5491 cd35 3567 8a96 34f9 cd07     6:...T5.g5...4..
   19f48:	42b4 8aaa 1d3d ccd9 6219 8abe 0d65 ccab     .B..=....b..e...
   19f58:	9394 8ad2 0578 cc7d d720 8ae6 057c cc4f     ....x.}. ...|.O.
   19f68:	2cbb 8afb 0d79 cc21 9462 8b0f 1d75 cbf3     .,..y.!.b...u...
   19f78:	0e11 8b24 3579 cbc5 99c6 8b38 558a cb97     ..$.y5....8..U..
   19f88:	377c 8b4d 7db0 cb69 e733 8b61 adf3 cb3b     |7M..}i.3.a...;.
   19f98:	a8e4 8b76 e658 cb0d 7c8f 8b8b 26e8 cae0     ..v.X....|...&..
   19fa8:	622f 8ba0 6fa9 cab2 59c1 8bb5 c0a3 ca84     /b...o...Y......
   19fb8:	6343 8bca 19db ca57 7eb0 8bdf 7b5a ca29     Cc....W..~..Z{).
   19fc8:	ac05 8bf4 e527 c9fb eb40 8c09 5748 c9ce     ....'...@...HW..
   19fd8:	3c5d 8c1f d1c5 c9a0 9f58 8c34 54a4 c973     ]<......X.4..Ts.
   19fe8:	142f 8c4a dfec c945 9ade 8c5f 73a5 c918     /.J...E..._..s..
   19ff8:	3362 8c75 0fd6 c8eb ddb7 8c8a b485 c8bd     b3u.............
   1a008:	99da 8ca0 61ba c890 67c8 8cb6 177b c863     .....a...g..{.c.
   1a018:	477d 8ccc d5d0 c835 38f6 8ce2 9cbf c808     }G....5..8......
   1a028:	3c30 8cf8 6c50 c7db 5127 8d0e 4489 c7ae     0<..Pl..'Q...D..
   1a038:	77d8 8d24 2572 c781 b03f 8d3a 0f11 c754     .w$.r%..?.:...T.
   1a048:	fa59 8d50 016d c727 5623 8d67 fc8d c6f9     Y.P.m.'.#Vg.....
   1a058:	c399 8d7d 0079 c6cd 42b8 8d94 0d37 c6a0     ..}.y....B..7...
   1a068:	d37b 8daa 22ce c673 75e0 8dc1 4144 c646     {...."s..u..DAF.
   1a078:	29e4 8dd8 68a2 c619 ef82 8dee 98ee c5ec     .)...h..........
   1a088:	c6b7 8e05 d22e c5bf af80 8e1c 146a c593     ............j...
   1a098:	a9da 8e33 5fa9 c566 b5bf 8e4a b3f1 c539     ..3.._f...J...9.
   1a0a8:	d32e 8e61 1149 c50d 0222 8e79 77b8 c4e0     ..a.I...".y..w..
   1a0b8:	4298 8e90 e746 c4b3 948c 8ea7 5ff9 c487     .B..F........_..
   1a0c8:	f7fb 8ebe e1d7 c45a 6ce1 8ed6 6ce8 c42e     ......Z..l...l..
   1a0d8:	f33b 8eed 0133 c402 8b04 8f05 9ebe c3d5     ;...3...........
   1a0e8:	343a 8f1d 4590 c3a9 eed8 8f34 f5b0 c37c     :4...E....4...|.
   1a0f8:	badb 8f4c af26 c350 9840 8f64 71f7 c324     ..L.&.P.@.d..q$.
   1a108:	8701 8f7c 3e2a c2f8 871d 8f94 13c7 c2cc     ..|.*>..........
   1a118:	988f 8fac f2d4 c29f bb53 8fc4 db58 c273     ........S...X.s.
   1a128:	ef66 8fdc cd5a c247 34c4 8ff5 c8e1 c21b     f...Z.G..4......
   1a138:	8b69 900d cdf3 c1ef f352 9025 dc97 c1c3     i.......R.%.....
   1a148:	6c7b 903e f4d4 c197 f6df 9056 16b0 c16c     {l>.......V...l.
   1a158:	927c 906f 4233 c140 3f4d 9088 7764 c114     |.o.3B@.M?..dw..
   1a168:	fd4e 90a0 b648 c0e8 cc7d 90b9 fee7 c0bc     N...H...}.......
   1a178:	acd4 90d2 5148 c091 9e50 90eb ad70 c065     ....HQ..P...p.e.
   1a188:	a0ee 9104 1368 c03a b4a9 911d 8336 c00e     ....h.:.....6...
   1a198:	d97d 9136 fcdf bfe2 0f67 9150 806c bfb7     }.6.....g.P.l...
   1a1a8:	5663 9169 0de3 bf8c ae6d 9182 a54a bf60     cVi.....m...J.`.
   1a1b8:	1781 919c 46a8 bf35 919a 91b5 f205 bf09     .....F5.........
   1a1c8:	1cb6 91cf a765 bede b8d0 91e8 66d1 beb3     ....e........f..
   1a1d8:	65e4 9202 304f be88 23ef 921c 03e6 be5d     .e..O0...#....].
   1a1e8:	f2ec 9235 e19b be31 d2d7 924f c977 be06     ..5...1...O.w...
   1a1f8:	c3ac 9269 bb7f bddb c568 9283 b7bb bdb0     ..i.....h.......
   1a208:	d806 929d be30 bd85 fb82 92b7 cee5 bd5a     ....0.........Z.
   1a218:	2fd9 92d2 e9e2 bd2f 7505 92ec 0f2c bd05     ./..../..u..,...
   1a228:	cb04 9306 3ecb bcda 31d1 9321 78c4 bcaf     .....>...1!..x..
   1a238:	a968 933b bd1f bc84 31c5 9356 0be2 bc5a     h.;......1V...Z.
   1a248:	cae4 9370 6513 bc2f 74c1 938b c8ba bc04     ..p..e/..t......
   1a258:	2f57 93a6 36dd bbda faa3 93c0 af82 bbaf     W/...6..........
   1a268:	d6a0 93db 32b0 bb85 c34a 93f6 c06d bb5a     .....2..J...m.Z.
   1a278:	c09e 9411 58c0 bb30 ce96 942c fbb0 bb05     .....X0...,.....
   1a288:	ed2f 9447 a943 badb 1c65 9463 6180 bab1     /.G.C...e.c..a..
   1a298:	5c33 947e 246d ba87 ac95 9499 f210 ba5c     3\~.m$........\.
   1a2a8:	0d87 94b5 ca71 ba32 7f05 94d0 ad95 ba08     ....q.2.........
   1a2b8:	010b 94ec 9b83 b9de 9394 9507 9442 b9b4     ............B...
   1a2c8:	369c 9523 97d8 b98a ea1e 953e a64c b960     .6#.......>.L.`.
   1a2d8:	ae17 955a bfa4 b936 8283 9576 e3e6 b90c     ..Z...6...v.....
   1a2e8:	675c 9592 1319 b8e3 5c9f 95ae 4d44 b8b9     \g.......\..DM..
   1a2f8:	6247 95ca 926d b88f 7850 95e6 e299 b865     Gb..m...Px....e.
   1a308:	9eb6 9602 3dd1 b83c d574 961e a41a b812     .....=<.t.......
   1a318:	1c86 963b 157a b7e9 73e7 9657 91f8 b7bf     ..;.z....sW.....
   1a328:	db94 9673 199b b796 5388 9690 ac69 b76c     ..s......S..i.l.
   1a338:	dbbe 96ac 4a67 b743 7432 96c9 f39e b719     ....gJC.2t......
   1a348:	1ce0 96e6 a812 b6f0 d5c3 9702 67ca b6c7     .............g..
   1a358:	9ed7 971f 32cd b69e 7817 973c 0921 b675     .....2...x<.!.u.
   1a368:	617f 9759 eacd b64b 5b0a 9776 d7d6 b622     .aY...K..[v...".
   1a378:	64b5 9793 d043 b5f9 7e7a 97b0 d41a b5d0     .d..C...z~......
   1a388:	a855 97cd e362 b5a7 e242 97ea fe22 b57e     U...b...B...".~.
   1a398:	2c3b 9808 245e b556 863d 9825 561e b52d     ;,..^$V.=.%..V-.
   1a3a8:	f043 9842 9368 b504 6a49 9860 dc42 b4db     C.B.h...Ij`.B...
   1a3b8:	f449 987d 30b3 b4b3 8e40 989b 90c0 b48a     I.}..0..@.......
   1a3c8:	3828 98b9 fc70 b461 f1fe 98d6 73ca b439     (8..p.a......s9.
   1a3d8:	bbbc 98f4 f6d3 b410 955f 9912 8592 b3e8     ........_.......
   1a3e8:	7ee0 9930 200c b3c0 783d 994e c649 b397     .~0.. ..=xN.I...
   1a3f8:	816f 996c 784f b36f 9a74 998a 3623 b347     o.l.Oxo.t...#6G.
   1a408:	c345 99a8 ffcc b31e fbde 99c6 d550 b2f6     E...........P...
   1a418:	443b 99e5 b6b5 b2ce 9c57 9a03 a402 b2a6     ;D......W.......
   1a428:	042d 9a22 9d3c b27e 7bb9 9a40 a26a b256     -.".<.~..{@.j.V.
   1a438:	02f5 9a5f b392 b22e 99de 9a7d d0ba b206     .._.......}.....
   1a448:	406e 9a9c f9e9 b1de f6a1 9aba 2f23 b1b7     n@..........#/..
   1a458:	bc71 9ad9 7071 b18f 91db 9af8 bdd7 b167     q...qp........g.
   1a468:	76da 9b17 175b b140 6b68 9b36 7d05 b118     .v..[.@.hk6..}..
   1a478:	6f81 9b55 eeda b0f0 8320 9b74 6ce0 b0c9     .oU..... .t..l..
   1a488:	a641 9b93 f71d b0a1 d8de 9bb2 8d97 b07a     A.............z.
   1a498:	1af3 9bd2 3055 b053 6c7a 9bf1 df5c b02b     ....U0S.zl..\.+.
   1a4a8:	cd70 9c10 9ab3 b004 3dcf 9c30 625f afdd     p........=0._b..
   1a4b8:	bd93 9c4f 3667 afb6 4cb6 9c6f 16d1 af8f     ..O.g6...Lo.....
   1a4c8:	eb34 9c8e 03a2 af68 9907 9cae fce1 af40     4.....h.......@.
   1a4d8:	562c 9cce 0293 af1a 229c 9cee 14c0 aef3     ,V......."......
   1a4e8:	fe54 9d0d 336c aecc e94d 9d2d 5e9e aea5     T...l3..M.-..^..
   1a4f8:	e385 9d4d 965b ae7e ecf4 9d6d daab ae57     ..M.[.~...m...W.
   1a508:	0597 9d8e 2b92 ae31 2d68 9dae 8916 ae0a     .....+1.h-......
   1a518:	6463 9dce f33e ade3 aa82 9dee 6a10 adbd     cd..>........j..
   1a528:	ffc1 9e0e ed92 ad96 641b 9e2f 7dc8 ad70     .........d/..}p.
   1a538:	d78a 9e4f 1aba ad4a 5a09 9e70 c46e ad23     ..O...J..Zp.n.#.
   1a548:	eb94 9e90 7ae8 acfd 8c26 9eb1 3e30 acd7     .....z..&...0>..
   1a558:	3bb9 9ed2 0e4b acb1 fa49 9ef2 eb3e ac8a     .;..K...I...>...
   1a568:	c7d0 9f13 d510 ac64 a449 9f34 cbc7 ac3e     ......d.I.4...>.
   1a578:	8fb0 9f55 cf69 ac18 89ff 9f76 dffb abf2     ..U.i.....v.....
   1a588:	9331 9f97 fd83 abcc ab41 9fb8 2807 aba7     1.......A....(..
   1a598:	d22a 9fd9 5f8d ab81 07e7 9ffb a41a ab5b     *...._........[.
   1a5a8:	4c73 a01c f5b5 ab35 9fc8 a03d 5464 ab10     sL....5...=.dT..
   1a5b8:	01e1 a05f c02c aaea 72ba a080 3912 aac5     .._.,....r...9..
   1a5c8:	f24d a0a1 bf1e aa9f 8095 a0c3 5253 aa7a     M...........SRz.
   1a5d8:	1d8c a0e5 f2ba aa54 c92f a106 a056 aa2f     ......T./...V./.
   1a5e8:	8376 a128 5b2e aa0a 4c5e a14a 2347 a9e5     v.(..[..^LJ.G#..
   1a5f8:	23e1 a16c f8a8 a9bf 09fa a18e db56 a99a     .#l.........V...
   1a608:	fea3 a1af cb57 a975 01d7 a1d2 c8b0 a950     ....W.u.......P.
   1a618:	1392 a1f4 d367 a92b 33cd a216 eb82 a906     ....g.+..3......
   1a628:	6284 a238 1106 a8e2 9fb1 a25a 43fa a8bd     .b8.......Z..C..
   1a638:	eb4f a27c 8463 a898 4559 a29f d246 a873     O.|.c...YE..F.s.
   1a648:	adc9 a2c1 2daa a84f 249b a2e4 9693 a82a     .....-O..$....*.
   1a658:	a9c8 a306 0d08 a806 3d4b a329 910f a7e1     ........K=).....
   1a668:	df20 a34b 22ac a7bd 8f41 a36e c1e5 a798      .K.."..A.n.....
   1a678:	4da8 a391 6ec0 a774 1a50 a3b4 2943 a750     .M...nt.P...C)P.
   1a688:	f534 a3d6 f174 a72b de4e a3f9 c757 a707     4...t.+.N...W...
   1a698:	d599 a41c aaf2 a6e3 db10 a43f 9c4b a6bf     ..........?.K...
   1a6a8:	eeac a462 9b68 a69b 106a a486 a84e a677     ..b.h...j...N.w.
   1a6b8:	4043 a4a9 c303 a653 7e32 a4cc eb8b a62f     C@....S.2~..../.
   1a6c8:	ca31 a4ef 21ee a60c 243b a513 662f a5e8     1....!..;$../f..
   1a6d8:	8c4b a536 b855 a5c4 025b a55a 1866 a5a1     K.6.U...[.Z.f...
   1a6e8:	8666 a57d 8666 a57d 1866 a5a1 025b a55a     f.}.f.}.f...[.Z.
   1a6f8:	b855 a5c4 8c4b a536 662f a5e8 243b a513     U...K.6./f..;$..
   1a708:	21ee a60c ca31 a4ef eb8b a62f 7e32 a4cc     .!..1...../.2~..
   1a718:	c303 a653 4043 a4a9 a84e a677 106a a486     ..S.C@..N.w.j...
   1a728:	9b68 a69b eeac a462 9c4b a6bf db10 a43f     h.....b.K.....?.
   1a738:	aaf2 a6e3 d599 a41c c757 a707 de4e a3f9     ........W...N...
   1a748:	f174 a72b f534 a3d6 2943 a750 1a50 a3b4     t.+.4...C)P.P...
   1a758:	6ec0 a774 4da8 a391 c1e5 a798 8f41 a36e     .nt..M......A.n.
   1a768:	22ac a7bd df20 a34b 910f a7e1 3d4b a329     .".. .K.....K=).
   1a778:	0d08 a806 a9c8 a306 9693 a82a 249b a2e4     ..........*..$..
   1a788:	2daa a84f adc9 a2c1 d246 a873 4559 a29f     .-O.....F.s.YE..
   1a798:	8463 a898 eb4f a27c 43fa a8bd 9fb1 a25a     c...O.|..C....Z.
   1a7a8:	1106 a8e2 6284 a238 eb82 a906 33cd a216     .....b8......3..
   1a7b8:	d367 a92b 1392 a1f4 c8b0 a950 01d7 a1d2     g.+.......P.....
   1a7c8:	cb57 a975 fea3 a1af db56 a99a 09fa a18e     W.u.....V.......
   1a7d8:	f8a8 a9bf 23e1 a16c 2347 a9e5 4c5e a14a     .....#l.G#..^LJ.
   1a7e8:	5b2e aa0a 8376 a128 a056 aa2f c92f a106     .[..v.(.V././...
   1a7f8:	f2ba aa54 1d8c a0e5 5253 aa7a 8095 a0c3     ..T.....SRz.....
   1a808:	bf1e aa9f f24d a0a1 3912 aac5 72ba a080     ....M....9...r..
   1a818:	c02c aaea 01e1 a05f 5464 ab10 9fc8 a03d     ,....._.dT....=.
   1a828:	f5b5 ab35 4c73 a01c a41a ab5b 07e7 9ffb     ..5.sL....[.....
   1a838:	5f8d ab81 d22a 9fd9 2807 aba7 ab41 9fb8     ._..*....(..A...
   1a848:	fd83 abcc 9331 9f97 dffb abf2 89ff 9f76     ....1.........v.
   1a858:	cf69 ac18 8fb0 9f55 cbc7 ac3e a449 9f34     i.....U...>.I.4.
   1a868:	d510 ac64 c7d0 9f13 eb3e ac8a fa49 9ef2     ..d.....>...I...
   1a878:	0e4b acb1 3bb9 9ed2 3e30 acd7 8c26 9eb1     K....;..0>..&...
   1a888:	7ae8 acfd eb94 9e90 c46e ad23 5a09 9e70     .z......n.#..Zp.
   1a898:	1aba ad4a d78a 9e4f 7dc8 ad70 641b 9e2f     ..J...O..}p..d/.
   1a8a8:	ed92 ad96 ffc1 9e0e 6a10 adbd aa82 9dee     .........j......
   1a8b8:	f33e ade3 6463 9dce 8916 ae0a 2d68 9dae     >...cd......h-..
   1a8c8:	2b92 ae31 0597 9d8e daab ae57 ecf4 9d6d     .+1.......W...m.
   1a8d8:	965b ae7e e385 9d4d 5e9e aea5 e94d 9d2d     [.~...M..^..M.-.
   1a8e8:	336c aecc fe54 9d0d 14c0 aef3 229c 9cee     l3..T........"..
   1a8f8:	0293 af1a 562c 9cce fce1 af40 9907 9cae     ....,V....@.....
   1a908:	03a2 af68 eb34 9c8e 16d1 af8f 4cb6 9c6f     ..h.4........Lo.
   1a918:	3667 afb6 bd93 9c4f 625f afdd 3dcf 9c30     g6....O._b...=0.
   1a928:	9ab3 b004 cd70 9c10 df5c b02b 6c7a 9bf1     ....p...\.+.zl..
   1a938:	3055 b053 1af3 9bd2 8d97 b07a d8de 9bb2     U0S.......z.....
   1a948:	f71d b0a1 a641 9b93 6ce0 b0c9 8320 9b74     ....A....l.. .t.
   1a958:	eeda b0f0 6f81 9b55 7d05 b118 6b68 9b36     .....oU..}..hk6.
   1a968:	175b b140 76da 9b17 bdd7 b167 91db 9af8     [.@..v....g.....
   1a978:	7071 b18f bc71 9ad9 2f23 b1b7 f6a1 9aba     qp..q...#/......
   1a988:	f9e9 b1de 406e 9a9c d0ba b206 99de 9a7d     ....n@........}.
   1a998:	b392 b22e 02f5 9a5f a26a b256 7bb9 9a40     ......_.j.V..{@.
   1a9a8:	9d3c b27e 042d 9a22 a402 b2a6 9c57 9a03     <.~.-.".....W...
   1a9b8:	b6b5 b2ce 443b 99e5 d550 b2f6 fbde 99c6     ....;D..P.......
   1a9c8:	ffcc b31e c345 99a8 3623 b347 9a74 998a     ....E...#6G.t...
   1a9d8:	784f b36f 816f 996c c649 b397 783d 994e     Oxo.o.l.I...=xN.
   1a9e8:	200c b3c0 7ee0 9930 8592 b3e8 955f 9912     . ...~0....._...
   1a9f8:	f6d3 b410 bbbc 98f4 73ca b439 f1fe 98d6     .........s9.....
   1aa08:	fc70 b461 3828 98b9 90c0 b48a 8e40 989b     p.a.(8......@...
   1aa18:	30b3 b4b3 f449 987d dc42 b4db 6a49 9860     .0..I.}.B...Ij`.
   1aa28:	9368 b504 f043 9842 561e b52d 863d 9825     h...C.B..V-.=.%.
   1aa38:	245e b556 2c3b 9808 fe22 b57e e242 97ea     ^$V.;,..".~.B...
   1aa48:	e362 b5a7 a855 97cd d41a b5d0 7e7a 97b0     b...U.......z~..
   1aa58:	d043 b5f9 64b5 9793 d7d6 b622 5b0a 9776     C....d...."..[v.
   1aa68:	eacd b64b 617f 9759 0921 b675 7817 973c     ..K..aY.!.u..x<.
   1aa78:	32cd b69e 9ed7 971f 67ca b6c7 d5c3 9702     .2.......g......
   1aa88:	a812 b6f0 1ce0 96e6 f39e b719 7432 96c9     ............2t..
   1aa98:	4a67 b743 dbbe 96ac ac69 b76c 5388 9690     gJC.....i.l..S..
   1aaa8:	199b b796 db94 9673 91f8 b7bf 73e7 9657     ......s......sW.
   1aab8:	157a b7e9 1c86 963b a41a b812 d574 961e     z.....;.....t...
   1aac8:	3dd1 b83c 9eb6 9602 e299 b865 7850 95e6     .=<.......e.Px..
   1aad8:	926d b88f 6247 95ca 4d44 b8b9 5c9f 95ae     m...Gb..DM...\..
   1aae8:	1319 b8e3 675c 9592 e3e6 b90c 8283 9576     ....\g........v.
   1aaf8:	bfa4 b936 ae17 955a a64c b960 ea1e 953e     ..6...Z.L.`...>.
   1ab08:	97d8 b98a 369c 9523 9442 b9b4 9394 9507     .....6#.B.......
   1ab18:	9b83 b9de 010b 94ec ad95 ba08 7f05 94d0     ................
   1ab28:	ca71 ba32 0d87 94b5 f210 ba5c ac95 9499     q.2.......\.....
   1ab38:	246d ba87 5c33 947e 6180 bab1 1c65 9463     m$..3\~..a..e.c.
   1ab48:	a943 badb ed2f 9447 fbb0 bb05 ce96 942c     C.../.G.......,.
   1ab58:	58c0 bb30 c09e 9411 c06d bb5a c34a 93f6     .X0.....m.Z.J...
   1ab68:	32b0 bb85 d6a0 93db af82 bbaf faa3 93c0     .2..............
   1ab78:	36dd bbda 2f57 93a6 c8ba bc04 74c1 938b     .6..W/.......t..
   1ab88:	6513 bc2f cae4 9370 0be2 bc5a 31c5 9356     .e/...p...Z..1V.
   1ab98:	bd1f bc84 a968 933b 78c4 bcaf 31d1 9321     ....h.;..x...1!.
   1aba8:	3ecb bcda cb04 9306 0f2c bd05 7505 92ec     .>......,....u..
   1abb8:	e9e2 bd2f 2fd9 92d2 cee5 bd5a fb82 92b7     ../../....Z.....
   1abc8:	be30 bd85 d806 929d b7bb bdb0 c568 9283     0...........h...
   1abd8:	bb7f bddb c3ac 9269 c977 be06 d2d7 924f     ......i.w.....O.
   1abe8:	e19b be31 f2ec 9235 03e6 be5d 23ef 921c     ..1...5...]..#..
   1abf8:	304f be88 65e4 9202 66d1 beb3 b8d0 91e8     O0...e...f......
   1ac08:	a765 bede 1cb6 91cf f205 bf09 919a 91b5     e...............
   1ac18:	46a8 bf35 1781 919c a54a bf60 ae6d 9182     .F5.....J.`.m...
   1ac28:	0de3 bf8c 5663 9169 806c bfb7 0f67 9150     ....cVi.l...g.P.
   1ac38:	fcdf bfe2 d97d 9136 8336 c00e b4a9 911d     ....}.6.6.......
   1ac48:	1368 c03a a0ee 9104 ad70 c065 9e50 90eb     h.:.....p.e.P...
   1ac58:	5148 c091 acd4 90d2 fee7 c0bc cc7d 90b9     HQ..........}...
   1ac68:	b648 c0e8 fd4e 90a0 7764 c114 3f4d 9088     H...N...dw..M?..
   1ac78:	4233 c140 927c 906f 16b0 c16c f6df 9056     3B@.|.o...l...V.
   1ac88:	f4d4 c197 6c7b 903e dc97 c1c3 f352 9025     ....{l>.....R.%.
   1ac98:	cdf3 c1ef 8b69 900d c8e1 c21b 34c4 8ff5     ....i........4..
   1aca8:	cd5a c247 ef66 8fdc db58 c273 bb53 8fc4     Z.G.f...X.s.S...
   1acb8:	f2d4 c29f 988f 8fac 13c7 c2cc 871d 8f94     ................
   1acc8:	3e2a c2f8 8701 8f7c 71f7 c324 9840 8f64     *>....|..q$.@.d.
   1acd8:	af26 c350 badb 8f4c f5b0 c37c eed8 8f34     &.P...L...|...4.
   1ace8:	4590 c3a9 343a 8f1d 9ebe c3d5 8b04 8f05     .E..:4..........
   1acf8:	0133 c402 f33b 8eed 6ce8 c42e 6ce1 8ed6     3...;....l...l..
   1ad08:	e1d7 c45a f7fb 8ebe 5ff9 c487 948c 8ea7     ..Z......_......
   1ad18:	e746 c4b3 4298 8e90 77b8 c4e0 0222 8e79     F....B...w..".y.
   1ad28:	1149 c50d d32e 8e61 b3f1 c539 b5bf 8e4a     I.....a...9...J.
   1ad38:	5fa9 c566 a9da 8e33 146a c593 af80 8e1c     ._f...3.j.......
   1ad48:	d22e c5bf c6b7 8e05 98ee c5ec ef82 8dee     ................
   1ad58:	68a2 c619 29e4 8dd8 4144 c646 75e0 8dc1     .h...)..DAF..u..
   1ad68:	22ce c673 d37b 8daa 0d37 c6a0 42b8 8d94     ."s.{...7....B..
   1ad78:	0079 c6cd c399 8d7d fc8d c6f9 5623 8d67     y.....}.....#Vg.
   1ad88:	016d c727 fa59 8d50 0f11 c754 b03f 8d3a     m.'.Y.P...T.?.:.
   1ad98:	2572 c781 77d8 8d24 4489 c7ae 5127 8d0e     r%...w$..D..'Q..
   1ada8:	6c50 c7db 3c30 8cf8 9cbf c808 38f6 8ce2     Pl..0<.......8..
   1adb8:	d5d0 c835 477d 8ccc 177b c863 67c8 8cb6     ..5.}G..{.c..g..
   1adc8:	61ba c890 99da 8ca0 b485 c8bd ddb7 8c8a     .a..............
   1add8:	0fd6 c8eb 3362 8c75 73a5 c918 9ade 8c5f     ....b3u..s...._.
   1ade8:	dfec c945 142f 8c4a 54a4 c973 9f58 8c34     ..E./.J..Ts.X.4.
   1adf8:	d1c5 c9a0 3c5d 8c1f 5748 c9ce eb40 8c09     ....]<..HW..@...
   1ae08:	e527 c9fb ac05 8bf4 7b5a ca29 7eb0 8bdf     '.......Z{)..~..
   1ae18:	19db ca57 6343 8bca c0a3 ca84 59c1 8bb5     ..W.Cc.......Y..
   1ae28:	6fa9 cab2 622f 8ba0 26e8 cae0 7c8f 8b8b     .o../b...&...|..
   1ae38:	e658 cb0d a8e4 8b76 adf3 cb3b e733 8b61     X.....v...;.3.a.
   1ae48:	7db0 cb69 377c 8b4d 558a cb97 99c6 8b38     .}i.|7M..U....8.
   1ae58:	3579 cbc5 0e11 8b24 1d75 cbf3 9462 8b0f     y5....$.u...b...
   1ae68:	0d79 cc21 2cbb 8afb 057c cc4f d720 8ae6     y.!..,..|.O. ...
   1ae78:	0578 cc7d 9394 8ad2 0d65 ccab 6219 8abe     x.}.....e....b..
   1ae88:	1d3d ccd9 42b4 8aaa 34f9 cd07 3567 8a96     =....B...4..g5..
   1ae98:	5491 cd35 3a36 8a82 7bfe cd63 5123 8a6e     .T5.6:...{c.#Qn.
   1aea8:	ab39 cd91 7a31 8a5a e23a cdbf b564 8a46     9...1zZ.:...d.F.
   1aeb8:	20fc cdee 02be 8a33 6777 ce1c 6243 8a1f     . ....3.wg..Cb..
   1aec8:	b5a2 ce4a d3f5 8a0b 0b79 ce79 57d8 89f8     ..J.....y.y..W..
   1aed8:	68f2 cea7 edef 89e4 ce08 ced5 963c 89d1     .h..........<...
   1aee8:	3ab3 cf04 50c3 89be aeeb cf32 1d87 89ab     .:...P....2.....
   1aef8:	2aaa cf61 fc8a 8997 ade9 cf8f edcf 8984     .*a.............
   1af08:	389f cfbe f15a 8971 cac7 cfec 072e 895f     .8..Z.q......._.
   1af18:	6459 d01b 2f4c 894c 054e d04a 69b9 8939     Yd..L/L.N.J..i9.
   1af28:	ad9e d078 b677 8926 5d42 d0a7 1589 8914     ..x.w.&.B]......
   1af38:	1434 d0d6 86f2 8901 d26b d104 0ab4 88ef     4.......k.......
   1af48:	97e2 d133 a0d3 88dc 6490 d162 4951 88ca     ..3......db.QI..
   1af58:	386e d191 0432 88b8 1375 d1c0 d177 88a5     n8..2...u...w...
   1af68:	f59e d1ee b125 8893 dee2 d21d a33d 8881     ....%.......=...
   1af78:	cf39 d24c a7c2 886f c69c d27b beb8 885d     9.L...o...{...].
   1af88:	c504 d2aa e821 884b ca6a d2d9 23ff 883a     ....!.K.j....#:.
   1af98:	d6c7 d308 7256 8828 ea12 d337 d327 8816     ....Vr(...7.'...
   1afa8:	0446 d367 4677 8805 255a d396 cc48 87f3     F.g.wF..Z%..H...
   1afb8:	4d47 d3c5 649b 87e2 7c06 d3f4 0f75 87d1     GM...d...|..u...
   1afc8:	b191 d423 ccd7 87bf eddf d452 9cc5 87ae     ..#.......R.....
   1afd8:	30e9 d482 7f41 879d 7aa8 d4b1 744d 878c     .0..A....z..Mt..
   1afe8:	cb15 d4e0 7bec 877b 2228 d510 9621 876a     .....{{.("..!.j.
   1aff8:	7fda d53f c2ef 8759 e424 d56e 0258 8749     ..?...Y.$.n.X.I.
   1b008:	4eff d59e 545e 8738 c062 d5cd b905 8727     .N..^T8.b.....'.
   1b018:	3848 d5fd 304e 8717 b6a8 d62c ba3d 8706     H8..N0....,.=...
   1b028:	3b7b d65c 56d3 86f6 c6ba d68b 0614 86e6     {;\..V..........
   1b038:	585e d6bb c802 86d5 f05f d6ea 9c9f 86c5     ^X......_.......
   1b048:	8eb5 d71a 83ee 86b5 335b d74a 7df2 86a5     ........[3J..}..
   1b058:	de47 d779 8aac 8695 8f73 d7a9 aa20 8685     G.y.....s... ...
   1b068:	46d8 d7d9 dc4f 8675 046e d809 213c 8666     .F..O.u.n...<!f.
   1b078:	c82d d838 78eb 8656 920f d868 e35c 8646     -.8..xV...h.\.F.
   1b088:	620c d898 6092 8637 381d d8c8 f091 8627     .b...`7..8....'.
   1b098:	1439 d8f8 9359 8618 f65b d927 48ef 8609     9...Y...[.'..H..
   1b0a8:	de7a d957 1153 85fa cc90 d987 ec88 85ea     z.W.S...........
   1b0b8:	c094 d9b7 da91 85db ba7f d9e7 db70 85cc     ............p...
   1b0c8:	ba4a da17 ef28 85bd bfee da47 15b9 85af     J...(.....G.....
   1b0d8:	cb63 da77 4f28 85a0 dca1 daa7 9b76 8591     c.w.(O......v...
   1b0e8:	f3a2 dad7 faa5 8582 105e db08 6cb8 8574     ........^....lt.
   1b0f8:	32cd db38 f1b0 8565 5ae9 db68 8991 8557     .28...e..Zh...W.
   1b108:	88a8 db98 345c 8549 bc06 dbc8 f214 853a     ....\4I.......:.
   1b118:	f4f8 dbf8 c2bb 852c 3379 dc29 a652 851e     ......,.y3).R...
   1b128:	7781 dc59 9cdd 8510 c109 dc89 a65c 8502     .wY.........\...
   1b138:	1008 dcba c2d4 84f4 6478 dcea f244 84e6     ........xd..D...
   1b148:	be51 dd1a 34b1 84d9 1d8c dd4b 8a1b 84cb     Q....4....K.....
   1b158:	8220 dd7b f286 84bd ec08 ddab 6df2 84b0      .{..........m..
   1b168:	5b3b dddc fc62 84a2 cfb1 de0c 9dd9 8495     ;[..b...........
   1b178:	4964 de3d 5258 8488 c84b de6d 19e1 847b     dI=.XR..K.m...{.
   1b188:	4c60 de9e f477 846d d59b dece e21a 8460     `L..w.m.......`.
   1b198:	63f4 deff e2cf 8453 f764 df2f f695 8446     .c....S.d./...F.
   1b1a8:	8fe4 df60 1d70 843a 2d6b df91 5762 842d     ..`.p.:.k-..bW-.
   1b1b8:	cff3 dfc1 a46c 8420 7773 dff2 0490 8414     ....l. .sw......
   1b1c8:	23e5 e023 77d0 8407 d541 e053 fe2e 83fa     .##..w..A.S.....
   1b1d8:	8b7f e084 97ad 83ee 4698 e0b5 444d 83e2     .........F..MD..
   1b1e8:	0685 e0e6 0412 83d6 cb3d e116 d6fc 83c9     ........=.......
   1b1f8:	94ba e147 bd0e 83bd 62f3 e178 b649 83b1     ..G......bx.I...
   1b208:	35e2 e1a9 c2b0 83a5 0d7e e1da e244 8399     .5......~...D...
   1b218:	e9c1 e20a 1507 838e caa2 e23b 5afb 8382     ..........;..Z..
   1b228:	b01b e26c b422 8376 9a23 e29d 207d 836b     ..l.".v.#...} k.
   1b238:	88b3 e2ce a00f 835f 7bc3 e2ff 32d8 8354     ......_..{...2T.
   1b248:	734d e330 d8dc 8348 6f48 e361 921b 833d     Ms0...H.Hoa...=.
   1b258:	6fad e392 5e97 8332 7474 e3c3 3e52 8327     .o...^2.tt..R>'.
   1b268:	7d96 e3f4 314e 831c 8b0a e425 378d 8311     .}..N1....%..7..
   1b278:	9ccb e456 5110 8306 b2d0 e487 7dd8 82fb     ..V..Q.......}..
   1b288:	cd11 e4b8 bde8 82f0 eb87 e4e9 1141 82e6     ............A...
   1b298:	0e2a e51b 77e5 82db 34f3 e54c f1d5 82d0     *....w...4L.....
   1b2a8:	5fda e57d 7f14 82c6 8ed8 e5ae 1fa2 82bc     ._}.............
   1b2b8:	c1e5 e5df d381 82b1 f8f9 e610 9ab3 82a7     ................
   1b2c8:	340d e642 753a 829d 7319 e673 6317 8293     .4B.:u...ss..c..
   1b2d8:	b616 e6a4 644b 8289 fcfc e6d5 78d8 827f     ....Kd.......x..
   1b2e8:	47c4 e707 a0c0 8275 9665 e738 dc04 826b     .G....u.e.8...k.
   1b2f8:	e8d8 e769 2aa6 8262 3f16 e79b 8ca7 8258     ..i..*b..?....X.
   1b308:	9917 e7cc 0208 824f f6d4 e7fd 8acc 8245     ......O.......E.
   1b318:	5844 e82f 26f3 823c bd61 e860 d67f 8232     DX/..&<.a.`...2.
   1b328:	2622 e892 9971 8229 9280 e8c3 6fcc 8220     "&..q.)......o .
   1b338:	0273 e8f5 5990 8217 75f4 e926 56be 820e     s....Y...u&..V..
   1b348:	ecfb e957 6758 8205 6781 e989 8b60 81fc     ..W.Xg...g..`...
   1b358:	e57d e9ba c2d7 81f3 66e8 e9ec 0dbe 81eb     }........f......
   1b368:	ebbb ea1d 6c16 81e2 73ee ea4f dde1 81d9     .....l...sO.....
   1b378:	ff7a ea80 6321 81d1 8e56 eab2 fbd6 81c8     z...!c..V.......
   1b388:	207a eae4 a801 81c0 b5e1 eb15 67a5 81b8     z ...........g..
   1b398:	4e81 eb47 3ac2 81b0 ea52 eb78 2159 81a8     .NG..:..R.x.Y!..
   1b3a8:	894f ebaa 1b6d 81a0 2b6e ebdc 28fd 8198     O...m...n+...(..
   1b3b8:	d0a8 ec0d 4a0c 8190 78f6 ec3f 7e9a 8188     .....J...x?..~..
   1b3c8:	244f ec71 c6a9 8180 d2ad eca2 223a 8179     O$q.........:"y.
   1b3d8:	8407 ecd4 914e 8171 3856 ed06 13e6 816a     ....N.q.V8....j.
   1b3e8:	ef91 ed37 aa04 8162 a9b3 ed69 53a8 815b     ..7...b...i..S[.
   1b3f8:	66b2 ed9b 10d4 8154 2687 edcd e188 814c     .f....T..&....L.
   1b408:	e92b edfe c5c7 8145 ae96 ee30 bd90 813e     +.....E...0...>.
   1b418:	76bf ee62 c8e6 8137 41a0 ee94 e7c9 8130     .vb...7..A....0.
   1b428:	0f31 eec6 1a3a 812a df6a eef7 603a 8123     1...:.*.j...:`#.
   1b438:	b243 ef29 b9ca 811c 87b5 ef5b 26ec 8116     C.).......[..&..
   1b448:	5fb8 ef8d a7a0 810f 3a45 efbf 3be8 8109     ._......E:...;..
   1b458:	1753 eff1 e3c4 8102 f6da f022 9f35 80fc     S.........".5...
   1b468:	d8d5 f054 6e3c 80f6 bd39 f086 50db 80f0     ..T.<n..9....P..
   1b478:	a401 f0b8 4712 80ea 8d24 f0ea 50e2 80e4     .....G..$....P..
   1b488:	789a f11c 6e4c 80de 665c f14e 9f51 80d8     .x..Ln..\fN.Q...
   1b498:	5662 f180 e3f2 80d2 48a5 f1b2 3c2f 80cd     bV.......H../<..
   1b4a8:	3d1c f1e4 a80a 80c7 33c0 f216 2784 80c2     .=.......3...'..
   1b4b8:	2c8a f248 ba9d 80bc 2771 f27a 6156 80b7     .,H.....q'z.Va..
   1b4c8:	246e f2ac 1baf 80b2 2379 f2de e9ab 80ac     n$......y#......
   1b4d8:	248a f310 cb49 80a7 279b f342 c08b 80a2     .$..I....'B.....
   1b4e8:	2ca2 f374 c971 809d 3398 f3a6 e5fb 8098     .,t.q....3......
   1b4f8:	3c77 f3d8 162c 8094 4735 f40a 5a02 808f     w<..,...5G...Z..
   1b508:	53cb f43c b180 808a 6231 f46e 1ca6 8086     .S<.....1bn.....
   1b518:	7261 f4a0 9b74 8081 8451 f4d2 2dec 807d     ar..t...Q....-}.
   1b528:	97fb f504 d40d 8078 ad56 f536 8dd9 8074     ......x.V.6...t.
   1b538:	c45b f568 5b50 8070 dd02 f59a 3c74 806c     [.h.P[p.....t<l.
   1b548:	f743 f5cc 3143 8068 1318 f5ff 39c0 8064     C...C1h......9d.
   1b558:	3077 f631 55eb 8060 4f59 f663 85c4 805c     w01..U`.YOc...\.
   1b568:	6fb7 f695 c94c 8058 9188 f6c7 2084 8055     .o..L.X...... U.
   1b578:	b4c6 f6f9 8b6b 8051 d967 f72b 0a04 804e     ....k.Q.g.+...N.
   1b588:	ff66 f75d 9c4d 804a 26b9 f790 4248 8047     f.].M.J..&..HBG.
   1b598:	4f59 f7c2 fbf6 8043 793e f7f4 c956 8040     YO....C.>y..V.@.
   1b5a8:	a462 f826 aa6a 803d d0bb f858 9f31 803a     b.&.j.=...X.1.:.
   1b5b8:	fe42 f88a a7ac 8037 2cef f8bd c3dd 8034     B.....7..,....4.
   1b5c8:	5cbb f8ef f3c2 8031 8d9e f921 375d 802f     .\....1...!.]7/.
   1b5d8:	bf91 f953 8ead 802c f28a f985 f9b4 8029     ..S...,.......).
   1b5e8:	2684 f9b8 7872 8027 5b75 f9ea 0ae7 8025     .&..rx'.u[....%.
   1b5f8:	9157 fa1c b114 8022 c821 fa4e 6af8 8020     W.....".!.N..j .
   1b608:	ffcb fa80 3895 801e 384f fab3 19ea 801c     .....8..O8......
   1b618:	71a4 fae5 0ef8 801a abc2 fb17 17bf 8018     .q..............
   1b628:	e6a3 fb49 3440 8016 223d fb7c 647b 8014     ..I.@4..="|.{d..
   1b638:	5e89 fbae a86f 8012 9b80 fbe0 001f 8011     .^..o...........
   1b648:	d91a fc12 6b88 800f 174e fc45 eaad 800d     .....k..N.E.....
   1b658:	5616 fc77 7d8c 800c 956a fca9 2427 800b     .Vw..}..j...'$..
   1b668:	d541 fcdb de7e 8009 1594 fd0e ac90 8008     A...~...........
   1b678:	565c fd40 8e5e 8007 9790 fd72 83e8 8006     \V@.^.....r.....
   1b688:	d929 fda4 8d2f 8005 1b1e fdd7 aa32 8004     ).../.......2...
   1b698:	5d69 fe09 daf1 8003 a002 fe3b 1f6d 8003     i]........;.m...
   1b6a8:	e2e0 fe6d 77a6 8002 25fd fea0 e39b 8001     ..m..w...%......
   1b6b8:	694f fed2 634e 8001 acd0 ff04 f6bd 8000     Oi..Nc..........
   1b6c8:	f078 ff36 9dea 8000 343f ff69 58d4 8000     x.6.....?4i..X..
   1b6d8:	781d ff9b 277a 8000 bc0b ffcd 09df 8000     .x..z'..........

0001b6e8 <twiddleCoef>:
   1b6e8:	0000 3f80 0000 0000 ffec 3f7f 0fd5 3ac9     ...?.......?...:
   1b6f8:	ffb1 3f7f 0fc6 3b49 ff4e 3f7f cbc1 3b96     ...?..I;N..?...;
   1b708:	fec4 3f7f 0f88 3bc9 fe13 3f7f 5330 3bfb     ...?...;...?0S.;
   1b718:	fd39 3f7f cb58 3c16 fc39 3f7f ed02 3c2f     9..?X..<9..?../<
   1b728:	fb11 3f7f 0e90 3c49 f9c1 3f7f 2fff 3c62     ...?..I<...?./b<
   1b738:	f84a 3f7f 514b 3c7b f6ac 3f7f 3938 3c8a     J..?KQ{<...?89.<
   1b748:	f4e6 3f7f c9b6 3c96 f2f8 3f7f 5a1c 3ca3     ...?...<...?.Z.<
   1b758:	f0e3 3f7f ea69 3caf eea7 3f7f 7a9b 3cbc     ...?i..<...?.z.<
   1b768:	ec43 3f7f 0ab0 3cc9 e9b8 3f7f 9aa6 3cd5     C..?...<...?...<
   1b778:	e705 3f7f 2a7a 3ce2 e42b 3f7f ba2c 3cee     ...?z*.<+..?,..<
   1b788:	e129 3f7f 49ba 3cfb de00 3f7f ec90 3d03     )..?.I.<...?...=
   1b798:	daaf 3f7f 342f 3d0a d737 3f7f 7bb8 3d10     ...?/4.=7..?.{.=
   1b7a8:	d397 3f7f c32c 3d16 cfd1 3f7f 0a88 3d1d     ...?,..=...?...=
   1b7b8:	cbe2 3f7f 51cb 3d23 c7cc 3f7f 98f6 3d29     ...?.Q#=...?..)=
   1b7c8:	c38f 3f7f e007 3d2f bf2a 3f7f 26fc 3d36     ...?../=*..?.&6=
   1b7d8:	ba9e 3f7f 6dd5 3d3c b5ea 3f7f b491 3d42     ...?.m<=...?..B=
   1b7e8:	b10f 3f7f fb30 3d48 ac0d 3f7f 41af 3d4f     ...?0.H=...?.AO=
   1b7f8:	a6e3 3f7f 880e 3d55 a191 3f7f ce4c 3d5b     ...?..U=...?L.[=
   1b808:	9c18 3f7f 1469 3d62 9678 3f7f 5a62 3d68     ...?i.b=x..?bZh=
   1b818:	90b1 3f7f a038 3d6e 8ac2 3f7f e5e9 3d74     ...?8.n=...?..t=
   1b828:	84ab 3f7f 2b74 3d7b 7e6d 3f7f b86c 3d80     ...?t+{=m~.?l..=
   1b838:	7808 3f7f db0a 3d83 717b 3f7f fd94 3d86     .x.?...={q.?...=
   1b848:	6ac7 3f7f 200a 3d8a 63ec 3f7f 426a 3d8d     .j.?. .=.c.?jB.=
   1b858:	5ce9 3f7f 64b4 3d90 55bf 3f7f 86e7 3d93     .\.?.d.=.U.?...=
   1b868:	4e6d 3f7f a905 3d96 46f4 3f7f cb0a 3d99     mN.?...=.F.?...=
   1b878:	3f54 3f7f ecf9 3d9c 378c 3f7f 0ecf 3da0     T?.?...=.7.?...=
   1b888:	2f9d 3f7f 308c 3da3 2787 3f7f 5230 3da6     ./.?.0.=.'.?0R.=
   1b898:	1f49 3f7f 73ba 3da9 16e4 3f7f 952b 3dac     I..?.s.=...?+..=
   1b8a8:	0e58 3f7f b680 3daf 05a4 3f7f d7bb 3db2     X..?...=...?...=
   1b8b8:	fcc9 3f7e f8da 3db5 f3c7 3f7e 19dd 3db9     ..~?...=..~?...=
   1b8c8:	ea9d 3f7e 3ac3 3dbc e14c 3f7e 5b8d 3dbf     ..~?.:.=L.~?.[.=
   1b8d8:	d7d4 3f7e 7c39 3dc2 ce34 3f7e 9cc6 3dc5     ..~?9|.=4.~?...=
   1b8e8:	c46d 3f7e bd36 3dc8 ba7f 3f7e dd86 3dcb     m.~?6..=..~?...=
   1b8f8:	b069 3f7e fdb7 3dce a62d 3f7e 1dc8 3dd2     i.~?...=-.~?...=
   1b908:	9bc9 3f7e 3db9 3dd5 913d 3f7e 5d89 3dd8     ..~?.=.==.~?.].=
   1b918:	868b 3f7e 7d37 3ddb 7bb1 3f7e 9cc4 3dde     ..~?7}.=.{~?...=
   1b928:	70b0 3f7e bc2e 3de1 6588 3f7e db76 3de4     .p~?...=.e~?v..=
   1b938:	5a38 3f7e fa9a 3de7 4ec1 3f7e 199a 3deb     8Z~?...=.N~?...=
   1b948:	4323 3f7e 3876 3dee 375e 3f7e 572e 3df1     #C~?v8.=^7~?.W.=
   1b958:	2b72 3f7e 75c0 3df4 1f5e 3f7e 942c 3df7     r+~?.u.=^.~?,..=
   1b968:	1324 3f7e b273 3dfa 06c2 3f7e d092 3dfd     $.~?s..=..~?...=
   1b978:	fa38 3f7d 7745 3e00 ed88 3f7d 062e 3e02     8.}?Ew.>..}?...>
   1b988:	e0b1 3f7d 9502 3e03 d3b2 3f7d 23c2 3e05     ..}?...>..}?.#.>
   1b998:	c68c 3f7d b26e 3e06 b940 3f7d 4105 3e08     ..}?n..>@.}?.A.>
   1b9a8:	abcc 3f7d cf86 3e09 9e30 3f7d 5df3 3e0b     ..}?...>0.}?.].>
   1b9b8:	906e 3f7d ec4a 3e0c 8285 3f7d 7a8b 3e0e     n.}?J..>..}?.z.>
   1b9c8:	7474 3f7d 08b7 3e10 663d 3f7d 96cc 3e11     tt}?...>=f}?...>
   1b9d8:	57de 3f7d 24ca 3e13 4959 3f7d b2b2 3e14     .W}?.$.>YI}?...>
   1b9e8:	3aac 3f7d 4083 3e16 2bd8 3f7d ce3d 3e17     .:}?.@.>.+}?=..>
   1b9f8:	1cdd 3f7d 5be0 3e19 0dbc 3f7d e96b 3e1a     ..}?.[.>..}?k..>
   1ba08:	fe73 3f7c 76de 3e1c ef03 3f7c 0438 3e1e     s.|?.v.>..|?8..>
   1ba18:	df6c 3f7c 917b 3e1f cfae 3f7c 1ea5 3e21     l.|?{..>..|?..!>
   1ba28:	bfc9 3f7c abb6 3e22 afbd 3f7c 38ad 3e24     ..|?..">..|?.8$>
   1ba38:	9f8a 3f7c c58c 3e25 8f31 3f7c 5251 3e27     ..|?..%>1.|?QR'>
   1ba48:	7eb0 3f7c defc 3e28 6e08 3f7c 6b8d 3e2a     .~|?..(>.n|?.k*>
   1ba58:	5d3a 3f7c f804 3e2b 4c44 3f7c 8461 3e2d     :]|?..+>DL|?a.->
   1ba68:	3b28 3f7c 10a2 3e2f 29e5 3f7c 9cc9 3e30     (;|?../>.)|?..0>
   1ba78:	187a 3f7c 28d4 3e32 06e9 3f7c b4c4 3e33     z.|?.(2>..|?..3>
   1ba88:	f531 3f7b 4098 3e35 e353 3f7b cc50 3e36     1.{?.@5>S.{?P.6>
   1ba98:	d14d 3f7b 57ec 3e38 bf20 3f7b e36c 3e39     M.{?.W8> .{?l.9>
   1baa8:	accd 3f7b 6ecf 3e3b 9a53 3f7b fa15 3e3c     ..{?.n;>S.{?..<>
   1bab8:	87b2 3f7b 853e 3e3e 74ea 3f7b 1049 3e40     ..{?>.>>.t{?I.@>
   1bac8:	61fc 3f7b 9b37 3e41 4ee7 3f7b 2607 3e43     .a{?7.A>.N{?.&C>
   1bad8:	3bab 3f7b b0b9 3e44 2848 3f7b 3b4d 3e46     .;{?..D>H({?M;F>
   1bae8:	14be 3f7b c5c2 3e47 010e 3f7b 5018 3e49     ..{?..G>..{?.PI>
   1baf8:	ed37 3f7a da4f 3e4a d93a 3f7a 6467 3e4c     7.z?O.J>:.z?gdL>
   1bb08:	c516 3f7a ee60 3e4d b0cb 3f7a 7838 3e4f     ..z?`.M>..z?8xO>
   1bb18:	9c59 3f7a 01f1 3e51 87c1 3f7a 8b89 3e52     Y.z?..Q>..z?..R>
   1bb28:	7302 3f7a 1501 3e54 5e1c 3f7a 9e58 3e55     .sz?..T>.^z?X.U>
   1bb38:	4910 3f7a 278f 3e57 33dd 3f7a b0a4 3e58     .Iz?.'W>.3z?..X>
   1bb48:	1e84 3f7a 3997 3e5a 0904 3f7a c26a 3e5b     ..z?.9Z>..z?j.[>
   1bb58:	f35e 3f79 4b1a 3e5d dd91 3f79 d3a8 3e5e     ^.y?.K]>..y?..^>
   1bb68:	c79d 3f79 5c13 3e60 b183 3f79 e45c 3e61     ..y?.\`>..y?\.a>
   1bb78:	9b43 3f79 6c83 3e63 84dc 3f79 f486 3e64     C.y?.lc>..y?..d>
   1bb88:	6e4e 3f79 7c66 3e66 579a 3f79 0422 3e68     Nny?f|f>.Wy?".h>
   1bb98:	40c0 3f79 8bba 3e69 29bf 3f79 132f 3e6b     .@y?..i>.)y?/.k>
   1bba8:	1298 3f79 9a7f 3e6c fb4a 3f78 21ab 3e6e     ..y?..l>J.x?.!n>
   1bbb8:	e3d6 3f78 a8b2 3e6f cc3b 3f78 2f94 3e71     ..x?..o>;.x?./q>
   1bbc8:	b47b 3f78 b651 3e72 9c93 3f78 3ce8 3e74     {.x?Q.r>..x?.<t>
   1bbd8:	8486 3f78 c35a 3e75 6c52 3f78 49a6 3e77     ..x?Z.u>Rlx?.Iw>
   1bbe8:	53f8 3f78 cfcc 3e78 3b77 3f78 55cb 3e7a     .Sx?..x>w;x?.Uz>
   1bbf8:	22d1 3f78 dba4 3e7b 0a04 3f78 6156 3e7d     ."x?..{>..x?Va}>
   1bc08:	f110 3f77 e6e1 3e7e d7f7 3f77 3622 3e80     ..w?..~>..w?"6.>
   1bc18:	beb7 3f77 f8c0 3e80 a551 3f77 bb4a 3e81     ..w?...>Q.w?J..>
   1bc28:	8bc5 3f77 7dc0 3e82 7213 3f77 4022 3e83     ..w?.}.>.rw?"@.>
   1bc38:	583a 3f77 0270 3e84 3e3c 3f77 c4aa 3e84     :Xw?p..><>w?...>
   1bc48:	2417 3f77 86ce 3e85 09cc 3f77 48df 3e86     .$w?...>..w?.H.>
   1bc58:	ef5b 3f76 0ada 3e87 d4c4 3f76 ccc1 3e87     [.v?...>..v?...>
   1bc68:	ba07 3f76 8e93 3e88 9f24 3f76 5050 3e89     ..v?...>$.v?PP.>
   1bc78:	841b 3f76 11f7 3e8a 68ec 3f76 d38a 3e8a     ..v?...>.hv?...>
   1bc88:	4d97 3f76 9507 3e8b 321b 3f76 566e 3e8c     .Mv?...>.2v?nV.>
   1bc98:	167a 3f76 17c0 3e8d fab3 3f75 d8fc 3e8d     z.v?...>..u?...>
   1bca8:	dec6 3f75 9a22 3e8e c2b3 3f75 5b32 3e8f     ..u?"..>..u?2[.>
   1bcb8:	a67b 3f75 1c2c 3e90 8a1c 3f75 dd10 3e90     {.u?,..>..u?...>
   1bcc8:	6d97 3f75 9ddd 3e91 50ed 3f75 5e94 3e92     .mu?...>.Pu?.^.>
   1bcd8:	341d 3f75 1f35 3e93 1727 3f75 dfbf 3e93     .4u?5..>'.u?...>
   1bce8:	fa0b 3f74 a031 3e94 dcc9 3f74 608d 3e95     ..t?1..>..t?.`.>
   1bcf8:	bf62 3f74 20d2 3e96 a1d5 3f74 e100 3e96     b.t?. .>..t?...>
   1bd08:	8422 3f74 a117 3e97 6649 3f74 6116 3e98     ".t?...>Ift?.a.>
   1bd18:	484b 3f74 20fe 3e99 2a27 3f74 e0ce 3e99     KHt?. .>'*t?...>
   1bd28:	0bdd 3f74 a086 3e9a ed6e 3f73 6027 3e9b     ..t?...>n.s?'`.>
   1bd38:	ced9 3f73 1faf 3e9c b01f 3f73 df20 3e9c     ..s?...>..s? ..>
   1bd48:	913f 3f73 9e78 3e9d 7239 3f73 5db8 3e9e     ?.s?x..>9rs?.].>
   1bd58:	530e 3f73 1cdf 3e9f 33be 3f73 dbee 3e9f     .Ss?...>.3s?...>
   1bd68:	1447 3f73 9ae5 3ea0 f4ac 3f72 59c2 3ea1     G.s?...>..r?.Y.>
   1bd78:	d4eb 3f72 1887 3ea2 b504 3f72 d733 3ea2     ..r?...>..r?3..>
   1bd88:	94f8 3f72 95c5 3ea3 74c7 3f72 543f 3ea4     ..r?...>.tr??T.>
   1bd98:	5470 3f72 129f 3ea5 33f4 3f72 d0e5 3ea5     pTr?...>.3r?...>
   1bda8:	1352 3f72 8f12 3ea6 f28c 3f71 4d25 3ea7     R.r?...>..q?%M.>
   1bdb8:	d19f 3f71 0b1f 3ea8 b08e 3f71 c8fe 3ea8     ..q?...>..q?...>
   1bdc8:	8f57 3f71 86c4 3ea9 6dfb 3f71 446f 3eaa     W.q?...>.mq?oD.>
   1bdd8:	4c7a 3f71 0201 3eab 2ad4 3f71 bf77 3eab     zLq?...>.*q?w..>
   1bde8:	0908 3f71 7cd4 3eac e717 3f70 3a15 3ead     ..q?.|.>..p?.:.>
   1bdf8:	c501 3f70 f73c 3ead a2c6 3f70 b449 3eae     ..p?<..>..p?I..>
   1be08:	8066 3f70 713a 3eaf 5de1 3f70 2e10 3eb0     f.p?:q.>.]p?...>
   1be18:	3b37 3f70 eacb 3eb0 1867 3f70 a76b 3eb1     7;p?...>g.p?k..>
   1be28:	f573 3f6f 63ef 3eb2 d25a 3f6f 2058 3eb3     s.o?.c.>Z.o?X .>
   1be38:	af1b 3f6f dca5 3eb3 8bb8 3f6f 98d6 3eb4     ..o?...>..o?...>
   1be48:	6830 3f6f 54ec 3eb5 4483 3f6f 10e6 3eb6     0ho?.T.>.Do?...>
   1be58:	20b0 3f6f ccc3 3eb6 fcba 3f6e 8884 3eb7     . o?...>..n?...>
   1be68:	d89e 3f6e 442a 3eb8 b45d 3f6e ffb2 3eb8     ..n?*D.>].n?...>
   1be78:	8ff8 3f6e bb1e 3eb9 6b6d 3f6e 766e 3eba     ..n?...>mkn?nv.>
   1be88:	46be 3f6e 31a0 3ebb 21eb 3f6e ecb6 3ebb     .Fn?.1.>.!n?...>
   1be98:	fcf2 3f6d a7af 3ebc d7d5 3f6d 628b 3ebd     ..m?...>..m?.b.>
   1bea8:	b293 3f6d 1d4a 3ebe 8d2d 3f6d d7eb 3ebe     ..m?J..>-.m?...>
   1beb8:	67a1 3f6d 926f 3ebf 41f2 3f6d 4cd5 3ec0     .gm?o..>.Am?.L.>
   1bec8:	1c1d 3f6d 071e 3ec1 f624 3f6c c148 3ec1     ..m?...>$.l?H..>
   1bed8:	d007 3f6c 7b55 3ec2 a9c5 3f6c 3544 3ec3     ..l?U{.>..l?D5.>
   1bee8:	835e 3f6c ef15 3ec3 5cd4 3f6c a8c8 3ec4     ^.l?...>.\l?...>
   1bef8:	3624 3f6c 625c 3ec5 0f50 3f6c 1bd2 3ec6     $6l?\b.>P.l?...>
   1bf08:	e858 3f6b d529 3ec6 c13b 3f6b 8e62 3ec7     X.k?)..>;.k?b..>
   1bf18:	99fb 3f6b 477c 3ec8 7295 3f6b 0077 3ec9     ..k?|G.>.rk?w..>
   1bf28:	4b0c 3f6b b953 3ec9 235e 3f6b 7210 3eca     .Kk?S..>^#k?.r.>
   1bf38:	fb8c 3f6a 2aae 3ecb d395 3f6a e32c 3ecb     ..j?.*.>..j?,..>
   1bf48:	ab7b 3f6a 9b8b 3ecc 833c 3f6a 53ca 3ecd     {.j?...><.j?.S.>
   1bf58:	5ad9 3f6a 0bea 3ece 3252 3f6a c3ea 3ece     .Zj?...>R2j?...>
   1bf68:	09a7 3f6a 7bca 3ecf e0d7 3f69 338a 3ed0     ..j?.{.>..i?.3.>
   1bf78:	b7e4 3f69 eb2a 3ed0 8ecc 3f69 a2aa 3ed1     ..i?*..>..i?...>
   1bf88:	6591 3f69 5a09 3ed2 3c32 3f69 1148 3ed3     .ei?.Z.>2<i?H..>
   1bf98:	12ae 3f69 c867 3ed3 e907 3f68 7f64 3ed4     ..i?g..>..h?d..>
   1bfa8:	bf3c 3f68 3641 3ed5 954c 3f68 ecfd 3ed5     <.h?A6.>L.h?...>
   1bfb8:	6b39 3f68 a399 3ed6 4103 3f68 5a13 3ed7     9kh?...>.Ah?.Z.>
   1bfc8:	16a8 3f68 106b 3ed8 ec29 3f67 c6a3 3ed8     ..h?k..>).g?...>
   1bfd8:	c187 3f67 7cb9 3ed9 96c1 3f67 32ad 3eda     ..g?.|.>..g?.2.>
   1bfe8:	6bd8 3f67 e880 3eda 40ca 3f67 9e31 3edb     .kg?...>.@g?1..>
   1bff8:	1599 3f67 53c1 3edc ea45 3f66 092e 3edd     ..g?.S.>E.f?...>
   1c008:	becc 3f66 be79 3edd 9330 3f66 73a2 3ede     ..f?y..>0.f?.s.>
   1c018:	6771 3f66 28a9 3edf 3b8e 3f66 dd8d 3edf     qgf?.(.>.;f?...>
   1c028:	0f88 3f66 924f 3ee0 e35e 3f65 46ee 3ee1     ..f?O..>^.e?.F.>
   1c038:	b710 3f65 fb6a 3ee1 8aa0 3f65 afc4 3ee2     ..e?j..>..e?...>
   1c048:	5e0b 3f65 63fa 3ee3 3154 3f65 180e 3ee4     .^e?.c.>T1e?...>
   1c058:	0479 3f65 cbfe 3ee4 d77b 3f64 7fcb 3ee5     y.e?...>{.d?...>
   1c068:	aa59 3f64 3375 3ee6 7d14 3f64 e6fb 3ee6     Y.d?u3.>.}d?...>
   1c078:	4fac 3f64 9a5d 3ee7 2221 3f64 4d9c 3ee8     .Od?]..>!"d?.M.>
   1c088:	f473 3f63 00b7 3ee9 c6a1 3f63 b3ae 3ee9     s.c?...>..c?...>
   1c098:	98ac 3f63 6681 3eea 6a95 3f63 1930 3eeb     ..c?.f.>.jc?0..>
   1c0a8:	3c5a 3f63 cbbb 3eeb 0dfc 3f63 7e21 3eec     Z<c?...>..c?!~.>
   1c0b8:	df7b 3f62 3063 3eed b0d7 3f62 e280 3eed     {.b?c0.>..b?...>
   1c0c8:	8210 3f62 9479 3eee 5326 3f62 464c 3eef     ..b?y..>&Sb?LF.>
   1c0d8:	241a 3f62 f7fb 3eef f4ea 3f61 a985 3ef0     .$b?...>..a?...>
   1c0e8:	c598 3f61 5aea 3ef1 9622 3f61 0c29 3ef2     ..a?.Z.>".a?)..>
   1c0f8:	668a 3f61 bd43 3ef2 36d0 3f61 6e38 3ef3     .fa?C..>.6a?8n.>
   1c108:	06f2 3f61 1f07 3ef4 d6f2 3f60 cfb1 3ef4     ..a?...>..`?...>
   1c118:	a6cf 3f60 8035 3ef5 7689 3f60 3093 3ef6     ..`?5..>.v`?.0.>
   1c128:	4621 3f60 e0cb 3ef6 1596 3f60 90dc 3ef7     !F`?...>..`?...>
   1c138:	e4e9 3f5f 40c8 3ef8 b419 3f5f f08e 3ef8     .._?.@.>.._?...>
   1c148:	8327 3f5f a02d 3ef9 5212 3f5f 4fa5 3efa     '._?-..>.R_?.O.>
   1c158:	20db 3f5f fef7 3efa ef81 3f5e ae22 3efb     . _?...>..^?"..>
   1c168:	be05 3f5e 5d27 3efc 8c67 3f5e 0c04 3efd     ..^?'].>g.^?...>
   1c178:	5aa6 3f5e babb 3efd 28c3 3f5e 694a 3efe     .Z^?...>.(^?Ji.>
   1c188:	f6be 3f5d 17b2 3eff c497 3f5d c5f3 3eff     ..]?...>..]?...>
   1c198:	924d 3f5d 3a06 3f00 5fe1 3f5d 90ff 3f00     M.]?.:.?._]?...?
   1c1a8:	2d53 3f5d e7e4 3f00 faa3 3f5c 3eb5 3f01     S-]?...?..\?.>.?
   1c1b8:	c7d1 3f5c 9573 3f01 94dd 3f5c ec1c 3f01     ..\?s..?..\?...?
   1c1c8:	61c7 3f5c 42b1 3f02 2e8e 3f5c 9932 3f02     .a\?.B.?..\?2..?
   1c1d8:	fb34 3f5b ef9f 3f02 c7b8 3f5b 45f8 3f03     4.[?...?..[?.E.?
   1c1e8:	941a 3f5b 9c3d 3f03 605a 3f5b f26d 3f03     ..[?=..?Z`[?m..?
   1c1f8:	2c79 3f5b 4889 3f04 f875 3f5a 9e91 3f04     y,[?.H.?u.Z?...?
   1c208:	c450 3f5a f484 3f04 9009 3f5a 4a62 3f05     P.Z?...?..Z?bJ.?
   1c218:	5ba0 3f5a a02c 3f05 2716 3f5a f5e2 3f05     .[Z?,..?.'Z?...?
   1c228:	f26a 3f59 4b82 3f06 bd9c 3f59 a10e 3f06     j.Y?.K.?..Y?...?
   1c238:	88ad 3f59 f686 3f06 539c 3f59 4be8 3f07     ..Y?...?.SY?.K.?
   1c248:	1e6a 3f59 a136 3f07 e916 3f58 f66f 3f07     j.Y?6..?..X?o..?
   1c258:	b3a1 3f58 4b92 3f08 7e0b 3f58 a0a1 3f08     ..X?.K.?.~X?...?
   1c268:	4853 3f58 f59b 3f08 1279 3f58 4a7f 3f09     SHX?...?y.X?.J.?
   1c278:	dc7f 3f57 9f4e 3f09 a663 3f57 f409 3f09     ..W?N..?c.W?...?
   1c288:	7026 3f57 48ad 3f0a 39c7 3f57 9d3d 3f0a     &pW?.H.?.9W?=..?
   1c298:	0348 3f57 f1b7 3f0a cca7 3f56 461c 3f0b     H.W?...?..V?.F.?
   1c2a8:	95e5 3f56 9a6b 3f0b 5f02 3f56 eea5 3f0b     ..V?k..?._V?...?
   1c2b8:	27fe 3f56 42c9 3f0c f0d9 3f55 96d7 3f0c     .'V?.B.?..U?...?
   1c2c8:	b993 3f55 ead0 3f0c 822c 3f55 3eb3 3f0d     ..U?...?,.U?.>.?
   1c2d8:	4aa4 3f55 9281 3f0d 12fb 3f55 e638 3f0d     .JU?...?..U?8..?
   1c2e8:	db31 3f54 39da 3f0e a347 3f54 8d65 3f0e     1.T?.9.?G.T?e..?
   1c2f8:	6b3b 3f54 e0db 3f0e 330f 3f54 343b 3f0f     ;kT?...?.3T?;4.?
   1c308:	fac3 3f53 8784 3f0f c255 3f53 dab8 3f0f     ..S?...?U.S?...?
   1c318:	89c7 3f53 2dd5 3f10 5118 3f53 80dc 3f10     ..S?.-.?.QS?...?
   1c328:	1849 3f53 d3cd 3f10 df59 3f52 26a7 3f11     I.S?...?Y.R?.&.?
   1c338:	a649 3f52 796b 3f11 6d18 3f52 cc19 3f11     I.R?ky.?.mR?...?
   1c348:	33c6 3f52 1eb0 3f12 fa54 3f51 7130 3f12     .3R?...?T.Q?0q.?
   1c358:	c0c2 3f51 c39a 3f12 8710 3f51 15ee 3f13     ..Q?...?..Q?...?
   1c368:	4d3d 3f51 682a 3f13 134a 3f51 ba50 3f13     =MQ?*h.?J.Q?P..?
   1c378:	d937 3f50 0c5f 3f14 9f03 3f50 5e58 3f14     7.P?_..?..P?X^.?
   1c388:	64af 3f50 b039 3f14 2a3b 3f50 0204 3f15     .dP?9..?;*P?...?
   1c398:	efa8 3f4f 53b7 3f15 b4f4 3f4f a554 3f15     ..O?.S.?..O?T..?
   1c3a8:	7a1f 3f4f f6d9 3f15 3f2b 3f4f 4847 3f16     .zO?...?+?O?GH.?
   1c3b8:	0417 3f4f 999f 3f16 c8e4 3f4e eade 3f16     ..O?...?..N?...?
   1c3c8:	8d90 3f4e 3c07 3f17 521c 3f4e 8d18 3f17     ..N?.<.?.RN?...?
   1c3d8:	1689 3f4e de12 3f17 dad5 3f4d 2ef5 3f18     ..N?...?..M?...?
   1c3e8:	9f02 3f4d 7fc0 3f18 6310 3f4d d073 3f18     ..M?...?.cM?s..?
   1c3f8:	26fd 3f4d 210f 3f19 eacb 3f4c 7194 3f19     .&M?.!.?..L?.q.?
   1c408:	ae79 3f4c c200 3f19 7208 3f4c 1255 3f1a     y.L?...?.rL?U..?
   1c418:	3578 3f4c 6293 3f1a f8c7 3f4b b2b8 3f1a     x5L?.b.?..K?...?
   1c428:	bbf8 3f4b 02c6 3f1b 7f09 3f4b 52bb 3f1b     ..K?...?..K?.R.?
   1c438:	41fa 3f4b a299 3f1b 04cc 3f4b f25f 3f1b     .AK?...?..K?_..?
   1c448:	c77f 3f4a 420c 3f1c 8a13 3f4a 91a2 3f1c     ..J?.B.?..J?...?
   1c458:	4c87 3f4a e11f 3f1c 0edc 3f4a 3084 3f1d     .LJ?...?..J?.0.?
   1c468:	d112 3f49 7fd1 3f1d 9329 3f49 cf06 3f1d     ..I?...?).I?...?
   1c478:	5521 3f49 1e22 3f1e 16fa 3f49 6d26 3f1e     !UI?"..?..I?&m.?
   1c488:	d8b3 3f48 bc12 3f1e 9a4e 3f48 0ae5 3f1f     ..H?...?N.H?...?
   1c498:	5bca 3f48 599f 3f1f 1d27 3f48 a841 3f1f     .[H?.Y.?'.H?A..?
   1c4a8:	de65 3f47 f6cb 3f1f 9f84 3f47 453b 3f20     e.G?...?..G?;E ?
   1c4b8:	6085 3f47 9393 3f20 2167 3f47 e1d2 3f20     .`G?.. ?g!G?.. ?
   1c4c8:	e22a 3f46 2ff9 3f21 a2ce 3f46 7e06 3f21     *.F?./!?..F?.~!?
   1c4d8:	6354 3f46 cbfb 3f21 23bb 3f46 19d7 3f22     TcF?..!?.#F?.."?
   1c4e8:	e403 3f45 6799 3f22 a42d 3f45 b543 3f22     ..E?.g"?-.E?C."?
   1c4f8:	6439 3f45 02d3 3f23 2426 3f45 504b 3f23     9dE?..#?&$E?KP#?
   1c508:	e3f5 3f44 9da9 3f23 a3a5 3f44 eaee 3f23     ..D?..#?..D?..#?
   1c518:	6337 3f44 381a 3f24 22ab 3f44 852c 3f24     7cD?.8$?."D?,.$?
   1c528:	e200 3f43 d225 3f24 a138 3f43 1f04 3f25     ..C?%.$?8.C?..%?
   1c538:	6051 3f43 6bcb 3f25 1f4c 3f43 b877 3f25     Q`C?.k%?L.C?w.%?
   1c548:	de29 3f42 050a 3f26 9ce8 3f42 5184 3f26     ).B?..&?..B?.Q&?
   1c558:	5b89 3f42 9de3 3f26 1a0b 3f42 ea2a 3f26     .[B?..&?..B?*.&?
   1c568:	d870 3f41 3656 3f27 96b7 3f41 8268 3f27     p.A?V6'?..A?h.'?
   1c578:	54e1 3f41 ce61 3f27 12ec 3f41 1a40 3f28     .TA?a.'?..A?@.(?
   1c588:	d0da 3f40 6605 3f28 8ea9 3f40 b1b0 3f28     ..@?.f(?..@?..(?
   1c598:	4c5c 3f40 fd41 3f28 09f0 3f40 48b8 3f29     \L@?A.(?..@?.H)?
   1c5a8:	c767 3f3f 9415 3f29 84c0 3f3f df57 3f29     g.??..)?..??W.)?
   1c5b8:	41fc 3f3f 2a80 3f2a ff1b 3f3e 758e 3f2a     .A??.**?..>?.u*?
   1c5c8:	bc1b 3f3e c082 3f2a 78ff 3f3e 0b5b 3f2b     ..>?..*?.x>?[.+?
   1c5d8:	35c5 3f3e 561b 3f2b f26e 3f3d a0bf 3f2b     .5>?.V+?n.=?..+?
   1c5e8:	aef9 3f3d eb4a 3f2b 6b67 3f3d 35b9 3f2c     ..=?J.+?gk=?.5,?
   1c5f8:	27b8 3f3d 800f 3f2c e3ec 3f3c ca49 3f2c     .'=?..,?..<?I.,?
   1c608:	a003 3f3c 1469 3f2d 5bfc 3f3c 5e6f 3f2d     ..<?i.-?.[<?o^-?
   1c618:	17d9 3f3c a859 3f2d d398 3f3b f229 3f2d     ..<?Y.-?..;?).-?
   1c628:	8f3b 3f3b 3bde 3f2e 4ac1 3f3b 8578 3f2e     ;.;?.;.?.J;?x..?
   1c638:	0629 3f3b cef7 3f2e c175 3f3a 185b 3f2f     ).;?...?u.:?[./?
   1c648:	7ca4 3f3a 61a5 3f2f 37b7 3f3a aad3 3f2f     .|:?.a/?.7:?../?
   1c658:	f2ac 3f39 f3e6 3f2f ad85 3f39 3cde 3f30     ..9?../?..9?.<0?
   1c668:	6842 3f39 85bb 3f30 22e1 3f39 ce7c 3f30     Bh9?..0?."9?|.0?
   1c678:	dd65 3f38 1722 3f31 97cb 3f38 5fad 3f31     e.8?".1?..8?._1?
   1c688:	5216 3f38 a81d 3f31 0c43 3f38 f071 3f31     .R8?..1?C.8?q.1?
   1c698:	c655 3f37 38aa 3f32 804a 3f37 80c7 3f32     U.7?.82?J.7?..2?
   1c6a8:	3a23 3f37 c8c9 3f32 f3df 3f36 10af 3f33     #:7?..2?..6?..3?
   1c6b8:	ad7f 3f36 587a 3f33 6704 3f36 a029 3f33     ..6?zX3?.g6?).3?
   1c6c8:	206c 3f36 e7bc 3f33 d9b8 3f35 2f34 3f34     l 6?..3?..5?4/4?
   1c6d8:	92e7 3f35 768f 3f34 4bfb 3f35 bdcf 3f34     ..5?.v4?.K5?..4?
   1c6e8:	04f3 3f35 04f3 3f35 bdcf 3f34 4bfb 3f35     ..5?..5?..4?.K5?
   1c6f8:	768f 3f34 92e7 3f35 2f34 3f34 d9b8 3f35     .v4?..5?4/4?..5?
   1c708:	e7bc 3f33 206c 3f36 a029 3f33 6704 3f36     ..3?l 6?).3?.g6?
   1c718:	587a 3f33 ad7f 3f36 10af 3f33 f3df 3f36     zX3?..6?..3?..6?
   1c728:	c8c9 3f32 3a23 3f37 80c7 3f32 804a 3f37     ..2?#:7?..2?J.7?
   1c738:	38aa 3f32 c655 3f37 f071 3f31 0c43 3f38     .82?U.7?q.1?C.8?
   1c748:	a81d 3f31 5216 3f38 5fad 3f31 97cb 3f38     ..1?.R8?._1?..8?
   1c758:	1722 3f31 dd65 3f38 ce7c 3f30 22e1 3f39     ".1?e.8?|.0?."9?
   1c768:	85bb 3f30 6842 3f39 3cde 3f30 ad85 3f39     ..0?Bh9?.<0?..9?
   1c778:	f3e6 3f2f f2ac 3f39 aad3 3f2f 37b7 3f3a     ../?..9?../?.7:?
   1c788:	61a5 3f2f 7ca4 3f3a 185b 3f2f c175 3f3a     .a/?.|:?[./?u.:?
   1c798:	cef7 3f2e 0629 3f3b 8578 3f2e 4ac1 3f3b     ...?).;?x..?.J;?
   1c7a8:	3bde 3f2e 8f3b 3f3b f229 3f2d d398 3f3b     .;.?;.;?).-?..;?
   1c7b8:	a859 3f2d 17d9 3f3c 5e6f 3f2d 5bfc 3f3c     Y.-?..<?o^-?.[<?
   1c7c8:	1469 3f2d a003 3f3c ca49 3f2c e3ec 3f3c     i.-?..<?I.,?..<?
   1c7d8:	800f 3f2c 27b8 3f3d 35b9 3f2c 6b67 3f3d     ..,?.'=?.5,?gk=?
   1c7e8:	eb4a 3f2b aef9 3f3d a0bf 3f2b f26e 3f3d     J.+?..=?..+?n.=?
   1c7f8:	561b 3f2b 35c5 3f3e 0b5b 3f2b 78ff 3f3e     .V+?.5>?[.+?.x>?
   1c808:	c082 3f2a bc1b 3f3e 758e 3f2a ff1b 3f3e     ..*?..>?.u*?..>?
   1c818:	2a80 3f2a 41fc 3f3f df57 3f29 84c0 3f3f     .**?.A??W.)?..??
   1c828:	9415 3f29 c767 3f3f 48b8 3f29 09f0 3f40     ..)?g.??.H)?..@?
   1c838:	fd41 3f28 4c5c 3f40 b1b0 3f28 8ea9 3f40     A.(?\L@?..(?..@?
   1c848:	6605 3f28 d0da 3f40 1a40 3f28 12ec 3f41     .f(?..@?@.(?..A?
   1c858:	ce61 3f27 54e1 3f41 8268 3f27 96b7 3f41     a.'?.TA?h.'?..A?
   1c868:	3656 3f27 d870 3f41 ea2a 3f26 1a0b 3f42     V6'?p.A?*.&?..B?
   1c878:	9de3 3f26 5b89 3f42 5184 3f26 9ce8 3f42     ..&?.[B?.Q&?..B?
   1c888:	050a 3f26 de29 3f42 b877 3f25 1f4c 3f43     ..&?).B?w.%?L.C?
   1c898:	6bcb 3f25 6051 3f43 1f04 3f25 a138 3f43     .k%?Q`C?..%?8.C?
   1c8a8:	d225 3f24 e200 3f43 852c 3f24 22ab 3f44     %.$?..C?,.$?."D?
   1c8b8:	381a 3f24 6337 3f44 eaee 3f23 a3a5 3f44     .8$?7cD?..#?..D?
   1c8c8:	9da9 3f23 e3f5 3f44 504b 3f23 2426 3f45     ..#?..D?KP#?&$E?
   1c8d8:	02d3 3f23 6439 3f45 b543 3f22 a42d 3f45     ..#?9dE?C."?-.E?
   1c8e8:	6799 3f22 e403 3f45 19d7 3f22 23bb 3f46     .g"?..E?.."?.#F?
   1c8f8:	cbfb 3f21 6354 3f46 7e06 3f21 a2ce 3f46     ..!?TcF?.~!?..F?
   1c908:	2ff9 3f21 e22a 3f46 e1d2 3f20 2167 3f47     ./!?*.F?.. ?g!G?
   1c918:	9393 3f20 6085 3f47 453b 3f20 9f84 3f47     .. ?.`G?;E ?..G?
   1c928:	f6cb 3f1f de65 3f47 a841 3f1f 1d27 3f48     ...?e.G?A..?'.H?
   1c938:	599f 3f1f 5bca 3f48 0ae5 3f1f 9a4e 3f48     .Y.?.[H?...?N.H?
   1c948:	bc12 3f1e d8b3 3f48 6d26 3f1e 16fa 3f49     ...?..H?&m.?..I?
   1c958:	1e22 3f1e 5521 3f49 cf06 3f1d 9329 3f49     "..?!UI?...?).I?
   1c968:	7fd1 3f1d d112 3f49 3084 3f1d 0edc 3f4a     ...?..I?.0.?..J?
   1c978:	e11f 3f1c 4c87 3f4a 91a2 3f1c 8a13 3f4a     ...?.LJ?...?..J?
   1c988:	420c 3f1c c77f 3f4a f25f 3f1b 04cc 3f4b     .B.?..J?_..?..K?
   1c998:	a299 3f1b 41fa 3f4b 52bb 3f1b 7f09 3f4b     ...?.AK?.R.?..K?
   1c9a8:	02c6 3f1b bbf8 3f4b b2b8 3f1a f8c7 3f4b     ...?..K?...?..K?
   1c9b8:	6293 3f1a 3578 3f4c 1255 3f1a 7208 3f4c     .b.?x5L?U..?.rL?
   1c9c8:	c200 3f19 ae79 3f4c 7194 3f19 eacb 3f4c     ...?y.L?.q.?..L?
   1c9d8:	210f 3f19 26fd 3f4d d073 3f18 6310 3f4d     .!.?.&M?s..?.cM?
   1c9e8:	7fc0 3f18 9f02 3f4d 2ef5 3f18 dad5 3f4d     ...?..M?...?..M?
   1c9f8:	de12 3f17 1689 3f4e 8d18 3f17 521c 3f4e     ...?..N?...?.RN?
   1ca08:	3c07 3f17 8d90 3f4e eade 3f16 c8e4 3f4e     .<.?..N?...?..N?
   1ca18:	999f 3f16 0417 3f4f 4847 3f16 3f2b 3f4f     ...?..O?GH.?+?O?
   1ca28:	f6d9 3f15 7a1f 3f4f a554 3f15 b4f4 3f4f     ...?.zO?T..?..O?
   1ca38:	53b7 3f15 efa8 3f4f 0204 3f15 2a3b 3f50     .S.?..O?...?;*P?
   1ca48:	b039 3f14 64af 3f50 5e58 3f14 9f03 3f50     9..?.dP?X^.?..P?
   1ca58:	0c5f 3f14 d937 3f50 ba50 3f13 134a 3f51     _..?7.P?P..?J.Q?
   1ca68:	682a 3f13 4d3d 3f51 15ee 3f13 8710 3f51     *h.?=MQ?...?..Q?
   1ca78:	c39a 3f12 c0c2 3f51 7130 3f12 fa54 3f51     ...?..Q?0q.?T.Q?
   1ca88:	1eb0 3f12 33c6 3f52 cc19 3f11 6d18 3f52     ...?.3R?...?.mR?
   1ca98:	796b 3f11 a649 3f52 26a7 3f11 df59 3f52     ky.?I.R?.&.?Y.R?
   1caa8:	d3cd 3f10 1849 3f53 80dc 3f10 5118 3f53     ...?I.S?...?.QS?
   1cab8:	2dd5 3f10 89c7 3f53 dab8 3f0f c255 3f53     .-.?..S?...?U.S?
   1cac8:	8784 3f0f fac3 3f53 343b 3f0f 330f 3f54     ...?..S?;4.?.3T?
   1cad8:	e0db 3f0e 6b3b 3f54 8d65 3f0e a347 3f54     ...?;kT?e..?G.T?
   1cae8:	39da 3f0e db31 3f54 e638 3f0d 12fb 3f55     .9.?1.T?8..?..U?
   1caf8:	9281 3f0d 4aa4 3f55 3eb3 3f0d 822c 3f55     ...?.JU?.>.?,.U?
   1cb08:	ead0 3f0c b993 3f55 96d7 3f0c f0d9 3f55     ...?..U?...?..U?
   1cb18:	42c9 3f0c 27fe 3f56 eea5 3f0b 5f02 3f56     .B.?.'V?...?._V?
   1cb28:	9a6b 3f0b 95e5 3f56 461c 3f0b cca7 3f56     k..?..V?.F.?..V?
   1cb38:	f1b7 3f0a 0348 3f57 9d3d 3f0a 39c7 3f57     ...?H.W?=..?.9W?
   1cb48:	48ad 3f0a 7026 3f57 f409 3f09 a663 3f57     .H.?&pW?...?c.W?
   1cb58:	9f4e 3f09 dc7f 3f57 4a7f 3f09 1279 3f58     N..?..W?.J.?y.X?
   1cb68:	f59b 3f08 4853 3f58 a0a1 3f08 7e0b 3f58     ...?SHX?...?.~X?
   1cb78:	4b92 3f08 b3a1 3f58 f66f 3f07 e916 3f58     .K.?..X?o..?..X?
   1cb88:	a136 3f07 1e6a 3f59 4be8 3f07 539c 3f59     6..?j.Y?.K.?.SY?
   1cb98:	f686 3f06 88ad 3f59 a10e 3f06 bd9c 3f59     ...?..Y?...?..Y?
   1cba8:	4b82 3f06 f26a 3f59 f5e2 3f05 2716 3f5a     .K.?j.Y?...?.'Z?
   1cbb8:	a02c 3f05 5ba0 3f5a 4a62 3f05 9009 3f5a     ,..?.[Z?bJ.?..Z?
   1cbc8:	f484 3f04 c450 3f5a 9e91 3f04 f875 3f5a     ...?P.Z?...?u.Z?
   1cbd8:	4889 3f04 2c79 3f5b f26d 3f03 605a 3f5b     .H.?y,[?m..?Z`[?
   1cbe8:	9c3d 3f03 941a 3f5b 45f8 3f03 c7b8 3f5b     =..?..[?.E.?..[?
   1cbf8:	ef9f 3f02 fb34 3f5b 9932 3f02 2e8e 3f5c     ...?4.[?2..?..\?
   1cc08:	42b1 3f02 61c7 3f5c ec1c 3f01 94dd 3f5c     .B.?.a\?...?..\?
   1cc18:	9573 3f01 c7d1 3f5c 3eb5 3f01 faa3 3f5c     s..?..\?.>.?..\?
   1cc28:	e7e4 3f00 2d53 3f5d 90ff 3f00 5fe1 3f5d     ...?S-]?...?._]?
   1cc38:	3a06 3f00 924d 3f5d c5f3 3eff c497 3f5d     .:.?M.]?...>..]?
   1cc48:	17b2 3eff f6be 3f5d 694a 3efe 28c3 3f5e     ...>..]?Ji.>.(^?
   1cc58:	babb 3efd 5aa6 3f5e 0c04 3efd 8c67 3f5e     ...>.Z^?...>g.^?
   1cc68:	5d27 3efc be05 3f5e ae22 3efb ef81 3f5e     '].>..^?"..>..^?
   1cc78:	fef7 3efa 20db 3f5f 4fa5 3efa 5212 3f5f     ...>. _?.O.>.R_?
   1cc88:	a02d 3ef9 8327 3f5f f08e 3ef8 b419 3f5f     -..>'._?...>.._?
   1cc98:	40c8 3ef8 e4e9 3f5f 90dc 3ef7 1596 3f60     .@.>.._?...>..`?
   1cca8:	e0cb 3ef6 4621 3f60 3093 3ef6 7689 3f60     ...>!F`?.0.>.v`?
   1ccb8:	8035 3ef5 a6cf 3f60 cfb1 3ef4 d6f2 3f60     5..>..`?...>..`?
   1ccc8:	1f07 3ef4 06f2 3f61 6e38 3ef3 36d0 3f61     ...>..a?8n.>.6a?
   1ccd8:	bd43 3ef2 668a 3f61 0c29 3ef2 9622 3f61     C..>.fa?)..>".a?
   1cce8:	5aea 3ef1 c598 3f61 a985 3ef0 f4ea 3f61     .Z.>..a?...>..a?
   1ccf8:	f7fb 3eef 241a 3f62 464c 3eef 5326 3f62     ...>.$b?LF.>&Sb?
   1cd08:	9479 3eee 8210 3f62 e280 3eed b0d7 3f62     y..>..b?...>..b?
   1cd18:	3063 3eed df7b 3f62 7e21 3eec 0dfc 3f63     c0.>{.b?!~.>..c?
   1cd28:	cbbb 3eeb 3c5a 3f63 1930 3eeb 6a95 3f63     ...>Z<c?0..>.jc?
   1cd38:	6681 3eea 98ac 3f63 b3ae 3ee9 c6a1 3f63     .f.>..c?...>..c?
   1cd48:	00b7 3ee9 f473 3f63 4d9c 3ee8 2221 3f64     ...>s.c?.M.>!"d?
   1cd58:	9a5d 3ee7 4fac 3f64 e6fb 3ee6 7d14 3f64     ]..>.Od?...>.}d?
   1cd68:	3375 3ee6 aa59 3f64 7fcb 3ee5 d77b 3f64     u3.>Y.d?...>{.d?
   1cd78:	cbfe 3ee4 0479 3f65 180e 3ee4 3154 3f65     ...>y.e?...>T1e?
   1cd88:	63fa 3ee3 5e0b 3f65 afc4 3ee2 8aa0 3f65     .c.>.^e?...>..e?
   1cd98:	fb6a 3ee1 b710 3f65 46ee 3ee1 e35e 3f65     j..>..e?.F.>^.e?
   1cda8:	924f 3ee0 0f88 3f66 dd8d 3edf 3b8e 3f66     O..>..f?...>.;f?
   1cdb8:	28a9 3edf 6771 3f66 73a2 3ede 9330 3f66     .(.>qgf?.s.>0.f?
   1cdc8:	be79 3edd becc 3f66 092e 3edd ea45 3f66     y..>..f?...>E.f?
   1cdd8:	53c1 3edc 1599 3f67 9e31 3edb 40ca 3f67     .S.>..g?1..>.@g?
   1cde8:	e880 3eda 6bd8 3f67 32ad 3eda 96c1 3f67     ...>.kg?.2.>..g?
   1cdf8:	7cb9 3ed9 c187 3f67 c6a3 3ed8 ec29 3f67     .|.>..g?...>).g?
   1ce08:	106b 3ed8 16a8 3f68 5a13 3ed7 4103 3f68     k..>..h?.Z.>.Ah?
   1ce18:	a399 3ed6 6b39 3f68 ecfd 3ed5 954c 3f68     ...>9kh?...>L.h?
   1ce28:	3641 3ed5 bf3c 3f68 7f64 3ed4 e907 3f68     A6.><.h?d..>..h?
   1ce38:	c867 3ed3 12ae 3f69 1148 3ed3 3c32 3f69     g..>..i?H..>2<i?
   1ce48:	5a09 3ed2 6591 3f69 a2aa 3ed1 8ecc 3f69     .Z.>.ei?...>..i?
   1ce58:	eb2a 3ed0 b7e4 3f69 338a 3ed0 e0d7 3f69     *..>..i?.3.>..i?
   1ce68:	7bca 3ecf 09a7 3f6a c3ea 3ece 3252 3f6a     .{.>..j?...>R2j?
   1ce78:	0bea 3ece 5ad9 3f6a 53ca 3ecd 833c 3f6a     ...>.Zj?.S.><.j?
   1ce88:	9b8b 3ecc ab7b 3f6a e32c 3ecb d395 3f6a     ...>{.j?,..>..j?
   1ce98:	2aae 3ecb fb8c 3f6a 7210 3eca 235e 3f6b     .*.>..j?.r.>^#k?
   1cea8:	b953 3ec9 4b0c 3f6b 0077 3ec9 7295 3f6b     S..>.Kk?w..>.rk?
   1ceb8:	477c 3ec8 99fb 3f6b 8e62 3ec7 c13b 3f6b     |G.>..k?b..>;.k?
   1cec8:	d529 3ec6 e858 3f6b 1bd2 3ec6 0f50 3f6c     )..>X.k?...>P.l?
   1ced8:	625c 3ec5 3624 3f6c a8c8 3ec4 5cd4 3f6c     \b.>$6l?...>.\l?
   1cee8:	ef15 3ec3 835e 3f6c 3544 3ec3 a9c5 3f6c     ...>^.l?D5.>..l?
   1cef8:	7b55 3ec2 d007 3f6c c148 3ec1 f624 3f6c     U{.>..l?H..>$.l?
   1cf08:	071e 3ec1 1c1d 3f6d 4cd5 3ec0 41f2 3f6d     ...>..m?.L.>.Am?
   1cf18:	926f 3ebf 67a1 3f6d d7eb 3ebe 8d2d 3f6d     o..>.gm?...>-.m?
   1cf28:	1d4a 3ebe b293 3f6d 628b 3ebd d7d5 3f6d     J..>..m?.b.>..m?
   1cf38:	a7af 3ebc fcf2 3f6d ecb6 3ebb 21eb 3f6e     ...>..m?...>.!n?
   1cf48:	31a0 3ebb 46be 3f6e 766e 3eba 6b6d 3f6e     .1.>.Fn?nv.>mkn?
   1cf58:	bb1e 3eb9 8ff8 3f6e ffb2 3eb8 b45d 3f6e     ...>..n?...>].n?
   1cf68:	442a 3eb8 d89e 3f6e 8884 3eb7 fcba 3f6e     *D.>..n?...>..n?
   1cf78:	ccc3 3eb6 20b0 3f6f 10e6 3eb6 4483 3f6f     ...>. o?...>.Do?
   1cf88:	54ec 3eb5 6830 3f6f 98d6 3eb4 8bb8 3f6f     .T.>0ho?...>..o?
   1cf98:	dca5 3eb3 af1b 3f6f 2058 3eb3 d25a 3f6f     ...>..o?X .>Z.o?
   1cfa8:	63ef 3eb2 f573 3f6f a76b 3eb1 1867 3f70     .c.>s.o?k..>g.p?
   1cfb8:	eacb 3eb0 3b37 3f70 2e10 3eb0 5de1 3f70     ...>7;p?...>.]p?
   1cfc8:	713a 3eaf 8066 3f70 b449 3eae a2c6 3f70     :q.>f.p?I..>..p?
   1cfd8:	f73c 3ead c501 3f70 3a15 3ead e717 3f70     <..>..p?.:.>..p?
   1cfe8:	7cd4 3eac 0908 3f71 bf77 3eab 2ad4 3f71     .|.>..q?w..>.*q?
   1cff8:	0201 3eab 4c7a 3f71 446f 3eaa 6dfb 3f71     ...>zLq?oD.>.mq?
   1d008:	86c4 3ea9 8f57 3f71 c8fe 3ea8 b08e 3f71     ...>W.q?...>..q?
   1d018:	0b1f 3ea8 d19f 3f71 4d25 3ea7 f28c 3f71     ...>..q?%M.>..q?
   1d028:	8f12 3ea6 1352 3f72 d0e5 3ea5 33f4 3f72     ...>R.r?...>.3r?
   1d038:	129f 3ea5 5470 3f72 543f 3ea4 74c7 3f72     ...>pTr??T.>.tr?
   1d048:	95c5 3ea3 94f8 3f72 d733 3ea2 b504 3f72     ...>..r?3..>..r?
   1d058:	1887 3ea2 d4eb 3f72 59c2 3ea1 f4ac 3f72     ...>..r?.Y.>..r?
   1d068:	9ae5 3ea0 1447 3f73 dbee 3e9f 33be 3f73     ...>G.s?...>.3s?
   1d078:	1cdf 3e9f 530e 3f73 5db8 3e9e 7239 3f73     ...>.Ss?.].>9rs?
   1d088:	9e78 3e9d 913f 3f73 df20 3e9c b01f 3f73     x..>?.s? ..>..s?
   1d098:	1faf 3e9c ced9 3f73 6027 3e9b ed6e 3f73     ...>..s?'`.>n.s?
   1d0a8:	a086 3e9a 0bdd 3f74 e0ce 3e99 2a27 3f74     ...>..t?...>'*t?
   1d0b8:	20fe 3e99 484b 3f74 6116 3e98 6649 3f74     . .>KHt?.a.>Ift?
   1d0c8:	a117 3e97 8422 3f74 e100 3e96 a1d5 3f74     ...>".t?...>..t?
   1d0d8:	20d2 3e96 bf62 3f74 608d 3e95 dcc9 3f74     . .>b.t?.`.>..t?
   1d0e8:	a031 3e94 fa0b 3f74 dfbf 3e93 1727 3f75     1..>..t?...>'.u?
   1d0f8:	1f35 3e93 341d 3f75 5e94 3e92 50ed 3f75     5..>.4u?.^.>.Pu?
   1d108:	9ddd 3e91 6d97 3f75 dd10 3e90 8a1c 3f75     ...>.mu?...>..u?
   1d118:	1c2c 3e90 a67b 3f75 5b32 3e8f c2b3 3f75     ,..>{.u?2[.>..u?
   1d128:	9a22 3e8e dec6 3f75 d8fc 3e8d fab3 3f75     "..>..u?...>..u?
   1d138:	17c0 3e8d 167a 3f76 566e 3e8c 321b 3f76     ...>z.v?nV.>.2v?
   1d148:	9507 3e8b 4d97 3f76 d38a 3e8a 68ec 3f76     ...>.Mv?...>.hv?
   1d158:	11f7 3e8a 841b 3f76 5050 3e89 9f24 3f76     ...>..v?PP.>$.v?
   1d168:	8e93 3e88 ba07 3f76 ccc1 3e87 d4c4 3f76     ...>..v?...>..v?
   1d178:	0ada 3e87 ef5b 3f76 48df 3e86 09cc 3f77     ...>[.v?.H.>..w?
   1d188:	86ce 3e85 2417 3f77 c4aa 3e84 3e3c 3f77     ...>.$w?...><>w?
   1d198:	0270 3e84 583a 3f77 4022 3e83 7213 3f77     p..>:Xw?"@.>.rw?
   1d1a8:	7dc0 3e82 8bc5 3f77 bb4a 3e81 a551 3f77     .}.>..w?J..>Q.w?
   1d1b8:	f8c0 3e80 beb7 3f77 3622 3e80 d7f7 3f77     ...>..w?"6.>..w?
   1d1c8:	e6e1 3e7e f110 3f77 6156 3e7d 0a04 3f78     ..~>..w?Va}>..x?
   1d1d8:	dba4 3e7b 22d1 3f78 55cb 3e7a 3b77 3f78     ..{>."x?.Uz>w;x?
   1d1e8:	cfcc 3e78 53f8 3f78 49a6 3e77 6c52 3f78     ..x>.Sx?.Iw>Rlx?
   1d1f8:	c35a 3e75 8486 3f78 3ce8 3e74 9c93 3f78     Z.u>..x?.<t>..x?
   1d208:	b651 3e72 b47b 3f78 2f94 3e71 cc3b 3f78     Q.r>{.x?./q>;.x?
   1d218:	a8b2 3e6f e3d6 3f78 21ab 3e6e fb4a 3f78     ..o>..x?.!n>J.x?
   1d228:	9a7f 3e6c 1298 3f79 132f 3e6b 29bf 3f79     ..l>..y?/.k>.)y?
   1d238:	8bba 3e69 40c0 3f79 0422 3e68 579a 3f79     ..i>.@y?".h>.Wy?
   1d248:	7c66 3e66 6e4e 3f79 f486 3e64 84dc 3f79     f|f>Nny?..d>..y?
   1d258:	6c83 3e63 9b43 3f79 e45c 3e61 b183 3f79     .lc>C.y?\.a>..y?
   1d268:	5c13 3e60 c79d 3f79 d3a8 3e5e dd91 3f79     .\`>..y?..^>..y?
   1d278:	4b1a 3e5d f35e 3f79 c26a 3e5b 0904 3f7a     .K]>^.y?j.[>..z?
   1d288:	3997 3e5a 1e84 3f7a b0a4 3e58 33dd 3f7a     .9Z>..z?..X>.3z?
   1d298:	278f 3e57 4910 3f7a 9e58 3e55 5e1c 3f7a     .'W>.Iz?X.U>.^z?
   1d2a8:	1501 3e54 7302 3f7a 8b89 3e52 87c1 3f7a     ..T>.sz?..R>..z?
   1d2b8:	01f1 3e51 9c59 3f7a 7838 3e4f b0cb 3f7a     ..Q>Y.z?8xO>..z?
   1d2c8:	ee60 3e4d c516 3f7a 6467 3e4c d93a 3f7a     `.M>..z?gdL>:.z?
   1d2d8:	da4f 3e4a ed37 3f7a 5018 3e49 010e 3f7b     O.J>7.z?.PI>..{?
   1d2e8:	c5c2 3e47 14be 3f7b 3b4d 3e46 2848 3f7b     ..G>..{?M;F>H({?
   1d2f8:	b0b9 3e44 3bab 3f7b 2607 3e43 4ee7 3f7b     ..D>.;{?.&C>.N{?
   1d308:	9b37 3e41 61fc 3f7b 1049 3e40 74ea 3f7b     7.A>.a{?I.@>.t{?
   1d318:	853e 3e3e 87b2 3f7b fa15 3e3c 9a53 3f7b     >.>>..{?..<>S.{?
   1d328:	6ecf 3e3b accd 3f7b e36c 3e39 bf20 3f7b     .n;>..{?l.9> .{?
   1d338:	57ec 3e38 d14d 3f7b cc50 3e36 e353 3f7b     .W8>M.{?P.6>S.{?
   1d348:	4098 3e35 f531 3f7b b4c4 3e33 06e9 3f7c     .@5>1.{?..3>..|?
   1d358:	28d4 3e32 187a 3f7c 9cc9 3e30 29e5 3f7c     .(2>z.|?..0>.)|?
   1d368:	10a2 3e2f 3b28 3f7c 8461 3e2d 4c44 3f7c     ../>(;|?a.->DL|?
   1d378:	f804 3e2b 5d3a 3f7c 6b8d 3e2a 6e08 3f7c     ..+>:]|?.k*>.n|?
   1d388:	defc 3e28 7eb0 3f7c 5251 3e27 8f31 3f7c     ..(>.~|?QR'>1.|?
   1d398:	c58c 3e25 9f8a 3f7c 38ad 3e24 afbd 3f7c     ..%>..|?.8$>..|?
   1d3a8:	abb6 3e22 bfc9 3f7c 1ea5 3e21 cfae 3f7c     ..">..|?..!>..|?
   1d3b8:	917b 3e1f df6c 3f7c 0438 3e1e ef03 3f7c     {..>l.|?8..>..|?
   1d3c8:	76de 3e1c fe73 3f7c e96b 3e1a 0dbc 3f7d     .v.>s.|?k..>..}?
   1d3d8:	5be0 3e19 1cdd 3f7d ce3d 3e17 2bd8 3f7d     .[.>..}?=..>.+}?
   1d3e8:	4083 3e16 3aac 3f7d b2b2 3e14 4959 3f7d     .@.>.:}?...>YI}?
   1d3f8:	24ca 3e13 57de 3f7d 96cc 3e11 663d 3f7d     .$.>.W}?...>=f}?
   1d408:	08b7 3e10 7474 3f7d 7a8b 3e0e 8285 3f7d     ...>tt}?.z.>..}?
   1d418:	ec4a 3e0c 906e 3f7d 5df3 3e0b 9e30 3f7d     J..>n.}?.].>0.}?
   1d428:	cf86 3e09 abcc 3f7d 4105 3e08 b940 3f7d     ...>..}?.A.>@.}?
   1d438:	b26e 3e06 c68c 3f7d 23c2 3e05 d3b2 3f7d     n..>..}?.#.>..}?
   1d448:	9502 3e03 e0b1 3f7d 062e 3e02 ed88 3f7d     ...>..}?...>..}?
   1d458:	7745 3e00 fa38 3f7d d092 3dfd 06c2 3f7e     Ew.>8.}?...=..~?
   1d468:	b273 3dfa 1324 3f7e 942c 3df7 1f5e 3f7e     s..=$.~?,..=^.~?
   1d478:	75c0 3df4 2b72 3f7e 572e 3df1 375e 3f7e     .u.=r+~?.W.=^7~?
   1d488:	3876 3dee 4323 3f7e 199a 3deb 4ec1 3f7e     v8.=#C~?...=.N~?
   1d498:	fa9a 3de7 5a38 3f7e db76 3de4 6588 3f7e     ...=8Z~?v..=.e~?
   1d4a8:	bc2e 3de1 70b0 3f7e 9cc4 3dde 7bb1 3f7e     ...=.p~?...=.{~?
   1d4b8:	7d37 3ddb 868b 3f7e 5d89 3dd8 913d 3f7e     7}.=..~?.].==.~?
   1d4c8:	3db9 3dd5 9bc9 3f7e 1dc8 3dd2 a62d 3f7e     .=.=..~?...=-.~?
   1d4d8:	fdb7 3dce b069 3f7e dd86 3dcb ba7f 3f7e     ...=i.~?...=..~?
   1d4e8:	bd36 3dc8 c46d 3f7e 9cc6 3dc5 ce34 3f7e     6..=m.~?...=4.~?
   1d4f8:	7c39 3dc2 d7d4 3f7e 5b8d 3dbf e14c 3f7e     9|.=..~?.[.=L.~?
   1d508:	3ac3 3dbc ea9d 3f7e 19dd 3db9 f3c7 3f7e     .:.=..~?...=..~?
   1d518:	f8da 3db5 fcc9 3f7e d7bb 3db2 05a4 3f7f     ...=..~?...=...?
   1d528:	b680 3daf 0e58 3f7f 952b 3dac 16e4 3f7f     ...=X..?+..=...?
   1d538:	73ba 3da9 1f49 3f7f 5230 3da6 2787 3f7f     .s.=I..?0R.=.'.?
   1d548:	308c 3da3 2f9d 3f7f 0ecf 3da0 378c 3f7f     .0.=./.?...=.7.?
   1d558:	ecf9 3d9c 3f54 3f7f cb0a 3d99 46f4 3f7f     ...=T?.?...=.F.?
   1d568:	a905 3d96 4e6d 3f7f 86e7 3d93 55bf 3f7f     ...=mN.?...=.U.?
   1d578:	64b4 3d90 5ce9 3f7f 426a 3d8d 63ec 3f7f     .d.=.\.?jB.=.c.?
   1d588:	200a 3d8a 6ac7 3f7f fd94 3d86 717b 3f7f     . .=.j.?...={q.?
   1d598:	db0a 3d83 7808 3f7f b86c 3d80 7e6d 3f7f     ...=.x.?l..=m~.?
   1d5a8:	2b74 3d7b 84ab 3f7f e5e9 3d74 8ac2 3f7f     t+{=...?..t=...?
   1d5b8:	a038 3d6e 90b1 3f7f 5a62 3d68 9678 3f7f     8.n=...?bZh=x..?
   1d5c8:	1469 3d62 9c18 3f7f ce4c 3d5b a191 3f7f     i.b=...?L.[=...?
   1d5d8:	880e 3d55 a6e3 3f7f 41af 3d4f ac0d 3f7f     ..U=...?.AO=...?
   1d5e8:	fb30 3d48 b10f 3f7f b491 3d42 b5ea 3f7f     0.H=...?..B=...?
   1d5f8:	6dd5 3d3c ba9e 3f7f 26fc 3d36 bf2a 3f7f     .m<=...?.&6=*..?
   1d608:	e007 3d2f c38f 3f7f 98f6 3d29 c7cc 3f7f     ../=...?..)=...?
   1d618:	51cb 3d23 cbe2 3f7f 0a88 3d1d cfd1 3f7f     .Q#=...?...=...?
   1d628:	c32c 3d16 d397 3f7f 7bb8 3d10 d737 3f7f     ,..=...?.{.=7..?
   1d638:	342f 3d0a daaf 3f7f ec90 3d03 de00 3f7f     /4.=...?...=...?
   1d648:	49ba 3cfb e129 3f7f ba2c 3cee e42b 3f7f     .I.<)..?,..<+..?
   1d658:	2a7a 3ce2 e705 3f7f 9aa6 3cd5 e9b8 3f7f     z*.<...?...<...?
   1d668:	0ab0 3cc9 ec43 3f7f 7a9b 3cbc eea7 3f7f     ...<C..?.z.<...?
   1d678:	ea69 3caf f0e3 3f7f 5a1c 3ca3 f2f8 3f7f     i..<...?.Z.<...?
   1d688:	c9b6 3c96 f4e6 3f7f 3938 3c8a f6ac 3f7f     ...<...?89.<...?
   1d698:	514b 3c7b f84a 3f7f 2fff 3c62 f9c1 3f7f     KQ{<J..?./b<...?
   1d6a8:	0e90 3c49 fb11 3f7f ed02 3c2f fc39 3f7f     ..I<...?../<9..?
   1d6b8:	cb58 3c16 fd39 3f7f 5330 3bfb fe13 3f7f     X..<9..?0S.;...?
   1d6c8:	0f88 3bc9 fec4 3f7f cbc1 3b96 ff4e 3f7f     ...;...?...;N..?
   1d6d8:	0fc6 3b49 ffb1 3f7f 0fd5 3ac9 ffec 3f7f     ..I;...?...:...?
   1d6e8:	a80b 248c 0000 3f80 0fd5 bac9 ffec 3f7f     ...$...?.......?
   1d6f8:	0fc6 bb49 ffb1 3f7f cbc1 bb96 ff4e 3f7f     ..I....?....N..?
   1d708:	0f88 bbc9 fec4 3f7f 5330 bbfb fe13 3f7f     .......?0S.....?
   1d718:	cb58 bc16 fd39 3f7f ed02 bc2f fc39 3f7f     X...9..?../.9..?
   1d728:	0e90 bc49 fb11 3f7f 2fff bc62 f9c1 3f7f     ..I....?./b....?
   1d738:	514b bc7b f84a 3f7f 3938 bc8a f6ac 3f7f     KQ{.J..?89.....?
   1d748:	c9b6 bc96 f4e6 3f7f 5a1c bca3 f2f8 3f7f     .......?.Z.....?
   1d758:	ea69 bcaf f0e3 3f7f 7a9b bcbc eea7 3f7f     i......?.z.....?
   1d768:	0ab0 bcc9 ec43 3f7f 9aa6 bcd5 e9b8 3f7f     ....C..?.......?
   1d778:	2a7a bce2 e705 3f7f ba2c bcee e42b 3f7f     z*.....?,...+..?
   1d788:	49ba bcfb e129 3f7f ec90 bd03 de00 3f7f     .I..)..?.......?
   1d798:	342f bd0a daaf 3f7f 7bb8 bd10 d737 3f7f     /4.....?.{..7..?
   1d7a8:	c32c bd16 d397 3f7f 0a88 bd1d cfd1 3f7f     ,......?.......?
   1d7b8:	51cb bd23 cbe2 3f7f 98f6 bd29 c7cc 3f7f     .Q#....?..)....?
   1d7c8:	e007 bd2f c38f 3f7f 26fc bd36 bf2a 3f7f     ../....?.&6.*..?
   1d7d8:	6dd5 bd3c ba9e 3f7f b491 bd42 b5ea 3f7f     .m<....?..B....?
   1d7e8:	fb30 bd48 b10f 3f7f 41af bd4f ac0d 3f7f     0.H....?.AO....?
   1d7f8:	880e bd55 a6e3 3f7f ce4c bd5b a191 3f7f     ..U....?L.[....?
   1d808:	1469 bd62 9c18 3f7f 5a62 bd68 9678 3f7f     i.b....?bZh.x..?
   1d818:	a038 bd6e 90b1 3f7f e5e9 bd74 8ac2 3f7f     8.n....?..t....?
   1d828:	2b74 bd7b 84ab 3f7f b86c bd80 7e6d 3f7f     t+{....?l...m~.?
   1d838:	db0a bd83 7808 3f7f fd94 bd86 717b 3f7f     .....x.?....{q.?
   1d848:	200a bd8a 6ac7 3f7f 426a bd8d 63ec 3f7f     . ...j.?jB...c.?
   1d858:	64b4 bd90 5ce9 3f7f 86e7 bd93 55bf 3f7f     .d...\.?.....U.?
   1d868:	a905 bd96 4e6d 3f7f cb0a bd99 46f4 3f7f     ....mN.?.....F.?
   1d878:	ecf9 bd9c 3f54 3f7f 0ecf bda0 378c 3f7f     ....T?.?.....7.?
   1d888:	308c bda3 2f9d 3f7f 5230 bda6 2787 3f7f     .0.../.?0R...'.?
   1d898:	73ba bda9 1f49 3f7f 952b bdac 16e4 3f7f     .s..I..?+......?
   1d8a8:	b680 bdaf 0e58 3f7f d7bb bdb2 05a4 3f7f     ....X..?.......?
   1d8b8:	f8da bdb5 fcc9 3f7e 19dd bdb9 f3c7 3f7e     ......~?......~?
   1d8c8:	3ac3 bdbc ea9d 3f7e 5b8d bdbf e14c 3f7e     .:....~?.[..L.~?
   1d8d8:	7c39 bdc2 d7d4 3f7e 9cc6 bdc5 ce34 3f7e     9|....~?....4.~?
   1d8e8:	bd36 bdc8 c46d 3f7e dd86 bdcb ba7f 3f7e     6...m.~?......~?
   1d8f8:	fdb7 bdce b069 3f7e 1dc8 bdd2 a62d 3f7e     ....i.~?....-.~?
   1d908:	3db9 bdd5 9bc9 3f7e 5d89 bdd8 913d 3f7e     .=....~?.]..=.~?
   1d918:	7d37 bddb 868b 3f7e 9cc4 bdde 7bb1 3f7e     7}....~?.....{~?
   1d928:	bc2e bde1 70b0 3f7e db76 bde4 6588 3f7e     .....p~?v....e~?
   1d938:	fa9a bde7 5a38 3f7e 199a bdeb 4ec1 3f7e     ....8Z~?.....N~?
   1d948:	3876 bdee 4323 3f7e 572e bdf1 375e 3f7e     v8..#C~?.W..^7~?
   1d958:	75c0 bdf4 2b72 3f7e 942c bdf7 1f5e 3f7e     .u..r+~?,...^.~?
   1d968:	b273 bdfa 1324 3f7e d092 bdfd 06c2 3f7e     s...$.~?......~?
   1d978:	7745 be00 fa38 3f7d 062e be02 ed88 3f7d     Ew..8.}?......}?
   1d988:	9502 be03 e0b1 3f7d 23c2 be05 d3b2 3f7d     ......}?.#....}?
   1d998:	b26e be06 c68c 3f7d 4105 be08 b940 3f7d     n.....}?.A..@.}?
   1d9a8:	cf86 be09 abcc 3f7d 5df3 be0b 9e30 3f7d     ......}?.]..0.}?
   1d9b8:	ec4a be0c 906e 3f7d 7a8b be0e 8285 3f7d     J...n.}?.z....}?
   1d9c8:	08b7 be10 7474 3f7d 96cc be11 663d 3f7d     ....tt}?....=f}?
   1d9d8:	24ca be13 57de 3f7d b2b2 be14 4959 3f7d     .$...W}?....YI}?
   1d9e8:	4083 be16 3aac 3f7d ce3d be17 2bd8 3f7d     .@...:}?=....+}?
   1d9f8:	5be0 be19 1cdd 3f7d e96b be1a 0dbc 3f7d     .[....}?k.....}?
   1da08:	76de be1c fe73 3f7c 0438 be1e ef03 3f7c     .v..s.|?8.....|?
   1da18:	917b be1f df6c 3f7c 1ea5 be21 cfae 3f7c     {...l.|?..!...|?
   1da28:	abb6 be22 bfc9 3f7c 38ad be24 afbd 3f7c     .."...|?.8$...|?
   1da38:	c58c be25 9f8a 3f7c 5251 be27 8f31 3f7c     ..%...|?QR'.1.|?
   1da48:	defc be28 7eb0 3f7c 6b8d be2a 6e08 3f7c     ..(..~|?.k*..n|?
   1da58:	f804 be2b 5d3a 3f7c 8461 be2d 4c44 3f7c     ..+.:]|?a.-.DL|?
   1da68:	10a2 be2f 3b28 3f7c 9cc9 be30 29e5 3f7c     ../.(;|?..0..)|?
   1da78:	28d4 be32 187a 3f7c b4c4 be33 06e9 3f7c     .(2.z.|?..3...|?
   1da88:	4098 be35 f531 3f7b cc50 be36 e353 3f7b     .@5.1.{?P.6.S.{?
   1da98:	57ec be38 d14d 3f7b e36c be39 bf20 3f7b     .W8.M.{?l.9. .{?
   1daa8:	6ecf be3b accd 3f7b fa15 be3c 9a53 3f7b     .n;...{?..<.S.{?
   1dab8:	853e be3e 87b2 3f7b 1049 be40 74ea 3f7b     >.>...{?I.@..t{?
   1dac8:	9b37 be41 61fc 3f7b 2607 be43 4ee7 3f7b     7.A..a{?.&C..N{?
   1dad8:	b0b9 be44 3bab 3f7b 3b4d be46 2848 3f7b     ..D..;{?M;F.H({?
   1dae8:	c5c2 be47 14be 3f7b 5018 be49 010e 3f7b     ..G...{?.PI...{?
   1daf8:	da4f be4a ed37 3f7a 6467 be4c d93a 3f7a     O.J.7.z?gdL.:.z?
   1db08:	ee60 be4d c516 3f7a 7838 be4f b0cb 3f7a     `.M...z?8xO...z?
   1db18:	01f1 be51 9c59 3f7a 8b89 be52 87c1 3f7a     ..Q.Y.z?..R...z?
   1db28:	1501 be54 7302 3f7a 9e58 be55 5e1c 3f7a     ..T..sz?X.U..^z?
   1db38:	278f be57 4910 3f7a b0a4 be58 33dd 3f7a     .'W..Iz?..X..3z?
   1db48:	3997 be5a 1e84 3f7a c26a be5b 0904 3f7a     .9Z...z?j.[...z?
   1db58:	4b1a be5d f35e 3f79 d3a8 be5e dd91 3f79     .K].^.y?..^...y?
   1db68:	5c13 be60 c79d 3f79 e45c be61 b183 3f79     .\`...y?\.a...y?
   1db78:	6c83 be63 9b43 3f79 f486 be64 84dc 3f79     .lc.C.y?..d...y?
   1db88:	7c66 be66 6e4e 3f79 0422 be68 579a 3f79     f|f.Nny?".h..Wy?
   1db98:	8bba be69 40c0 3f79 132f be6b 29bf 3f79     ..i..@y?/.k..)y?
   1dba8:	9a7f be6c 1298 3f79 21ab be6e fb4a 3f78     ..l...y?.!n.J.x?
   1dbb8:	a8b2 be6f e3d6 3f78 2f94 be71 cc3b 3f78     ..o...x?./q.;.x?
   1dbc8:	b651 be72 b47b 3f78 3ce8 be74 9c93 3f78     Q.r.{.x?.<t...x?
   1dbd8:	c35a be75 8486 3f78 49a6 be77 6c52 3f78     Z.u...x?.Iw.Rlx?
   1dbe8:	cfcc be78 53f8 3f78 55cb be7a 3b77 3f78     ..x..Sx?.Uz.w;x?
   1dbf8:	dba4 be7b 22d1 3f78 6156 be7d 0a04 3f78     ..{.."x?Va}...x?
   1dc08:	e6e1 be7e f110 3f77 3622 be80 d7f7 3f77     ..~...w?"6....w?
   1dc18:	f8c0 be80 beb7 3f77 bb4a be81 a551 3f77     ......w?J...Q.w?
   1dc28:	7dc0 be82 8bc5 3f77 4022 be83 7213 3f77     .}....w?"@...rw?
   1dc38:	0270 be84 583a 3f77 c4aa be84 3e3c 3f77     p...:Xw?....<>w?
   1dc48:	86ce be85 2417 3f77 48df be86 09cc 3f77     .....$w?.H....w?
   1dc58:	0ada be87 ef5b 3f76 ccc1 be87 d4c4 3f76     ....[.v?......v?
   1dc68:	8e93 be88 ba07 3f76 5050 be89 9f24 3f76     ......v?PP..$.v?
   1dc78:	11f7 be8a 841b 3f76 d38a be8a 68ec 3f76     ......v?.....hv?
   1dc88:	9507 be8b 4d97 3f76 566e be8c 321b 3f76     .....Mv?nV...2v?
   1dc98:	17c0 be8d 167a 3f76 d8fc be8d fab3 3f75     ....z.v?......u?
   1dca8:	9a22 be8e dec6 3f75 5b32 be8f c2b3 3f75     ".....u?2[....u?
   1dcb8:	1c2c be90 a67b 3f75 dd10 be90 8a1c 3f75     ,...{.u?......u?
   1dcc8:	9ddd be91 6d97 3f75 5e94 be92 50ed 3f75     .....mu?.^...Pu?
   1dcd8:	1f35 be93 341d 3f75 dfbf be93 1727 3f75     5....4u?....'.u?
   1dce8:	a031 be94 fa0b 3f74 608d be95 dcc9 3f74     1.....t?.`....t?
   1dcf8:	20d2 be96 bf62 3f74 e100 be96 a1d5 3f74     . ..b.t?......t?
   1dd08:	a117 be97 8422 3f74 6116 be98 6649 3f74     ....".t?.a..Ift?
   1dd18:	20fe be99 484b 3f74 e0ce be99 2a27 3f74     . ..KHt?....'*t?
   1dd28:	a086 be9a 0bdd 3f74 6027 be9b ed6e 3f73     ......t?'`..n.s?
   1dd38:	1faf be9c ced9 3f73 df20 be9c b01f 3f73     ......s? .....s?
   1dd48:	9e78 be9d 913f 3f73 5db8 be9e 7239 3f73     x...?.s?.]..9rs?
   1dd58:	1cdf be9f 530e 3f73 dbee be9f 33be 3f73     .....Ss?.....3s?
   1dd68:	9ae5 bea0 1447 3f73 59c2 bea1 f4ac 3f72     ....G.s?.Y....r?
   1dd78:	1887 bea2 d4eb 3f72 d733 bea2 b504 3f72     ......r?3.....r?
   1dd88:	95c5 bea3 94f8 3f72 543f bea4 74c7 3f72     ......r??T...tr?
   1dd98:	129f bea5 5470 3f72 d0e5 bea5 33f4 3f72     ....pTr?.....3r?
   1dda8:	8f12 bea6 1352 3f72 4d25 bea7 f28c 3f71     ....R.r?%M....q?
   1ddb8:	0b1f bea8 d19f 3f71 c8fe bea8 b08e 3f71     ......q?......q?
   1ddc8:	86c4 bea9 8f57 3f71 446f beaa 6dfb 3f71     ....W.q?oD...mq?
   1ddd8:	0201 beab 4c7a 3f71 bf77 beab 2ad4 3f71     ....zLq?w....*q?
   1dde8:	7cd4 beac 0908 3f71 3a15 bead e717 3f70     .|....q?.:....p?
   1ddf8:	f73c bead c501 3f70 b449 beae a2c6 3f70     <.....p?I.....p?
   1de08:	713a beaf 8066 3f70 2e10 beb0 5de1 3f70     :q..f.p?.....]p?
   1de18:	eacb beb0 3b37 3f70 a76b beb1 1867 3f70     ....7;p?k...g.p?
   1de28:	63ef beb2 f573 3f6f 2058 beb3 d25a 3f6f     .c..s.o?X ..Z.o?
   1de38:	dca5 beb3 af1b 3f6f 98d6 beb4 8bb8 3f6f     ......o?......o?
   1de48:	54ec beb5 6830 3f6f 10e6 beb6 4483 3f6f     .T..0ho?.....Do?
   1de58:	ccc3 beb6 20b0 3f6f 8884 beb7 fcba 3f6e     ..... o?......n?
   1de68:	442a beb8 d89e 3f6e ffb2 beb8 b45d 3f6e     *D....n?....].n?
   1de78:	bb1e beb9 8ff8 3f6e 766e beba 6b6d 3f6e     ......n?nv..mkn?
   1de88:	31a0 bebb 46be 3f6e ecb6 bebb 21eb 3f6e     .1...Fn?.....!n?
   1de98:	a7af bebc fcf2 3f6d 628b bebd d7d5 3f6d     ......m?.b....m?
   1dea8:	1d4a bebe b293 3f6d d7eb bebe 8d2d 3f6d     J.....m?....-.m?
   1deb8:	926f bebf 67a1 3f6d 4cd5 bec0 41f2 3f6d     o....gm?.L...Am?
   1dec8:	071e bec1 1c1d 3f6d c148 bec1 f624 3f6c     ......m?H...$.l?
   1ded8:	7b55 bec2 d007 3f6c 3544 bec3 a9c5 3f6c     U{....l?D5....l?
   1dee8:	ef15 bec3 835e 3f6c a8c8 bec4 5cd4 3f6c     ....^.l?.....\l?
   1def8:	625c bec5 3624 3f6c 1bd2 bec6 0f50 3f6c     \b..$6l?....P.l?
   1df08:	d529 bec6 e858 3f6b 8e62 bec7 c13b 3f6b     )...X.k?b...;.k?
   1df18:	477c bec8 99fb 3f6b 0077 bec9 7295 3f6b     |G....k?w....rk?
   1df28:	b953 bec9 4b0c 3f6b 7210 beca 235e 3f6b     S....Kk?.r..^#k?
   1df38:	2aae becb fb8c 3f6a e32c becb d395 3f6a     .*....j?,.....j?
   1df48:	9b8b becc ab7b 3f6a 53ca becd 833c 3f6a     ....{.j?.S..<.j?
   1df58:	0bea bece 5ad9 3f6a c3ea bece 3252 3f6a     .....Zj?....R2j?
   1df68:	7bca becf 09a7 3f6a 338a bed0 e0d7 3f69     .{....j?.3....i?
   1df78:	eb2a bed0 b7e4 3f69 a2aa bed1 8ecc 3f69     *.....i?......i?
   1df88:	5a09 bed2 6591 3f69 1148 bed3 3c32 3f69     .Z...ei?H...2<i?
   1df98:	c867 bed3 12ae 3f69 7f64 bed4 e907 3f68     g.....i?d.....h?
   1dfa8:	3641 bed5 bf3c 3f68 ecfd bed5 954c 3f68     A6..<.h?....L.h?
   1dfb8:	a399 bed6 6b39 3f68 5a13 bed7 4103 3f68     ....9kh?.Z...Ah?
   1dfc8:	106b bed8 16a8 3f68 c6a3 bed8 ec29 3f67     k.....h?....).g?
   1dfd8:	7cb9 bed9 c187 3f67 32ad beda 96c1 3f67     .|....g?.2....g?
   1dfe8:	e880 beda 6bd8 3f67 9e31 bedb 40ca 3f67     .....kg?1....@g?
   1dff8:	53c1 bedc 1599 3f67 092e bedd ea45 3f66     .S....g?....E.f?
   1e008:	be79 bedd becc 3f66 73a2 bede 9330 3f66     y.....f?.s..0.f?
   1e018:	28a9 bedf 6771 3f66 dd8d bedf 3b8e 3f66     .(..qgf?.....;f?
   1e028:	924f bee0 0f88 3f66 46ee bee1 e35e 3f65     O.....f?.F..^.e?
   1e038:	fb6a bee1 b710 3f65 afc4 bee2 8aa0 3f65     j.....e?......e?
   1e048:	63fa bee3 5e0b 3f65 180e bee4 3154 3f65     .c...^e?....T1e?
   1e058:	cbfe bee4 0479 3f65 7fcb bee5 d77b 3f64     ....y.e?....{.d?
   1e068:	3375 bee6 aa59 3f64 e6fb bee6 7d14 3f64     u3..Y.d?.....}d?
   1e078:	9a5d bee7 4fac 3f64 4d9c bee8 2221 3f64     ]....Od?.M..!"d?
   1e088:	00b7 bee9 f473 3f63 b3ae bee9 c6a1 3f63     ....s.c?......c?
   1e098:	6681 beea 98ac 3f63 1930 beeb 6a95 3f63     .f....c?0....jc?
   1e0a8:	cbbb beeb 3c5a 3f63 7e21 beec 0dfc 3f63     ....Z<c?!~....c?
   1e0b8:	3063 beed df7b 3f62 e280 beed b0d7 3f62     c0..{.b?......b?
   1e0c8:	9479 beee 8210 3f62 464c beef 5326 3f62     y.....b?LF..&Sb?
   1e0d8:	f7fb beef 241a 3f62 a985 bef0 f4ea 3f61     .....$b?......a?
   1e0e8:	5aea bef1 c598 3f61 0c29 bef2 9622 3f61     .Z....a?)...".a?
   1e0f8:	bd43 bef2 668a 3f61 6e38 bef3 36d0 3f61     C....fa?8n...6a?
   1e108:	1f07 bef4 06f2 3f61 cfb1 bef4 d6f2 3f60     ......a?......`?
   1e118:	8035 bef5 a6cf 3f60 3093 bef6 7689 3f60     5.....`?.0...v`?
   1e128:	e0cb bef6 4621 3f60 90dc bef7 1596 3f60     ....!F`?......`?
   1e138:	40c8 bef8 e4e9 3f5f f08e bef8 b419 3f5f     .@...._?......_?
   1e148:	a02d bef9 8327 3f5f 4fa5 befa 5212 3f5f     -...'._?.O...R_?
   1e158:	fef7 befa 20db 3f5f ae22 befb ef81 3f5e     ..... _?".....^?
   1e168:	5d27 befc be05 3f5e 0c04 befd 8c67 3f5e     ']....^?....g.^?
   1e178:	babb befd 5aa6 3f5e 694a befe 28c3 3f5e     .....Z^?Ji...(^?
   1e188:	17b2 beff f6be 3f5d c5f3 beff c497 3f5d     ......]?......]?
   1e198:	3a06 bf00 924d 3f5d 90ff bf00 5fe1 3f5d     .:..M.]?....._]?
   1e1a8:	e7e4 bf00 2d53 3f5d 3eb5 bf01 faa3 3f5c     ....S-]?.>....\?
   1e1b8:	9573 bf01 c7d1 3f5c ec1c bf01 94dd 3f5c     s.....\?......\?
   1e1c8:	42b1 bf02 61c7 3f5c 9932 bf02 2e8e 3f5c     .B...a\?2.....\?
   1e1d8:	ef9f bf02 fb34 3f5b 45f8 bf03 c7b8 3f5b     ....4.[?.E....[?
   1e1e8:	9c3d bf03 941a 3f5b f26d bf03 605a 3f5b     =.....[?m...Z`[?
   1e1f8:	4889 bf04 2c79 3f5b 9e91 bf04 f875 3f5a     .H..y,[?....u.Z?
   1e208:	f484 bf04 c450 3f5a 4a62 bf05 9009 3f5a     ....P.Z?bJ....Z?
   1e218:	a02c bf05 5ba0 3f5a f5e2 bf05 2716 3f5a     ,....[Z?.....'Z?
   1e228:	4b82 bf06 f26a 3f59 a10e bf06 bd9c 3f59     .K..j.Y?......Y?
   1e238:	f686 bf06 88ad 3f59 4be8 bf07 539c 3f59     ......Y?.K...SY?
   1e248:	a136 bf07 1e6a 3f59 f66f bf07 e916 3f58     6...j.Y?o.....X?
   1e258:	4b92 bf08 b3a1 3f58 a0a1 bf08 7e0b 3f58     .K....X?.....~X?
   1e268:	f59b bf08 4853 3f58 4a7f bf09 1279 3f58     ....SHX?.J..y.X?
   1e278:	9f4e bf09 dc7f 3f57 f409 bf09 a663 3f57     N.....W?....c.W?
   1e288:	48ad bf0a 7026 3f57 9d3d bf0a 39c7 3f57     .H..&pW?=....9W?
   1e298:	f1b7 bf0a 0348 3f57 461c bf0b cca7 3f56     ....H.W?.F....V?
   1e2a8:	9a6b bf0b 95e5 3f56 eea5 bf0b 5f02 3f56     k.....V?....._V?
   1e2b8:	42c9 bf0c 27fe 3f56 96d7 bf0c f0d9 3f55     .B...'V?......U?
   1e2c8:	ead0 bf0c b993 3f55 3eb3 bf0d 822c 3f55     ......U?.>..,.U?
   1e2d8:	9281 bf0d 4aa4 3f55 e638 bf0d 12fb 3f55     .....JU?8.....U?
   1e2e8:	39da bf0e db31 3f54 8d65 bf0e a347 3f54     .9..1.T?e...G.T?
   1e2f8:	e0db bf0e 6b3b 3f54 343b bf0f 330f 3f54     ....;kT?;4...3T?
   1e308:	8784 bf0f fac3 3f53 dab8 bf0f c255 3f53     ......S?....U.S?
   1e318:	2dd5 bf10 89c7 3f53 80dc bf10 5118 3f53     .-....S?.....QS?
   1e328:	d3cd bf10 1849 3f53 26a7 bf11 df59 3f52     ....I.S?.&..Y.R?
   1e338:	796b bf11 a649 3f52 cc19 bf11 6d18 3f52     ky..I.R?.....mR?
   1e348:	1eb0 bf12 33c6 3f52 7130 bf12 fa54 3f51     .....3R?0q..T.Q?
   1e358:	c39a bf12 c0c2 3f51 15ee bf13 8710 3f51     ......Q?......Q?
   1e368:	682a bf13 4d3d 3f51 ba50 bf13 134a 3f51     *h..=MQ?P...J.Q?
   1e378:	0c5f bf14 d937 3f50 5e58 bf14 9f03 3f50     _...7.P?X^....P?
   1e388:	b039 bf14 64af 3f50 0204 bf15 2a3b 3f50     9....dP?....;*P?
   1e398:	53b7 bf15 efa8 3f4f a554 bf15 b4f4 3f4f     .S....O?T.....O?
   1e3a8:	f6d9 bf15 7a1f 3f4f 4847 bf16 3f2b 3f4f     .....zO?GH..+?O?
   1e3b8:	999f bf16 0417 3f4f eade bf16 c8e4 3f4e     ......O?......N?
   1e3c8:	3c07 bf17 8d90 3f4e 8d18 bf17 521c 3f4e     .<....N?.....RN?
   1e3d8:	de12 bf17 1689 3f4e 2ef5 bf18 dad5 3f4d     ......N?......M?
   1e3e8:	7fc0 bf18 9f02 3f4d d073 bf18 6310 3f4d     ......M?s....cM?
   1e3f8:	210f bf19 26fd 3f4d 7194 bf19 eacb 3f4c     .!...&M?.q....L?
   1e408:	c200 bf19 ae79 3f4c 1255 bf1a 7208 3f4c     ....y.L?U....rL?
   1e418:	6293 bf1a 3578 3f4c b2b8 bf1a f8c7 3f4b     .b..x5L?......K?
   1e428:	02c6 bf1b bbf8 3f4b 52bb bf1b 7f09 3f4b     ......K?.R....K?
   1e438:	a299 bf1b 41fa 3f4b f25f bf1b 04cc 3f4b     .....AK?_.....K?
   1e448:	420c bf1c c77f 3f4a 91a2 bf1c 8a13 3f4a     .B....J?......J?
   1e458:	e11f bf1c 4c87 3f4a 3084 bf1d 0edc 3f4a     .....LJ?.0....J?
   1e468:	7fd1 bf1d d112 3f49 cf06 bf1d 9329 3f49     ......I?....).I?
   1e478:	1e22 bf1e 5521 3f49 6d26 bf1e 16fa 3f49     "...!UI?&m....I?
   1e488:	bc12 bf1e d8b3 3f48 0ae5 bf1f 9a4e 3f48     ......H?....N.H?
   1e498:	599f bf1f 5bca 3f48 a841 bf1f 1d27 3f48     .Y...[H?A...'.H?
   1e4a8:	f6cb bf1f de65 3f47 453b bf20 9f84 3f47     ....e.G?;E ...G?
   1e4b8:	9393 bf20 6085 3f47 e1d2 bf20 2167 3f47     .. ..`G?.. .g!G?
   1e4c8:	2ff9 bf21 e22a 3f46 7e06 bf21 a2ce 3f46     ./!.*.F?.~!...F?
   1e4d8:	cbfb bf21 6354 3f46 19d7 bf22 23bb 3f46     ..!.TcF?.."..#F?
   1e4e8:	6799 bf22 e403 3f45 b543 bf22 a42d 3f45     .g"...E?C.".-.E?
   1e4f8:	02d3 bf23 6439 3f45 504b bf23 2426 3f45     ..#.9dE?KP#.&$E?
   1e508:	9da9 bf23 e3f5 3f44 eaee bf23 a3a5 3f44     ..#...D?..#...D?
   1e518:	381a bf24 6337 3f44 852c bf24 22ab 3f44     .8$.7cD?,.$.."D?
   1e528:	d225 bf24 e200 3f43 1f04 bf25 a138 3f43     %.$...C?..%.8.C?
   1e538:	6bcb bf25 6051 3f43 b877 bf25 1f4c 3f43     .k%.Q`C?w.%.L.C?
   1e548:	050a bf26 de29 3f42 5184 bf26 9ce8 3f42     ..&.).B?.Q&...B?
   1e558:	9de3 bf26 5b89 3f42 ea2a bf26 1a0b 3f42     ..&..[B?*.&...B?
   1e568:	3656 bf27 d870 3f41 8268 bf27 96b7 3f41     V6'.p.A?h.'...A?
   1e578:	ce61 bf27 54e1 3f41 1a40 bf28 12ec 3f41     a.'..TA?@.(...A?
   1e588:	6605 bf28 d0da 3f40 b1b0 bf28 8ea9 3f40     .f(...@?..(...@?
   1e598:	fd41 bf28 4c5c 3f40 48b8 bf29 09f0 3f40     A.(.\L@?.H)...@?
   1e5a8:	9415 bf29 c767 3f3f df57 bf29 84c0 3f3f     ..).g.??W.)...??
   1e5b8:	2a80 bf2a 41fc 3f3f 758e bf2a ff1b 3f3e     .**..A??.u*...>?
   1e5c8:	c082 bf2a bc1b 3f3e 0b5b bf2b 78ff 3f3e     ..*...>?[.+..x>?
   1e5d8:	561b bf2b 35c5 3f3e a0bf bf2b f26e 3f3d     .V+..5>?..+.n.=?
   1e5e8:	eb4a bf2b aef9 3f3d 35b9 bf2c 6b67 3f3d     J.+...=?.5,.gk=?
   1e5f8:	800f bf2c 27b8 3f3d ca49 bf2c e3ec 3f3c     ..,..'=?I.,...<?
   1e608:	1469 bf2d a003 3f3c 5e6f bf2d 5bfc 3f3c     i.-...<?o^-..[<?
   1e618:	a859 bf2d 17d9 3f3c f229 bf2d d398 3f3b     Y.-...<?).-...;?
   1e628:	3bde bf2e 8f3b 3f3b 8578 bf2e 4ac1 3f3b     .;..;.;?x....J;?
   1e638:	cef7 bf2e 0629 3f3b 185b bf2f c175 3f3a     ....).;?[./.u.:?
   1e648:	61a5 bf2f 7ca4 3f3a aad3 bf2f 37b7 3f3a     .a/..|:?../..7:?
   1e658:	f3e6 bf2f f2ac 3f39 3cde bf30 ad85 3f39     ../...9?.<0...9?
   1e668:	85bb bf30 6842 3f39 ce7c bf30 22e1 3f39     ..0.Bh9?|.0.."9?
   1e678:	1722 bf31 dd65 3f38 5fad bf31 97cb 3f38     ".1.e.8?._1...8?
   1e688:	a81d bf31 5216 3f38 f071 bf31 0c43 3f38     ..1..R8?q.1.C.8?
   1e698:	38aa bf32 c655 3f37 80c7 bf32 804a 3f37     .82.U.7?..2.J.7?
   1e6a8:	c8c9 bf32 3a23 3f37 10af bf33 f3df 3f36     ..2.#:7?..3...6?
   1e6b8:	587a bf33 ad7f 3f36 a029 bf33 6704 3f36     zX3...6?).3..g6?
   1e6c8:	e7bc bf33 206c 3f36 2f34 bf34 d9b8 3f35     ..3.l 6?4/4...5?
   1e6d8:	768f bf34 92e7 3f35 bdcf bf34 4bfb 3f35     .v4...5?..4..K5?
   1e6e8:	04f3 bf35 04f3 3f35 4bfb bf35 bdcf 3f34     ..5...5?.K5...4?
   1e6f8:	92e7 bf35 768f 3f34 d9b8 bf35 2f34 3f34     ..5..v4?..5.4/4?
   1e708:	206c bf36 e7bc 3f33 6704 bf36 a029 3f33     l 6...3?.g6.).3?
   1e718:	ad7f bf36 587a 3f33 f3df bf36 10af 3f33     ..6.zX3?..6...3?
   1e728:	3a23 bf37 c8c9 3f32 804a bf37 80c7 3f32     #:7...2?J.7...2?
   1e738:	c655 bf37 38aa 3f32 0c43 bf38 f071 3f31     U.7..82?C.8.q.1?
   1e748:	5216 bf38 a81d 3f31 97cb bf38 5fad 3f31     .R8...1?..8.._1?
   1e758:	dd65 bf38 1722 3f31 22e1 bf39 ce7c 3f30     e.8.".1?."9.|.0?
   1e768:	6842 bf39 85bb 3f30 ad85 bf39 3cde 3f30     Bh9...0?..9..<0?
   1e778:	f2ac bf39 f3e6 3f2f 37b7 bf3a aad3 3f2f     ..9.../?.7:.../?
   1e788:	7ca4 bf3a 61a5 3f2f c175 bf3a 185b 3f2f     .|:..a/?u.:.[./?
   1e798:	0629 bf3b cef7 3f2e 4ac1 bf3b 8578 3f2e     ).;....?.J;.x..?
   1e7a8:	8f3b bf3b 3bde 3f2e d398 bf3b f229 3f2d     ;.;..;.?..;.).-?
   1e7b8:	17d9 bf3c a859 3f2d 5bfc bf3c 5e6f 3f2d     ..<.Y.-?.[<.o^-?
   1e7c8:	a003 bf3c 1469 3f2d e3ec bf3c ca49 3f2c     ..<.i.-?..<.I.,?
   1e7d8:	27b8 bf3d 800f 3f2c 6b67 bf3d 35b9 3f2c     .'=...,?gk=..5,?
   1e7e8:	aef9 bf3d eb4a 3f2b f26e bf3d a0bf 3f2b     ..=.J.+?n.=...+?
   1e7f8:	35c5 bf3e 561b 3f2b 78ff bf3e 0b5b 3f2b     .5>..V+?.x>.[.+?
   1e808:	bc1b bf3e c082 3f2a ff1b bf3e 758e 3f2a     ..>...*?..>..u*?
   1e818:	41fc bf3f 2a80 3f2a 84c0 bf3f df57 3f29     .A?..**?..?.W.)?
   1e828:	c767 bf3f 9415 3f29 09f0 bf40 48b8 3f29     g.?...)?..@..H)?
   1e838:	4c5c bf40 fd41 3f28 8ea9 bf40 b1b0 3f28     \L@.A.(?..@...(?
   1e848:	d0da bf40 6605 3f28 12ec bf41 1a40 3f28     ..@..f(?..A.@.(?
   1e858:	54e1 bf41 ce61 3f27 96b7 bf41 8268 3f27     .TA.a.'?..A.h.'?
   1e868:	d870 bf41 3656 3f27 1a0b bf42 ea2a 3f26     p.A.V6'?..B.*.&?
   1e878:	5b89 bf42 9de3 3f26 9ce8 bf42 5184 3f26     .[B...&?..B..Q&?
   1e888:	de29 bf42 050a 3f26 1f4c bf43 b877 3f25     ).B...&?L.C.w.%?
   1e898:	6051 bf43 6bcb 3f25 a138 bf43 1f04 3f25     Q`C..k%?8.C...%?
   1e8a8:	e200 bf43 d225 3f24 22ab bf44 852c 3f24     ..C.%.$?."D.,.$?
   1e8b8:	6337 bf44 381a 3f24 a3a5 bf44 eaee 3f23     7cD..8$?..D...#?
   1e8c8:	e3f5 bf44 9da9 3f23 2426 bf45 504b 3f23     ..D...#?&$E.KP#?
   1e8d8:	6439 bf45 02d3 3f23 a42d bf45 b543 3f22     9dE...#?-.E.C."?
   1e8e8:	e403 bf45 6799 3f22 23bb bf46 19d7 3f22     ..E..g"?.#F..."?
   1e8f8:	6354 bf46 cbfb 3f21 a2ce bf46 7e06 3f21     TcF...!?..F..~!?
   1e908:	e22a bf46 2ff9 3f21 2167 bf47 e1d2 3f20     *.F../!?g!G... ?
   1e918:	6085 bf47 9393 3f20 9f84 bf47 453b 3f20     .`G... ?..G.;E ?
   1e928:	de65 bf47 f6cb 3f1f 1d27 bf48 a841 3f1f     e.G....?'.H.A..?
   1e938:	5bca bf48 599f 3f1f 9a4e bf48 0ae5 3f1f     .[H..Y.?N.H....?
   1e948:	d8b3 bf48 bc12 3f1e 16fa bf49 6d26 3f1e     ..H....?..I.&m.?
   1e958:	5521 bf49 1e22 3f1e 9329 bf49 cf06 3f1d     !UI."..?).I....?
   1e968:	d112 bf49 7fd1 3f1d 0edc bf4a 3084 3f1d     ..I....?..J..0.?
   1e978:	4c87 bf4a e11f 3f1c 8a13 bf4a 91a2 3f1c     .LJ....?..J....?
   1e988:	c77f bf4a 420c 3f1c 04cc bf4b f25f 3f1b     ..J..B.?..K._..?
   1e998:	41fa bf4b a299 3f1b 7f09 bf4b 52bb 3f1b     .AK....?..K..R.?
   1e9a8:	bbf8 bf4b 02c6 3f1b f8c7 bf4b b2b8 3f1a     ..K....?..K....?
   1e9b8:	3578 bf4c 6293 3f1a 7208 bf4c 1255 3f1a     x5L..b.?.rL.U..?
   1e9c8:	ae79 bf4c c200 3f19 eacb bf4c 7194 3f19     y.L....?..L..q.?
   1e9d8:	26fd bf4d 210f 3f19 6310 bf4d d073 3f18     .&M..!.?.cM.s..?
   1e9e8:	9f02 bf4d 7fc0 3f18 dad5 bf4d 2ef5 3f18     ..M....?..M....?
   1e9f8:	1689 bf4e de12 3f17 521c bf4e 8d18 3f17     ..N....?.RN....?
   1ea08:	8d90 bf4e 3c07 3f17 c8e4 bf4e eade 3f16     ..N..<.?..N....?
   1ea18:	0417 bf4f 999f 3f16 3f2b bf4f 4847 3f16     ..O....?+?O.GH.?
   1ea28:	7a1f bf4f f6d9 3f15 b4f4 bf4f a554 3f15     .zO....?..O.T..?
   1ea38:	efa8 bf4f 53b7 3f15 2a3b bf50 0204 3f15     ..O..S.?;*P....?
   1ea48:	64af bf50 b039 3f14 9f03 bf50 5e58 3f14     .dP.9..?..P.X^.?
   1ea58:	d937 bf50 0c5f 3f14 134a bf51 ba50 3f13     7.P._..?J.Q.P..?
   1ea68:	4d3d bf51 682a 3f13 8710 bf51 15ee 3f13     =MQ.*h.?..Q....?
   1ea78:	c0c2 bf51 c39a 3f12 fa54 bf51 7130 3f12     ..Q....?T.Q.0q.?
   1ea88:	33c6 bf52 1eb0 3f12 6d18 bf52 cc19 3f11     .3R....?.mR....?
   1ea98:	a649 bf52 796b 3f11 df59 bf52 26a7 3f11     I.R.ky.?Y.R..&.?
   1eaa8:	1849 bf53 d3cd 3f10 5118 bf53 80dc 3f10     I.S....?.QS....?
   1eab8:	89c7 bf53 2dd5 3f10 c255 bf53 dab8 3f0f     ..S..-.?U.S....?
   1eac8:	fac3 bf53 8784 3f0f 330f bf54 343b 3f0f     ..S....?.3T.;4.?
   1ead8:	6b3b bf54 e0db 3f0e a347 bf54 8d65 3f0e     ;kT....?G.T.e..?
   1eae8:	db31 bf54 39da 3f0e 12fb bf55 e638 3f0d     1.T..9.?..U.8..?
   1eaf8:	4aa4 bf55 9281 3f0d 822c bf55 3eb3 3f0d     .JU....?,.U..>.?
   1eb08:	b993 bf55 ead0 3f0c f0d9 bf55 96d7 3f0c     ..U....?..U....?
   1eb18:	27fe bf56 42c9 3f0c 5f02 bf56 eea5 3f0b     .'V..B.?._V....?
   1eb28:	95e5 bf56 9a6b 3f0b cca7 bf56 461c 3f0b     ..V.k..?..V..F.?
   1eb38:	0348 bf57 f1b7 3f0a 39c7 bf57 9d3d 3f0a     H.W....?.9W.=..?
   1eb48:	7026 bf57 48ad 3f0a a663 bf57 f409 3f09     &pW..H.?c.W....?
   1eb58:	dc7f bf57 9f4e 3f09 1279 bf58 4a7f 3f09     ..W.N..?y.X..J.?
   1eb68:	4853 bf58 f59b 3f08 7e0b bf58 a0a1 3f08     SHX....?.~X....?
   1eb78:	b3a1 bf58 4b92 3f08 e916 bf58 f66f 3f07     ..X..K.?..X.o..?
   1eb88:	1e6a bf59 a136 3f07 539c bf59 4be8 3f07     j.Y.6..?.SY..K.?
   1eb98:	88ad bf59 f686 3f06 bd9c bf59 a10e 3f06     ..Y....?..Y....?
   1eba8:	f26a bf59 4b82 3f06 2716 bf5a f5e2 3f05     j.Y..K.?.'Z....?
   1ebb8:	5ba0 bf5a a02c 3f05 9009 bf5a 4a62 3f05     .[Z.,..?..Z.bJ.?
   1ebc8:	c450 bf5a f484 3f04 f875 bf5a 9e91 3f04     P.Z....?u.Z....?
   1ebd8:	2c79 bf5b 4889 3f04 605a bf5b f26d 3f03     y,[..H.?Z`[.m..?
   1ebe8:	941a bf5b 9c3d 3f03 c7b8 bf5b 45f8 3f03     ..[.=..?..[..E.?
   1ebf8:	fb34 bf5b ef9f 3f02 2e8e bf5c 9932 3f02     4.[....?..\.2..?
   1ec08:	61c7 bf5c 42b1 3f02 94dd bf5c ec1c 3f01     .a\..B.?..\....?
   1ec18:	c7d1 bf5c 9573 3f01 faa3 bf5c 3eb5 3f01     ..\.s..?..\..>.?
   1ec28:	2d53 bf5d e7e4 3f00 5fe1 bf5d 90ff 3f00     S-]....?._]....?
   1ec38:	924d bf5d 3a06 3f00 c497 bf5d c5f3 3eff     M.]..:.?..]....>
   1ec48:	f6be bf5d 17b2 3eff 28c3 bf5e 694a 3efe     ..]....>.(^.Ji.>
   1ec58:	5aa6 bf5e babb 3efd 8c67 bf5e 0c04 3efd     .Z^....>g.^....>
   1ec68:	be05 bf5e 5d27 3efc ef81 bf5e ae22 3efb     ..^.'].>..^."..>
   1ec78:	20db bf5f fef7 3efa 5212 bf5f 4fa5 3efa     . _....>.R_..O.>
   1ec88:	8327 bf5f a02d 3ef9 b419 bf5f f08e 3ef8     '._.-..>.._....>
   1ec98:	e4e9 bf5f 40c8 3ef8 1596 bf60 90dc 3ef7     .._..@.>..`....>
   1eca8:	4621 bf60 e0cb 3ef6 7689 bf60 3093 3ef6     !F`....>.v`..0.>
   1ecb8:	a6cf bf60 8035 3ef5 d6f2 bf60 cfb1 3ef4     ..`.5..>..`....>
   1ecc8:	06f2 bf61 1f07 3ef4 36d0 bf61 6e38 3ef3     ..a....>.6a.8n.>
   1ecd8:	668a bf61 bd43 3ef2 9622 bf61 0c29 3ef2     .fa.C..>".a.)..>
   1ece8:	c598 bf61 5aea 3ef1 f4ea bf61 a985 3ef0     ..a..Z.>..a....>
   1ecf8:	241a bf62 f7fb 3eef 5326 bf62 464c 3eef     .$b....>&Sb.LF.>
   1ed08:	8210 bf62 9479 3eee b0d7 bf62 e280 3eed     ..b.y..>..b....>
   1ed18:	df7b bf62 3063 3eed 0dfc bf63 7e21 3eec     {.b.c0.>..c.!~.>
   1ed28:	3c5a bf63 cbbb 3eeb 6a95 bf63 1930 3eeb     Z<c....>.jc.0..>
   1ed38:	98ac bf63 6681 3eea c6a1 bf63 b3ae 3ee9     ..c..f.>..c....>
   1ed48:	f473 bf63 00b7 3ee9 2221 bf64 4d9c 3ee8     s.c....>!"d..M.>
   1ed58:	4fac bf64 9a5d 3ee7 7d14 bf64 e6fb 3ee6     .Od.]..>.}d....>
   1ed68:	aa59 bf64 3375 3ee6 d77b bf64 7fcb 3ee5     Y.d.u3.>{.d....>
   1ed78:	0479 bf65 cbfe 3ee4 3154 bf65 180e 3ee4     y.e....>T1e....>
   1ed88:	5e0b bf65 63fa 3ee3 8aa0 bf65 afc4 3ee2     .^e..c.>..e....>
   1ed98:	b710 bf65 fb6a 3ee1 e35e bf65 46ee 3ee1     ..e.j..>^.e..F.>
   1eda8:	0f88 bf66 924f 3ee0 3b8e bf66 dd8d 3edf     ..f.O..>.;f....>
   1edb8:	6771 bf66 28a9 3edf 9330 bf66 73a2 3ede     qgf..(.>0.f..s.>
   1edc8:	becc bf66 be79 3edd ea45 bf66 092e 3edd     ..f.y..>E.f....>
   1edd8:	1599 bf67 53c1 3edc 40ca bf67 9e31 3edb     ..g..S.>.@g.1..>
   1ede8:	6bd8 bf67 e880 3eda 96c1 bf67 32ad 3eda     .kg....>..g..2.>
   1edf8:	c187 bf67 7cb9 3ed9 ec29 bf67 c6a3 3ed8     ..g..|.>).g....>
   1ee08:	16a8 bf68 106b 3ed8 4103 bf68 5a13 3ed7     ..h.k..>.Ah..Z.>
   1ee18:	6b39 bf68 a399 3ed6 954c bf68 ecfd 3ed5     9kh....>L.h....>
   1ee28:	bf3c bf68 3641 3ed5 e907 bf68 7f64 3ed4     <.h.A6.>..h.d..>
   1ee38:	12ae bf69 c867 3ed3 3c32 bf69 1148 3ed3     ..i.g..>2<i.H..>
   1ee48:	6591 bf69 5a09 3ed2 8ecc bf69 a2aa 3ed1     .ei..Z.>..i....>
   1ee58:	b7e4 bf69 eb2a 3ed0 e0d7 bf69 338a 3ed0     ..i.*..>..i..3.>
   1ee68:	09a7 bf6a 7bca 3ecf 3252 bf6a c3ea 3ece     ..j..{.>R2j....>
   1ee78:	5ad9 bf6a 0bea 3ece 833c bf6a 53ca 3ecd     .Zj....><.j..S.>
   1ee88:	ab7b bf6a 9b8b 3ecc d395 bf6a e32c 3ecb     {.j....>..j.,..>
   1ee98:	fb8c bf6a 2aae 3ecb 235e bf6b 7210 3eca     ..j..*.>^#k..r.>
   1eea8:	4b0c bf6b b953 3ec9 7295 bf6b 0077 3ec9     .Kk.S..>.rk.w..>
   1eeb8:	99fb bf6b 477c 3ec8 c13b bf6b 8e62 3ec7     ..k.|G.>;.k.b..>
   1eec8:	e858 bf6b d529 3ec6 0f50 bf6c 1bd2 3ec6     X.k.)..>P.l....>
   1eed8:	3624 bf6c 625c 3ec5 5cd4 bf6c a8c8 3ec4     $6l.\b.>.\l....>
   1eee8:	835e bf6c ef15 3ec3 a9c5 bf6c 3544 3ec3     ^.l....>..l.D5.>
   1eef8:	d007 bf6c 7b55 3ec2 f624 bf6c c148 3ec1     ..l.U{.>$.l.H..>
   1ef08:	1c1d bf6d 071e 3ec1 41f2 bf6d 4cd5 3ec0     ..m....>.Am..L.>
   1ef18:	67a1 bf6d 926f 3ebf 8d2d bf6d d7eb 3ebe     .gm.o..>-.m....>
   1ef28:	b293 bf6d 1d4a 3ebe d7d5 bf6d 628b 3ebd     ..m.J..>..m..b.>
   1ef38:	fcf2 bf6d a7af 3ebc 21eb bf6e ecb6 3ebb     ..m....>.!n....>
   1ef48:	46be bf6e 31a0 3ebb 6b6d bf6e 766e 3eba     .Fn..1.>mkn.nv.>
   1ef58:	8ff8 bf6e bb1e 3eb9 b45d bf6e ffb2 3eb8     ..n....>].n....>
   1ef68:	d89e bf6e 442a 3eb8 fcba bf6e 8884 3eb7     ..n.*D.>..n....>
   1ef78:	20b0 bf6f ccc3 3eb6 4483 bf6f 10e6 3eb6     . o....>.Do....>
   1ef88:	6830 bf6f 54ec 3eb5 8bb8 bf6f 98d6 3eb4     0ho..T.>..o....>
   1ef98:	af1b bf6f dca5 3eb3 d25a bf6f 2058 3eb3     ..o....>Z.o.X .>
   1efa8:	f573 bf6f 63ef 3eb2 1867 bf70 a76b 3eb1     s.o..c.>g.p.k..>
   1efb8:	3b37 bf70 eacb 3eb0 5de1 bf70 2e10 3eb0     7;p....>.]p....>
   1efc8:	8066 bf70 713a 3eaf a2c6 bf70 b449 3eae     f.p.:q.>..p.I..>
   1efd8:	c501 bf70 f73c 3ead e717 bf70 3a15 3ead     ..p.<..>..p..:.>
   1efe8:	0908 bf71 7cd4 3eac 2ad4 bf71 bf77 3eab     ..q..|.>.*q.w..>
   1eff8:	4c7a bf71 0201 3eab 6dfb bf71 446f 3eaa     zLq....>.mq.oD.>
   1f008:	8f57 bf71 86c4 3ea9 b08e bf71 c8fe 3ea8     W.q....>..q....>
   1f018:	d19f bf71 0b1f 3ea8 f28c bf71 4d25 3ea7     ..q....>..q.%M.>
   1f028:	1352 bf72 8f12 3ea6 33f4 bf72 d0e5 3ea5     R.r....>.3r....>
   1f038:	5470 bf72 129f 3ea5 74c7 bf72 543f 3ea4     pTr....>.tr.?T.>
   1f048:	94f8 bf72 95c5 3ea3 b504 bf72 d733 3ea2     ..r....>..r.3..>
   1f058:	d4eb bf72 1887 3ea2 f4ac bf72 59c2 3ea1     ..r....>..r..Y.>
   1f068:	1447 bf73 9ae5 3ea0 33be bf73 dbee 3e9f     G.s....>.3s....>
   1f078:	530e bf73 1cdf 3e9f 7239 bf73 5db8 3e9e     .Ss....>9rs..].>
   1f088:	913f bf73 9e78 3e9d b01f bf73 df20 3e9c     ?.s.x..>..s. ..>
   1f098:	ced9 bf73 1faf 3e9c ed6e bf73 6027 3e9b     ..s....>n.s.'`.>
   1f0a8:	0bdd bf74 a086 3e9a 2a27 bf74 e0ce 3e99     ..t....>'*t....>
   1f0b8:	484b bf74 20fe 3e99 6649 bf74 6116 3e98     KHt.. .>Ift..a.>
   1f0c8:	8422 bf74 a117 3e97 a1d5 bf74 e100 3e96     ".t....>..t....>
   1f0d8:	bf62 bf74 20d2 3e96 dcc9 bf74 608d 3e95     b.t.. .>..t..`.>
   1f0e8:	fa0b bf74 a031 3e94 1727 bf75 dfbf 3e93     ..t.1..>'.u....>
   1f0f8:	341d bf75 1f35 3e93 50ed bf75 5e94 3e92     .4u.5..>.Pu..^.>
   1f108:	6d97 bf75 9ddd 3e91 8a1c bf75 dd10 3e90     .mu....>..u....>
   1f118:	a67b bf75 1c2c 3e90 c2b3 bf75 5b32 3e8f     {.u.,..>..u.2[.>
   1f128:	dec6 bf75 9a22 3e8e fab3 bf75 d8fc 3e8d     ..u."..>..u....>
   1f138:	167a bf76 17c0 3e8d 321b bf76 566e 3e8c     z.v....>.2v.nV.>
   1f148:	4d97 bf76 9507 3e8b 68ec bf76 d38a 3e8a     .Mv....>.hv....>
   1f158:	841b bf76 11f7 3e8a 9f24 bf76 5050 3e89     ..v....>$.v.PP.>
   1f168:	ba07 bf76 8e93 3e88 d4c4 bf76 ccc1 3e87     ..v....>..v....>
   1f178:	ef5b bf76 0ada 3e87 09cc bf77 48df 3e86     [.v....>..w..H.>
   1f188:	2417 bf77 86ce 3e85 3e3c bf77 c4aa 3e84     .$w....><>w....>
   1f198:	583a bf77 0270 3e84 7213 bf77 4022 3e83     :Xw.p..>.rw."@.>
   1f1a8:	8bc5 bf77 7dc0 3e82 a551 bf77 bb4a 3e81     ..w..}.>Q.w.J..>
   1f1b8:	beb7 bf77 f8c0 3e80 d7f7 bf77 3622 3e80     ..w....>..w."6.>
   1f1c8:	f110 bf77 e6e1 3e7e 0a04 bf78 6156 3e7d     ..w...~>..x.Va}>
   1f1d8:	22d1 bf78 dba4 3e7b 3b77 bf78 55cb 3e7a     ."x...{>w;x..Uz>
   1f1e8:	53f8 bf78 cfcc 3e78 6c52 bf78 49a6 3e77     .Sx...x>Rlx..Iw>
   1f1f8:	8486 bf78 c35a 3e75 9c93 bf78 3ce8 3e74     ..x.Z.u>..x..<t>
   1f208:	b47b bf78 b651 3e72 cc3b bf78 2f94 3e71     {.x.Q.r>;.x../q>
   1f218:	e3d6 bf78 a8b2 3e6f fb4a bf78 21ab 3e6e     ..x...o>J.x..!n>
   1f228:	1298 bf79 9a7f 3e6c 29bf bf79 132f 3e6b     ..y...l>.)y./.k>
   1f238:	40c0 bf79 8bba 3e69 579a bf79 0422 3e68     .@y...i>.Wy.".h>
   1f248:	6e4e bf79 7c66 3e66 84dc bf79 f486 3e64     Nny.f|f>..y...d>
   1f258:	9b43 bf79 6c83 3e63 b183 bf79 e45c 3e61     C.y..lc>..y.\.a>
   1f268:	c79d bf79 5c13 3e60 dd91 bf79 d3a8 3e5e     ..y..\`>..y...^>
   1f278:	f35e bf79 4b1a 3e5d 0904 bf7a c26a 3e5b     ^.y..K]>..z.j.[>
   1f288:	1e84 bf7a 3997 3e5a 33dd bf7a b0a4 3e58     ..z..9Z>.3z...X>
   1f298:	4910 bf7a 278f 3e57 5e1c bf7a 9e58 3e55     .Iz..'W>.^z.X.U>
   1f2a8:	7302 bf7a 1501 3e54 87c1 bf7a 8b89 3e52     .sz...T>..z...R>
   1f2b8:	9c59 bf7a 01f1 3e51 b0cb bf7a 7838 3e4f     Y.z...Q>..z.8xO>
   1f2c8:	c516 bf7a ee60 3e4d d93a bf7a 6467 3e4c     ..z.`.M>:.z.gdL>
   1f2d8:	ed37 bf7a da4f 3e4a 010e bf7b 5018 3e49     7.z.O.J>..{..PI>
   1f2e8:	14be bf7b c5c2 3e47 2848 bf7b 3b4d 3e46     ..{...G>H({.M;F>
   1f2f8:	3bab bf7b b0b9 3e44 4ee7 bf7b 2607 3e43     .;{...D>.N{..&C>
   1f308:	61fc bf7b 9b37 3e41 74ea bf7b 1049 3e40     .a{.7.A>.t{.I.@>
   1f318:	87b2 bf7b 853e 3e3e 9a53 bf7b fa15 3e3c     ..{.>.>>S.{...<>
   1f328:	accd bf7b 6ecf 3e3b bf20 bf7b e36c 3e39     ..{..n;> .{.l.9>
   1f338:	d14d bf7b 57ec 3e38 e353 bf7b cc50 3e36     M.{..W8>S.{.P.6>
   1f348:	f531 bf7b 4098 3e35 06e9 bf7c b4c4 3e33     1.{..@5>..|...3>
   1f358:	187a bf7c 28d4 3e32 29e5 bf7c 9cc9 3e30     z.|..(2>.)|...0>
   1f368:	3b28 bf7c 10a2 3e2f 4c44 bf7c 8461 3e2d     (;|.../>DL|.a.->
   1f378:	5d3a bf7c f804 3e2b 6e08 bf7c 6b8d 3e2a     :]|...+>.n|..k*>
   1f388:	7eb0 bf7c defc 3e28 8f31 bf7c 5251 3e27     .~|...(>1.|.QR'>
   1f398:	9f8a bf7c c58c 3e25 afbd bf7c 38ad 3e24     ..|...%>..|..8$>
   1f3a8:	bfc9 bf7c abb6 3e22 cfae bf7c 1ea5 3e21     ..|...">..|...!>
   1f3b8:	df6c bf7c 917b 3e1f ef03 bf7c 0438 3e1e     l.|.{..>..|.8..>
   1f3c8:	fe73 bf7c 76de 3e1c 0dbc bf7d e96b 3e1a     s.|..v.>..}.k..>
   1f3d8:	1cdd bf7d 5be0 3e19 2bd8 bf7d ce3d 3e17     ..}..[.>.+}.=..>
   1f3e8:	3aac bf7d 4083 3e16 4959 bf7d b2b2 3e14     .:}..@.>YI}....>
   1f3f8:	57de bf7d 24ca 3e13 663d bf7d 96cc 3e11     .W}..$.>=f}....>
   1f408:	7474 bf7d 08b7 3e10 8285 bf7d 7a8b 3e0e     tt}....>..}..z.>
   1f418:	906e bf7d ec4a 3e0c 9e30 bf7d 5df3 3e0b     n.}.J..>0.}..].>
   1f428:	abcc bf7d cf86 3e09 b940 bf7d 4105 3e08     ..}....>@.}..A.>
   1f438:	c68c bf7d b26e 3e06 d3b2 bf7d 23c2 3e05     ..}.n..>..}..#.>
   1f448:	e0b1 bf7d 9502 3e03 ed88 bf7d 062e 3e02     ..}....>..}....>
   1f458:	fa38 bf7d 7745 3e00 06c2 bf7e d092 3dfd     8.}.Ew.>..~....=
   1f468:	1324 bf7e b273 3dfa 1f5e bf7e 942c 3df7     $.~.s..=^.~.,..=
   1f478:	2b72 bf7e 75c0 3df4 375e bf7e 572e 3df1     r+~..u.=^7~..W.=
   1f488:	4323 bf7e 3876 3dee 4ec1 bf7e 199a 3deb     #C~.v8.=.N~....=
   1f498:	5a38 bf7e fa9a 3de7 6588 bf7e db76 3de4     8Z~....=.e~.v..=
   1f4a8:	70b0 bf7e bc2e 3de1 7bb1 bf7e 9cc4 3dde     .p~....=.{~....=
   1f4b8:	868b bf7e 7d37 3ddb 913d bf7e 5d89 3dd8     ..~.7}.==.~..].=
   1f4c8:	9bc9 bf7e 3db9 3dd5 a62d bf7e 1dc8 3dd2     ..~..=.=-.~....=
   1f4d8:	b069 bf7e fdb7 3dce ba7f bf7e dd86 3dcb     i.~....=..~....=
   1f4e8:	c46d bf7e bd36 3dc8 ce34 bf7e 9cc6 3dc5     m.~.6..=4.~....=
   1f4f8:	d7d4 bf7e 7c39 3dc2 e14c bf7e 5b8d 3dbf     ..~.9|.=L.~..[.=
   1f508:	ea9d bf7e 3ac3 3dbc f3c7 bf7e 19dd 3db9     ..~..:.=..~....=
   1f518:	fcc9 bf7e f8da 3db5 05a4 bf7f d7bb 3db2     ..~....=.......=
   1f528:	0e58 bf7f b680 3daf 16e4 bf7f 952b 3dac     X......=....+..=
   1f538:	1f49 bf7f 73ba 3da9 2787 bf7f 5230 3da6     I....s.=.'..0R.=
   1f548:	2f9d bf7f 308c 3da3 378c bf7f 0ecf 3da0     ./...0.=.7.....=
   1f558:	3f54 bf7f ecf9 3d9c 46f4 bf7f cb0a 3d99     T?.....=.F.....=
   1f568:	4e6d bf7f a905 3d96 55bf bf7f 86e7 3d93     mN.....=.U.....=
   1f578:	5ce9 bf7f 64b4 3d90 63ec bf7f 426a 3d8d     .\...d.=.c..jB.=
   1f588:	6ac7 bf7f 200a 3d8a 717b bf7f fd94 3d86     .j... .={q.....=
   1f598:	7808 bf7f db0a 3d83 7e6d bf7f b86c 3d80     .x.....=m~..l..=
   1f5a8:	84ab bf7f 2b74 3d7b 8ac2 bf7f e5e9 3d74     ....t+{=......t=
   1f5b8:	90b1 bf7f a038 3d6e 9678 bf7f 5a62 3d68     ....8.n=x...bZh=
   1f5c8:	9c18 bf7f 1469 3d62 a191 bf7f ce4c 3d5b     ....i.b=....L.[=
   1f5d8:	a6e3 bf7f 880e 3d55 ac0d bf7f 41af 3d4f     ......U=.....AO=
   1f5e8:	b10f bf7f fb30 3d48 b5ea bf7f b491 3d42     ....0.H=......B=
   1f5f8:	ba9e bf7f 6dd5 3d3c bf2a bf7f 26fc 3d36     .....m<=*....&6=
   1f608:	c38f bf7f e007 3d2f c7cc bf7f 98f6 3d29     ....../=......)=
   1f618:	cbe2 bf7f 51cb 3d23 cfd1 bf7f 0a88 3d1d     .....Q#=.......=
   1f628:	d397 bf7f c32c 3d16 d737 bf7f 7bb8 3d10     ....,..=7....{.=
   1f638:	daaf bf7f 342f 3d0a de00 bf7f ec90 3d03     ..../4.=.......=
   1f648:	e129 bf7f 49ba 3cfb e42b bf7f ba2c 3cee     )....I.<+...,..<
   1f658:	e705 bf7f 2a7a 3ce2 e9b8 bf7f 9aa6 3cd5     ....z*.<.......<
   1f668:	ec43 bf7f 0ab0 3cc9 eea7 bf7f 7a9b 3cbc     C......<.....z.<
   1f678:	f0e3 bf7f ea69 3caf f2f8 bf7f 5a1c 3ca3     ....i..<.....Z.<
   1f688:	f4e6 bf7f c9b6 3c96 f6ac bf7f 3938 3c8a     .......<....89.<
   1f698:	f84a bf7f 514b 3c7b f9c1 bf7f 2fff 3c62     J...KQ{<...../b<
   1f6a8:	fb11 bf7f 0e90 3c49 fc39 bf7f ed02 3c2f     ......I<9...../<
   1f6b8:	fd39 bf7f cb58 3c16 fe13 bf7f 5330 3bfb     9...X..<....0S.;
   1f6c8:	fec4 bf7f 0f88 3bc9 ff4e bf7f cbc1 3b96     .......;N......;
   1f6d8:	ffb1 bf7f 0fc6 3b49 ffec bf7f 0fd5 3ac9     ......I;.......:
   1f6e8:	0000 bf80 a80b 250c ffec bf7f 0fd5 bac9     .......%........
   1f6f8:	ffb1 bf7f 0fc6 bb49 ff4e bf7f cbc1 bb96     ......I.N.......
   1f708:	fec4 bf7f 0f88 bbc9 fe13 bf7f 5330 bbfb     ............0S..
   1f718:	fd39 bf7f cb58 bc16 fc39 bf7f ed02 bc2f     9...X...9...../.
   1f728:	fb11 bf7f 0e90 bc49 f9c1 bf7f 2fff bc62     ......I....../b.
   1f738:	f84a bf7f 514b bc7b f6ac bf7f 3938 bc8a     J...KQ{.....89..
   1f748:	f4e6 bf7f c9b6 bc96 f2f8 bf7f 5a1c bca3     .............Z..
   1f758:	f0e3 bf7f ea69 bcaf eea7 bf7f 7a9b bcbc     ....i........z..
   1f768:	ec43 bf7f 0ab0 bcc9 e9b8 bf7f 9aa6 bcd5     C...............
   1f778:	e705 bf7f 2a7a bce2 e42b bf7f ba2c bcee     ....z*..+...,...
   1f788:	e129 bf7f 49ba bcfb de00 bf7f ec90 bd03     )....I..........
   1f798:	daaf bf7f 342f bd0a d737 bf7f 7bb8 bd10     ..../4..7....{..
   1f7a8:	d397 bf7f c32c bd16 cfd1 bf7f 0a88 bd1d     ....,...........
   1f7b8:	cbe2 bf7f 51cb bd23 c7cc bf7f 98f6 bd29     .....Q#.......).
   1f7c8:	c38f bf7f e007 bd2f bf2a bf7f 26fc bd36     ....../.*....&6.
   1f7d8:	ba9e bf7f 6dd5 bd3c b5ea bf7f b491 bd42     .....m<.......B.
   1f7e8:	b10f bf7f fb30 bd48 ac0d bf7f 41af bd4f     ....0.H......AO.
   1f7f8:	a6e3 bf7f 880e bd55 a191 bf7f ce4c bd5b     ......U.....L.[.
   1f808:	9c18 bf7f 1469 bd62 9678 bf7f 5a62 bd68     ....i.b.x...bZh.
   1f818:	90b1 bf7f a038 bd6e 8ac2 bf7f e5e9 bd74     ....8.n.......t.
   1f828:	84ab bf7f 2b74 bd7b 7e6d bf7f b86c bd80     ....t+{.m~..l...
   1f838:	7808 bf7f db0a bd83 717b bf7f fd94 bd86     .x......{q......
   1f848:	6ac7 bf7f 200a bd8a 63ec bf7f 426a bd8d     .j... ...c..jB..
   1f858:	5ce9 bf7f 64b4 bd90 55bf bf7f 86e7 bd93     .\...d...U......
   1f868:	4e6d bf7f a905 bd96 46f4 bf7f cb0a bd99     mN.......F......
   1f878:	3f54 bf7f ecf9 bd9c 378c bf7f 0ecf bda0     T?.......7......
   1f888:	2f9d bf7f 308c bda3 2787 bf7f 5230 bda6     ./...0...'..0R..
   1f898:	1f49 bf7f 73ba bda9 16e4 bf7f 952b bdac     I....s......+...
   1f8a8:	0e58 bf7f b680 bdaf 05a4 bf7f d7bb bdb2     X...............
   1f8b8:	fcc9 bf7e f8da bdb5 f3c7 bf7e 19dd bdb9     ..~.......~.....
   1f8c8:	ea9d bf7e 3ac3 bdbc e14c bf7e 5b8d bdbf     ..~..:..L.~..[..
   1f8d8:	d7d4 bf7e 7c39 bdc2 ce34 bf7e 9cc6 bdc5     ..~.9|..4.~.....
   1f8e8:	c46d bf7e bd36 bdc8 ba7f bf7e dd86 bdcb     m.~.6.....~.....
   1f8f8:	b069 bf7e fdb7 bdce a62d bf7e 1dc8 bdd2     i.~.....-.~.....
   1f908:	9bc9 bf7e 3db9 bdd5 913d bf7e 5d89 bdd8     ..~..=..=.~..]..
   1f918:	868b bf7e 7d37 bddb 7bb1 bf7e 9cc4 bdde     ..~.7}...{~.....
   1f928:	70b0 bf7e bc2e bde1 6588 bf7e db76 bde4     .p~......e~.v...
   1f938:	5a38 bf7e fa9a bde7 4ec1 bf7e 199a bdeb     8Z~......N~.....
   1f948:	4323 bf7e 3876 bdee 375e bf7e 572e bdf1     #C~.v8..^7~..W..
   1f958:	2b72 bf7e 75c0 bdf4 1f5e bf7e 942c bdf7     r+~..u..^.~.,...
   1f968:	1324 bf7e b273 bdfa 06c2 bf7e d092 bdfd     $.~.s.....~.....
   1f978:	fa38 bf7d 7745 be00 ed88 bf7d 062e be02     8.}.Ew....}.....
   1f988:	e0b1 bf7d 9502 be03 d3b2 bf7d 23c2 be05     ..}.......}..#..
   1f998:	c68c bf7d b26e be06 b940 bf7d 4105 be08     ..}.n...@.}..A..
   1f9a8:	abcc bf7d cf86 be09 9e30 bf7d 5df3 be0b     ..}.....0.}..]..
   1f9b8:	906e bf7d ec4a be0c 8285 bf7d 7a8b be0e     n.}.J.....}..z..
   1f9c8:	7474 bf7d 08b7 be10 663d bf7d 96cc be11     tt}.....=f}.....
   1f9d8:	57de bf7d 24ca be13 4959 bf7d b2b2 be14     .W}..$..YI}.....
   1f9e8:	3aac bf7d 4083 be16 2bd8 bf7d ce3d be17     .:}..@...+}.=...
   1f9f8:	1cdd bf7d 5be0 be19 0dbc bf7d e96b be1a     ..}..[....}.k...
   1fa08:	fe73 bf7c 76de be1c ef03 bf7c 0438 be1e     s.|..v....|.8...
   1fa18:	df6c bf7c 917b be1f cfae bf7c 1ea5 be21     l.|.{.....|...!.
   1fa28:	bfc9 bf7c abb6 be22 afbd bf7c 38ad be24     ..|..."...|..8$.
   1fa38:	9f8a bf7c c58c be25 8f31 bf7c 5251 be27     ..|...%.1.|.QR'.
   1fa48:	7eb0 bf7c defc be28 6e08 bf7c 6b8d be2a     .~|...(..n|..k*.
   1fa58:	5d3a bf7c f804 be2b 4c44 bf7c 8461 be2d     :]|...+.DL|.a.-.
   1fa68:	3b28 bf7c 10a2 be2f 29e5 bf7c 9cc9 be30     (;|.../..)|...0.
   1fa78:	187a bf7c 28d4 be32 06e9 bf7c b4c4 be33     z.|..(2...|...3.
   1fa88:	f531 bf7b 4098 be35 e353 bf7b cc50 be36     1.{..@5.S.{.P.6.
   1fa98:	d14d bf7b 57ec be38 bf20 bf7b e36c be39     M.{..W8. .{.l.9.
   1faa8:	accd bf7b 6ecf be3b 9a53 bf7b fa15 be3c     ..{..n;.S.{...<.
   1fab8:	87b2 bf7b 853e be3e 74ea bf7b 1049 be40     ..{.>.>..t{.I.@.
   1fac8:	61fc bf7b 9b37 be41 4ee7 bf7b 2607 be43     .a{.7.A..N{..&C.
   1fad8:	3bab bf7b b0b9 be44 2848 bf7b 3b4d be46     .;{...D.H({.M;F.
   1fae8:	14be bf7b c5c2 be47 010e bf7b 5018 be49     ..{...G...{..PI.
   1faf8:	ed37 bf7a da4f be4a d93a bf7a 6467 be4c     7.z.O.J.:.z.gdL.
   1fb08:	c516 bf7a ee60 be4d b0cb bf7a 7838 be4f     ..z.`.M...z.8xO.
   1fb18:	9c59 bf7a 01f1 be51 87c1 bf7a 8b89 be52     Y.z...Q...z...R.
   1fb28:	7302 bf7a 1501 be54 5e1c bf7a 9e58 be55     .sz...T..^z.X.U.
   1fb38:	4910 bf7a 278f be57 33dd bf7a b0a4 be58     .Iz..'W..3z...X.
   1fb48:	1e84 bf7a 3997 be5a 0904 bf7a c26a be5b     ..z..9Z...z.j.[.
   1fb58:	f35e bf79 4b1a be5d dd91 bf79 d3a8 be5e     ^.y..K]...y...^.
   1fb68:	c79d bf79 5c13 be60 b183 bf79 e45c be61     ..y..\`...y.\.a.
   1fb78:	9b43 bf79 6c83 be63 84dc bf79 f486 be64     C.y..lc...y...d.
   1fb88:	6e4e bf79 7c66 be66 579a bf79 0422 be68     Nny.f|f..Wy.".h.
   1fb98:	40c0 bf79 8bba be69 29bf bf79 132f be6b     .@y...i..)y./.k.
   1fba8:	1298 bf79 9a7f be6c fb4a bf78 21ab be6e     ..y...l.J.x..!n.
   1fbb8:	e3d6 bf78 a8b2 be6f cc3b bf78 2f94 be71     ..x...o.;.x../q.
   1fbc8:	b47b bf78 b651 be72 9c93 bf78 3ce8 be74     {.x.Q.r...x..<t.
   1fbd8:	8486 bf78 c35a be75 6c52 bf78 49a6 be77     ..x.Z.u.Rlx..Iw.
   1fbe8:	53f8 bf78 cfcc be78 3b77 bf78 55cb be7a     .Sx...x.w;x..Uz.
   1fbf8:	22d1 bf78 dba4 be7b 0a04 bf78 6156 be7d     ."x...{...x.Va}.
   1fc08:	f110 bf77 e6e1 be7e d7f7 bf77 3622 be80     ..w...~...w."6..
   1fc18:	beb7 bf77 f8c0 be80 a551 bf77 bb4a be81     ..w.....Q.w.J...
   1fc28:	8bc5 bf77 7dc0 be82 7213 bf77 4022 be83     ..w..}...rw."@..
   1fc38:	583a bf77 0270 be84 3e3c bf77 c4aa be84     :Xw.p...<>w.....
   1fc48:	2417 bf77 86ce be85 09cc bf77 48df be86     .$w.......w..H..
   1fc58:	ef5b bf76 0ada be87 d4c4 bf76 ccc1 be87     [.v.......v.....
   1fc68:	ba07 bf76 8e93 be88 9f24 bf76 5050 be89     ..v.....$.v.PP..
   1fc78:	841b bf76 11f7 be8a 68ec bf76 d38a be8a     ..v......hv.....
   1fc88:	4d97 bf76 9507 be8b 321b bf76 566e be8c     .Mv......2v.nV..
   1fc98:	167a bf76 17c0 be8d fab3 bf75 d8fc be8d     z.v.......u.....
   1fca8:	dec6 bf75 9a22 be8e c2b3 bf75 5b32 be8f     ..u.".....u.2[..
   1fcb8:	a67b bf75 1c2c be90 8a1c bf75 dd10 be90     {.u.,.....u.....
   1fcc8:	6d97 bf75 9ddd be91 50ed bf75 5e94 be92     .mu......Pu..^..
   1fcd8:	341d bf75 1f35 be93 1727 bf75 dfbf be93     .4u.5...'.u.....
   1fce8:	fa0b bf74 a031 be94 dcc9 bf74 608d be95     ..t.1.....t..`..
   1fcf8:	bf62 bf74 20d2 be96 a1d5 bf74 e100 be96     b.t.. ....t.....
   1fd08:	8422 bf74 a117 be97 6649 bf74 6116 be98     ".t.....Ift..a..
   1fd18:	484b bf74 20fe be99 2a27 bf74 e0ce be99     KHt.. ..'*t.....
   1fd28:	0bdd bf74 a086 be9a ed6e bf73 6027 be9b     ..t.....n.s.'`..
   1fd38:	ced9 bf73 1faf be9c b01f bf73 df20 be9c     ..s.......s. ...
   1fd48:	913f bf73 9e78 be9d 7239 bf73 5db8 be9e     ?.s.x...9rs..]..
   1fd58:	530e bf73 1cdf be9f 33be bf73 dbee be9f     .Ss......3s.....
   1fd68:	1447 bf73 9ae5 bea0 f4ac bf72 59c2 bea1     G.s.......r..Y..
   1fd78:	d4eb bf72 1887 bea2 b504 bf72 d733 bea2     ..r.......r.3...
   1fd88:	94f8 bf72 95c5 bea3 74c7 bf72 543f bea4     ..r......tr.?T..
   1fd98:	5470 bf72 129f bea5 33f4 bf72 d0e5 bea5     pTr......3r.....
   1fda8:	1352 bf72 8f12 bea6 f28c bf71 4d25 bea7     R.r.......q.%M..
   1fdb8:	d19f bf71 0b1f bea8 b08e bf71 c8fe bea8     ..q.......q.....
   1fdc8:	8f57 bf71 86c4 bea9 6dfb bf71 446f beaa     W.q......mq.oD..
   1fdd8:	4c7a bf71 0201 beab 2ad4 bf71 bf77 beab     zLq......*q.w...
   1fde8:	0908 bf71 7cd4 beac e717 bf70 3a15 bead     ..q..|....p..:..
   1fdf8:	c501 bf70 f73c bead a2c6 bf70 b449 beae     ..p.<.....p.I...
   1fe08:	8066 bf70 713a beaf 5de1 bf70 2e10 beb0     f.p.:q...]p.....
   1fe18:	3b37 bf70 eacb beb0 1867 bf70 a76b beb1     7;p.....g.p.k...
   1fe28:	f573 bf6f 63ef beb2 d25a bf6f 2058 beb3     s.o..c..Z.o.X ..
   1fe38:	af1b bf6f dca5 beb3 8bb8 bf6f 98d6 beb4     ..o.......o.....
   1fe48:	6830 bf6f 54ec beb5 4483 bf6f 10e6 beb6     0ho..T...Do.....
   1fe58:	20b0 bf6f ccc3 beb6 fcba bf6e 8884 beb7     . o.......n.....
   1fe68:	d89e bf6e 442a beb8 b45d bf6e ffb2 beb8     ..n.*D..].n.....
   1fe78:	8ff8 bf6e bb1e beb9 6b6d bf6e 766e beba     ..n.....mkn.nv..
   1fe88:	46be bf6e 31a0 bebb 21eb bf6e ecb6 bebb     .Fn..1...!n.....
   1fe98:	fcf2 bf6d a7af bebc d7d5 bf6d 628b bebd     ..m.......m..b..
   1fea8:	b293 bf6d 1d4a bebe 8d2d bf6d d7eb bebe     ..m.J...-.m.....
   1feb8:	67a1 bf6d 926f bebf 41f2 bf6d 4cd5 bec0     .gm.o....Am..L..
   1fec8:	1c1d bf6d 071e bec1 f624 bf6c c148 bec1     ..m.....$.l.H...
   1fed8:	d007 bf6c 7b55 bec2 a9c5 bf6c 3544 bec3     ..l.U{....l.D5..
   1fee8:	835e bf6c ef15 bec3 5cd4 bf6c a8c8 bec4     ^.l......\l.....
   1fef8:	3624 bf6c 625c bec5 0f50 bf6c 1bd2 bec6     $6l.\b..P.l.....
   1ff08:	e858 bf6b d529 bec6 c13b bf6b 8e62 bec7     X.k.)...;.k.b...
   1ff18:	99fb bf6b 477c bec8 7295 bf6b 0077 bec9     ..k.|G...rk.w...
   1ff28:	4b0c bf6b b953 bec9 235e bf6b 7210 beca     .Kk.S...^#k..r..
   1ff38:	fb8c bf6a 2aae becb d395 bf6a e32c becb     ..j..*....j.,...
   1ff48:	ab7b bf6a 9b8b becc 833c bf6a 53ca becd     {.j.....<.j..S..
   1ff58:	5ad9 bf6a 0bea bece 3252 bf6a c3ea bece     .Zj.....R2j.....
   1ff68:	09a7 bf6a 7bca becf e0d7 bf69 338a bed0     ..j..{....i..3..
   1ff78:	b7e4 bf69 eb2a bed0 8ecc bf69 a2aa bed1     ..i.*.....i.....
   1ff88:	6591 bf69 5a09 bed2 3c32 bf69 1148 bed3     .ei..Z..2<i.H...
   1ff98:	12ae bf69 c867 bed3 e907 bf68 7f64 bed4     ..i.g.....h.d...
   1ffa8:	bf3c bf68 3641 bed5 954c bf68 ecfd bed5     <.h.A6..L.h.....
   1ffb8:	6b39 bf68 a399 bed6 4103 bf68 5a13 bed7     9kh......Ah..Z..
   1ffc8:	16a8 bf68 106b bed8 ec29 bf67 c6a3 bed8     ..h.k...).g.....
   1ffd8:	c187 bf67 7cb9 bed9 96c1 bf67 32ad beda     ..g..|....g..2..
   1ffe8:	6bd8 bf67 e880 beda 40ca bf67 9e31 bedb     .kg......@g.1...
   1fff8:	1599 bf67 53c1 bedc ea45 bf66 092e bedd     ..g..S..E.f.....
   20008:	becc bf66 be79 bedd 9330 bf66 73a2 bede     ..f.y...0.f..s..
   20018:	6771 bf66 28a9 bedf 3b8e bf66 dd8d bedf     qgf..(...;f.....
   20028:	0f88 bf66 924f bee0 e35e bf65 46ee bee1     ..f.O...^.e..F..
   20038:	b710 bf65 fb6a bee1 8aa0 bf65 afc4 bee2     ..e.j.....e.....
   20048:	5e0b bf65 63fa bee3 3154 bf65 180e bee4     .^e..c..T1e.....
   20058:	0479 bf65 cbfe bee4 d77b bf64 7fcb bee5     y.e.....{.d.....
   20068:	aa59 bf64 3375 bee6 7d14 bf64 e6fb bee6     Y.d.u3...}d.....
   20078:	4fac bf64 9a5d bee7 2221 bf64 4d9c bee8     .Od.]...!"d..M..
   20088:	f473 bf63 00b7 bee9 c6a1 bf63 b3ae bee9     s.c.......c.....
   20098:	98ac bf63 6681 beea 6a95 bf63 1930 beeb     ..c..f...jc.0...
   200a8:	3c5a bf63 cbbb beeb 0dfc bf63 7e21 beec     Z<c.......c.!~..
   200b8:	df7b bf62 3063 beed b0d7 bf62 e280 beed     {.b.c0....b.....
   200c8:	8210 bf62 9479 beee 5326 bf62 464c beef     ..b.y...&Sb.LF..
   200d8:	241a bf62 f7fb beef f4ea bf61 a985 bef0     .$b.......a.....
   200e8:	c598 bf61 5aea bef1 9622 bf61 0c29 bef2     ..a..Z..".a.)...
   200f8:	668a bf61 bd43 bef2 36d0 bf61 6e38 bef3     .fa.C....6a.8n..
   20108:	06f2 bf61 1f07 bef4 d6f2 bf60 cfb1 bef4     ..a.......`.....
   20118:	a6cf bf60 8035 bef5 7689 bf60 3093 bef6     ..`.5....v`..0..
   20128:	4621 bf60 e0cb bef6 1596 bf60 90dc bef7     !F`.......`.....
   20138:	e4e9 bf5f 40c8 bef8 b419 bf5f f08e bef8     .._..@...._.....
   20148:	8327 bf5f a02d bef9 5212 bf5f 4fa5 befa     '._.-....R_..O..
   20158:	20db bf5f fef7 befa ef81 bf5e ae22 befb     . _.......^."...
   20168:	be05 bf5e 5d27 befc 8c67 bf5e 0c04 befd     ..^.']..g.^.....
   20178:	5aa6 bf5e babb befd 28c3 bf5e 694a befe     .Z^......(^.Ji..
   20188:	f6be bf5d 17b2 beff c497 bf5d c5f3 beff     ..].......].....
   20198:	924d bf5d 3a06 bf00 5fe1 bf5d 90ff bf00     M.]..:..._].....
   201a8:	2d53 bf5d e7e4 bf00 faa3 bf5c 3eb5 bf01     S-].......\..>..
   201b8:	c7d1 bf5c 9573 bf01 94dd bf5c ec1c bf01     ..\.s.....\.....
   201c8:	61c7 bf5c 42b1 bf02 2e8e bf5c 9932 bf02     .a\..B....\.2...
   201d8:	fb34 bf5b ef9f bf02 c7b8 bf5b 45f8 bf03     4.[.......[..E..
   201e8:	941a bf5b 9c3d bf03 605a bf5b f26d bf03     ..[.=...Z`[.m...
   201f8:	2c79 bf5b 4889 bf04 f875 bf5a 9e91 bf04     y,[..H..u.Z.....
   20208:	c450 bf5a f484 bf04 9009 bf5a 4a62 bf05     P.Z.......Z.bJ..
   20218:	5ba0 bf5a a02c bf05 2716 bf5a f5e2 bf05     .[Z.,....'Z.....
   20228:	f26a bf59 4b82 bf06 bd9c bf59 a10e bf06     j.Y..K....Y.....
   20238:	88ad bf59 f686 bf06 539c bf59 4be8 bf07     ..Y......SY..K..
   20248:	1e6a bf59 a136 bf07 e916 bf58 f66f bf07     j.Y.6.....X.o...
   20258:	b3a1 bf58 4b92 bf08 7e0b bf58 a0a1 bf08     ..X..K...~X.....
   20268:	4853 bf58 f59b bf08 1279 bf58 4a7f bf09     SHX.....y.X..J..
   20278:	dc7f bf57 9f4e bf09 a663 bf57 f409 bf09     ..W.N...c.W.....
   20288:	7026 bf57 48ad bf0a 39c7 bf57 9d3d bf0a     &pW..H...9W.=...
   20298:	0348 bf57 f1b7 bf0a cca7 bf56 461c bf0b     H.W.......V..F..
   202a8:	95e5 bf56 9a6b bf0b 5f02 bf56 eea5 bf0b     ..V.k...._V.....
   202b8:	27fe bf56 42c9 bf0c f0d9 bf55 96d7 bf0c     .'V..B....U.....
   202c8:	b993 bf55 ead0 bf0c 822c bf55 3eb3 bf0d     ..U.....,.U..>..
   202d8:	4aa4 bf55 9281 bf0d 12fb bf55 e638 bf0d     .JU.......U.8...
   202e8:	db31 bf54 39da bf0e a347 bf54 8d65 bf0e     1.T..9..G.T.e...
   202f8:	6b3b bf54 e0db bf0e 330f bf54 343b bf0f     ;kT......3T.;4..
   20308:	fac3 bf53 8784 bf0f c255 bf53 dab8 bf0f     ..S.....U.S.....
   20318:	89c7 bf53 2dd5 bf10 5118 bf53 80dc bf10     ..S..-...QS.....
   20328:	1849 bf53 d3cd bf10 df59 bf52 26a7 bf11     I.S.....Y.R..&..
   20338:	a649 bf52 796b bf11 6d18 bf52 cc19 bf11     I.R.ky...mR.....
   20348:	33c6 bf52 1eb0 bf12 fa54 bf51 7130 bf12     .3R.....T.Q.0q..
   20358:	c0c2 bf51 c39a bf12 8710 bf51 15ee bf13     ..Q.......Q.....
   20368:	4d3d bf51 682a bf13 134a bf51 ba50 bf13     =MQ.*h..J.Q.P...
   20378:	d937 bf50 0c5f bf14 9f03 bf50 5e58 bf14     7.P._.....P.X^..
   20388:	64af bf50 b039 bf14 2a3b bf50 0204 bf15     .dP.9...;*P.....
   20398:	efa8 bf4f 53b7 bf15 b4f4 bf4f a554 bf15     ..O..S....O.T...
   203a8:	7a1f bf4f f6d9 bf15 3f2b bf4f 4847 bf16     .zO.....+?O.GH..
   203b8:	0417 bf4f 999f bf16 c8e4 bf4e eade bf16     ..O.......N.....
   203c8:	8d90 bf4e 3c07 bf17 521c bf4e 8d18 bf17     ..N..<...RN.....
   203d8:	1689 bf4e de12 bf17 dad5 bf4d 2ef5 bf18     ..N.......M.....
   203e8:	9f02 bf4d 7fc0 bf18 6310 bf4d d073 bf18     ..M......cM.s...
   203f8:	26fd bf4d 210f bf19 eacb bf4c 7194 bf19     .&M..!....L..q..
   20408:	ae79 bf4c c200 bf19 7208 bf4c 1255 bf1a     y.L......rL.U...
   20418:	3578 bf4c 6293 bf1a f8c7 bf4b b2b8 bf1a     x5L..b....K.....
   20428:	bbf8 bf4b 02c6 bf1b 7f09 bf4b 52bb bf1b     ..K.......K..R..
   20438:	41fa bf4b a299 bf1b 04cc bf4b f25f bf1b     .AK.......K._...
   20448:	c77f bf4a 420c bf1c 8a13 bf4a 91a2 bf1c     ..J..B....J.....
   20458:	4c87 bf4a e11f bf1c 0edc bf4a 3084 bf1d     .LJ.......J..0..
   20468:	d112 bf49 7fd1 bf1d 9329 bf49 cf06 bf1d     ..I.....).I.....
   20478:	5521 bf49 1e22 bf1e 16fa bf49 6d26 bf1e     !UI.".....I.&m..
   20488:	d8b3 bf48 bc12 bf1e 9a4e bf48 0ae5 bf1f     ..H.....N.H.....
   20498:	5bca bf48 599f bf1f 1d27 bf48 a841 bf1f     .[H..Y..'.H.A...
   204a8:	de65 bf47 f6cb bf1f 9f84 bf47 453b bf20     e.G.......G.;E .
   204b8:	6085 bf47 9393 bf20 2167 bf47 e1d2 bf20     .`G... .g!G... .
   204c8:	e22a bf46 2ff9 bf21 a2ce bf46 7e06 bf21     *.F../!...F..~!.
   204d8:	6354 bf46 cbfb bf21 23bb bf46 19d7 bf22     TcF...!..#F...".
   204e8:	e403 bf45 6799 bf22 a42d bf45 b543 bf22     ..E..g".-.E.C.".
   204f8:	6439 bf45 02d3 bf23 2426 bf45 504b bf23     9dE...#.&$E.KP#.
   20508:	e3f5 bf44 9da9 bf23 a3a5 bf44 eaee bf23     ..D...#...D...#.
   20518:	6337 bf44 381a bf24 22ab bf44 852c bf24     7cD..8$.."D.,.$.
   20528:	e200 bf43 d225 bf24 a138 bf43 1f04 bf25     ..C.%.$.8.C...%.
   20538:	6051 bf43 6bcb bf25 1f4c bf43 b877 bf25     Q`C..k%.L.C.w.%.
   20548:	de29 bf42 050a bf26 9ce8 bf42 5184 bf26     ).B...&...B..Q&.
   20558:	5b89 bf42 9de3 bf26 1a0b bf42 ea2a bf26     .[B...&...B.*.&.
   20568:	d870 bf41 3656 bf27 96b7 bf41 8268 bf27     p.A.V6'...A.h.'.
   20578:	54e1 bf41 ce61 bf27 12ec bf41 1a40 bf28     .TA.a.'...A.@.(.
   20588:	d0da bf40 6605 bf28 8ea9 bf40 b1b0 bf28     ..@..f(...@...(.
   20598:	4c5c bf40 fd41 bf28 09f0 bf40 48b8 bf29     \L@.A.(...@..H).
   205a8:	c767 bf3f 9415 bf29 84c0 bf3f df57 bf29     g.?...)...?.W.).
   205b8:	41fc bf3f 2a80 bf2a ff1b bf3e 758e bf2a     .A?..**...>..u*.
   205c8:	bc1b bf3e c082 bf2a 78ff bf3e 0b5b bf2b     ..>...*..x>.[.+.
   205d8:	35c5 bf3e 561b bf2b f26e bf3d a0bf bf2b     .5>..V+.n.=...+.
   205e8:	aef9 bf3d eb4a bf2b 6b67 bf3d 35b9 bf2c     ..=.J.+.gk=..5,.
   205f8:	27b8 bf3d 800f bf2c e3ec bf3c ca49 bf2c     .'=...,...<.I.,.
   20608:	a003 bf3c 1469 bf2d 5bfc bf3c 5e6f bf2d     ..<.i.-..[<.o^-.
   20618:	17d9 bf3c a859 bf2d d398 bf3b f229 bf2d     ..<.Y.-...;.).-.
   20628:	8f3b bf3b 3bde bf2e 4ac1 bf3b 8578 bf2e     ;.;..;...J;.x...
   20638:	0629 bf3b cef7 bf2e c175 bf3a 185b bf2f     ).;.....u.:.[./.
   20648:	7ca4 bf3a 61a5 bf2f 37b7 bf3a aad3 bf2f     .|:..a/..7:.../.
   20658:	f2ac bf39 f3e6 bf2f ad85 bf39 3cde bf30     ..9.../...9..<0.
   20668:	6842 bf39 85bb bf30 22e1 bf39 ce7c bf30     Bh9...0.."9.|.0.
   20678:	dd65 bf38 1722 bf31 97cb bf38 5fad bf31     e.8.".1...8.._1.
   20688:	5216 bf38 a81d bf31 0c43 bf38 f071 bf31     .R8...1.C.8.q.1.
   20698:	c655 bf37 38aa bf32 804a bf37 80c7 bf32     U.7..82.J.7...2.
   206a8:	3a23 bf37 c8c9 bf32 f3df bf36 10af bf33     #:7...2...6...3.
   206b8:	ad7f bf36 587a bf33 6704 bf36 a029 bf33     ..6.zX3..g6.).3.
   206c8:	206c bf36 e7bc bf33 d9b8 bf35 2f34 bf34     l 6...3...5.4/4.
   206d8:	92e7 bf35 768f bf34 4bfb bf35 bdcf bf34     ..5..v4..K5...4.
   206e8:	04f3 bf35 04f3 bf35 bdcf bf34 4bfb bf35     ..5...5...4..K5.
   206f8:	768f bf34 92e7 bf35 2f34 bf34 d9b8 bf35     .v4...5.4/4...5.
   20708:	e7bc bf33 206c bf36 a029 bf33 6704 bf36     ..3.l 6.).3..g6.
   20718:	587a bf33 ad7f bf36 10af bf33 f3df bf36     zX3...6...3...6.
   20728:	c8c9 bf32 3a23 bf37 80c7 bf32 804a bf37     ..2.#:7...2.J.7.
   20738:	38aa bf32 c655 bf37 f071 bf31 0c43 bf38     .82.U.7.q.1.C.8.
   20748:	a81d bf31 5216 bf38 5fad bf31 97cb bf38     ..1..R8.._1...8.
   20758:	1722 bf31 dd65 bf38 ce7c bf30 22e1 bf39     ".1.e.8.|.0.."9.
   20768:	85bb bf30 6842 bf39 3cde bf30 ad85 bf39     ..0.Bh9..<0...9.
   20778:	f3e6 bf2f f2ac bf39 aad3 bf2f 37b7 bf3a     ../...9.../..7:.
   20788:	61a5 bf2f 7ca4 bf3a 185b bf2f c175 bf3a     .a/..|:.[./.u.:.
   20798:	cef7 bf2e 0629 bf3b 8578 bf2e 4ac1 bf3b     ....).;.x....J;.
   207a8:	3bde bf2e 8f3b bf3b f229 bf2d d398 bf3b     .;..;.;.).-...;.
   207b8:	a859 bf2d 17d9 bf3c 5e6f bf2d 5bfc bf3c     Y.-...<.o^-..[<.
   207c8:	1469 bf2d a003 bf3c ca49 bf2c e3ec bf3c     i.-...<.I.,...<.
   207d8:	800f bf2c 27b8 bf3d 35b9 bf2c 6b67 bf3d     ..,..'=..5,.gk=.
   207e8:	eb4a bf2b aef9 bf3d a0bf bf2b f26e bf3d     J.+...=...+.n.=.
   207f8:	561b bf2b 35c5 bf3e 0b5b bf2b 78ff bf3e     .V+..5>.[.+..x>.
   20808:	c082 bf2a bc1b bf3e 758e bf2a ff1b bf3e     ..*...>..u*...>.
   20818:	2a80 bf2a 41fc bf3f df57 bf29 84c0 bf3f     .**..A?.W.)...?.
   20828:	9415 bf29 c767 bf3f 48b8 bf29 09f0 bf40     ..).g.?..H)...@.
   20838:	fd41 bf28 4c5c bf40 b1b0 bf28 8ea9 bf40     A.(.\L@...(...@.
   20848:	6605 bf28 d0da bf40 1a40 bf28 12ec bf41     .f(...@.@.(...A.
   20858:	ce61 bf27 54e1 bf41 8268 bf27 96b7 bf41     a.'..TA.h.'...A.
   20868:	3656 bf27 d870 bf41 ea2a bf26 1a0b bf42     V6'.p.A.*.&...B.
   20878:	9de3 bf26 5b89 bf42 5184 bf26 9ce8 bf42     ..&..[B..Q&...B.
   20888:	050a bf26 de29 bf42 b877 bf25 1f4c bf43     ..&.).B.w.%.L.C.
   20898:	6bcb bf25 6051 bf43 1f04 bf25 a138 bf43     .k%.Q`C...%.8.C.
   208a8:	d225 bf24 e200 bf43 852c bf24 22ab bf44     %.$...C.,.$.."D.
   208b8:	381a bf24 6337 bf44 eaee bf23 a3a5 bf44     .8$.7cD...#...D.
   208c8:	9da9 bf23 e3f5 bf44 504b bf23 2426 bf45     ..#...D.KP#.&$E.
   208d8:	02d3 bf23 6439 bf45 b543 bf22 a42d bf45     ..#.9dE.C.".-.E.
   208e8:	6799 bf22 e403 bf45 19d7 bf22 23bb bf46     .g"...E..."..#F.
   208f8:	cbfb bf21 6354 bf46 7e06 bf21 a2ce bf46     ..!.TcF..~!...F.
   20908:	2ff9 bf21 e22a bf46 e1d2 bf20 2167 bf47     ./!.*.F... .g!G.
   20918:	9393 bf20 6085 bf47 453b bf20 9f84 bf47     .. ..`G.;E ...G.
   20928:	f6cb bf1f de65 bf47 a841 bf1f 1d27 bf48     ....e.G.A...'.H.
   20938:	599f bf1f 5bca bf48 0ae5 bf1f 9a4e bf48     .Y...[H.....N.H.
   20948:	bc12 bf1e d8b3 bf48 6d26 bf1e 16fa bf49     ......H.&m....I.
   20958:	1e22 bf1e 5521 bf49 cf06 bf1d 9329 bf49     "...!UI.....).I.
   20968:	7fd1 bf1d d112 bf49 3084 bf1d 0edc bf4a     ......I..0....J.
   20978:	e11f bf1c 4c87 bf4a 91a2 bf1c 8a13 bf4a     .....LJ.......J.
   20988:	420c bf1c c77f bf4a f25f bf1b 04cc bf4b     .B....J._.....K.
   20998:	a299 bf1b 41fa bf4b 52bb bf1b 7f09 bf4b     .....AK..R....K.
   209a8:	02c6 bf1b bbf8 bf4b b2b8 bf1a f8c7 bf4b     ......K.......K.
   209b8:	6293 bf1a 3578 bf4c 1255 bf1a 7208 bf4c     .b..x5L.U....rL.
   209c8:	c200 bf19 ae79 bf4c 7194 bf19 eacb bf4c     ....y.L..q....L.
   209d8:	210f bf19 26fd bf4d d073 bf18 6310 bf4d     .!...&M.s....cM.
   209e8:	7fc0 bf18 9f02 bf4d 2ef5 bf18 dad5 bf4d     ......M.......M.
   209f8:	de12 bf17 1689 bf4e 8d18 bf17 521c bf4e     ......N......RN.
   20a08:	3c07 bf17 8d90 bf4e eade bf16 c8e4 bf4e     .<....N.......N.
   20a18:	999f bf16 0417 bf4f 4847 bf16 3f2b bf4f     ......O.GH..+?O.
   20a28:	f6d9 bf15 7a1f bf4f a554 bf15 b4f4 bf4f     .....zO.T.....O.
   20a38:	53b7 bf15 efa8 bf4f 0204 bf15 2a3b bf50     .S....O.....;*P.
   20a48:	b039 bf14 64af bf50 5e58 bf14 9f03 bf50     9....dP.X^....P.
   20a58:	0c5f bf14 d937 bf50 ba50 bf13 134a bf51     _...7.P.P...J.Q.
   20a68:	682a bf13 4d3d bf51 15ee bf13 8710 bf51     *h..=MQ.......Q.
   20a78:	c39a bf12 c0c2 bf51 7130 bf12 fa54 bf51     ......Q.0q..T.Q.
   20a88:	1eb0 bf12 33c6 bf52 cc19 bf11 6d18 bf52     .....3R......mR.
   20a98:	796b bf11 a649 bf52 26a7 bf11 df59 bf52     ky..I.R..&..Y.R.
   20aa8:	d3cd bf10 1849 bf53 80dc bf10 5118 bf53     ....I.S......QS.
   20ab8:	2dd5 bf10 89c7 bf53 dab8 bf0f c255 bf53     .-....S.....U.S.
   20ac8:	8784 bf0f fac3 bf53 343b bf0f 330f bf54     ......S.;4...3T.
   20ad8:	e0db bf0e 6b3b bf54 8d65 bf0e a347 bf54     ....;kT.e...G.T.
   20ae8:	39da bf0e db31 bf54 e638 bf0d 12fb bf55     .9..1.T.8.....U.
   20af8:	9281 bf0d 4aa4 bf55 3eb3 bf0d 822c bf55     .....JU..>..,.U.
   20b08:	ead0 bf0c b993 bf55 96d7 bf0c f0d9 bf55     ......U.......U.
   20b18:	42c9 bf0c 27fe bf56 eea5 bf0b 5f02 bf56     .B...'V......_V.
   20b28:	9a6b bf0b 95e5 bf56 461c bf0b cca7 bf56     k.....V..F....V.
   20b38:	f1b7 bf0a 0348 bf57 9d3d bf0a 39c7 bf57     ....H.W.=....9W.
   20b48:	48ad bf0a 7026 bf57 f409 bf09 a663 bf57     .H..&pW.....c.W.
   20b58:	9f4e bf09 dc7f bf57 4a7f bf09 1279 bf58     N.....W..J..y.X.
   20b68:	f59b bf08 4853 bf58 a0a1 bf08 7e0b bf58     ....SHX......~X.
   20b78:	4b92 bf08 b3a1 bf58 f66f bf07 e916 bf58     .K....X.o.....X.
   20b88:	a136 bf07 1e6a bf59 4be8 bf07 539c bf59     6...j.Y..K...SY.
   20b98:	f686 bf06 88ad bf59 a10e bf06 bd9c bf59     ......Y.......Y.
   20ba8:	4b82 bf06 f26a bf59 f5e2 bf05 2716 bf5a     .K..j.Y......'Z.
   20bb8:	a02c bf05 5ba0 bf5a 4a62 bf05 9009 bf5a     ,....[Z.bJ....Z.
   20bc8:	f484 bf04 c450 bf5a 9e91 bf04 f875 bf5a     ....P.Z.....u.Z.
   20bd8:	4889 bf04 2c79 bf5b f26d bf03 605a bf5b     .H..y,[.m...Z`[.
   20be8:	9c3d bf03 941a bf5b 45f8 bf03 c7b8 bf5b     =.....[..E....[.
   20bf8:	ef9f bf02 fb34 bf5b 9932 bf02 2e8e bf5c     ....4.[.2.....\.
   20c08:	42b1 bf02 61c7 bf5c ec1c bf01 94dd bf5c     .B...a\.......\.
   20c18:	9573 bf01 c7d1 bf5c 3eb5 bf01 faa3 bf5c     s.....\..>....\.
   20c28:	e7e4 bf00 2d53 bf5d 90ff bf00 5fe1 bf5d     ....S-]......_].
   20c38:	3a06 bf00 924d bf5d c5f3 beff c497 bf5d     .:..M.].......].
   20c48:	17b2 beff f6be bf5d 694a befe 28c3 bf5e     ......].Ji...(^.
   20c58:	babb befd 5aa6 bf5e 0c04 befd 8c67 bf5e     .....Z^.....g.^.
   20c68:	5d27 befc be05 bf5e ae22 befb ef81 bf5e     ']....^.".....^.
   20c78:	fef7 befa 20db bf5f 4fa5 befa 5212 bf5f     ..... _..O...R_.
   20c88:	a02d bef9 8327 bf5f f08e bef8 b419 bf5f     -...'._......._.
   20c98:	40c8 bef8 e4e9 bf5f 90dc bef7 1596 bf60     .@...._.......`.
   20ca8:	e0cb bef6 4621 bf60 3093 bef6 7689 bf60     ....!F`..0...v`.
   20cb8:	8035 bef5 a6cf bf60 cfb1 bef4 d6f2 bf60     5.....`.......`.
   20cc8:	1f07 bef4 06f2 bf61 6e38 bef3 36d0 bf61     ......a.8n...6a.
   20cd8:	bd43 bef2 668a bf61 0c29 bef2 9622 bf61     C....fa.)...".a.
   20ce8:	5aea bef1 c598 bf61 a985 bef0 f4ea bf61     .Z....a.......a.
   20cf8:	f7fb beef 241a bf62 464c beef 5326 bf62     .....$b.LF..&Sb.
   20d08:	9479 beee 8210 bf62 e280 beed b0d7 bf62     y.....b.......b.
   20d18:	3063 beed df7b bf62 7e21 beec 0dfc bf63     c0..{.b.!~....c.
   20d28:	cbbb beeb 3c5a bf63 1930 beeb 6a95 bf63     ....Z<c.0....jc.
   20d38:	6681 beea 98ac bf63 b3ae bee9 c6a1 bf63     .f....c.......c.
   20d48:	00b7 bee9 f473 bf63 4d9c bee8 2221 bf64     ....s.c..M..!"d.
   20d58:	9a5d bee7 4fac bf64 e6fb bee6 7d14 bf64     ]....Od......}d.
   20d68:	3375 bee6 aa59 bf64 7fcb bee5 d77b bf64     u3..Y.d.....{.d.
   20d78:	cbfe bee4 0479 bf65 180e bee4 3154 bf65     ....y.e.....T1e.
   20d88:	63fa bee3 5e0b bf65 afc4 bee2 8aa0 bf65     .c...^e.......e.
   20d98:	fb6a bee1 b710 bf65 46ee bee1 e35e bf65     j.....e..F..^.e.
   20da8:	924f bee0 0f88 bf66 dd8d bedf 3b8e bf66     O.....f......;f.
   20db8:	28a9 bedf 6771 bf66 73a2 bede 9330 bf66     .(..qgf..s..0.f.
   20dc8:	be79 bedd becc bf66 092e bedd ea45 bf66     y.....f.....E.f.
   20dd8:	53c1 bedc 1599 bf67 9e31 bedb 40ca bf67     .S....g.1....@g.
   20de8:	e880 beda 6bd8 bf67 32ad beda 96c1 bf67     .....kg..2....g.
   20df8:	7cb9 bed9 c187 bf67 c6a3 bed8 ec29 bf67     .|....g.....).g.
   20e08:	106b bed8 16a8 bf68 5a13 bed7 4103 bf68     k.....h..Z...Ah.
   20e18:	a399 bed6 6b39 bf68 ecfd bed5 954c bf68     ....9kh.....L.h.
   20e28:	3641 bed5 bf3c bf68 7f64 bed4 e907 bf68     A6..<.h.d.....h.
   20e38:	c867 bed3 12ae bf69 1148 bed3 3c32 bf69     g.....i.H...2<i.
   20e48:	5a09 bed2 6591 bf69 a2aa bed1 8ecc bf69     .Z...ei.......i.
   20e58:	eb2a bed0 b7e4 bf69 338a bed0 e0d7 bf69     *.....i..3....i.
   20e68:	7bca becf 09a7 bf6a c3ea bece 3252 bf6a     .{....j.....R2j.
   20e78:	0bea bece 5ad9 bf6a 53ca becd 833c bf6a     .....Zj..S..<.j.
   20e88:	9b8b becc ab7b bf6a e32c becb d395 bf6a     ....{.j.,.....j.
   20e98:	2aae becb fb8c bf6a 7210 beca 235e bf6b     .*....j..r..^#k.
   20ea8:	b953 bec9 4b0c bf6b 0077 bec9 7295 bf6b     S....Kk.w....rk.
   20eb8:	477c bec8 99fb bf6b 8e62 bec7 c13b bf6b     |G....k.b...;.k.
   20ec8:	d529 bec6 e858 bf6b 1bd2 bec6 0f50 bf6c     )...X.k.....P.l.
   20ed8:	625c bec5 3624 bf6c a8c8 bec4 5cd4 bf6c     \b..$6l......\l.
   20ee8:	ef15 bec3 835e bf6c 3544 bec3 a9c5 bf6c     ....^.l.D5....l.
   20ef8:	7b55 bec2 d007 bf6c c148 bec1 f624 bf6c     U{....l.H...$.l.
   20f08:	071e bec1 1c1d bf6d 4cd5 bec0 41f2 bf6d     ......m..L...Am.
   20f18:	926f bebf 67a1 bf6d d7eb bebe 8d2d bf6d     o....gm.....-.m.
   20f28:	1d4a bebe b293 bf6d 628b bebd d7d5 bf6d     J.....m..b....m.
   20f38:	a7af bebc fcf2 bf6d ecb6 bebb 21eb bf6e     ......m......!n.
   20f48:	31a0 bebb 46be bf6e 766e beba 6b6d bf6e     .1...Fn.nv..mkn.
   20f58:	bb1e beb9 8ff8 bf6e ffb2 beb8 b45d bf6e     ......n.....].n.
   20f68:	442a beb8 d89e bf6e 8884 beb7 fcba bf6e     *D....n.......n.
   20f78:	ccc3 beb6 20b0 bf6f 10e6 beb6 4483 bf6f     ..... o......Do.
   20f88:	54ec beb5 6830 bf6f 98d6 beb4 8bb8 bf6f     .T..0ho.......o.
   20f98:	dca5 beb3 af1b bf6f 2058 beb3 d25a bf6f     ......o.X ..Z.o.
   20fa8:	63ef beb2 f573 bf6f a76b beb1 1867 bf70     .c..s.o.k...g.p.
   20fb8:	eacb beb0 3b37 bf70 2e10 beb0 5de1 bf70     ....7;p......]p.
   20fc8:	713a beaf 8066 bf70 b449 beae a2c6 bf70     :q..f.p.I.....p.
   20fd8:	f73c bead c501 bf70 3a15 bead e717 bf70     <.....p..:....p.
   20fe8:	7cd4 beac 0908 bf71 bf77 beab 2ad4 bf71     .|....q.w....*q.
   20ff8:	0201 beab 4c7a bf71 446f beaa 6dfb bf71     ....zLq.oD...mq.
   21008:	86c4 bea9 8f57 bf71 c8fe bea8 b08e bf71     ....W.q.......q.
   21018:	0b1f bea8 d19f bf71 4d25 bea7 f28c bf71     ......q.%M....q.
   21028:	8f12 bea6 1352 bf72 d0e5 bea5 33f4 bf72     ....R.r......3r.
   21038:	129f bea5 5470 bf72 543f bea4 74c7 bf72     ....pTr.?T...tr.
   21048:	95c5 bea3 94f8 bf72 d733 bea2 b504 bf72     ......r.3.....r.
   21058:	1887 bea2 d4eb bf72 59c2 bea1 f4ac bf72     ......r..Y....r.
   21068:	9ae5 bea0 1447 bf73 dbee be9f 33be bf73     ....G.s......3s.
   21078:	1cdf be9f 530e bf73 5db8 be9e 7239 bf73     .....Ss..]..9rs.
   21088:	9e78 be9d 913f bf73 df20 be9c b01f bf73     x...?.s. .....s.
   21098:	1faf be9c ced9 bf73 6027 be9b ed6e bf73     ......s.'`..n.s.
   210a8:	a086 be9a 0bdd bf74 e0ce be99 2a27 bf74     ......t.....'*t.
   210b8:	20fe be99 484b bf74 6116 be98 6649 bf74     . ..KHt..a..Ift.
   210c8:	a117 be97 8422 bf74 e100 be96 a1d5 bf74     ....".t.......t.
   210d8:	20d2 be96 bf62 bf74 608d be95 dcc9 bf74     . ..b.t..`....t.
   210e8:	a031 be94 fa0b bf74 dfbf be93 1727 bf75     1.....t.....'.u.
   210f8:	1f35 be93 341d bf75 5e94 be92 50ed bf75     5....4u..^...Pu.
   21108:	9ddd be91 6d97 bf75 dd10 be90 8a1c bf75     .....mu.......u.
   21118:	1c2c be90 a67b bf75 5b32 be8f c2b3 bf75     ,...{.u.2[....u.
   21128:	9a22 be8e dec6 bf75 d8fc be8d fab3 bf75     ".....u.......u.
   21138:	17c0 be8d 167a bf76 566e be8c 321b bf76     ....z.v.nV...2v.
   21148:	9507 be8b 4d97 bf76 d38a be8a 68ec bf76     .....Mv......hv.
   21158:	11f7 be8a 841b bf76 5050 be89 9f24 bf76     ......v.PP..$.v.
   21168:	8e93 be88 ba07 bf76 ccc1 be87 d4c4 bf76     ......v.......v.
   21178:	0ada be87 ef5b bf76 48df be86 09cc bf77     ....[.v..H....w.
   21188:	86ce be85 2417 bf77 c4aa be84 3e3c bf77     .....$w.....<>w.
   21198:	0270 be84 583a bf77 4022 be83 7213 bf77     p...:Xw."@...rw.
   211a8:	7dc0 be82 8bc5 bf77 bb4a be81 a551 bf77     .}....w.J...Q.w.
   211b8:	f8c0 be80 beb7 bf77 3622 be80 d7f7 bf77     ......w."6....w.
   211c8:	e6e1 be7e f110 bf77 6156 be7d 0a04 bf78     ..~...w.Va}...x.
   211d8:	dba4 be7b 22d1 bf78 55cb be7a 3b77 bf78     ..{.."x..Uz.w;x.
   211e8:	cfcc be78 53f8 bf78 49a6 be77 6c52 bf78     ..x..Sx..Iw.Rlx.
   211f8:	c35a be75 8486 bf78 3ce8 be74 9c93 bf78     Z.u...x..<t...x.
   21208:	b651 be72 b47b bf78 2f94 be71 cc3b bf78     Q.r.{.x../q.;.x.
   21218:	a8b2 be6f e3d6 bf78 21ab be6e fb4a bf78     ..o...x..!n.J.x.
   21228:	9a7f be6c 1298 bf79 132f be6b 29bf bf79     ..l...y./.k..)y.
   21238:	8bba be69 40c0 bf79 0422 be68 579a bf79     ..i..@y.".h..Wy.
   21248:	7c66 be66 6e4e bf79 f486 be64 84dc bf79     f|f.Nny...d...y.
   21258:	6c83 be63 9b43 bf79 e45c be61 b183 bf79     .lc.C.y.\.a...y.
   21268:	5c13 be60 c79d bf79 d3a8 be5e dd91 bf79     .\`...y...^...y.
   21278:	4b1a be5d f35e bf79 c26a be5b 0904 bf7a     .K].^.y.j.[...z.
   21288:	3997 be5a 1e84 bf7a b0a4 be58 33dd bf7a     .9Z...z...X..3z.
   21298:	278f be57 4910 bf7a 9e58 be55 5e1c bf7a     .'W..Iz.X.U..^z.
   212a8:	1501 be54 7302 bf7a 8b89 be52 87c1 bf7a     ..T..sz...R...z.
   212b8:	01f1 be51 9c59 bf7a 7838 be4f b0cb bf7a     ..Q.Y.z.8xO...z.
   212c8:	ee60 be4d c516 bf7a 6467 be4c d93a bf7a     `.M...z.gdL.:.z.
   212d8:	da4f be4a ed37 bf7a 5018 be49 010e bf7b     O.J.7.z..PI...{.
   212e8:	c5c2 be47 14be bf7b 3b4d be46 2848 bf7b     ..G...{.M;F.H({.
   212f8:	b0b9 be44 3bab bf7b 2607 be43 4ee7 bf7b     ..D..;{..&C..N{.
   21308:	9b37 be41 61fc bf7b 1049 be40 74ea bf7b     7.A..a{.I.@..t{.
   21318:	853e be3e 87b2 bf7b fa15 be3c 9a53 bf7b     >.>...{...<.S.{.
   21328:	6ecf be3b accd bf7b e36c be39 bf20 bf7b     .n;...{.l.9. .{.
   21338:	57ec be38 d14d bf7b cc50 be36 e353 bf7b     .W8.M.{.P.6.S.{.
   21348:	4098 be35 f531 bf7b b4c4 be33 06e9 bf7c     .@5.1.{...3...|.
   21358:	28d4 be32 187a bf7c 9cc9 be30 29e5 bf7c     .(2.z.|...0..)|.
   21368:	10a2 be2f 3b28 bf7c 8461 be2d 4c44 bf7c     ../.(;|.a.-.DL|.
   21378:	f804 be2b 5d3a bf7c 6b8d be2a 6e08 bf7c     ..+.:]|..k*..n|.
   21388:	defc be28 7eb0 bf7c 5251 be27 8f31 bf7c     ..(..~|.QR'.1.|.
   21398:	c58c be25 9f8a bf7c 38ad be24 afbd bf7c     ..%...|..8$...|.
   213a8:	abb6 be22 bfc9 bf7c 1ea5 be21 cfae bf7c     .."...|...!...|.
   213b8:	917b be1f df6c bf7c 0438 be1e ef03 bf7c     {...l.|.8.....|.
   213c8:	76de be1c fe73 bf7c e96b be1a 0dbc bf7d     .v..s.|.k.....}.
   213d8:	5be0 be19 1cdd bf7d ce3d be17 2bd8 bf7d     .[....}.=....+}.
   213e8:	4083 be16 3aac bf7d b2b2 be14 4959 bf7d     .@...:}.....YI}.
   213f8:	24ca be13 57de bf7d 96cc be11 663d bf7d     .$...W}.....=f}.
   21408:	08b7 be10 7474 bf7d 7a8b be0e 8285 bf7d     ....tt}..z....}.
   21418:	ec4a be0c 906e bf7d 5df3 be0b 9e30 bf7d     J...n.}..]..0.}.
   21428:	cf86 be09 abcc bf7d 4105 be08 b940 bf7d     ......}..A..@.}.
   21438:	b26e be06 c68c bf7d 23c2 be05 d3b2 bf7d     n.....}..#....}.
   21448:	9502 be03 e0b1 bf7d 062e be02 ed88 bf7d     ......}.......}.
   21458:	7745 be00 fa38 bf7d d092 bdfd 06c2 bf7e     Ew..8.}.......~.
   21468:	b273 bdfa 1324 bf7e 942c bdf7 1f5e bf7e     s...$.~.,...^.~.
   21478:	75c0 bdf4 2b72 bf7e 572e bdf1 375e bf7e     .u..r+~..W..^7~.
   21488:	3876 bdee 4323 bf7e 199a bdeb 4ec1 bf7e     v8..#C~......N~.
   21498:	fa9a bde7 5a38 bf7e db76 bde4 6588 bf7e     ....8Z~.v....e~.
   214a8:	bc2e bde1 70b0 bf7e 9cc4 bdde 7bb1 bf7e     .....p~......{~.
   214b8:	7d37 bddb 868b bf7e 5d89 bdd8 913d bf7e     7}....~..]..=.~.
   214c8:	3db9 bdd5 9bc9 bf7e 1dc8 bdd2 a62d bf7e     .=....~.....-.~.
   214d8:	fdb7 bdce b069 bf7e dd86 bdcb ba7f bf7e     ....i.~.......~.
   214e8:	bd36 bdc8 c46d bf7e 9cc6 bdc5 ce34 bf7e     6...m.~.....4.~.
   214f8:	7c39 bdc2 d7d4 bf7e 5b8d bdbf e14c bf7e     9|....~..[..L.~.
   21508:	3ac3 bdbc ea9d bf7e 19dd bdb9 f3c7 bf7e     .:....~.......~.
   21518:	f8da bdb5 fcc9 bf7e d7bb bdb2 05a4 bf7f     ......~.........
   21528:	b680 bdaf 0e58 bf7f 952b bdac 16e4 bf7f     ....X...+.......
   21538:	73ba bda9 1f49 bf7f 5230 bda6 2787 bf7f     .s..I...0R...'..
   21548:	308c bda3 2f9d bf7f 0ecf bda0 378c bf7f     .0.../.......7..
   21558:	ecf9 bd9c 3f54 bf7f cb0a bd99 46f4 bf7f     ....T?.......F..
   21568:	a905 bd96 4e6d bf7f 86e7 bd93 55bf bf7f     ....mN.......U..
   21578:	64b4 bd90 5ce9 bf7f 426a bd8d 63ec bf7f     .d...\..jB...c..
   21588:	200a bd8a 6ac7 bf7f fd94 bd86 717b bf7f     . ...j......{q..
   21598:	db0a bd83 7808 bf7f b86c bd80 7e6d bf7f     .....x..l...m~..
   215a8:	2b74 bd7b 84ab bf7f e5e9 bd74 8ac2 bf7f     t+{.......t.....
   215b8:	a038 bd6e 90b1 bf7f 5a62 bd68 9678 bf7f     8.n.....bZh.x...
   215c8:	1469 bd62 9c18 bf7f ce4c bd5b a191 bf7f     i.b.....L.[.....
   215d8:	880e bd55 a6e3 bf7f 41af bd4f ac0d bf7f     ..U......AO.....
   215e8:	fb30 bd48 b10f bf7f b491 bd42 b5ea bf7f     0.H.......B.....
   215f8:	6dd5 bd3c ba9e bf7f 26fc bd36 bf2a bf7f     .m<......&6.*...
   21608:	e007 bd2f c38f bf7f 98f6 bd29 c7cc bf7f     ../.......).....
   21618:	51cb bd23 cbe2 bf7f 0a88 bd1d cfd1 bf7f     .Q#.............
   21628:	c32c bd16 d397 bf7f 7bb8 bd10 d737 bf7f     ,........{..7...
   21638:	342f bd0a daaf bf7f ec90 bd03 de00 bf7f     /4..............
   21648:	49ba bcfb e129 bf7f ba2c bcee e42b bf7f     .I..)...,...+...
   21658:	2a7a bce2 e705 bf7f 9aa6 bcd5 e9b8 bf7f     z*..............
   21668:	0ab0 bcc9 ec43 bf7f 7a9b bcbc eea7 bf7f     ....C....z......
   21678:	ea69 bcaf f0e3 bf7f 5a1c bca3 f2f8 bf7f     i........Z......
   21688:	c9b6 bc96 f4e6 bf7f 3938 bc8a f6ac bf7f     ........89......
   21698:	514b bc7b f84a bf7f 2fff bc62 f9c1 bf7f     KQ{.J..../b.....
   216a8:	0e90 bc49 fb11 bf7f ed02 bc2f fc39 bf7f     ..I......./.9...
   216b8:	cb58 bc16 fd39 bf7f 5330 bbfb fe13 bf7f     X...9...0S......
   216c8:	0f88 bbc9 fec4 bf7f cbc1 bb96 ff4e bf7f     ............N...
   216d8:	0fc6 bb49 ffb1 bf7f 0fd5 bac9 ffec bf7f     ..I.............

000216e8 <armBitRevTable>:
   216e8:	0400 0200 0600 0100 0500 0300 0700 0080     ................
   216f8:	0480 0280 0680 0180 0580 0380 0780 0040     ..............@.
   21708:	0440 0240 0640 0140 0540 0340 0740 00c0     @.@.@.@.@.@.@...
   21718:	04c0 02c0 06c0 01c0 05c0 03c0 07c0 0020     .............. .
   21728:	0420 0220 0620 0120 0520 0320 0720 00a0      . . . . . . ...
   21738:	04a0 02a0 06a0 01a0 05a0 03a0 07a0 0060     ..............`.
   21748:	0460 0260 0660 0160 0560 0360 0760 00e0     `.`.`.`.`.`.`...
   21758:	04e0 02e0 06e0 01e0 05e0 03e0 07e0 0010     ................
   21768:	0410 0210 0610 0110 0510 0310 0710 0090     ................
   21778:	0490 0290 0690 0190 0590 0390 0790 0050     ..............P.
   21788:	0450 0250 0650 0150 0550 0350 0750 00d0     P.P.P.P.P.P.P...
   21798:	04d0 02d0 06d0 01d0 05d0 03d0 07d0 0030     ..............0.
   217a8:	0430 0230 0630 0130 0530 0330 0730 00b0     0.0.0.0.0.0.0...
   217b8:	04b0 02b0 06b0 01b0 05b0 03b0 07b0 0070     ..............p.
   217c8:	0470 0270 0670 0170 0570 0370 0770 00f0     p.p.p.p.p.p.p...
   217d8:	04f0 02f0 06f0 01f0 05f0 03f0 07f0 0008     ................
   217e8:	0408 0208 0608 0108 0508 0308 0708 0088     ................
   217f8:	0488 0288 0688 0188 0588 0388 0788 0048     ..............H.
   21808:	0448 0248 0648 0148 0548 0348 0748 00c8     H.H.H.H.H.H.H...
   21818:	04c8 02c8 06c8 01c8 05c8 03c8 07c8 0028     ..............(.
   21828:	0428 0228 0628 0128 0528 0328 0728 00a8     (.(.(.(.(.(.(...
   21838:	04a8 02a8 06a8 01a8 05a8 03a8 07a8 0068     ..............h.
   21848:	0468 0268 0668 0168 0568 0368 0768 00e8     h.h.h.h.h.h.h...
   21858:	04e8 02e8 06e8 01e8 05e8 03e8 07e8 0018     ................
   21868:	0418 0218 0618 0118 0518 0318 0718 0098     ................
   21878:	0498 0298 0698 0198 0598 0398 0798 0058     ..............X.
   21888:	0458 0258 0658 0158 0558 0358 0758 00d8     X.X.X.X.X.X.X...
   21898:	04d8 02d8 06d8 01d8 05d8 03d8 07d8 0038     ..............8.
   218a8:	0438 0238 0638 0138 0538 0338 0738 00b8     8.8.8.8.8.8.8...
   218b8:	04b8 02b8 06b8 01b8 05b8 03b8 07b8 0078     ..............x.
   218c8:	0478 0278 0678 0178 0578 0378 0778 00f8     x.x.x.x.x.x.x...
   218d8:	04f8 02f8 06f8 01f8 05f8 03f8 07f8 0004     ................
   218e8:	0404 0204 0604 0104 0504 0304 0704 0084     ................
   218f8:	0484 0284 0684 0184 0584 0384 0784 0044     ..............D.
   21908:	0444 0244 0644 0144 0544 0344 0744 00c4     D.D.D.D.D.D.D...
   21918:	04c4 02c4 06c4 01c4 05c4 03c4 07c4 0024     ..............$.
   21928:	0424 0224 0624 0124 0524 0324 0724 00a4     $.$.$.$.$.$.$...
   21938:	04a4 02a4 06a4 01a4 05a4 03a4 07a4 0064     ..............d.
   21948:	0464 0264 0664 0164 0564 0364 0764 00e4     d.d.d.d.d.d.d...
   21958:	04e4 02e4 06e4 01e4 05e4 03e4 07e4 0014     ................
   21968:	0414 0214 0614 0114 0514 0314 0714 0094     ................
   21978:	0494 0294 0694 0194 0594 0394 0794 0054     ..............T.
   21988:	0454 0254 0654 0154 0554 0354 0754 00d4     T.T.T.T.T.T.T...
   21998:	04d4 02d4 06d4 01d4 05d4 03d4 07d4 0034     ..............4.
   219a8:	0434 0234 0634 0134 0534 0334 0734 00b4     4.4.4.4.4.4.4...
   219b8:	04b4 02b4 06b4 01b4 05b4 03b4 07b4 0074     ..............t.
   219c8:	0474 0274 0674 0174 0574 0374 0774 00f4     t.t.t.t.t.t.t...
   219d8:	04f4 02f4 06f4 01f4 05f4 03f4 07f4 000c     ................
   219e8:	040c 020c 060c 010c 050c 030c 070c 008c     ................
   219f8:	048c 028c 068c 018c 058c 038c 078c 004c     ..............L.
   21a08:	044c 024c 064c 014c 054c 034c 074c 00cc     L.L.L.L.L.L.L...
   21a18:	04cc 02cc 06cc 01cc 05cc 03cc 07cc 002c     ..............,.
   21a28:	042c 022c 062c 012c 052c 032c 072c 00ac     ,.,.,.,.,.,.,...
   21a38:	04ac 02ac 06ac 01ac 05ac 03ac 07ac 006c     ..............l.
   21a48:	046c 026c 066c 016c 056c 036c 076c 00ec     l.l.l.l.l.l.l...
   21a58:	04ec 02ec 06ec 01ec 05ec 03ec 07ec 001c     ................
   21a68:	041c 021c 061c 011c 051c 031c 071c 009c     ................
   21a78:	049c 029c 069c 019c 059c 039c 079c 005c     ..............\.
   21a88:	045c 025c 065c 015c 055c 035c 075c 00dc     \.\.\.\.\.\.\...
   21a98:	04dc 02dc 06dc 01dc 05dc 03dc 07dc 003c     ..............<.
   21aa8:	043c 023c 063c 013c 053c 033c 073c 00bc     <.<.<.<.<.<.<...
   21ab8:	04bc 02bc 06bc 01bc 05bc 03bc 07bc 007c     ..............|.
   21ac8:	047c 027c 067c 017c 057c 037c 077c 00fc     |.|.|.|.|.|.|...
   21ad8:	04fc 02fc 06fc 01fc 05fc 03fc 07fc 0002     ................
   21ae8:	0402 0202 0602 0102 0502 0302 0702 0082     ................
   21af8:	0482 0282 0682 0182 0582 0382 0782 0042     ..............B.
   21b08:	0442 0242 0642 0142 0542 0342 0742 00c2     B.B.B.B.B.B.B...
   21b18:	04c2 02c2 06c2 01c2 05c2 03c2 07c2 0022     ..............".
   21b28:	0422 0222 0622 0122 0522 0322 0722 00a2     "."."."."."."...
   21b38:	04a2 02a2 06a2 01a2 05a2 03a2 07a2 0062     ..............b.
   21b48:	0462 0262 0662 0162 0562 0362 0762 00e2     b.b.b.b.b.b.b...
   21b58:	04e2 02e2 06e2 01e2 05e2 03e2 07e2 0012     ................
   21b68:	0412 0212 0612 0112 0512 0312 0712 0092     ................
   21b78:	0492 0292 0692 0192 0592 0392 0792 0052     ..............R.
   21b88:	0452 0252 0652 0152 0552 0352 0752 00d2     R.R.R.R.R.R.R...
   21b98:	04d2 02d2 06d2 01d2 05d2 03d2 07d2 0032     ..............2.
   21ba8:	0432 0232 0632 0132 0532 0332 0732 00b2     2.2.2.2.2.2.2...
   21bb8:	04b2 02b2 06b2 01b2 05b2 03b2 07b2 0072     ..............r.
   21bc8:	0472 0272 0672 0172 0572 0372 0772 00f2     r.r.r.r.r.r.r...
   21bd8:	04f2 02f2 06f2 01f2 05f2 03f2 07f2 000a     ................
   21be8:	040a 020a 060a 010a 050a 030a 070a 008a     ................
   21bf8:	048a 028a 068a 018a 058a 038a 078a 004a     ..............J.
   21c08:	044a 024a 064a 014a 054a 034a 074a 00ca     J.J.J.J.J.J.J...
   21c18:	04ca 02ca 06ca 01ca 05ca 03ca 07ca 002a     ..............*.
   21c28:	042a 022a 062a 012a 052a 032a 072a 00aa     *.*.*.*.*.*.*...
   21c38:	04aa 02aa 06aa 01aa 05aa 03aa 07aa 006a     ..............j.
   21c48:	046a 026a 066a 016a 056a 036a 076a 00ea     j.j.j.j.j.j.j...
   21c58:	04ea 02ea 06ea 01ea 05ea 03ea 07ea 001a     ................
   21c68:	041a 021a 061a 011a 051a 031a 071a 009a     ................
   21c78:	049a 029a 069a 019a 059a 039a 079a 005a     ..............Z.
   21c88:	045a 025a 065a 015a 055a 035a 075a 00da     Z.Z.Z.Z.Z.Z.Z...
   21c98:	04da 02da 06da 01da 05da 03da 07da 003a     ..............:.
   21ca8:	043a 023a 063a 013a 053a 033a 073a 00ba     :.:.:.:.:.:.:...
   21cb8:	04ba 02ba 06ba 01ba 05ba 03ba 07ba 007a     ..............z.
   21cc8:	047a 027a 067a 017a 057a 037a 077a 00fa     z.z.z.z.z.z.z...
   21cd8:	04fa 02fa 06fa 01fa 05fa 03fa 07fa 0006     ................
   21ce8:	0406 0206 0606 0106 0506 0306 0706 0086     ................
   21cf8:	0486 0286 0686 0186 0586 0386 0786 0046     ..............F.
   21d08:	0446 0246 0646 0146 0546 0346 0746 00c6     F.F.F.F.F.F.F...
   21d18:	04c6 02c6 06c6 01c6 05c6 03c6 07c6 0026     ..............&.
   21d28:	0426 0226 0626 0126 0526 0326 0726 00a6     &.&.&.&.&.&.&...
   21d38:	04a6 02a6 06a6 01a6 05a6 03a6 07a6 0066     ..............f.
   21d48:	0466 0266 0666 0166 0566 0366 0766 00e6     f.f.f.f.f.f.f...
   21d58:	04e6 02e6 06e6 01e6 05e6 03e6 07e6 0016     ................
   21d68:	0416 0216 0616 0116 0516 0316 0716 0096     ................
   21d78:	0496 0296 0696 0196 0596 0396 0796 0056     ..............V.
   21d88:	0456 0256 0656 0156 0556 0356 0756 00d6     V.V.V.V.V.V.V...
   21d98:	04d6 02d6 06d6 01d6 05d6 03d6 07d6 0036     ..............6.
   21da8:	0436 0236 0636 0136 0536 0336 0736 00b6     6.6.6.6.6.6.6...
   21db8:	04b6 02b6 06b6 01b6 05b6 03b6 07b6 0076     ..............v.
   21dc8:	0476 0276 0676 0176 0576 0376 0776 00f6     v.v.v.v.v.v.v...
   21dd8:	04f6 02f6 06f6 01f6 05f6 03f6 07f6 000e     ................
   21de8:	040e 020e 060e 010e 050e 030e 070e 008e     ................
   21df8:	048e 028e 068e 018e 058e 038e 078e 004e     ..............N.
   21e08:	044e 024e 064e 014e 054e 034e 074e 00ce     N.N.N.N.N.N.N...
   21e18:	04ce 02ce 06ce 01ce 05ce 03ce 07ce 002e     ................
   21e28:	042e 022e 062e 012e 052e 032e 072e 00ae     ................
   21e38:	04ae 02ae 06ae 01ae 05ae 03ae 07ae 006e     ..............n.
   21e48:	046e 026e 066e 016e 056e 036e 076e 00ee     n.n.n.n.n.n.n...
   21e58:	04ee 02ee 06ee 01ee 05ee 03ee 07ee 001e     ................
   21e68:	041e 021e 061e 011e 051e 031e 071e 009e     ................
   21e78:	049e 029e 069e 019e 059e 039e 079e 005e     ..............^.
   21e88:	045e 025e 065e 015e 055e 035e 075e 00de     ^.^.^.^.^.^.^...
   21e98:	04de 02de 06de 01de 05de 03de 07de 003e     ..............>.
   21ea8:	043e 023e 063e 013e 053e 033e 073e 00be     >.>.>.>.>.>.>...
   21eb8:	04be 02be 06be 01be 05be 03be 07be 007e     ..............~.
   21ec8:	047e 027e 067e 017e 057e 037e 077e 00fe     ~.~.~.~.~.~.~...
   21ed8:	04fe 02fe 06fe 01fe 05fe 03fe 07fe 0001     ................
   21ee8:	7173 7472 0066 ffff                         sqrtf...

00021ef0 <_global_impure_ptr>:
   21ef0:	bcd0 1fff ffff ffff                         ........

00021ef8 <__mprec_tens>:
   21ef8:	0000 0000 0000 3ff0 0000 0000 0000 4024     .......?......$@
   21f08:	0000 0000 0000 4059 0000 0000 4000 408f     ......Y@.....@.@
   21f18:	0000 0000 8800 40c3 0000 0000 6a00 40f8     .......@.....j.@
   21f28:	0000 0000 8480 412e 0000 0000 12d0 4163     .......A......cA
   21f38:	0000 0000 d784 4197 0000 0000 cd65 41cd     .......A....e..A
   21f48:	0000 2000 a05f 4202 0000 e800 4876 4237     ... _..B....vH7B
   21f58:	0000 a200 1a94 426d 0000 e540 309c 42a2     ......mB..@..0.B
   21f68:	0000 1e90 bcc4 42d6 0000 2634 6bf5 430c     .......B..4&.k.C
   21f78:	8000 37e0 c379 4341 a000 85d8 3457 4376     ...7y.AC....W4vC
   21f88:	c800 674e c16d 43ab 3d00 6091 58e4 43e1     ..Ngm..C.=.`.X.C
   21f98:	8c40 78b5 af1d 4415 ef50 d6e2 1ae4 444b     @..x...DP.....KD
   21fa8:	d592 064d f0cf 4480 4af6 c7e1 2d02 44b5     ..M....D.J...-.D
   21fb8:	9db4 79d9 7843 44ea                         ...yCx.D

00021fc0 <p05.6085>:
   21fc0:	0005 0000 0019 0000 007d 0000 ffff ffff     ........}.......

00021fd0 <__mprec_bigtens>:
   21fd0:	8000 37e0 c379 4341 6e17 b505 b8b5 4693     ...7y.AC.n.....F
   21fe0:	f9f5 e93f 4f03 4d38 1d32 f930 7748 5a82     ..?..O8M2.0.Hw.Z
   21ff0:	bf3c 7f73 4fdd 7515 6e49 6966 696e 7974     <.s..O.uInfinity
   22000:	0000 0000 614e 004e                         ....NaN.

00022008 <_init>:
   22008:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2200a:	bf00      	nop
   2200c:	bcf8      	pop	{r3, r4, r5, r6, r7}
   2200e:	bc08      	pop	{r3}
   22010:	469e      	mov	lr, r3
   22012:	4770      	bx	lr

00022014 <__init_array_start>:
   22014:	0000ec29 	.word	0x0000ec29

00022018 <__frame_dummy_init_array_entry>:
   22018:	00000435 00004d4d 000065d1 000065e9     5...MM...e...e..
   22028:	0000681d 00006835 0000684d 00006865     .h..5h..Mh..eh..
   22038:	000068f9 00006911 00006a21 00006a39     .h...i..!j..9j..
   22048:	00006a51 00006a69 00006a81 00006a99     Qj..ij...j...j..
   22058:	00006e05 000072a1                       .n...r..

Disassembly of section .fini:

00022060 <_fini>:
   22060:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   22062:	bf00      	nop

Disassembly of section .data:

1fffb798 <port_E_isr>:
#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
PORT_ISR_FUNCTION_CLZ(D)
PORT_ISR_FUNCTION_CLZ(E)
1fffb798:	b538      	push	{r3, r4, r5, lr}
1fffb79a:	4b08      	ldr	r3, [pc, #32]	; (1fffb7bc <port_E_isr+0x24>)
1fffb79c:	681c      	ldr	r4, [r3, #0]
1fffb79e:	601c      	str	r4, [r3, #0]
1fffb7a0:	b154      	cbz	r4, 1fffb7b8 <port_E_isr+0x20>
1fffb7a2:	4d07      	ldr	r5, [pc, #28]	; (1fffb7c0 <port_E_isr+0x28>)
1fffb7a4:	fa94 f3a4 	rbit	r3, r4
1fffb7a8:	fab3 f383 	clz	r3, r3
1fffb7ac:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fffb7b0:	4798      	blx	r3
1fffb7b2:	1e63      	subs	r3, r4, #1
1fffb7b4:	401c      	ands	r4, r3
1fffb7b6:	d1f5      	bne.n	1fffb7a4 <port_E_isr+0xc>
1fffb7b8:	bd38      	pop	{r3, r4, r5, pc}
1fffb7ba:	bf00      	nop
1fffb7bc:	4004d0a0 	.word	0x4004d0a0
1fffb7c0:	1fffbadc 	.word	0x1fffbadc

1fffb7c4 <port_D_isr>:

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
PORT_ISR_FUNCTION_CLZ(D)
1fffb7c4:	b538      	push	{r3, r4, r5, lr}
1fffb7c6:	4b08      	ldr	r3, [pc, #32]	; (1fffb7e8 <port_D_isr+0x24>)
1fffb7c8:	681c      	ldr	r4, [r3, #0]
1fffb7ca:	601c      	str	r4, [r3, #0]
1fffb7cc:	b154      	cbz	r4, 1fffb7e4 <port_D_isr+0x20>
1fffb7ce:	4d07      	ldr	r5, [pc, #28]	; (1fffb7ec <port_D_isr+0x28>)
1fffb7d0:	fa94 f3a4 	rbit	r3, r4
1fffb7d4:	fab3 f383 	clz	r3, r3
1fffb7d8:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fffb7dc:	4798      	blx	r3
1fffb7de:	1e63      	subs	r3, r4, #1
1fffb7e0:	401c      	ands	r4, r3
1fffb7e2:	d1f5      	bne.n	1fffb7d0 <port_D_isr+0xc>
1fffb7e4:	bd38      	pop	{r3, r4, r5, pc}
1fffb7e6:	bf00      	nop
1fffb7e8:	4004c0a0 	.word	0x4004c0a0
1fffb7ec:	1fffbabc 	.word	0x1fffbabc

1fffb7f0 <port_C_isr>:
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
1fffb7f0:	b538      	push	{r3, r4, r5, lr}
1fffb7f2:	4b08      	ldr	r3, [pc, #32]	; (1fffb814 <port_C_isr+0x24>)
1fffb7f4:	681c      	ldr	r4, [r3, #0]
1fffb7f6:	601c      	str	r4, [r3, #0]
1fffb7f8:	b154      	cbz	r4, 1fffb810 <port_C_isr+0x20>
1fffb7fa:	4d07      	ldr	r5, [pc, #28]	; (1fffb818 <port_C_isr+0x28>)
1fffb7fc:	fa94 f3a4 	rbit	r3, r4
1fffb800:	fab3 f383 	clz	r3, r3
1fffb804:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fffb808:	4798      	blx	r3
1fffb80a:	1e63      	subs	r3, r4, #1
1fffb80c:	401c      	ands	r4, r3
1fffb80e:	d1f5      	bne.n	1fffb7fc <port_C_isr+0xc>
1fffb810:	bd38      	pop	{r3, r4, r5, pc}
1fffb812:	bf00      	nop
1fffb814:	4004b0a0 	.word	0x4004b0a0
1fffb818:	1fffba8c 	.word	0x1fffba8c

1fffb81c <port_B_isr>:
	}
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
1fffb81c:	b538      	push	{r3, r4, r5, lr}
1fffb81e:	4b08      	ldr	r3, [pc, #32]	; (1fffb840 <port_B_isr+0x24>)
1fffb820:	681c      	ldr	r4, [r3, #0]
1fffb822:	601c      	str	r4, [r3, #0]
1fffb824:	b154      	cbz	r4, 1fffb83c <port_B_isr+0x20>
1fffb826:	4d07      	ldr	r5, [pc, #28]	; (1fffb844 <port_B_isr+0x28>)
1fffb828:	fa94 f3a4 	rbit	r3, r4
1fffb82c:	fab3 f383 	clz	r3, r3
1fffb830:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fffb834:	4798      	blx	r3
1fffb836:	1e63      	subs	r3, r4, #1
1fffb838:	401c      	ands	r4, r3
1fffb83a:	d1f5      	bne.n	1fffb828 <port_B_isr+0xc>
1fffb83c:	bd38      	pop	{r3, r4, r5, pc}
1fffb83e:	bf00      	nop
1fffb840:	4004a0a0 	.word	0x4004a0a0
1fffb844:	1fffba3c 	.word	0x1fffba3c

1fffb848 <port_A_isr>:
		}                                                     \
	}
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
1fffb848:	b538      	push	{r3, r4, r5, lr}
1fffb84a:	4b08      	ldr	r3, [pc, #32]	; (1fffb86c <port_A_isr+0x24>)
1fffb84c:	681c      	ldr	r4, [r3, #0]
1fffb84e:	601c      	str	r4, [r3, #0]
1fffb850:	b154      	cbz	r4, 1fffb868 <port_A_isr+0x20>
1fffb852:	4d07      	ldr	r5, [pc, #28]	; (1fffb870 <port_A_isr+0x28>)
1fffb854:	fa94 f3a4 	rbit	r3, r4
1fffb858:	fab3 f383 	clz	r3, r3
1fffb85c:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fffb860:	4798      	blx	r3
1fffb862:	1e63      	subs	r3, r4, #1
1fffb864:	401c      	ands	r4, r3
1fffb866:	d1f5      	bne.n	1fffb854 <port_A_isr+0xc>
1fffb868:	bd38      	pop	{r3, r4, r5, pc}
1fffb86a:	bf00      	nop
1fffb86c:	400490a0 	.word	0x400490a0
1fffb870:	1fffba04 	.word	0x1fffba04

1fffb874 <__dso_handle>:
1fffb874:	00000000                                ....

1fffb878 <feature_max>:
1fffb878:	a0000000 3e7ad7f2                       ......z>

1fffb880 <SONG_FEATURE>:
1fffb880:	00000001 00000000                       ........

1fffb888 <feature_min>:
1fffb888:	00000000 416312d0                       ......cA

1fffb890 <MASTER_GAIN_SCALER>:
1fffb890:	00000000 3ff00000                       .......?

1fffb898 <global_rms_scaler>:
1fffb898:	00000000 401c0000                       .......@

1fffb8a0 <data_logging_active>:
1fffb8a0:	00010101                                         .

1fffb8a1 <rear_mic_active>:
1fffb8a1:	98000101                                         .

1fffb8a2 <num_channels>:
1fffb8a2:	3a980001                                         ..

1fffb8a4 <lux_min_reading_delay>:
1fffb8a4:	00003a98                                .:..

1fffb8a8 <front_mic_active>:
1fffb8a8:	00000001 00000000                       ........

1fffb8b0 <global_peak_scaler>:
1fffb8b0:	00000000 40100000                       .......@

1fffb8b8 <CLICK_THRESH>:
1fffb8b8:	a0000000 3fd99999                       .......?

1fffb8c0 <stereo_audio>:
1fffb8c0:	00000001                                ....

1fffb8c4 <SONG_COLOR_FEATURE>:
1fffb8c4:	00000008                                ....

1fffb8c8 <global_fft_scaler>:
1fffb8c8:	00000000 40690000                       ......i@

1fffb8d0 <lux_max_reading_delay>:
1fffb8d0:	0001d4c0                                ....

1fffb8d4 <leds>:
1fffb8d4:	0205000a 1fffaaa0 1ffff73c 00000000     ........<.......
1fffb8e4:	00000000                                ....

1fffb8e8 <SPI>:
1fffb8e8:	4002c000 000122b0 00000000 00000000     ...@."..........
	...

1fffb920 <SdVolume::cacheBlockNumber_>:
1fffb920:	ffffffff                                ....

1fffb924 <Wire>:
1fffb924:	00012388 00000000 000003e8 00000000     .#..............
1fffb934:	40066000 00012340 00000000 00000000     .`.@@#..........
	...

1fffb990 <Wire1>:
1fffb990:	00012388 00000000 000003e8 00000000     .#..............
1fffb9a0:	40067000 00012360 00000000 00000000     .p.@`#..........
	...

1fffb9fc <analog_config_bits>:
1fffb9fc:	0000040a                                         .

1fffb9fd <analog_num_average>:
1fffb9fd:	48000004                                         ...

1fffba00 <__brkval>:
1fffba00:	20004948                                HI. 

1fffba04 <isr_table_portA>:
1fffba04:	00009e35 00009e35 00009e35 00009e35     5...5...5...5...
1fffba14:	00009e35 00009e35 00009e35 00009e35     5...5...5...5...
1fffba24:	00009e35 00009e35 00009e35 00009e35     5...5...5...5...
1fffba34:	00009e35 00009e35                       5...5...

1fffba3c <isr_table_portB>:
1fffba3c:	00009e35 00009e35 00009e35 00009e35     5...5...5...5...
1fffba4c:	00009e35 00009e35 00009e35 00009e35     5...5...5...5...
1fffba5c:	00009e35 00009e35 00009e35 00009e35     5...5...5...5...
1fffba6c:	00009e35 00009e35 00009e35 00009e35     5...5...5...5...
1fffba7c:	00009e35 00009e35 00009e35 00009e35     5...5...5...5...

1fffba8c <isr_table_portC>:
1fffba8c:	00009e35 00009e35 00009e35 00009e35     5...5...5...5...
1fffba9c:	00009e35 00009e35 00009e35 00009e35     5...5...5...5...
1fffbaac:	00009e35 00009e35 00009e35 00009e35     5...5...5...5...

1fffbabc <isr_table_portD>:
1fffbabc:	00009e35 00009e35 00009e35 00009e35     5...5...5...5...
1fffbacc:	00009e35 00009e35 00009e35 00009e35     5...5...5...5...

1fffbadc <isr_table_portE>:
1fffbadc:	00009e35 00009e35                       5...5...

1fffbae4 <AudioInputUSB::features>:
	...
1fffbaec:	000007ff                                ....

1fffbaf0 <usb_audio_transmit_callback::count>:
1fffbaf0:	00000005                                ....

1fffbaf4 <Serial>:
1fffbaf4:	000124ec 00000000 000003e8 00000000     .$..............

1fffbb04 <usb_buffer_available>:
1fffbb04:	ffffffff                                ....

1fffbb08 <device_descriptor>:
1fffbb08:	01100112 40000000 048a16c0 02010275     .......@....u...
1fffbb18:	00000103                                ....

1fffbb1c <usb_string_manufacturer_name_default>:
1fffbb1c:	00540318 00650065 0073006e 00640079     ..T.e.e.n.s.y.d.
1fffbb2c:	00690075 006f006e                       u.i.n.o.

1fffbb34 <config_descriptor>:
1fffbb34:	01550209 c0000106 000b0832 01020202     ..U.....2.......
1fffbb44:	00040904 02020100 24050001 05011000     ...........$....
1fffbb54:	01010124 06022404 00062405 81050701     $....$...$......
1fffbb64:	40001003 00010409 00000a02 02050700     ...@............
1fffbb74:	00004002 02830507 09000040 02000204     .@......@.......
1fffbb84:	00000301 00012407 06002501 01010224     .....$...%..$...
1fffbb94:	02240600 09000202 03010324 00010201     ..$.....$.......
1fffbba4:	02032409 01010104 05050900 00004002     .$...........@..
1fffbbb4:	25050000 09010101 40028405 00000000     ...%.......@....
1fffbbc4:	01012505 030b0803 00010103 03040900     .%..............
1fffbbd4:	01010000 240a0000 3e010001 05040200     .......$...>....
1fffbbe4:	0102240c 02000602 00000003 02032409     .$...........$..
1fffbbf4:	01000101 02240c00 00010103 00000302     ......$.........
1fffbc04:	06240a00 01010331 09000202 02040324     ..$.1.......$...
1fffbc14:	00310006 00040409 00020100 04040900     ..1.............
1fffbc24:	02010101 24070000 01030201 02240b00     .......$......$.
1fffbc34:	10020201 00ac4401 09860509 000100b4     .....D..........
1fffbc44:	01250700 00000000 00050409 00020100     ..%.............
1fffbc54:	05040900 02010201 24070000 01030301     ...........$....
1fffbc64:	02240b00 10020201 00ac4401 05070509     ..$......D......
1fffbc74:	000100b4 01250788 00000000 11880509     ......%.........
1fffbc84:	05010003 00000000                       ........

1fffbc8c <usb_string_product_name_default>:
1fffbc8c:	00540324 00650065 0073006e 00200079     $.T.e.e.n.s.y. .
1fffbc9c:	0049004d 00490044 0041002f 00640075     M.I.D.I./.A.u.d.
1fffbcac:	006f0069                                i.o.

1fffbcb0 <string0>:
1fffbcb0:	04090304                                ....

1fffbcb4 <usb_string_serial_number_default>:
1fffbcb4:	0000030c 00000000 00000000 00000000     ................
1fffbcc4:	00000000 00010000                                ......

1fffbcca <__fdlib_version>:
1fffbcca:	00000001 00000000                                ......

1fffbcd0 <impure_data>:
1fffbcd0:	00000000 1fffbfbc 1fffc024 1fffc08c     ........$.......
	...
1fffbd78:	00000001 00000000 abcd330e e66d1234     .........3..4.m.
1fffbd88:	0005deec 0000000b 00000000 00000000     ................
	...

1fffc0f8 <_impure_ptr>:
1fffc0f8:	1fffbcd0                                ....

1fffc0fc <__malloc_av_>:
	...
1fffc104:	1fffc0fc 1fffc0fc 1fffc104 1fffc104     ................
1fffc114:	1fffc10c 1fffc10c 1fffc114 1fffc114     ................
1fffc124:	1fffc11c 1fffc11c 1fffc124 1fffc124     ........$...$...
1fffc134:	1fffc12c 1fffc12c 1fffc134 1fffc134     ,...,...4...4...
1fffc144:	1fffc13c 1fffc13c 1fffc144 1fffc144     <...<...D...D...
1fffc154:	1fffc14c 1fffc14c 1fffc154 1fffc154     L...L...T...T...
1fffc164:	1fffc15c 1fffc15c 1fffc164 1fffc164     \...\...d...d...
1fffc174:	1fffc16c 1fffc16c 1fffc174 1fffc174     l...l...t...t...
1fffc184:	1fffc17c 1fffc17c 1fffc184 1fffc184     |...|...........
1fffc194:	1fffc18c 1fffc18c 1fffc194 1fffc194     ................
1fffc1a4:	1fffc19c 1fffc19c 1fffc1a4 1fffc1a4     ................
1fffc1b4:	1fffc1ac 1fffc1ac 1fffc1b4 1fffc1b4     ................
1fffc1c4:	1fffc1bc 1fffc1bc 1fffc1c4 1fffc1c4     ................
1fffc1d4:	1fffc1cc 1fffc1cc 1fffc1d4 1fffc1d4     ................
1fffc1e4:	1fffc1dc 1fffc1dc 1fffc1e4 1fffc1e4     ................
1fffc1f4:	1fffc1ec 1fffc1ec 1fffc1f4 1fffc1f4     ................
1fffc204:	1fffc1fc 1fffc1fc 1fffc204 1fffc204     ................
1fffc214:	1fffc20c 1fffc20c 1fffc214 1fffc214     ................
1fffc224:	1fffc21c 1fffc21c 1fffc224 1fffc224     ........$...$...
1fffc234:	1fffc22c 1fffc22c 1fffc234 1fffc234     ,...,...4...4...
1fffc244:	1fffc23c 1fffc23c 1fffc244 1fffc244     <...<...D...D...
1fffc254:	1fffc24c 1fffc24c 1fffc254 1fffc254     L...L...T...T...
1fffc264:	1fffc25c 1fffc25c 1fffc264 1fffc264     \...\...d...d...
1fffc274:	1fffc26c 1fffc26c 1fffc274 1fffc274     l...l...t...t...
1fffc284:	1fffc27c 1fffc27c 1fffc284 1fffc284     |...|...........
1fffc294:	1fffc28c 1fffc28c 1fffc294 1fffc294     ................
1fffc2a4:	1fffc29c 1fffc29c 1fffc2a4 1fffc2a4     ................
1fffc2b4:	1fffc2ac 1fffc2ac 1fffc2b4 1fffc2b4     ................
1fffc2c4:	1fffc2bc 1fffc2bc 1fffc2c4 1fffc2c4     ................
1fffc2d4:	1fffc2cc 1fffc2cc 1fffc2d4 1fffc2d4     ................
1fffc2e4:	1fffc2dc 1fffc2dc 1fffc2e4 1fffc2e4     ................
1fffc2f4:	1fffc2ec 1fffc2ec 1fffc2f4 1fffc2f4     ................
1fffc304:	1fffc2fc 1fffc2fc 1fffc304 1fffc304     ................
1fffc314:	1fffc30c 1fffc30c 1fffc314 1fffc314     ................
1fffc324:	1fffc31c 1fffc31c 1fffc324 1fffc324     ........$...$...
1fffc334:	1fffc32c 1fffc32c 1fffc334 1fffc334     ,...,...4...4...
1fffc344:	1fffc33c 1fffc33c 1fffc344 1fffc344     <...<...D...D...
1fffc354:	1fffc34c 1fffc34c 1fffc354 1fffc354     L...L...T...T...
1fffc364:	1fffc35c 1fffc35c 1fffc364 1fffc364     \...\...d...d...
1fffc374:	1fffc36c 1fffc36c 1fffc374 1fffc374     l...l...t...t...
1fffc384:	1fffc37c 1fffc37c 1fffc384 1fffc384     |...|...........
1fffc394:	1fffc38c 1fffc38c 1fffc394 1fffc394     ................
1fffc3a4:	1fffc39c 1fffc39c 1fffc3a4 1fffc3a4     ................
1fffc3b4:	1fffc3ac 1fffc3ac 1fffc3b4 1fffc3b4     ................
1fffc3c4:	1fffc3bc 1fffc3bc 1fffc3c4 1fffc3c4     ................
1fffc3d4:	1fffc3cc 1fffc3cc 1fffc3d4 1fffc3d4     ................
1fffc3e4:	1fffc3dc 1fffc3dc 1fffc3e4 1fffc3e4     ................
1fffc3f4:	1fffc3ec 1fffc3ec 1fffc3f4 1fffc3f4     ................
1fffc404:	1fffc3fc 1fffc3fc 1fffc404 1fffc404     ................
1fffc414:	1fffc40c 1fffc40c 1fffc414 1fffc414     ................
1fffc424:	1fffc41c 1fffc41c 1fffc424 1fffc424     ........$...$...
1fffc434:	1fffc42c 1fffc42c 1fffc434 1fffc434     ,...,...4...4...
1fffc444:	1fffc43c 1fffc43c 1fffc444 1fffc444     <...<...D...D...
1fffc454:	1fffc44c 1fffc44c 1fffc454 1fffc454     L...L...T...T...
1fffc464:	1fffc45c 1fffc45c 1fffc464 1fffc464     \...\...d...d...
1fffc474:	1fffc46c 1fffc46c 1fffc474 1fffc474     l...l...t...t...
1fffc484:	1fffc47c 1fffc47c 1fffc484 1fffc484     |...|...........
1fffc494:	1fffc48c 1fffc48c 1fffc494 1fffc494     ................
1fffc4a4:	1fffc49c 1fffc49c 1fffc4a4 1fffc4a4     ................
1fffc4b4:	1fffc4ac 1fffc4ac 1fffc4b4 1fffc4b4     ................
1fffc4c4:	1fffc4bc 1fffc4bc 1fffc4c4 1fffc4c4     ................
1fffc4d4:	1fffc4cc 1fffc4cc 1fffc4d4 1fffc4d4     ................
1fffc4e4:	1fffc4dc 1fffc4dc 1fffc4e4 1fffc4e4     ................
1fffc4f4:	1fffc4ec 1fffc4ec 1fffc4f4 1fffc4f4     ................

1fffc504 <__malloc_trim_threshold>:
1fffc504:	00020000                                ....

1fffc508 <__malloc_sbrk_base>:
1fffc508:	ffffffff                                ....
